<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK</title>
  
  <subtitle>KK Blog</subtitle>
  <link href="https://k705.github.io/atom.xml" rel="self"/>
  
  <link href="https://k705.github.io/"/>
  <updated>2024-04-25T09:18:31.539Z</updated>
  <id>https://k705.github.io/</id>
  
  <author>
    <name>KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码规范</title>
    <link href="https://k705.github.io/2024/04/25/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://k705.github.io/2024/04/25/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2024-04-25T09:08:57.000Z</published>
    <updated>2024-04-25T09:18:31.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h2><p>市面上常用的命名规范：</p><ul><li><code>camelCase</code>（小驼峰式命名法 —— 首字母小写）</li><li><code>PascalCase</code>（大驼峰式命名法 —— 首字母大写）</li><li><code>kebab-case</code>（短横线连接式）</li><li><code>Snake</code>（下划线连接式）</li></ul><h3 id="1-1-项目文件命名"><a href="#1-1-项目文件命名" class="headerlink" title="1.1 项目文件命名"></a>1.1 项目文件命名</h3><h4 id="1-1-1-项目名"><a href="#1-1-1-项目名" class="headerlink" title="1.1.1 项目名"></a>1.1.1 项目名</h4><p>全部采用小写方式， 以<strong>短横线</strong>分隔。 例：<code>my-project-name</code>。</p><h4 id="1-1-2-目录名"><a href="#1-1-2-目录名" class="headerlink" title="1.1.2 目录名"></a>1.1.2 目录名</h4><p><strong>参照项目命名规则，有复数结构时，要采用复数命名法</strong>。例：docs、assets、components、directives、mixins、utils、views。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">my-project-name/</span><br><span class="line">|- <span class="title class_">BuildScript</span>    <span class="comment">// 流水线部署文件目录</span></span><br><span class="line">|- docs           <span class="comment">// 项目的细化文档目录（可选）</span></span><br><span class="line">|- nginx          <span class="comment">// 部署在容器上前端项目 nginx 代理文件目录</span></span><br><span class="line">|- node_modules   <span class="comment">// 下载的依赖包</span></span><br><span class="line">|- public         <span class="comment">// 静态页面目录</span></span><br><span class="line">    |- index.<span class="property">html</span> <span class="comment">// 项目入口</span></span><br><span class="line">|- src            <span class="comment">// 源码目录</span></span><br><span class="line">    |- api        <span class="comment">// http 请求目录</span></span><br><span class="line">    |- assets     <span class="comment">// 静态资源目录，这里的资源会被wabpack构建</span></span><br><span class="line">        |- icon   <span class="comment">// icon 存放目录</span></span><br><span class="line">        |- img    <span class="comment">// 图片存放目录</span></span><br><span class="line">        |- js     <span class="comment">// 公共 js 文件目录</span></span><br><span class="line">        |- scss   <span class="comment">// 公共样式 scss 存放目录</span></span><br><span class="line">            |- frame.<span class="property">scss</span>   <span class="comment">// 入口文件</span></span><br><span class="line">            |- <span class="variable language_">global</span>.<span class="property">scss</span>  <span class="comment">// 公共样式</span></span><br><span class="line">            |- reset.<span class="property">scss</span>   <span class="comment">// 重置样式</span></span><br><span class="line">    |- components     <span class="comment">// 组件</span></span><br><span class="line">    |- plugins        <span class="comment">// 插件</span></span><br><span class="line">    |- router         <span class="comment">// 路由</span></span><br><span class="line">    |- routes         <span class="comment">// 详细的路由拆分目录（可选）</span></span><br><span class="line">        |- index.<span class="property">js</span></span><br><span class="line">    |- store          <span class="comment">// 全局状态管理</span></span><br><span class="line">    |- utils          <span class="comment">// 工具存放目录</span></span><br><span class="line">        |- request.<span class="property">js</span> <span class="comment">// 公共请求工具</span></span><br><span class="line">    |- views          <span class="comment">// 页面存放目录</span></span><br><span class="line">    |- <span class="title class_">App</span>.<span class="property">vue</span>        <span class="comment">// 根组件</span></span><br><span class="line">    |- main.<span class="property">js</span>        <span class="comment">// 入口文件</span></span><br><span class="line">    |- tests          <span class="comment">// 测试用例</span></span><br><span class="line">    |- .<span class="property">browserslistrc</span><span class="comment">// 浏览器兼容配置文件</span></span><br><span class="line">    |- .<span class="property">editorconfig</span>  <span class="comment">// 编辑器配置文件</span></span><br><span class="line">    |- .<span class="property">eslintignore</span>  <span class="comment">// eslint 忽略规则</span></span><br><span class="line">    |- .<span class="property">eslintrc</span>.<span class="property">js</span>   <span class="comment">// eslint 规则</span></span><br><span class="line">    |- .<span class="property">gitignore</span>     <span class="comment">// git 忽略规则</span></span><br><span class="line">    |- babel.<span class="property">config</span>.<span class="property">js</span> <span class="comment">// babel 规则</span></span><br><span class="line">    |- <span class="title class_">Dockerfile</span> <span class="comment">// Docker 部署文件</span></span><br><span class="line">    |- jest.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">    |- package-lock.<span class="property">json</span></span><br><span class="line">    |- package.<span class="property">json</span> <span class="comment">// 依赖</span></span><br><span class="line">    |- <span class="variable constant_">README</span>.<span class="property">md</span> <span class="comment">// 项目 README</span></span><br><span class="line">    |- vue.<span class="property">config</span>.<span class="property">js</span> <span class="comment">// webpack 配置</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-图像文件名"><a href="#1-1-3-图像文件名" class="headerlink" title="1.1.3 图像文件名"></a>1.1.3 图像文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">banner_sina.gif</span><br><span class="line">menu_aboutus.gif</span><br><span class="line">menutitle_news.gif</span><br><span class="line">logo_police.gif</span><br><span class="line">logo_national.gif</span><br><span class="line">pic_people.jpg</span><br><span class="line">pic_TV.jpg</span><br></pre></td></tr></table></figure><h4 id="1-1-4-HTML-文件名"><a href="#1-1-4-HTML-文件名" class="headerlink" title="1.1.4 HTML 文件名"></a>1.1.4 HTML 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|- error_report.html</span><br><span class="line">|- success_report.html</span><br></pre></td></tr></table></figure><h4 id="1-1-5-CSS-文件名"><a href="#1-1-5-CSS-文件名" class="headerlink" title="1.1.5 CSS 文件名"></a>1.1.5 CSS 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|- normalize.less</span><br><span class="line">|- base.less</span><br><span class="line">|- <span class="built_in">date</span>-picker.scss</span><br><span class="line">|- <span class="built_in">input</span>-number.scss</span><br></pre></td></tr></table></figure><h4 id="1-1-6-JavaScript-文件名"><a href="#1-1-6-JavaScript-文件名" class="headerlink" title="1.1.6 JavaScript 文件名"></a>1.1.6 JavaScript 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|- index<span class="selector-class">.js</span></span><br><span class="line">|- plugin<span class="selector-class">.js</span></span><br><span class="line">|- util<span class="selector-class">.js</span></span><br><span class="line">|- date-util<span class="selector-class">.js</span></span><br><span class="line">|- account-model<span class="selector-class">.js</span></span><br><span class="line">|- collapse-<span class="attribute">transition</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><blockquote><p>上述规则可以快速记忆为“<strong>静态文件下划线，编译文件短横线</strong>”。</p></blockquote><h3 id="1-2-Vue-组件命名"><a href="#1-2-Vue-组件命名" class="headerlink" title="1.2 Vue 组件命名"></a>1.2 Vue 组件命名</h3><h4 id="1-2-1-单文件组件名"><a href="#1-2-1-单文件组件名" class="headerlink" title="1.2.1 单文件组件名"></a>1.2.1 单文件组件名</h4><p>文件扩展名为 <code>.vue</code> 的 <code>single-file components</code> (单文件组件)。单文件组件名应该始终是<strong>单词大写开头</strong> (PascalCase)。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-2-单例组件名"><a href="#1-2-2-单例组件名" class="headerlink" title="1.2.2 单例组件名"></a>1.2.2 单例组件名</h4><p><strong>只拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p><p>这不意味着组件只可用于一个单页面，而是<em>每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em>只是目前</em>在每个页面里只使用一次。</p><p>比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TheHeading.vue</span><br><span class="line">|- TheSidebar.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-3-基础组件名"><a href="#1-2-3-基础组件名" class="headerlink" title="1.2.3 基础组件名"></a>1.2.3 基础组件名</h4><blockquote><p>基础组件：不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。</p></blockquote><p>应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。<strong>基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- BaseButton.vue</span><br><span class="line">|- BaseTable.vue</span><br><span class="line">|- BaseIcon.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-4-业务组件"><a href="#1-2-4-业务组件" class="headerlink" title="1.2.4 业务组件"></a>1.2.4 业务组件</h4><blockquote><p>业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p></blockquote><p><strong>掺杂了复杂业务的组件（拥有自身 <code>data</code>、<code>prop</code> 的相关处理）即业务组件</strong>应该以 <code>Custom</code> 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- CustomCard.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-5-紧密耦合的组件名"><a href="#1-2-5-紧密耦合的组件名" class="headerlink" title="1.2.5 紧密耦合的组件名"></a>1.2.5 紧密耦合的组件名</h4><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong> 因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoListItem.vue</span><br><span class="line">|- TodoListItemButton.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-6-组件名中单词顺序"><a href="#1-2-6-组件名中单词顺序" class="headerlink" title="1.2.6 组件名中单词顺序"></a>1.2.6 组件名中单词顺序</h4><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong> 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。如下组件主要是用于搜索和设置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SearchButtonClear.vue</span><br><span class="line">|- SearchButtonRun.vue</span><br><span class="line">|- SearchInputQuery.vue</span><br><span class="line">|- SearchInputExcludeGlob.vue</span><br><span class="line">|- SettingsCheckboxTerms.vue</span><br><span class="line">|- SettingsCheckboxLaunchOnStartup.vue</span><br></pre></td></tr></table></figure><p>还有另一种多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。</p><h4 id="1-2-7-完整单词的组件名"><a href="#1-2-7-完整单词的组件名" class="headerlink" title="1.2.7 完整单词的组件名"></a>1.2.7 完整单词的组件名</h4><p><strong>组件名应该倾向于而不是缩写。</strong> 编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- StudentDashboardSettings.vue</span><br><span class="line">|- UserProfileOptions.vue</span><br></pre></td></tr></table></figure><h3 id="1-3-代码参数命名"><a href="#1-3-代码参数命名" class="headerlink" title="1.3 代码参数命名"></a>1.3 代码参数命名</h3><h4 id="1-3-1-name"><a href="#1-3-1-name" class="headerlink" title="1.3.1 name"></a>1.3.1 name</h4><p><strong>组件名应该始终是多个单词，应该始终是 PascalCase 的。</strong> 根组件 App 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt;</code> 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ToDoList&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-prop"><a href="#1-3-2-prop" class="headerlink" title="1.3.2 prop"></a>1.3.2 prop</h4><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case</strong>。我们单纯的遵循每个语言的约定，在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WelcomeMessage</span> <span class="attr">greeting-text</span>=<span class="string">&quot;hi&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">greetingText</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;syncing&#x27;</span>, <span class="string">&#x27;synced&#x27;</span>,].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-router"><a href="#1-3-3-router" class="headerlink" title="1.3.3 router"></a>1.3.3 router</h4><p><strong>Vue Router Path 命名采用 kebab-case 格式。</strong> 用 Snake（如：<code>/user_info</code>）或 camelCase（如：<code>/userInfo</code>)的单词会被当成一个单词，搜索引擎无法区分语义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user_info&#x27;</span>, <span class="comment">// user_info 当成一个单词</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">UserInfo</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27; - 用户&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user-info&#x27;</span>, <span class="comment">// 能解析成 user info</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">UserInfo</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27; - 用户&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="1-3-4-模板中组件"><a href="#1-3-4-模板中组件" class="headerlink" title="1.3.4 模板中组件"></a>1.3.4 模板中组件</h4><p><strong>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 DOM 模板中 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-5-自闭合组件"><a href="#1-3-5-自闭合组件" class="headerlink" title="1.3.5 自闭合组件"></a>1.3.5 自闭合组件</h4><p><strong>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在所有地方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-6-变量"><a href="#1-3-6-变量" class="headerlink" title="1.3.6 变量"></a>1.3.6 变量</h4><ul><li>命名方法：camelCase</li><li>命名规范：类型 + 对象描述或属性的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> getTitle = <span class="string">&quot;LoginTable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> tableTitle = <span class="string">&quot;LoginTable&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySchool = <span class="string">&quot;我的学校&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-7-常量"><a href="#1-3-7-常量" class="headerlink" title="1.3.7 常量"></a>1.3.7 常量</h4><ul><li>命名方法：全部大写下划线分割</li><li>命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_COUNT</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">URL</span> = <span class="string">&#x27;http://test.host.com&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-8-方法"><a href="#1-3-8-方法" class="headerlink" title="1.3.8 方法"></a>1.3.8 方法</h4><ul><li>命名方法：camelCase</li><li>命名规范：统一使用动词或者动词 + 名词形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、普通情况下，使用动词 + 名词形式</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">go、nextPage、show、open、login</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">jumpPage、openCarInfoDialog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、请求数据方法，以 data 结尾</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">takeData、confirmData、getList、postForm</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">getListData、postFormData</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、单个动词的情况</span></span><br><span class="line">init、refresh</span><br></pre></td></tr></table></figure><table><thead><tr><th>动词</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作 (权 )</td><td>函数返回一个布尔值。true：可执行；false：不可执行；</td></tr><tr><td>has</td><td>判断是否含有某个值</td><td>函数返回一个布尔值。true：含有此值；false：不含有此值；</td></tr><tr><td>is</td><td>判断是否为某个值</td><td>函数返回一个布尔值。true：为某个值；false：不为某个值；</td></tr><tr><td>get</td><td>获取某个值</td><td>函数返回一个非布尔值</td></tr><tr><td>set</td><td>设置某个值</td><td>无返回值、返回是否设置成功或者返回链式对象</td></tr></tbody></table><h4 id="1-3-9-自定义事件"><a href="#1-3-9-自定义事件" class="headerlink" title="1.3.9 自定义事件"></a>1.3.9 自定义事件</h4><p><strong>自定义事件应始终使用 kebab-case 的事件名。</strong></p><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;my-event&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponent</span> @my-event=<span class="string">&quot;handleDoSomething&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" title="https://developer.mozilla.org/zh-CN/docs/Web/Events">原生事件参考列表</a></li></ul><p>由原生事件可以发现其使用方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">&quot;toggleHeaderFocus&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;toggleHeaderFocus&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">&quot;toggleMenu&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.esc</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.enter</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.up.prevent</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.down.prevent</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.tab</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.delete</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseenter</span>=<span class="string">&quot;hasMouseHoverHead = true&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseleave</span>=<span class="string">&quot;hasMouseHoverHead = false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而为了区分<em>原生事件</em>和<em>自定义事件</em>在 Vue 中的使用，建议除了多单词事件名使用 kebab-case 的情况下，命名还需遵守为 <strong><code>on</code> + 动词</strong> 的形式，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-search</span>=<span class="string">&quot;handleSearch&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-clear</span>=<span class="string">&quot;handleClear&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-clickoutside</span>=<span class="string">&quot;handleClickOutside&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    handleTriggerItem () &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;on-clear&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-10-事件方法"><a href="#1-3-10-事件方法" class="headerlink" title="1.3.10 事件方法"></a>1.3.10 事件方法</h4><ul><li>命名方法：camelCase</li><li>命名规范：handle + 名称（可选）+ 动词</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">click.native.stop</span>=<span class="string">&quot;handleItemClick()&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">mouseenter.native.stop</span>=<span class="string">&quot;handleItemHover()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    handleItemClick () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    handleItemHover () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="二、代码规范"><a href="#二、代码规范" class="headerlink" title="二、代码规范"></a>二、代码规范</h2><h3 id="2-1-Vue"><a href="#2-1-Vue" class="headerlink" title="2.1 Vue"></a>2.1 Vue</h3><h4 id="2-1-1-代码结构"><a href="#2-1-1-代码结构" class="headerlink" title="2.1.1 代码结构"></a>2.1.1 代码结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;my-component&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DemoComponent</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">DemoComponent</span> <span class="keyword">from</span> <span class="string">&#x27;../components/DemoComponent&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">DemoComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">mixins</span>: [],</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">watch</span>: &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  created () &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  mounted () &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  destroyed () &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">#my-component &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-data"><a href="#2-1-2-data" class="headerlink" title="2.1.2 data"></a>2.1.2 data</h4><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In a .vue file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-prop"><a href="#2-1-3-prop" class="headerlink" title="2.1.3 prop"></a>2.1.3 prop</h4><p><strong>Prop 定义应该尽量详细。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">status</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;syncing&#x27;</span>, </span><br><span class="line">          <span class="string">&#x27;synced&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;version-conflict&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-computed"><a href="#2-1-4-computed" class="headerlink" title="2.1.4 computed"></a>2.1.4 computed</h4><p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性。</strong> 小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="attr">computed</span>: &#123; </span><br><span class="line">  <span class="attr">price</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> basePrice = <span class="variable language_">this</span>.<span class="property">manufactureCost</span> / (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">profitMargin</span>) </span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      basePrice - </span><br><span class="line">      basePrice * (<span class="variable language_">this</span>.<span class="property">discountPercent</span> || <span class="number">0</span>) </span><br><span class="line">    ) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">basePrice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">manufactureCost</span> / (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">profitMargin</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">discount</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">basePrice</span> * (<span class="variable language_">this</span>.<span class="property">discountPercent</span> || <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">finalPrice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">basePrice</span> - <span class="variable language_">this</span>.<span class="property">discount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-5-为-v-for-设置键值"><a href="#2-1-5-为-v-for-设置键值" class="headerlink" title="2.1.5 为 v-for 设置键值"></a>2.1.5 为 <code>v-for</code> 设置键值</h4><p>**在组件上必须用 <code>key</code> 搭配 <code>v-for</code>**，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href="https://bost.ocks.org/mike/constancy/" title="https://bost.ocks.org/mike/constancy/">对象固化 (object constancy)</a>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-6-v-if-和-v-for-互斥"><a href="#2-1-6-v-if-和-v-for-互斥" class="headerlink" title="2.1.6 v-if 和 v-for 互斥"></a>2.1.6 <code>v-if</code> 和 <code>v-for</code> 互斥</h4><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad：控制台报错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般我们在两种常见的情况下会倾向于这样做：</p><ul><li>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> user.<span class="property">isActive</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>, <code>ol</code>)。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-7-多个-attribute-的元素"><a href="#2-1-7-多个-attribute-的元素" class="headerlink" title="2.1.7 多个 attribute 的元素"></a>2.1.7 多个 attribute 的元素</h4><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://vuejs.org/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Vue Logo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">foo</span>=<span class="string">&quot;a&quot;</span> <span class="attr">bar</span>=<span class="string">&quot;b&quot;</span> <span class="attr">baz</span>=<span class="string">&quot;c&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://vuejs.org/images/logo.png&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;Vue Logo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span></span></span><br><span class="line"><span class="tag">  <span class="attr">foo</span>=<span class="string">&quot;a&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">bar</span>=<span class="string">&quot;b&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">baz</span>=<span class="string">&quot;c&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-8-模板中简单的表达式"><a href="#2-1-8-模板中简单的表达式" class="headerlink" title="2.1.8 模板中简单的表达式"></a>2.1.8 模板中简单的表达式</h4><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p><p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<strong>是什么</strong>，而非<strong>如何</strong>计算那个值。而且计算属性和方法使得代码可以重用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;&#123;</span><br><span class="line">  fullName.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>更好的做法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在模板中 --&gt;</span></span><br><span class="line">&#123;&#123; normalizedFullName &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复杂表达式已经移入一个计算属性</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedFullName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">fullName</span>.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-9-带引号的-attribute-值"><a href="#2-1-9-带引号的-attribute-值" class="headerlink" title="2.1.9 带引号的 attribute 值"></a>2.1.9 带引号的 attribute 值</h4><p><strong>非空 HTML 特性值应该始终带双引号。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppSidebar</span> <span class="attr">:style</span>=<span class="string">&#123;width:sidebarWidth+</span>&#x27;<span class="attr">px</span>&#x27;&#125;&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppSidebar</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: sidebarWidth + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-10-指令缩写"><a href="#2-1-10-指令缩写" class="headerlink" title="2.1.10 指令缩写"></a>2.1.10 指令缩写</h4><ul><li><strong>用 <code>:</code> 表示 <code>v-bind:</code></strong></li><li><strong>用 <code>@</code> 表示 <code>v-on:</code></strong></li><li><strong>用 <code>#</code> 表示 <code>v-slot:</code></strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;newTodoText&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:placeholder</span>=<span class="string">&quot;newTodoInstructions&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-HTML"><a href="#2-2-HTML" class="headerlink" title="2.2 HTML"></a>2.2 HTML</h3><h4 id="2-2-1-文件模板"><a href="#2-2-1-文件模板" class="headerlink" title="2.2.1 文件模板"></a>2.2.1 文件模板</h4><p>HTML5 文件模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5标准模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>移动端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>移动端HTML模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S DNS预解析 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E DNS预解析 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #include virtual=&quot;&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 线上样式页面片 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /本地调试方式 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://srcPath/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /开发机调试方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 本地调试 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PC 端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your keywords&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your description&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;author,email address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge,chrome=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-stand&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>PC端HTML模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S DNS预解析 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E DNS预解析 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #include virtual=&quot;&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 线上样式页面片 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /本地调试方式 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://srcPath/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /开发机调试方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 本地调试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-元素及标签闭合"><a href="#2-2-2-元素及标签闭合" class="headerlink" title="2.2.2 元素及标签闭合"></a>2.2.2 元素及标签闭合</h4><p>HTML 元素共有以下5种：</p><ul><li>空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</li><li>原始文本元素：script、style</li><li>RCDATA 元素：textarea、title</li><li>外来元素：来自 MathML 命名空间和 SVG 命名空间的元素</li><li>常规元素：其他 HTML 允许的元素都称为常规元素</li></ul><p>为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定：</p><ul><li>所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。</li><li>空元素标签都不加 “&#x2F;” 字符。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字，我有始有终，浏览器能正确解析<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> <span class="attr">data-tomark-pass</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字，我有始无终，浏览器亦能正确解析</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-代码嵌套"><a href="#2-2-3-代码嵌套" class="headerlink" title="2.2.3 代码嵌套"></a>2.2.3 代码嵌套</h4><p>元素嵌套规范，每个块状元素独立一行，内联元素可选。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>段落元素与标题元素只能嵌套内联元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-CSS"><a href="#2-3-CSS" class="headerlink" title="2.3 CSS"></a>2.3 CSS</h3><h4 id="2-3-1-样式文件"><a href="#2-3-1-样式文件" class="headerlink" title="2.3.1 样式文件"></a>2.3.1 样式文件</h4><p>样式文件必须写上 <code>@charset</code> 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 <code>“UTF-8”</code>。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @charset规则不在文件首行首个字符开始 */</span></span><br><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @charset规则没有用小写 */</span></span><br><span class="line"><span class="keyword">@CHARSET</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无@charset规则 */</span></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-代码格式化"><a href="#2-3-2-代码格式化" class="headerlink" title="2.3.2 代码格式化"></a>2.3.2 代码格式化</h4><p>样式书写一般有两种：一种是紧凑格式 （Compact），一种是展开格式（Expanded）。</p><ul><li>推荐：展开格式（Expanded）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：紧凑格式 （Compact）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">width</span>: <span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-代码大小写"><a href="#2-3-3-代码大小写" class="headerlink" title="2.3.3 代码大小写"></a>2.3.3 代码大小写</h4><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.JDC</span> &#123;</span><br><span class="line">  <span class="attribute">DISPLAY</span>: BLOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-代码易读性"><a href="#2-3-4-代码易读性" class="headerlink" title="2.3.4 代码易读性"></a>2.3.4 代码易读性</h4><ol><li>左括号与类名之间一个空格，冒号与属性值之间一个空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>逗号分隔的取值，逗号之后一个空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#333</span>, <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#333</span>,<span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>为单个 CSS 选择器或新声明开启新行。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>, <span class="selector-class">.jdc_logo</span>, <span class="selector-class">.jdc_hd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>, <span class="selector-class">.jdc_logo</span>, <span class="selector-class">.jdc_hd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;<span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>属性值十六进制数值能用简写的尽量用简写。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>不要为 <code>0</code> 指明单位。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-5-属性值引号"><a href="#2-3-5-属性值引号" class="headerlink" title="2.3.5 属性值引号"></a>2.3.5 属性值引号</h4><p>CSS 属性值需要用到引号时，统一使用单引号。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Hiragino Sans GB&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Hiragino Sans GB&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-6-属性书写建议"><a href="#2-3-6-属性书写建议" class="headerlink" title="2.3.6 属性书写建议"></a>2.3.6 属性书写建议</h4><p>建议遵循以下顺序：</p><ol><li><p>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</p></li><li><p>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</p></li><li><p>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</p></li><li><p>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background: linear-gradient …</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, <span class="string">&#x27;Helvetica Neue&#x27;</span>, Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-7-CSS3-浏览器私有前缀"><a href="#3-3-7-CSS3-浏览器私有前缀" class="headerlink" title="3.3.7 CSS3 浏览器私有前缀"></a>3.3.7 CSS3 浏览器私有前缀</h4><p>CSS3 浏览器私有前缀在前，标准前缀在后。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-JavaScript"><a href="#2-4-JavaScript" class="headerlink" title="2.4 JavaScript"></a>2.4 JavaScript</h3><h4 id="2-4-1-单行代码块"><a href="#2-4-1-单行代码块" class="headerlink" title="2.4.1 单行代码块"></a>2.4.1 单行代码块</h4><p>在单行代码块中使用空格。</p><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;bar = <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123; bar = <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-大括号风格"><a href="#2-4-2-大括号风格" class="headerlink" title="2.4.2 大括号风格"></a>2.4.2 大括号风格</h4><p>在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下：</p><ul><li><strong>【推荐】One True Brace Style</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Stroustrup</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Allman</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-代码中的空格"><a href="#2-4-3-代码中的空格" class="headerlink" title="2.4.3 代码中的空格"></a>2.4.3 代码中的空格</h4><ol><li>逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>, bar = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>,bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> , bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> ,bar = <span class="number">2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;haha&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span> : <span class="string">&#x27;haha&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>代码块前要添加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)&#123;</span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> ()&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>函数声明括号前要加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span> (x) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在函数调用时，禁止使用空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn ()</span><br><span class="line"></span><br><span class="line">fn</span><br><span class="line">()</span><br></pre></td></tr></table></figure><ol start="6"><li>在操作符前后都需要添加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="三、注释规范"><a href="#三、注释规范" class="headerlink" title="三、注释规范"></a>三、注释规范</h2><p><strong>注释的目的：</strong></p><ul><li><strong>提高代码的可读性，从而提高代码的可维护性</strong></li></ul><p><strong>注释的原则：</strong></p><ul><li><p><strong>如无必要，勿增注释 ( As short as possible )</strong></p></li><li><p><strong>如有必要，尽量详尽 ( As long as necessary )</strong></p></li></ul><h3 id="3-1-HTML-文件注释"><a href="#3-1-HTML-文件注释" class="headerlink" title="3.1 HTML 文件注释"></a>3.1 HTML 文件注释</h3><h4 id="3-1-1-单行注释"><a href="#3-1-1-单行注释" class="headerlink" title="3.1.1 单行注释"></a>3.1.1 单行注释</h4><p><strong>一般用于简单的描述，如某些状态描述、属性描述等。</strong></p><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。</p><ul><li>推荐：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>不推荐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-模块注释"><a href="#3-1-2-模块注释" class="headerlink" title="3.1.2 模块注释"></a>3.1.2 模块注释</h4><p><strong>一般用于描述模块的名称以及模块开始与结束的位置。</strong></p><p>注释内容前后各一个空格字符， <code>&lt;!-- S Comment Text --&gt;</code>表示模块开始， <code>&lt;!-- E Comment Text --&gt;</code>表示模块结束，模块与模块之间相隔一行。</p><ul><li>推荐：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- S Comment Text B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text B --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>不推荐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- S Comment Text B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text B --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-嵌套模块注释"><a href="#3-1-3-嵌套模块注释" class="headerlink" title="3.1.3 嵌套模块注释"></a>3.1.3 嵌套模块注释</h4><p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text --&gt;</span></span><br></pre></td></tr></table></figure><p>而改用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /Comment Text --&gt;</span></span><br></pre></td></tr></table></figure><p>注释写在模块结尾标签底部，单独一行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /mod_b --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_c&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /mod_c --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-CSS-文件注释"><a href="#3-2-CSS-文件注释" class="headerlink" title="3.2 CSS 文件注释"></a>3.2 CSS 文件注释</h3><h4 id="3-2-1-单行注释"><a href="#3-2-1-单行注释" class="headerlink" title="3.2.1 单行注释"></a>3.2.1 单行注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Comment Text */</span> </span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Comment Text */</span> </span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Comment Text*/</span></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;<span class="comment">/*Comment Text*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-模块注释"><a href="#3-2-2-模块注释" class="headerlink" title="3.2.2 模块注释"></a>3.2.2 模块注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，<code>/*</code> 与 模块信息描述占一行，多个横线分隔符 <code>-</code> 与 <code>*/</code> 占一行，行与行之间相隔两行。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Module A</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_a</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Module B</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_b</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Module A ---------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_a</span> &#123;&#125;</span><br><span class="line"><span class="comment">/* Module B ---------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_b</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-文件注释"><a href="#3-2-3-文件注释" class="headerlink" title="3.2.3 文件注释"></a>3.2.3 文件注释</h4><p>在样式文件编码声明 <code>@charset</code> 语句下面注明页面名称、作者、创建日期等信息。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc File Info</span></span><br><span class="line"><span class="comment"> * @author Author Name</span></span><br><span class="line"><span class="comment"> * @date 2015-10-10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-3-JavaScript-文件注释"><a href="#3-3-JavaScript-文件注释" class="headerlink" title="3.3 JavaScript 文件注释"></a>3.3 JavaScript 文件注释</h3><h4 id="3-3-1-单行注释"><a href="#3-3-1-单行注释" class="headerlink" title="3.3.1 单行注释"></a>3.3.1 单行注释</h4><p>单行注释使用 <code>//</code>，注释应单独一行写在被注释对象的上方，不要追加在某条语句的后面。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span> <span class="comment">// is current tab</span></span><br></pre></td></tr></table></figure><p>注释行的上方需要有一个空行（<strong>除非注释行上方是一个块的顶部</strong>），以增加可读性。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> () &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetching type...&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释行上面是一个块的顶部时不需要空行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> () &#123;  </span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> () &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetching type...&#x27;</span>)</span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-多行注释"><a href="#3-3-2-多行注释" class="headerlink" title="3.3.2 多行注释"></a>3.3.2 多行注释</h4><p>多行注释使用 <code>/** ... */</code>，而不是多行的 <code>//</code>。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span> (tag) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make() returns a new element</span></span><br><span class="line"><span class="comment">// based on the passed in tag name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span> (tag) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-注释空格"><a href="#3-3-3-注释空格" class="headerlink" title="3.3.3 注释空格"></a>3.3.3 注释空格</h4><p>注释内容和注释符之间需要有一个空格，以增加可读性。eslint: <code>spaced-comment</code>。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">tag</span>) &#123;  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *make() returns a new element</span></span><br><span class="line"><span class="comment"> *based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">tag</span>) &#123;  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-特殊标记"><a href="#3-3-4-特殊标记" class="headerlink" title="3.3.4 特殊标记"></a>3.3.4 特殊标记</h4><p>有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种：</p><ul><li><p><code>// FIXME</code> : 说明问题是什么</p></li><li><p><code>// TODO</code> : 说明还要做什么或者问题的解决方案</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Abacus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">super</span> ()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> shouldn’t use a global here</span></span><br><span class="line">      total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> total should be configurable by an options param</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">total</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-文档类注释"><a href="#3-3-5-文档类注释" class="headerlink" title="3.3.5 文档类注释"></a>3.3.5 文档类注释</h4><p>文档类注释，如函数、类、文件、事件等；都使用 jsdoc 规范。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Book类，代表一个书本.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">title</span> - 书本的标题.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">author</span> - 书本的作者.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span> (title, author) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">author</span> = author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取书本的标题</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> &#123;<span class="type">string|*</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">getTitle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置书本的页数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pageNum &#123;number&#125; 页数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">setPageNum</span>: <span class="keyword">function</span> (<span class="params">pageNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pageNum</span>=pageNum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-6-注释工具"><a href="#3-3-6-注释工具" class="headerlink" title="3.3.6 注释工具"></a>3.3.6 注释工具</h4><p><code>ESLint</code> 是当下最流行的 JS 代码检查工具，<code>ESLint</code> 中有一些注释相关的规则，用户可选择开启：</p><ul><li><p><code>valid-jsdoc</code></p></li><li><p><code>require-jsdoc</code></p></li><li><p><code>no-warning-comments</code></p></li><li><p><code>capitalized-comments</code></p></li><li><p><code>line-comment-position</code></p></li><li><p><code>lines-around-comment</code></p></li><li><p><code>multiline-comment-style</code></p></li><li><p><code>no-inline-comments</code></p></li><li><p><code>spaced-comment</code></p></li></ul><h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><ul><li>缩进换行请使用两个空格。</li><li>大型团队多人协作项目推荐 JavaScript 代码末尾加分号。</li><li>小型个人创新练手项目可尝试使用 JavaScript 代码末尾不加分号的风格，更加清爽简练。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、命名规范&quot;&gt;&lt;a href=&quot;#一、命名规范&quot; class=&quot;headerlink&quot; title=&quot;一、命名规范&quot;&gt;&lt;/a&gt;一、命名规范&lt;/h2&gt;&lt;p&gt;市面上常用的命名规范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;camelCase&lt;/code&gt;（小驼峰式命名</summary>
      
    
    
    
    
    <category term="代码规范" scheme="https://k705.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>vscode 功能与技巧</title>
    <link href="https://k705.github.io/2024/04/25/%E5%B7%A5%E5%85%B7-vscode%20%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <id>https://k705.github.io/2024/04/25/%E5%B7%A5%E5%85%B7-vscode%20%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E5%B7%A7/</id>
    <published>2024-04-25T03:22:46.000Z</published>
    <updated>2024-04-25T03:30:55.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode-功能与技巧"><a href="#vscode-功能与技巧" class="headerlink" title="vscode 功能与技巧"></a>vscode 功能与技巧</h1><ul><li>一键执行 npm scripts</li><li>一键 diff、预览</li><li>在新页面搜索</li><li>禅模式</li><li>git 视图显示目录树</li><li>在新编辑器打开文件</li><li>编辑时快速删除、复制、移动行</li><li>全局搜索文件、跳转到某行</li><li>快速切换大小写</li></ul><h2 id="一键执行-npm-scripts"><a href="#一键执行-npm-scripts" class="headerlink" title="一键执行 npm scripts"></a>一键执行 npm scripts</h2><p>vscode 会扫描所有的 npm scripts，然后列出来，直接点击 run 就会打开 terminal 来跑，而且高版本 vscode 还可以直接 debug 来跑。</p><p>根本不需要自己输入 npm run xxx。</p><h2 id="在侧栏打开文件"><a href="#在侧栏打开文件" class="headerlink" title="在侧栏打开文件"></a>在侧栏打开文件</h2><p>当打开文件的时候，默认会在当前编辑器打开，如果想新开一个编辑器打开呢？这时候可以按住 option 再点击文件，就会新开一个编辑器打开文件了。</p><h2 id="更强大的搜索"><a href="#更强大的搜索" class="headerlink" title="更强大的搜索"></a>更强大的搜索</h2><p>搜索这个面板有个按钮可能很多同学都没注意到过，点击之后会打开搜索页面来搜索，可以预览的搜索结果更丰富，行数更多。</p><h2 id="文件-diff-显示目录信息"><a href="#文件-diff-显示目录信息" class="headerlink" title="文件 diff 显示目录信息"></a>文件 diff 显示目录信息</h2><p>当我们改了多个文件的时候，会列在 source control 面板的列表里，有多个同名文件的时候特别不直观。</p><p>这时候其实可以切换成 tree view 的，显示目录树。</p><p>当有多个同名文件的时候，这样会清晰的多：</p><h2 id="编辑器一键预览-markdown"><a href="#编辑器一键预览-markdown" class="headerlink" title="编辑器一键预览 markdown"></a>编辑器一键预览 markdown</h2><p>markdown 需要安装插件么？不需要，vscode 本身就内置了这个功能。</p><p>右上角有个预览按钮，点击就会打开 markdown 预览界面，按住 option 再点击，则是同个窗口打开预览。</p><p>预览之后再点击 show source 按钮就会回去</p><h2 id="编辑区一键-diff"><a href="#编辑区一键-diff" class="headerlink" title="编辑区一键 diff"></a>编辑区一键 diff</h2><h3 id="快速切换-diff-和文件编辑视图"><a href="#快速切换-diff-和文件编辑视图" class="headerlink" title="快速切换 diff 和文件编辑视图"></a>快速切换 diff 和文件编辑视图</h3><p>当改了文件内容的时候，可以点击编辑区右上角的按钮，直接打开 diff，可能很多同学都没注意到这些按钮，但其实是很有用的。</p><p>再次点击就可以回到文件编辑状态</p><p>看功能描述 open changes、open files，很明显就是用于 diff 视图和文件编辑视图的切换。</p><h3 id="diff-视图快速在-diff-之间跳转"><a href="#diff-视图快速在-diff-之间跳转" class="headerlink" title="diff 视图快速在 diff 之间跳转"></a>diff 视图快速在 diff 之间跳转</h3><p>当文件内容特别多，比如好几千行的时候，要找 diff 还是比较麻烦的。其实根本不用自己去找，还容易漏，vscode 编辑器提供了上下按钮，可以直接跳到上一个 diff、下一个 diff</p><p>一键预览、一键 diff，这些都是能提高效率的功能。</p><h2 id="快速搜索功能入口"><a href="#快速搜索功能入口" class="headerlink" title="快速搜索功能入口"></a>快速搜索功能入口</h2><p>知道 vscode 有某个功能但是不知道入口在哪？ 直接用 help 下面的搜索框，搜索结果会直接标出来在哪个菜单下有什么按钮。</p><h2 id="禅模式"><a href="#禅模式" class="headerlink" title="禅模式"></a>禅模式</h2><p>vscode 提供了禅模式（zen mode），可以让你专注于写代码。</p><p>先按 command + k 再按 z 就可以进入禅模式，再按一次退出禅模式。</p><p>禅模式下只显示编辑区的信息，并且会全屏，看不到其他的东西，写代码能更专注。</p><h2 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h2><p>编辑器最主要的功能还是编辑，但其实有很多 vscode 的请打编辑功能大家可能没有过，我来罗列一下。</p><h3 id="行上下移动-复制"><a href="#行上下移动-复制" class="headerlink" title="行上下移动&#x2F;复制"></a>行上下移动&#x2F;复制</h3><p>如果把一行内容上移下移怎么做？</p><p>手动剪切粘贴的效率太低了，不如试下 option + 上&#x2F;下 的快捷键，快速把一行内容上下移动。</p><p>移动的时候想复制呢？再按住 shift 就行了。</p><h3 id="快速删除行"><a href="#快速删除行" class="headerlink" title="快速删除行"></a>快速删除行</h3><p>我们知道了如何快速复制行，那快速删除行呢？</p><p>按 command + shift + k 就好了。</p><p>如果删除多行，那么先选中，再按 command + shift + k。</p><h3 id="多光标同时编辑"><a href="#多光标同时编辑" class="headerlink" title="多光标同时编辑"></a>多光标同时编辑</h3><p>同时修改多个地方的内容？按住 option 点击要修改的地方就可以了。</p><p>如果是上下行的同一位置呢？那就 <strong>option + command + 上&#x2F;下</strong>，这样就是添加多行的同一位置的光标。</p><h2 id="comand-shift-p-相关"><a href="#comand-shift-p-相关" class="headerlink" title="comand + shift + p 相关"></a>comand + shift + p 相关</h2><p>这可能是大家都知道的一个快捷键，输入框中会有一个 &gt; 代表后面是命令，但还有一些大家可能不知道。</p><p>比如直接 command + p，不按 shift，这时候就是搜索文件。</p><p>比如直接按 ctrl + g，或者在输入框输入冒号就代表后面是跳转的行号，可以快速跳到某一行</p><p>当然搜索文件的时候也可以加冒号和行号，快速跳到该文件的那一行。</p><h3 id="快速切换大小写"><a href="#快速切换大小写" class="headerlink" title="快速切换大小写"></a>快速切换大小写</h3><p>还有一个小功能，有个内置的 upppercase、lowercase 的切换功能，可以快速切换选中内容的大小写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 vscode 中那些可以提效的一些功能，大家可能没有注意到过。</p><ul><li>一键 diff、预览</li><li>在新页面搜索</li><li>git 视图显示目录树</li><li>一键执行 npm scripts</li><li>在新编辑器打开文件</li><li>编辑时快速删除、复制、移动行</li><li>全局搜索文件、跳转到某行</li><li>快速切换大小写</li><li>禅模式</li></ul><p>熟悉了这些功能的使用，相信会给我们日常开发提升一些效率，学习下每天写代码的工具的使用技巧还是挺有意义的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode-功能与技巧&quot;&gt;&lt;a href=&quot;#vscode-功能与技巧&quot; class=&quot;headerlink&quot; title=&quot;vscode 功能与技巧&quot;&gt;&lt;/a&gt;vscode 功能与技巧&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一键执行 npm scripts&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="工具" scheme="https://k705.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Vue3-pure-admin</title>
    <link href="https://k705.github.io/2024/04/22/Vue3-pure-admin/"/>
    <id>https://k705.github.io/2024/04/22/Vue3-pure-admin/</id>
    <published>2024-04-22T01:58:28.000Z</published>
    <updated>2024-04-22T02:01:47.144Z</updated>
    
    
    
    
    
    <category term="Vue3" scheme="https://k705.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>AntDesign封装</title>
    <link href="https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-Table%E5%8F%8A%E5%85%B6%E7%AD%9B%E9%80%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"/>
    <id>https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-Table%E5%8F%8A%E5%85%B6%E7%AD%9B%E9%80%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T10:16:20.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>代码中使用到了<code>mobx</code>,其实如果只要部分功能,可以不使用<code>mobx</code>,但主要此处列出可以有借鉴效果</p></blockquote><h1 id="一、调用"><a href="#一、调用" class="headerlink" title="一、调用"></a>一、调用</h1><blockquote><p>基本用法与正常antd的table一摸一样,只是多了几个个性化属性,可以满足个性化需求</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="variable constant_">FC</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">Store</span> <span class="keyword">from</span> <span class="string">&#x27;../store&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">Table</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> columns <span class="keyword">from</span> <span class="string">&#x27;./columns&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;../style.scss&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">MyEmpty</span>,<span class="title class_">MyTable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;~/components&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">&gt;<span class="attr">store</span>: <span class="title class_">Store</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">PageTable</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> &#123;</span><br><span class="line">&gt;<span class="attr">source</span>: &#123; tableList, pageConfig, loading &#125;,</span><br><span class="line">&gt;getTableList,</span><br><span class="line">&gt;handleChangeTable,</span><br><span class="line">&gt;&#125; = props.<span class="property">store</span>;</span><br><span class="line">&gt;<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">getTableList</span>();</span><br><span class="line">&gt;&#125;, []);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> (</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.tableContainer&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyTable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">scroll</span>=<span class="string">&#123;&#123;</span> <span class="attr">x:</span> <span class="attr">600</span>, <span class="attr">y:</span> &#x27;<span class="attr">calc</span>(<span class="attr">100</span>% <span class="attr">-</span> <span class="attr">72px</span>)&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">rowKey</span>=<span class="string">&quot;hongjilin&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">showId</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">columns</span>=<span class="string">&#123;columns(props.store)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">dataSource</span>=<span class="string">&#123;tableList&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">pagination</span>=<span class="string">&#123;pageConfig&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">onChange</span>=<span class="string">&#123;handleChangeTable&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">locale</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">emptyText:</span> &lt;<span class="attr">MyEmpty</span> /&gt;</span>, //此处调用的是,如果为空组件</span></span><br><span class="line"><span class="language-xml">  &#125;&#125;</span></span><br><span class="line"><span class="language-xml">/&gt;</span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> (<span class="title class_">PageTable</span>);</span><br></pre></td></tr></table></figure></blockquote><h1 id="二、运行效果"><a href="#二、运行效果" class="headerlink" title="二、运行效果"></a>二、运行效果</h1><blockquote><p><img src="/k705.github.io/AntDesignOfReact%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210806184129571.png"></p></blockquote><h1 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h1><h2 id="Ⅰ-SCSS文件"><a href="#Ⅰ-SCSS文件" class="headerlink" title="Ⅰ-SCSS文件"></a>Ⅰ-SCSS文件</h2><blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//table.scss</span></span><br><span class="line">&gt;<span class="selector-class">.tableWrapper</span> &#123;</span><br><span class="line"> :global &#123;</span><br><span class="line">   <span class="selector-class">.ant-table-row-expand-icon</span> &#123;</span><br><span class="line">     &amp;<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">7px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">right</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">3px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     &amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">3px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">bottom</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">7px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.react-resizable</span> &#123;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">     <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.react-resizable-handle</span> &#123;</span><br><span class="line">     <span class="attribute">position</span>: absolute;</span><br><span class="line">     <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">cursor</span>: col-resize;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="selector-class">.filterBody</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line"> <span class="selector-class">.filterTitle</span> &#123;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">32px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.filterItem</span> &#123;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">   <span class="attribute">align-items</span>: center;</span><br><span class="line">   <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">   <span class="attribute">cursor</span>: pointer;</span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#353535</span>;</span><br><span class="line">   <span class="selector-class">.filterText</span> &#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">     <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &amp;<span class="selector-class">.cursorItem</span> &#123;</span><br><span class="line">     <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.filterItem</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">   <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">   <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">53</span>, <span class="number">105</span>, <span class="number">253</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.line</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#e8e8e8</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">16px</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅱ-resizable-title-tsx"><a href="#Ⅱ-resizable-title-tsx" class="headerlink" title="Ⅱ-resizable-title.tsx"></a>Ⅱ-resizable-title.tsx</h2><blockquote><p>此处为可拖拽表格组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; useLayoutEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">Resizable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-resizable&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">ResizableTitle</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; onResize, width, ...restProps &#125; = props;</span><br><span class="line"> <span class="keyword">const</span> thRef = useRef&lt;any&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Resizable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">width</span>=<span class="string">&#123;width</span> || <span class="attr">thRef.current</span>?<span class="attr">.offsetWidth</span> || <span class="attr">100</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">height</span>=<span class="string">&#123;0&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">handle</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       &lt;<span class="attr">span</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">className</span>=<span class="string">&quot;react-resizable-handle&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">           e.stopPropagation();</span></span><br><span class="line"><span class="language-xml">         &#125;&#125;</span></span><br><span class="line"><span class="language-xml">       /&gt;</span></span><br><span class="line"><span class="language-xml">     &#125;</span></span><br><span class="line"><span class="language-xml">     onResize=&#123;onResize&#125;</span></span><br><span class="line"><span class="language-xml">     draggableOpts=&#123;&#123; enableUserSelectHack: false &#125;&#125;</span></span><br><span class="line"><span class="language-xml">   &gt;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">th</span> <span class="attr">ref</span>=<span class="string">&#123;thRef&#125;</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Resizable</span>&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ResizableTitle</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅲ-table-tsx"><a href="#Ⅲ-table-tsx" class="headerlink" title="Ⅲ-table.tsx"></a>Ⅲ-table.tsx</h2><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123;</span><br><span class="line"> useCallback,</span><br><span class="line"> useEffect,</span><br><span class="line"> useMemo,</span><br><span class="line"> useRef,</span><br><span class="line"> useState,</span><br><span class="line">&gt;&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">Table</span>, <span class="title class_">TableProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">CheckOutlined</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; inject, observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./table.scss&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">ResizableTitle</span> <span class="keyword">from</span> <span class="string">&#x27;./resizable-title&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">ColumnsType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd/lib/table&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;interface <span class="title class_">SuperTableProps</span>&lt;<span class="title class_">RecordType</span>&gt; <span class="keyword">extends</span> <span class="title class_">TableProps</span>&lt;<span class="title class_">RecordType</span>&gt; &#123;</span><br><span class="line"> showId?: boolean;</span><br><span class="line"> <span class="comment">//是否显示筛选自定义列表图标</span></span><br><span class="line"> showColumnFilter?: boolean;</span><br><span class="line"> menuStore?: any;</span><br><span class="line"> userStore?: any;</span><br><span class="line"> <span class="comment">//首列ID是否浮动定位,传入为字符串类型,不传则为空不浮动</span></span><br><span class="line"> fixedType?: <span class="title class_">String</span> | <span class="literal">undefined</span>;</span><br><span class="line"> <span class="comment">//首列ID列的宽度</span></span><br><span class="line"> idWidth?: <span class="title class_">Number</span> | <span class="literal">undefined</span>;</span><br><span class="line"> <span class="comment">//是否需要默认渲染ID列--&gt;true:隐藏</span></span><br><span class="line"> hidderIDColumns?: boolean;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title class_">MyTable</span>&lt;<span class="title class_">RecordType</span> <span class="keyword">extends</span> object = any&gt;(</span><br><span class="line"> <span class="attr">props</span>: <span class="title class_">SuperTableProps</span>&lt;<span class="title class_">RecordType</span>&gt;</span><br><span class="line">&gt;) &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="variable constant_">TABLE_CONFIG_KEY</span> = <span class="string">`TABLE_COLUMNS_CONFIGS_<span class="subst">$&#123;props.userStore.user.name&#125;</span>`</span>;</span><br><span class="line"> <span class="keyword">const</span> &#123; showColumnFilter = <span class="literal">true</span> &#125; = props;</span><br><span class="line"> <span class="keyword">const</span> [hiddenColumns, setHiddenColumns] = <span class="title function_">useState</span>([]);</span><br><span class="line"> <span class="keyword">const</span> [columns, setColumns] = <span class="title function_">useState</span>([]);</span><br><span class="line"> <span class="keyword">const</span> [sorterColumn, setSorterColumn] = <span class="title function_">useState</span>();</span><br><span class="line"> <span class="keyword">const</span> handleResizeRef = useRef&lt;<span class="title class_">Function</span>&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> [pagiConfig, setPagiConfig] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"> <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初次进入页面时，从 localStorage 中读取数据，初始化 hiddenColumns</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">const</span> oldTableColumnsConfigs = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(</span><br><span class="line">     <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="variable constant_">TABLE_CONFIG_KEY</span>)</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">if</span> (!oldTableColumnsConfigs) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> oldHiddenColumns = oldTableColumnsConfigs[props.<span class="property">menuStore</span>.<span class="property">activeKey</span>];</span><br><span class="line">   <span class="keyword">if</span> (oldHiddenColumns) &#123;</span><br><span class="line">     <span class="title function_">setHiddenColumns</span>(oldHiddenColumns);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;, [props.<span class="property">menuStore</span>.<span class="property">activeKey</span>, setHiddenColumns]);</span><br><span class="line"></span><br><span class="line"> handleResizeRef.<span class="property">current</span> =</span><br><span class="line">   <span class="function">(<span class="params">index</span>) =&gt;</span></span><br><span class="line">     <span class="function">(<span class="params">e, &#123; size &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> nextColumns = [...columns];</span><br><span class="line">       nextColumns[index] = &#123;</span><br><span class="line">         ...nextColumns[index],</span><br><span class="line">         <span class="attr">width</span>: size.<span class="property">width</span>,</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="title function_">setColumns</span>(nextColumns);</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; pagination = &#123;&#125;, filters, sorter, otherParams &#125; = pagiConfig;</span><br><span class="line">   <span class="keyword">if</span> (pagination?.<span class="property">current</span> &gt; <span class="number">1</span> &amp;&amp; props?.<span class="property">dataSource</span>?.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 删除了最后一条数据应该返回上一页</span></span><br><span class="line">     <span class="keyword">let</span> newPagi = &#123;</span><br><span class="line">       ...pagination,</span><br><span class="line">       <span class="attr">current</span>: pagination.<span class="property">current</span> - <span class="number">1</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="title function_">handleTableChange</span>(newPagi, filters, sorter, ...otherParams);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;, [props?.<span class="property">dataSource</span>?.<span class="property">length</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; showId = <span class="literal">true</span> &#125; = props;</span><br><span class="line">   <span class="keyword">let</span> newColumns =</span><br><span class="line">     props.<span class="property">columns</span> ||</span><br><span class="line">     <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(props.<span class="property">children</span>, <span class="function">(<span class="params">child: any</span>) =&gt;</span> child?.<span class="property">props</span>);</span><br><span class="line">   <span class="keyword">const</span> hasIdField = newColumns.<span class="title function_">some</span>(</span><br><span class="line">     <span class="function">(<span class="params">col</span>) =&gt;</span> col.<span class="property">dataIndex</span>?.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;id&#x27;</span></span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hasIdField &amp;&amp; showId) &#123;</span><br><span class="line">     <span class="comment">//不传或者传入为false时,为不隐藏ID列</span></span><br><span class="line">     <span class="keyword">if</span> (!props?.<span class="property">hidderIDColumns</span>)</span><br><span class="line">       newColumns.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">         <span class="attr">title</span>: <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">         <span class="attr">dataIndex</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">         <span class="comment">//首列id宽度,如果不传入则默认150</span></span><br><span class="line">         <span class="attr">width</span>: props?.<span class="property">idWidth</span> || <span class="number">150</span>,</span><br><span class="line">         <span class="comment">//首列ID是否浮动定位,传入为字符串类型,不传则为空</span></span><br><span class="line">         <span class="attr">fixed</span>: props?.<span class="property">fixedType</span>,</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   newColumns = newColumns.<span class="title function_">map</span>(<span class="function">(<span class="params">col, index</span>) =&gt;</span> (&#123;</span><br><span class="line">     ...col,</span><br><span class="line">     <span class="attr">onHeaderCell</span>: <span class="function">(<span class="params">column</span>) =&gt;</span> (&#123;</span><br><span class="line">       <span class="attr">width</span>: column.<span class="property">width</span>,</span><br><span class="line">       <span class="attr">onResize</span>: handleResizeRef.<span class="title function_">current</span>(index),</span><br><span class="line">     &#125;),</span><br><span class="line">   &#125;));</span><br><span class="line">   <span class="title function_">setColumns</span>(newColumns);</span><br><span class="line"> &#125;, [props.<span class="property">columns</span>, props.<span class="property">children</span>, handleResizeRef]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> filteredColumns = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//此处根据传入数组</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">applySorterToColumns</span>(<span class="params">columns: ColumnsType</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> columns.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&#x27;sorter&#x27;</span> <span class="keyword">in</span> item) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           ...item,</span><br><span class="line">           <span class="attr">key</span>: item.<span class="property">key</span> || item.<span class="property">dataIndex</span>,</span><br><span class="line">           <span class="attr">sortOrder</span>:</span><br><span class="line">             sorterColumn?.<span class="property">field</span> == item.<span class="property">dataIndex</span> &amp;&amp; sorterColumn?.<span class="property">order</span>,</span><br><span class="line">         &#125;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         ...item,</span><br><span class="line">         <span class="attr">key</span>: item.<span class="property">key</span> || item.<span class="property">dataIndex</span>,</span><br><span class="line">         <span class="attr">isCustomSorter</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="comment">// sorter: (a, b) =&gt; &#123;</span></span><br><span class="line">         <span class="comment">//   return a[item.dataIndex] - b[item.dataIndex];</span></span><br><span class="line">         <span class="comment">// &#125;,</span></span><br><span class="line">         <span class="comment">// sortOrder:</span></span><br><span class="line">         <span class="comment">//   sorterColumn?.field == item.dataIndex &amp;&amp; sorterColumn?.order,</span></span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> filterColumns = columns.<span class="title function_">filter</span>(</span><br><span class="line">     <span class="function">(<span class="params">columns</span>) =&gt;</span> !hiddenColumns.<span class="title function_">includes</span>(columns.<span class="property">dataIndex</span>)</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">const</span> lastColumn = filterColumns[filterColumns.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">   filterColumns[filterColumns.<span class="property">length</span> - <span class="number">1</span>] = &#123;</span><br><span class="line">     ...lastColumn,</span><br><span class="line">     <span class="attr">filterDropdown</span>: showColumnFilter</span><br><span class="line">       ? <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (lastColumn.<span class="property">filterDropdown</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> lastColumn.<span class="title function_">filterDropdown</span>(...params);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_">filterDropdown</span>(...params);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       : <span class="literal">undefined</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//此行控制列表为部筛选图标</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">applySorterToColumns</span>(filterColumns);</span><br><span class="line"> &#125;, [columns, hiddenColumns, sorterColumn]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">setTableField</span>(<span class="params">dataIndex</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> newHiddenColumns = [...hiddenColumns];</span><br><span class="line">   <span class="keyword">if</span> (hiddenColumns.<span class="title function_">includes</span>(dataIndex)) &#123;</span><br><span class="line">     newHiddenColumns = hiddenColumns.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== dataIndex);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     newHiddenColumns = [...hiddenColumns, dataIndex];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断是否赋值</span></span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">     columns.<span class="title function_">some</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> value.<span class="property">title</span> == <span class="string">&#x27;操作&#x27;</span>) &amp;&amp;</span><br><span class="line">     columns.<span class="property">length</span> - <span class="number">1</span> == newHiddenColumns.<span class="property">length</span></span><br><span class="line">   ) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (columns.<span class="property">length</span> == newHiddenColumns.<span class="property">length</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">setHiddenColumns</span>(newHiddenColumns);</span><br><span class="line">   <span class="keyword">if</span> (!<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="variable constant_">TABLE_CONFIG_KEY</span>)) &#123;</span><br><span class="line">     <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(</span><br><span class="line">       <span class="variable constant_">TABLE_CONFIG_KEY</span>,</span><br><span class="line">       <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">         [props.<span class="property">menuStore</span>.<span class="property">activeKey</span>]: newHiddenColumns,</span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> oldTableColumnsConfigs = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(</span><br><span class="line">       <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="variable constant_">TABLE_CONFIG_KEY</span>)</span><br><span class="line">     );</span><br><span class="line">     <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(</span><br><span class="line">       <span class="variable constant_">TABLE_CONFIG_KEY</span>,</span><br><span class="line">       <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">         ...oldTableColumnsConfigs,</span><br><span class="line">         [props.<span class="property">menuStore</span>.<span class="property">activeKey</span>]: newHiddenColumns,</span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">filterDropdown</span>(<span class="params">...params</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.filterBody&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.filterTitle&#125;</span>&gt;</span>自定义表格字段<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">       &#123;columns?.map((column, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">         //不将`操作`放入自定义下拉框中---&gt;暂时将最后一列隐藏,后续再改</span></span><br><span class="line"><span class="language-xml">         if (columns?.length - 1 != index || column?.title != &#x27;操作&#x27;)</span></span><br><span class="line"><span class="language-xml">           return (</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">className</span>=<span class="string">&#123;style.filterItem&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setTableField(column.dataIndex)&#125;</span></span><br><span class="line"><span class="language-xml">             &gt;</span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.filterText&#125;</span>&gt;</span>&#123;column.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               &#123;!hiddenColumns.includes(column.dataIndex) &amp;&amp; <span class="tag">&lt;<span class="name">CheckOutlined</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           );</span></span><br><span class="line"><span class="language-xml">       &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">handleTableChange</span>(<span class="params">pagination, filters, sorter, ...otherParams</span>) &#123;</span><br><span class="line">   <span class="title function_">setPagiConfig</span>(&#123; pagination, filters, sorter, otherParams &#125;);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(sorter, <span class="string">&#x27;sorter&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="title function_">setSorterColumn</span>(&#123; <span class="attr">field</span>: sorter?.<span class="property">field</span>, <span class="attr">order</span>: sorter?.<span class="property">order</span> &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前端排序的字段，在 onChange 时清空 sorter</span></span><br><span class="line"><span class="comment">    * 避免外部捕获 sorter 后传给接口报错</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (sorter?.<span class="property">column</span>?.<span class="property">isCustomSorter</span>) &#123;</span><br><span class="line">     sorter.<span class="property">field</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">     sorter.<span class="property">order</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (props.<span class="property">onChange</span>) &#123;</span><br><span class="line">     props.<span class="title function_">onChange</span>(pagination, filters, sorter, ...otherParams);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// debugger</span></span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Table</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     &#123;<span class="attr">...props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">className</span>=<span class="string">&#123;style.tableWrapper&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">columns</span>=<span class="string">&#123;filteredColumns&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">onChange</span>=<span class="string">&#123;handleTableChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">components</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">header:</span> &#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">cell:</span> <span class="attr">ResizableTitle</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       &#125;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">...</span>(<span class="attr">props.components</span> || &#123;&#125;),</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   /&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">inject</span>(<span class="string">&#x27;menuStore&#x27;</span>, <span class="string">&#x27;userStore&#x27;</span>)(<span class="title function_">observer</span>(<span class="title class_">MyTable</span>));</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;代码中使用到了&lt;code&gt;mobx&lt;/code&gt;,其实如果只要部分功能,可以不使用&lt;code&gt;mobx&lt;/co</summary>
      
    
    
    
    
    <category term="AntDesign" scheme="https://k705.github.io/tags/AntDesign/"/>
    
  </entry>
  
  <entry>
    <title>Ajax笔记</title>
    <link href="https://k705.github.io/2024/04/08/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:44:52.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>本笔记为<code>尚硅谷Web前端Ajax教程初学者零基础入门到精通全套完整版</code>的学习笔记</p><p>该课程主要讲述原生AJAX的写法 以及 市场上常用的对于原生ajax封装的插件简单使用</p><p>此部分知识为学习axios预备知识,预备知识链:ajax –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">promise</a> –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">axios</a> –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0">react</a>&#x2F;<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88">vue</a></p><p>仅供本人<code>洪</code>学习使用</p><p>本人笔记地址分享:<a href="https://gitee.com/hongjilin/hongs-study-notes"><code>全部笔记</code></a>、<a href="https://gitee.com/hongjilin/hongs-study-notes/blob/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md"><code>ajax笔记</code></a></p><p>​记录时间: 2021-3-10当日学习完成</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、Ajax简介"><a href="#一、Ajax简介" class="headerlink" title="一、Ajax简介"></a>一、Ajax简介</h1><blockquote><p>AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。</p><p>通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：<code>无刷新获取数据</code>。</p><p>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p></blockquote><h2 id="1、XML简介"><a href="#1、XML简介" class="headerlink" title="1、XML简介"></a>1、XML简介</h2><blockquote><ol><li><p>XML 可扩展标记语言。</p></li><li><p>XML 被设计用来传输和存储数据。 </p></li><li><p>XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。</p></li></ol></blockquote><blockquote><p>比如说我有一个学生数据：<br>name &#x3D; “孙悟空” ; age &#x3D; 18 ; gender &#x3D; “男” ;</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用 XML 表示：</span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>孙悟空<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现在已经被 JSON 取代了。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;孙悟空&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;男&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2、Ajax的特点"><a href="#2、Ajax的特点" class="headerlink" title="2、Ajax的特点"></a>2、Ajax的特点</h2><h3 id="Ⅰ-AJAX-的优点"><a href="#Ⅰ-AJAX-的优点" class="headerlink" title="Ⅰ-AJAX 的优点"></a>Ⅰ-AJAX 的优点</h3><blockquote><ol><li><p>可以无需刷新页面而与服务器端进行通信。 </p></li><li><p>允许你根据用户事件来更新部分页面内容。</p></li></ol></blockquote><h3 id="Ⅱ-Ajax的缺点"><a href="#Ⅱ-Ajax的缺点" class="headerlink" title="Ⅱ-Ajax的缺点"></a>Ⅱ-Ajax的缺点</h3><blockquote><ol><li><p>没有浏览历史，不能回退</p></li><li><p>存在跨域问题(同源)</p></li><li><p>SEO 不友好</p></li></ol></blockquote><h2 id="3、HTTP简介"><a href="#3、HTTP简介" class="headerlink" title="3、HTTP简介"></a>3、HTTP简介</h2><blockquote><p>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则</p></blockquote><h3 id="Ⅰ-请求报文"><a href="#Ⅰ-请求报文" class="headerlink" title="Ⅰ-请求报文"></a>Ⅰ-请求报文</h3><blockquote><p><code>重点是格式与参数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;行   <span class="variable constant_">POST</span> /s?ie=utf-<span class="number">8</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> </span><br><span class="line"></span><br><span class="line">&gt;头   <span class="title class_">Host</span>: atguigu.<span class="property">com</span></span><br><span class="line">&gt;​    <span class="title class_">Cookie</span>: name=guigu</span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">type</span>: application/x-www-form-urlencoded</span><br><span class="line">&gt;​    <span class="title class_">User</span>-<span class="title class_">Agent</span>: chrome <span class="number">83</span></span><br><span class="line">&gt;空行</span><br><span class="line">&gt;体   username=admin&amp;password=admin</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-响应报文"><a href="#Ⅱ-响应报文" class="headerlink" title="Ⅱ-响应报文"></a>Ⅱ-响应报文</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;行   <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"></span><br><span class="line">&gt;头   <span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">length</span>: <span class="number">2048</span></span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">encoding</span>: gzip</span><br><span class="line">&gt;空行  </span><br><span class="line">&gt;体   &lt;html&gt;</span><br><span class="line">&gt;​      &lt;head&gt;</span><br><span class="line">&gt;​      &lt;/head&gt;</span><br><span class="line">&gt;​      &lt;body&gt;</span><br><span class="line">&gt;​        &lt;h1&gt;尚硅谷&lt;/h1&gt;</span><br><span class="line">&gt;​      &lt;/body&gt;</span><br><span class="line">&gt;​    &lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Chrome网络控制台查看通信报文"><a href="#Ⅲ-Chrome网络控制台查看通信报文" class="headerlink" title="Ⅲ-Chrome网络控制台查看通信报文"></a>Ⅲ-Chrome网络控制台查看通信报文</h3><blockquote><p>1、Network  –&gt; Hearders  请求头</p><p>2、Network  –&gt; Response 响应体:通常返回的是html</p></blockquote><h1 id="二、原生Ajax"><a href="#二、原生Ajax" class="headerlink" title="二、原生Ajax"></a>二、原生Ajax</h1><blockquote><p>1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。</p><p>2、当你前端想设置自定义的请求头时,需要如此后端设置响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示接收任意类型的请求</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123; <span class="comment">//响应头 允许跨域     运行自定义响应头</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure><p>3、<code>ajax请求状态</code>:xhr.readyState<br>    0：请求未初始化，还没有调用 open()。</p><p>​1：请求已经建立，但是还没有发送，还没有调用 send()。</p><p>​2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</p><p>​3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。</p><p>​4：响应已完成；您可以获取并使用服务器的响应了</p></blockquote><h3 id="〇-Ajax的使用"><a href="#〇-Ajax的使用" class="headerlink" title="〇-Ajax的使用"></a>〇-Ajax的使用</h3><blockquote><p>使用步骤:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>) 创建 <span class="title class_">XMLHttpRequest</span> 对象</span><br><span class="line">&gt;<span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&gt;<span class="number">2</span>) 设置请求信息</span><br><span class="line">&gt;xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">&gt;<span class="comment">//可以设置请求头，一般不设置</span></span><br><span class="line">&gt;xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">&gt;<span class="number">3</span>) 发送请求</span><br><span class="line">&gt;xhr.<span class="title function_">send</span>(body) <span class="comment">//get 请求不传 body 参数，只有 post 请求使用</span></span><br><span class="line">&gt;<span class="number">4</span>) 接收响应</span><br><span class="line">&gt;<span class="comment">//xhr.responseXML 接收 xml 格式的响应数据</span></span><br><span class="line">&gt;<span class="comment">//xhr.responseText 接收文本格式的响应数据</span></span><br><span class="line">&gt;xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">var</span> text = xhr.<span class="property">responseText</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&gt;&#125;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅰ-Get方式"><a href="#Ⅰ-Get方式" class="headerlink" title="Ⅰ-Get方式"></a>Ⅰ-Get方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//1. 创建对象</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="comment">//2. 初始化 设置请求方法和 url</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">  <span class="comment">//3. 发送</span></span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  <span class="comment">//4. 事件绑定 处理服务端返回的结果</span></span><br><span class="line">  <span class="comment">// on  when 当....时候</span></span><br><span class="line">  <span class="comment">// readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</span></span><br><span class="line">  <span class="comment">// change  改变</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//判断 (服务端返回了所有的结果)</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">//判断响应状态码 200  404  403 401 500</span></span><br><span class="line">      <span class="comment">// 2xx 成功</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="comment">//处理结果  行 头 空行 体</span></span><br><span class="line">        <span class="comment">//响应 </span></span><br><span class="line">        <span class="comment">// console.log(xhr.status);//状态码</span></span><br><span class="line">        <span class="comment">// console.log(xhr.statusText);//状态字符串</span></span><br><span class="line">        <span class="comment">// console.log(xhr.getAllResponseHeaders());//所有响应头</span></span><br><span class="line">        <span class="comment">// console.log(xhr.response);//响应体</span></span><br><span class="line">        <span class="comment">//设置 result 的文本</span></span><br><span class="line">        result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-Post方式"><a href="#Ⅱ-Post方式" class="headerlink" title="Ⅱ-Post方式"></a>Ⅱ-Post方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">   result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">//1. 创建对象</span></span><br><span class="line">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">       <span class="comment">//2. 初始化 设置类型与 URL</span></span><br><span class="line">       xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line">       <span class="comment">//设置请求头</span></span><br><span class="line">       xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">       xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span>);</span><br><span class="line">       <span class="comment">//3. 发送</span></span><br><span class="line">       xhr.<span class="title function_">send</span>(<span class="string">&#x27;a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">       <span class="comment">// xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;);</span></span><br><span class="line">       <span class="comment">// xhr.send(&#x27;1233211234567&#x27;);</span></span><br><span class="line">       <span class="comment">//4. 事件绑定</span></span><br><span class="line">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="comment">//判断</span></span><br><span class="line">           <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                   <span class="comment">//处理服务端返回的结果</span></span><br><span class="line">                   result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-解决ie缓存问题"><a href="#Ⅲ-解决ie缓存问题" class="headerlink" title="Ⅲ-解决ie缓存问题"></a>Ⅲ-解决ie缓存问题</h3><blockquote><p>问题：在一些浏览器中(IE),由于<code>缓存机制</code>的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。</p><p>解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 <code>xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now());</code></p></blockquote><h3 id="Ⅳ-请求超时与网络异常"><a href="#Ⅳ-请求超时与网络异常" class="headerlink" title="Ⅳ-请求超时与网络异常"></a>Ⅳ-请求超时与网络异常</h3><blockquote><p>当你的请求时间过长,或者无网络时,进行的相应处理</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">         <span class="comment">//超时设置 2s 设置</span></span><br><span class="line">         xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">         <span class="comment">//超时回调</span></span><br><span class="line">         xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;网络异常, 请稍后重试!!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//网络异常回调</span></span><br><span class="line">         xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;你的网络似乎出了一些问题!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         xhr.<span class="title function_">send</span>();</span><br><span class="line">         xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span>&lt; <span class="number">300</span>)&#123;</span><br><span class="line">                     result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><h3 id="Ⅴ-取消请求"><a href="#Ⅴ-取消请求" class="headerlink" title="Ⅴ-取消请求"></a>Ⅴ-取消请求</h3><blockquote><p>在请求发出去后<code>但是未响应完成</code>时可以进行取消请求操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">    x.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abort</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x.<span class="title function_">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅵ-重复请求问题"><a href="#Ⅵ-重复请求问题" class="headerlink" title="Ⅵ-重复请求问题"></a>Ⅵ-重复请求问题</h3><blockquote><p>利用之前Ⅴ中取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="comment">//判断标识变量</span></span><br><span class="line">         <span class="keyword">if</span>(isSending) x.<span class="title function_">abort</span>();<span class="comment">// 如果正在发送, 则取消该请求, 创建一个新的请求</span></span><br><span class="line">         x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">         <span class="comment">//修改 标识变量的值</span></span><br><span class="line">         isSending = <span class="literal">true</span>;</span><br><span class="line">         x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         x.<span class="title function_">send</span>();</span><br><span class="line">         x.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(x.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="comment">//修改标识变量</span></span><br><span class="line">                 isSending = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="三、常见三种Ajax请求方式"><a href="#三、常见三种Ajax请求方式" class="headerlink" title="三、常见三种Ajax请求方式"></a>三、常见三种Ajax请求方式</h1><h2 id="1、jQuery发送AJAX请求"><a href="#1、jQuery发送AJAX请求" class="headerlink" title="1、jQuery发送AJAX请求"></a>1、jQuery发送AJAX请求</h2><blockquote><p>jQuery有三种发送请求方法:</p><p>当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用<code>$.ajax()</code>方法</p></blockquote><h3 id="Ⅰ-get"><a href="#Ⅰ-get" class="headerlink" title="Ⅰ-$.get()"></a>Ⅰ-$.get()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          $.<span class="title function_">get</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">          &#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-post"><a href="#Ⅱ-post" class="headerlink" title="Ⅱ-$.post()"></a>Ⅱ-$.post()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">1</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          $.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-ajax"><a href="#Ⅲ-ajax" class="headerlink" title="Ⅲ-$.ajax"></a>Ⅲ-$.ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">2</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">             <span class="comment">//url</span></span><br><span class="line">             <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>,</span><br><span class="line">             <span class="comment">//参数</span></span><br><span class="line">             <span class="attr">data</span>: &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;,</span><br><span class="line">             <span class="comment">//请求类型</span></span><br><span class="line">             <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">             <span class="comment">//响应体结果</span></span><br><span class="line">             <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">             <span class="comment">//成功的回调</span></span><br><span class="line">             <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">                 <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//超时时间</span></span><br><span class="line">             <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">             <span class="comment">//失败的回调</span></span><br><span class="line">             <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出错啦!!&#x27;</span>);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//头信息</span></span><br><span class="line">             <span class="attr">headers</span>: &#123;</span><br><span class="line">                 <span class="attr">c</span>:<span class="number">300</span>,</span><br><span class="line">                 <span class="attr">d</span>:<span class="number">400</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h2 id="2、Axios发送AJAX请求"><a href="#2、Axios发送AJAX请求" class="headerlink" title="2、Axios发送AJAX请求"></a>2、Axios发送AJAX请求</h2><h3 id="Ⅰ-axios-get"><a href="#Ⅰ-axios-get" class="headerlink" title="Ⅰ-axios.get()"></a>Ⅰ-axios.get()</h3><blockquote><p>axios.get(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置 baseURL</span></span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//GET 请求</span></span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//url 参数</span></span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">vip</span>: <span class="number">7</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求头信息</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-axios-get"><a href="#Ⅱ-axios-get" class="headerlink" title="Ⅱ-axios.get()"></a>Ⅱ-axios.get()</h3><blockquote><p>axios.post(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;  </span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     axios.<span class="title function_">post</span>(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">       <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">       <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">     &#125;, &#123;</span><br><span class="line">       <span class="comment">//url </span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: <span class="number">200</span>,</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">9</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求头参数</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">         <span class="attr">weight</span>: <span class="number">180</span>,</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-axios-常用"><a href="#Ⅲ-axios-常用" class="headerlink" title="Ⅲ-axios() 常用"></a>Ⅲ-axios() <code>常用</code></h3><blockquote><p>axios({})</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line">btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="title function_">axios</span>(&#123;</span><br><span class="line">       <span class="comment">//请求方法</span></span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">       <span class="comment">//url</span></span><br><span class="line">       <span class="attr">url</span>: <span class="string">&#x27;/axios-server&#x27;</span>,</span><br><span class="line">       <span class="comment">//url参数</span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">level</span>: <span class="number">30</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">         <span class="attr">b</span>: <span class="number">200</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求体参数</span></span><br><span class="line">       <span class="attr">data</span>: &#123;</span><br><span class="line">         <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">         <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//响应状态码</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">       <span class="comment">//响应状态字符串</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">       <span class="comment">//响应头信息</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">       <span class="comment">//响应体</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3、Fetch发送AJAX请求"><a href="#3、Fetch发送AJAX请求" class="headerlink" title="3、Fetch发送AJAX请求"></a>3、Fetch发送AJAX请求</h2><blockquote><p>代码示例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//请求方法</span></span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="comment">//请求头</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求体</span></span><br><span class="line">      <span class="attr">body</span>: <span class="string">&#x27;username=admin&amp;password=admin&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return response.text();</span></span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="四、跨域与解决"><a href="#四、跨域与解决" class="headerlink" title="四、跨域与解决"></a>四、跨域与解决</h1><blockquote><h5 id="1、什么是跨越？"><a href="#1、什么是跨越？" class="headerlink" title="1、什么是跨越？"></a>1、什么是跨越？</h5><ul><li>一个网页向另一个不同域名&#x2F;不同协议&#x2F;不同端口的网页请求资源，这就是跨域。</li><li>跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。</li></ul><h5 id="2、为什么会产生跨域请求？"><a href="#2、为什么会产生跨域请求？" class="headerlink" title="2、为什么会产生跨域请求？"></a>2、为什么会产生跨域请求？</h5><ul><li>因为浏览器使用了同源策略</li></ul><h5 id="3、什么是同源策略？"><a href="#3、什么是同源策略？" class="headerlink" title="3、什么是同源策略？"></a>3、什么是同源策略？</h5><ul><li>同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。</li><li>同源： 协议、域名、端口号 必须完全相同。 <code>违背同源策略就是跨域</code>。</li></ul><h5 id="4、为什么浏览器要使用同源策略？"><a href="#4、为什么浏览器要使用同源策略？" class="headerlink" title="4、为什么浏览器要使用同源策略？"></a>4、为什么浏览器要使用同源策略？</h5><ul><li>是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能:</li><li><ul><li>1、共享Cookie、LocalStorage、IndexDB</li></ul></li><li><ul><li>2、获取DOM</li></ul></li><li><ul><li>3、AJAX请求不能发送</li></ul></li></ul><h5 id="5、跨域的五个解决方式"><a href="#5、跨域的五个解决方式" class="headerlink" title="5、跨域的五个解决方式:"></a>5、跨域的五个解决方式:</h5><p>​1、前端使用jsonp （不推荐使用）</p><p>​2、后台Http请求转发</p><p>​3、后台配置同源Cors （推荐）</p><p>​4、使用SpringCloud网关</p><p>​5、使用nginx做转发 (推荐)</p><p>本课程提到了其中的两种:</p></blockquote><h2 id="1、jsonP"><a href="#1、jsonP" class="headerlink" title="1、jsonP"></a>1、jsonP</h2><blockquote><p>1)JSONP 是什么?</p><p>​JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。</p><p>2)JSONP 怎么工作的？</p><p>​在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p></blockquote><h3 id="Ⅰ-jsonP的使用"><a href="#Ⅰ-jsonP的使用" class="headerlink" title="Ⅰ-jsonP的使用"></a>Ⅰ-jsonP的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1. 动态的创建一个 script 标签------------------------------------------------------------</span></span><br><span class="line">   <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//2. 设置 script 的 src， 设置回调函数</span></span><br><span class="line">   script.<span class="property">src</span> = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">abc</span>(<span class="params">data</span>) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(data.<span class="property">name</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">// 3. 将 script 添加到 body 中</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 服务器中路由的处理------------------------------------------------------</span></span><br><span class="line">   router.<span class="title function_">get</span>(<span class="string">&quot;/testAJAX&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">     <span class="keyword">var</span> callback = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">ame</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">       <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">     &#125;</span><br><span class="line">     res.<span class="title function_">send</span>(callback + <span class="string">&quot;(&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-jQuery发送jsonP请求"><a href="#Ⅱ-jQuery发送jsonP请求" class="headerlink" title="Ⅱ-jQuery发送jsonP请求"></a>Ⅱ-jQuery发送jsonP请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端代码-----------------------------------------------------------------------------------</span></span><br><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  $.<span class="title function_">getJSON</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">                名称: <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;</span></span><br><span class="line"><span class="string">                校区: <span class="subst">$&#123;data.city&#125;</span></span></span><br><span class="line"><span class="string">            `</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码-----------------------------------------------------------</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-我自己开发封装的jsonP插件"><a href="#Ⅲ-我自己开发封装的jsonP插件" class="headerlink" title="Ⅲ-我自己开发封装的jsonP插件"></a>Ⅲ-我自己开发封装的jsonP插件</h3><blockquote><p>1、代价:需要前后端联动<br>2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数<br>3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子）<br>4、参数拼接：url已经是带参的。和不带参的<br>5、id优化 额可以添加一个容器来管理id</p></blockquote><blockquote><p>1、前端调用测试封装好的jsonP代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试调用函数</span></span><br><span class="line">    <span class="keyword">let</span> test=<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        jsonP.<span class="title function_">req</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/jsonpx&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="string">&quot;111&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">callback</span>:<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&quot;成功&quot;</span>+result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、服务端测试代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/jsonpx&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">req, resp, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callback=req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="keyword">let</span> data=req.<span class="property">query</span>.<span class="property">a</span>;</span><br><span class="line">    <span class="keyword">if</span> (!data)&#123;</span><br><span class="line">        resp.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码&#x27;)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码`</span>+data+<span class="string">`&#x27;)`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>3、封装原生代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/**author:<span class="doctag">@hongjilin</span></span></span><br><span class="line"><span class="comment">     * 1.声明一个jsonP插件对象</span></span><br><span class="line"><span class="comment">     * 作用：隔开作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> jsonP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *2.在插件对象中创建两个名字备用符数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">char</span> = &#123;</span><br><span class="line">        <span class="title class_">Number</span>: <span class="string">&#x27;0123456789&#x27;</span>,</span><br><span class="line">        <span class="title class_">Letter</span>: <span class="string">&#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过随机数抽取备用字符数组库拼凑函数id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">charLen</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">numLen</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">newFunId</span> = <span class="keyword">function</span> (<span class="params">charLen, numLen</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; charLen; i++) &#123;</span><br><span class="line">            id += <span class="variable language_">this</span>.<span class="property">char</span>.<span class="property">Letter</span>.<span class="title function_">charAt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numLen; j++) &#123;</span><br><span class="line">            id += <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼接路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">url</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">jointUrl</span> = <span class="keyword">function</span> (<span class="params">url, key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url &amp;&amp; key &amp;&amp; value) &#123;</span><br><span class="line">            <span class="keyword">let</span> sign = <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">            <span class="comment">//如果是第一次</span></span><br><span class="line">            <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                sign = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            url += sign + key + <span class="string">&quot;=&quot;</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     封装err属性方便</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">err</span> = <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">options</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">req</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> jsonId=&#123;&#125;;</span><br><span class="line">        <span class="comment">//1.生成方法名</span></span><br><span class="line">        jsonId.<span class="property">funId</span> = <span class="variable language_">this</span>.<span class="title function_">newFunId</span>(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Userurl</span> = options.<span class="property">url</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Userdata</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">err</span>(<span class="string">&quot;输入不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">Userurl</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">err</span>(<span class="string">&quot;url不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">Userdata</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有data,初始化</span></span><br><span class="line">            <span class="title class_">Userdata</span> = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将函数名赋值给userdata的回调函数属性中</span></span><br><span class="line">        <span class="title class_">Userdata</span>.<span class="property">callback</span> = jsonId.<span class="property">funId</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="title class_">Userdata</span>) &#123;</span><br><span class="line">            <span class="title class_">Userurl</span> = <span class="variable language_">this</span>.<span class="title function_">jointUrl</span>(<span class="title class_">Userurl</span>, key, <span class="title class_">Userdata</span>[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span> , jsonId.<span class="property">funId</span>);</span><br><span class="line">        script.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span> , <span class="title class_">Userurl</span>);</span><br><span class="line">        <span class="comment">//动态生成函数</span></span><br><span class="line">        <span class="keyword">let</span> callback=<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">            <span class="comment">//业务逻辑回调</span></span><br><span class="line">            <span class="keyword">if</span> (options.<span class="property">callback</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    options.<span class="title function_">callback</span>(result)</span><br><span class="line">                &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">err</span>(e.<span class="property">message</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//善后</span></span><br><span class="line">            <span class="keyword">let</span> tmp=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(jsonId.<span class="property">funId</span>)</span><br><span class="line">            tmp.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(tmp);</span><br><span class="line">            <span class="built_in">eval</span>(jsonId.<span class="property">funId</span>+<span class="string">&#x27;=null&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;window.&quot;</span>+jsonId.<span class="property">funId</span>+<span class="string">&quot;=function(result)&#123; callback(result) &#125;&quot;</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h2><blockquote><p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS文档链接</a></p><p>2、CORS是什么?</p><p>​CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p><p>3、CORS是怎么工作的?</p><p>​CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。</p></blockquote><h3 id="Ⅰ-代码示例"><a href="#Ⅰ-代码示例" class="headerlink" title="Ⅰ-代码示例"></a>Ⅰ-代码示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">    <span class="comment">//响应首部中可以携带一个 Access-Control-Allow-Origin 字段</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-HTTP-响应首部字段"><a href="#Ⅱ-HTTP-响应首部字段" class="headerlink" title="Ⅱ-HTTP 响应首部字段"></a>Ⅱ-<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#http_%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 响应首部字段</a></h3><blockquote><p>本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。</p></blockquote><h4 id="1、Access-Control-Allow-Origin"><a href="#1、Access-Control-Allow-Origin" class="headerlink" title="1、Access-Control-Allow-Origin"></a>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-origin">Access-Control-Allow-Origin</a></h4><blockquote><p>响应首部中可以携带一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 字段，其语法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。</p><p>例如，下面的字段值将允许来自 <a href="http://mozilla.com/">http://mozilla.com</a> 的请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//mozilla.com</span></span><br></pre></td></tr></table></figure><p>如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。</p></blockquote><h4 id="2、Access-Control-Expose-Headers"><a href="#2、Access-Control-Expose-Headers" class="headerlink" title="2、Access-Control-Expose-Headers"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-expose-headers">Access-Control-Expose-Headers</a></h4><blockquote><p>译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a> 头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: X-<span class="title class_">My</span>-<span class="title class_">Custom</span>-<span class="title class_">Header</span>, X-<span class="title class_">Another</span>-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br></pre></td></tr></table></figure><p>这样浏览器就能够通过getResponseHeader访问<code>X-My-Custom-Header</code>和 <code>X-Another-Custom-Header</code> 响应头了。</p></blockquote><h4 id="3、Access-Control-Max-Age"><a href="#3、Access-Control-Max-Age" class="headerlink" title="3、Access-Control-Max-Age"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-max-age">Access-Control-Max-Age</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age"><code>Access-Control-Max-Age</code></a> 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure><p><code>delta-seconds</code> 参数表示preflight请求的结果在多少秒内有效。</p></blockquote><h4 id="4、Access-Control-Allow-Credentials"><a href="#4、Access-Control-Allow-Credentials" class="headerlink" title="4、Access-Control-Allow-Credentials"></a>4、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-credentials">Access-Control-Allow-Credentials</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a> 头指定了当浏览器的<code>credentials</code>设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用<code>credentials</code>。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="5、Access-Control-Allow-Methods"><a href="#5、Access-Control-Allow-Methods" class="headerlink" title="5、Access-Control-Allow-Methods"></a>5、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-methods">Access-Control-Allow-Methods</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h4 id="6、Access-Control-Allow-Headers"><a href="#6、Access-Control-Allow-Headers" class="headerlink" title="6、Access-Control-Allow-Headers"></a>6、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-headers">Access-Control-Allow-Headers</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a> 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-HTTP-请求首部字段"><a href="#Ⅲ-HTTP-请求首部字段" class="headerlink" title="Ⅲ-HTTP 请求首部字段"></a>Ⅲ-<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#http_%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 请求首部字段</a></h3><blockquote><p>本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。</p></blockquote><h4 id="1、Origin"><a href="#1、Origin" class="headerlink" title="1、Origin"></a>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#origin">Origin</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 首部字段表明预检请求或实际请求的源站。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Origin</span>: &lt;origin&gt;</span><br></pre></td></tr></table></figure><p>origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。</p><p><strong>Note:</strong> 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。</p><p>注意，在所有访问控制请求（Access control request）中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 首部字段<strong>总是</strong>被发送</p></blockquote><h4 id="2、Access-Control-Request-Method"><a href="#2、Access-Control-Request-Method" class="headerlink" title="2、Access-Control-Request-Method"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-request-method">Access-Control-Request-Method</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a> 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: &lt;method&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3、Access-Control-Request-Headers"><a href="#3、Access-Control-Request-Headers" class="headerlink" title="3、Access-Control-Request-Headers"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-request-headers">Access-Control-Request-Headers</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></blockquote><hr><hr><h1 id="五、服务端代码示例"><a href="#五、服务端代码示例" class="headerlink" title="五、服务端代码示例"></a>五、服务端代码示例</h1><blockquote><p>配合以上前端代码的服务端代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX - 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以接收任意类型的请求 </span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX POST&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON 响应</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应一个数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//对对象进行字符串转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对 IE 缓存</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO IE - 5&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时响应</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/delay&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&#x27;延时响应&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//axios 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/axios-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetch 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/fetch-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户名检测是否存在</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/check-username&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">exist</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;用户名已经存在&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本笔记为&lt;code&gt;尚硅谷Web前端Ajax教程初学者零基础入门到精通全套完整版&lt;/code&gt;的学习笔记&lt;/p</summary>
      
    
    
    
    
    <category term="Ajax" scheme="https://k705.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>antd原生Notification通知提醒框</title>
    <link href="https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-%E5%B0%81%E8%A3%85Notification%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92%E6%A1%86%E7%BB%84%E4%BB%B6/"/>
    <id>https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-%E5%B0%81%E8%A3%85Notification%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92%E6%A1%86%E7%BB%84%E4%BB%B6/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:33:17.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p><a href="https://ant.design/components/notification-cn/">antd原生Notification通知提醒框地址</a></p><p>此组件为二次封装[<code>antd原生Notification通知提醒框</code>],方便项目使用.也能起到一定的借鉴与记录作用</p></blockquote><h1 id="Ⅰ-封装的组件代码"><a href="#Ⅰ-封装的组件代码" class="headerlink" title="Ⅰ-封装的组件代码"></a>Ⅰ-封装的组件代码</h1><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> &#123; notification &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">//此处根据自己需求定义,也可以不进行匹配</span></span><br><span class="line">&gt;<span class="keyword">const</span>  <span class="title class_">NotificationType</span>= &#123;</span><br><span class="line">   <span class="title class_">NetError</span>: -<span class="number">1</span>,</span><br><span class="line">   <span class="title class_">ServerError</span>: -<span class="number">2</span>,</span><br><span class="line">   <span class="title class_">OtherError</span>: -<span class="number">3</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">NotificationConfig</span> &#123;</span><br><span class="line"> msg?;</span><br><span class="line"> duration?: <span class="built_in">number</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">HongNotification</span> = &#123;</span><br><span class="line"> <span class="comment">//配置默认[config],此处可修改</span></span><br><span class="line"> <span class="attr">defaultConfig</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">   <span class="attr">message</span>: <span class="string">&#x27;提示框&#x27;</span>,</span><br><span class="line">   <span class="attr">duration</span>: <span class="number">2</span>, <span class="comment">//默认自动关闭延时，单位秒</span></span><br><span class="line"> &#125;),</span><br><span class="line"> <span class="comment">// 二次确认</span></span><br><span class="line"> <span class="attr">base</span>: <span class="function">(<span class="params"><span class="keyword">type</span>, beforeConfig</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> config = beforeConfig;</span><br><span class="line">   <span class="comment">//当传入的提示内容为空,提示写死的内容</span></span><br><span class="line">   <span class="keyword">if</span> (config.<span class="property">msg</span> === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">     config = &#123;</span><br><span class="line">       <span class="attr">msg</span>: <span class="string">&#x27;请稍候重试&#x27;</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   config.<span class="property">description</span> = config.<span class="property">msg</span>;</span><br><span class="line">   <span class="keyword">delete</span> config.<span class="property">msg</span>;</span><br><span class="line"></span><br><span class="line">   notification[<span class="keyword">type</span>](</span><br><span class="line">     &#123; ...<span class="title class_">HongNotification</span>.<span class="title function_">defaultConfig</span>(), ...config &#125;</span><br><span class="line">   );</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">success</span>: <span class="function">(<span class="params">config: NotificationConfig = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!config.<span class="property">msg</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;success&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">info</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;info&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">warning</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;warning&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">error</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">   <span class="comment">// 传入的错误信息为-1 固定都是提示网络问题</span></span><br><span class="line">   <span class="keyword">if</span> (config.<span class="property">msg</span> == <span class="title class_">NotificationType</span>.<span class="property">NetError</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;网络异常，请检查网络环境后重试&#x27;</span>;</span><br><span class="line">    <span class="comment">//传入为-2,提示为服务器繁忙，请稍后重试错误 </span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.<span class="property">msg</span> == <span class="title class_">NotificationType</span>.<span class="property">ServerError</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;服务器繁忙，请稍后重试&#x27;</span>;</span><br><span class="line">     <span class="comment">//传入为-3,其他某种错误提示[可以自己定]</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.<span class="property">msg</span> == <span class="title class_">NotificationType</span>.<span class="property">OtherError</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;请稍候重试&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用二次确认函数</span></span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;error&#x27;</span>, config);</span><br><span class="line">   <span class="comment">//,如果不需要写死的数据,这样调用即可</span></span><br><span class="line">   <span class="comment">//  HongNotification.base(&#x27;error&#x27;, &#123;&#123;msg:&quot;努力学习的汪!!&quot;&#125;&#125;);</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">open</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;open&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HongNotification</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h1 id="Ⅱ-调用场景"><a href="#Ⅱ-调用场景" class="headerlink" title="Ⅱ-调用场景"></a>Ⅱ-调用场景</h1><blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;------------------  提示写死的数据方式:具体效果看下方[实现效果]  --------------------------;</span><br><span class="line">&gt;<span class="comment">//此为自己写死的固定提示</span></span><br><span class="line"><span class="title class_">HongNotification</span>.<span class="title function_">warning</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;无数据可导出&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// [res?.message]为服务端传来的,</span></span><br><span class="line">&gt;<span class="comment">//如果其值匹配代码中[NotificationType],则提示相应写死的提示内容 --&gt;如下方的网络异常</span></span><br><span class="line">&gt;<span class="comment">//如果没匹配上,直接显示服务端给的msg</span></span><br><span class="line"><span class="title class_">HongNotification</span>.<span class="title function_">error</span>(&#123; <span class="attr">msg</span>: res?.<span class="property">message</span> &#125;);</span><br><span class="line">                                            </span><br><span class="line">&gt;------------------- 具体场景示例代码  ----------------------------------------------- ;                        </span><br><span class="line"> getData = <span class="keyword">async</span> (params) =&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//当你进行请求时--&gt;[HTTP]泛指如axios ajax等请求  </span></span><br><span class="line">   <span class="keyword">const</span> res =<span class="keyword">await</span>  <span class="variable constant_">HTTP</span>.<span class="title function_">get</span>(<span class="string">&#x27;/api/请求的接口&#x27;</span>,&#123;params&#125;)</span><br><span class="line">     <span class="keyword">if</span> (res.<span class="property">code</span> == <span class="number">200</span> )  <span class="variable language_">this</span>.<span class="property">datas</span> = res?.<span class="property">data</span>;</span><br><span class="line">     <span class="comment">//如果服务端返回的状态码不是[200]则将其返回的错误信息以提示框显示  </span></span><br><span class="line">     <span class="keyword">else</span>  <span class="title class_">HongNotification</span>.<span class="title function_">error</span>(&#123; <span class="attr">msg</span>: res?.<span class="property">message</span> &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     <span class="title class_">HongNotification</span>.<span class="title function_">error</span>(&#123; <span class="attr">msg</span>: error &#125;);<span class="comment">//如果发生异常,将异常信息捕捉并传入提示框</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Ⅲ-实现效果"><a href="#Ⅲ-实现效果" class="headerlink" title="Ⅲ-实现效果"></a>Ⅲ-实现效果</h1><blockquote><p><img src="/k705.github.io/AntDesignOfReact%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210723164024197.png" alt="image-20210723164024197"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ant.design/components/notification-cn/</summary>
      
    
    
    
    
    <category term="antDesign" scheme="https://k705.github.io/tags/antDesign/"/>
    
  </entry>
  
  <entry>
    <title>Axios笔记</title>
    <link href="https://k705.github.io/2024/04/08/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:45:11.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>本笔记为<code>尚硅谷axios入门与源码解析</code>的学习笔记</p><p>该课程主要讲述 axios的API、源码分析、模拟实现重要功能</p><p>课程预备知识点: <code>HTTP</code> <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ajax</a> <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">promise</a>  </p><p><code>ps</code>:大学时候的课程一定要好好学,不然迟早要还的,留下了不学无术的眼泪:cry:</p><p>仅供本人<code>洪</code>学习使用</p><p>本人笔记地址分享:<a href="https://gitee.com/hongjilin/hongs-study-notes"><code>全部笔记</code></a>、<a href="https://gitee.com/hongjilin/hongs-study-notes/blob/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0.md"><code>axios笔记</code></a></p><p>​记录时间: 2021-3-15晚启  2021-3-19结束</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h2 id="预备工具"><a href="#预备工具" class="headerlink" title="预备工具"></a>预备工具</h2><blockquote><ol><li>作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。</li><li>安装json-server<br><code>npm install -g json-server</code></li><li>创建db.json<br>在一个文件夹下新建一个db.json文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-server&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动json-server<br>在当前文件夹下输入如下命令：<code>json-server db.json</code></li><li><a href="https://github.com/typicode/json-server">文档</a></li></ol></blockquote><h1 id="一、Axios的理解与使用"><a href="#一、Axios的理解与使用" class="headerlink" title="一、Axios的理解与使用"></a>一、Axios的理解与使用</h1><h2 id="Ⅰ-axios-是什么"><a href="#Ⅰ-axios-是什么" class="headerlink" title="Ⅰ-axios 是什么?"></a>Ⅰ-axios 是什么?</h2><blockquote><ol><li>前端最流行的 ajax 请求库 </li><li>react&#x2F;vue 官方都推荐使用 axios 发 ajax 请求 </li><li>文档: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ol></blockquote><h2 id="Ⅱ-axios-特点"><a href="#Ⅱ-axios-特点" class="headerlink" title="Ⅱ-axios 特点"></a>Ⅱ-axios 特点</h2><blockquote><ol><li>基于 xhr + promise 的异步 ajax 请求库 </li><li>浏览器端&#x2F;node 端都可以使用 </li><li>支持请求／响应拦截器 </li><li>支持请求取消 </li><li>请求&#x2F;响应数据转换 </li><li>批量发送多个请求</li></ol></blockquote><h2 id="Ⅲ-axios-常用语法"><a href="#Ⅲ-axios-常用语法" class="headerlink" title="Ⅲ-axios 常用语法"></a>Ⅲ-axios 常用语法</h2><blockquote><ol><li>axios(config): <code>通用/最本质</code>的发任意类型请求的方式 </li><li>axios(url[, config]): 可以只指定 url 发 get 请求 </li><li>axios.request(config): 等同于 axios(config) </li><li>axios.get(url[, config]): 发 get 请求 </li><li>axios.delete(url[, config]): 发 delete 请求 </li><li>axios.post(url[, data, config]): 发 post 请求</li><li>axios.put(url[, data, config]): 发 put 请求 </li><li>axios.defaults.xxx: 请求的默认全局配置 </li><li>axios.interceptors.request.use(): 添加请求拦截器 </li><li>axios.interceptors.response.use(): 添加响应拦截器 </li><li>axios.create([config]): 创建一个新的 axios(它没有下面的功能) </li><li>axios.Cancel(): 用于创建取消请求的错误对象 </li><li>axios.CancelToken(): 用于创建取消请求的 token 对象 </li><li>axios.isCancel(): 是否是一个取消请求的错误 </li><li>axios.all(promises): 用于批量执行多个异步请求 </li><li>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</li></ol></blockquote><h2 id="Ⅳ-原理图"><a href="#Ⅳ-原理图" class="headerlink" title="Ⅳ-原理图"></a>Ⅳ-原理图</h2><p><img src="/k705.github.io/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Axios%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Axios系统学习笔记原理图"></p><h2 id="Ⅴ-难点语法的理解和使用"><a href="#Ⅴ-难点语法的理解和使用" class="headerlink" title="Ⅴ-难点语法的理解和使用"></a>Ⅴ-难点语法的理解和使用</h2><h3 id="1、axios-create-config"><a href="#1、axios-create-config" class="headerlink" title="1、axios.create(config)"></a>1、axios.create(config)</h3><blockquote><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 </p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 </p></li><li><p>为什么要设计这个语法?</p></li></ol><p>  (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 </p><p>  (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line">  <span class="keyword">const</span> duanzi = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> onather = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line">  <span class="comment">// duanzi(&#123;</span></span><br><span class="line">  <span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line">  <span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(response);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  duanzi.<span class="title function_">get</span>(<span class="string">&#x27;/getJoke&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、拦截器函数-ajax-请求-请求的回调函数的调用顺序"><a href="#2、拦截器函数-ajax-请求-请求的回调函数的调用顺序" class="headerlink" title="2、拦截器函数&#x2F;ajax 请求&#x2F;请求的回调函数的调用顺序"></a>2、拦截器函数&#x2F;ajax 请求&#x2F;请求的回调函数的调用顺序</h3><blockquote><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 </li><li>流程: 请求拦截器2 &#x3D;&gt; 请求拦截器1 &#x3D;&gt; 发ajax请求 &#x3D;&gt; 响应拦截器1 &#x3D;&gt; 响应拦截器 2 &#x3D;&gt; 请求的回调 </li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// Promise</span></span><br><span class="line">  <span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.<span class="property">params</span> = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应拦截器</span></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// return response;</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、取消请求"><a href="#3、取消请求" class="headerlink" title="3、取消请求"></a>3、取消请求</h3><blockquote><ol><li>基本流程 配置 cancelToken 对象 </li><li>缓存用于取消请求的 cancel 函数 </li><li>在后面特定时机调用 cancel 函数取消请求 </li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li><li>实现功能 点击按钮, 取消某个正在请求中的请求,</li><li>实现功能 点击按钮, 取消某个正在请求中的请求</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//获取按钮</span></span><br><span class="line">  <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">  <span class="comment">//2.声明全局变量</span></span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//取消上一次的请求</span></span><br><span class="line">      <span class="title function_">cancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">      <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">        <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">        cancel = c;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">      <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">      cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">  btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">cancel</span>(); &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅵ-默认配置"><a href="#Ⅵ-默认配置" class="headerlink" title="Ⅵ-默认配置"></a>Ⅵ-默认配置</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认配置</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">       btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">axios</span>(&#123;</span><br><span class="line">               <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">           &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="二、Axios的难点问题"><a href="#二、Axios的难点问题" class="headerlink" title="二、Axios的难点问题"></a>二、Axios的难点问题</h1><h2 id="Ⅰ-目录结构"><a href="#Ⅰ-目录结构" class="headerlink" title="Ⅰ-目录结构"></a>Ⅰ-目录结构</h2><blockquote><p>├── &#x2F;dist&#x2F; # 项目输出目录<br>├── &#x2F;lib&#x2F; # 项目源码目录<br>│ ├── &#x2F;adapters&#x2F; # 定义请求的适配器 xhr、http<br>│ │ ├── http.js # 实现 http 适配器(包装 http 包)<br>│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)<br>│ ├── &#x2F;cancel&#x2F; # 定义取消功能<br>│ ├── &#x2F;core&#x2F; # 一些核心功能<br>│ │ ├── Axios.js # axios 的核心主类<br>│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数<br>│ │ ├── InterceptorManager.js # 拦截器的管理器<br>│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态<br>│ ├── &#x2F;helpers&#x2F; # 一些辅助方法<br>│ ├── axios.js # 对外暴露接口<br>│ ├── defaults.js # axios 的默认配置<br>│ └── utils.js # 公用工具<br>├── package.json # 项目信息<br>├── index.d.ts # 配置 TypeScript 的声明文件<br>└── index.js # 入口文件</p></blockquote><h2 id="Ⅱ-axios-与-Axios-的关系"><a href="#Ⅱ-axios-与-Axios-的关系" class="headerlink" title="Ⅱ-axios 与 Axios 的关系"></a>Ⅱ-axios 与 Axios 的关系</h2><blockquote><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li><li>axios 是 <code>Axios.prototype.request</code> 函数 bind()返回的函数</li><li>axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ol></blockquote><h2 id="Ⅲ-instance-与-axios-的区别"><a href="#Ⅲ-instance-与-axios-的区别" class="headerlink" title="Ⅲ- instance 与 axios 的区别?"></a>Ⅲ- instance 与 axios 的区别?</h2><blockquote><ol><li>相同:<br>(1) 都是一个能发任意请求的函数: request(config)<br>(2) 都有发特定请求的各种方法: get()&#x2F;post()&#x2F;put()&#x2F;delete()<br>(3) 都有默认配置和拦截器的属性: defaults&#x2F;interceptors</li><li>不同:<br>(1) 默认配置很可能不一样<br>(2) instance 没有 axios 后面添加的一些方法: create()&#x2F;CancelToken()&#x2F;all()</li></ol></blockquote><h2 id="Ⅳ-axios运行的整体流程"><a href="#Ⅳ-axios运行的整体流程" class="headerlink" title="Ⅳ-axios运行的整体流程"></a>Ⅳ-axios运行的整体流程</h2><blockquote><ol><li><p>整体流程:<br> request(config) &#x3D;&#x3D;&gt; dispatchRequest(config) &#x3D;&#x3D;&gt; xhrAdapter(config)</p></li><li><p>request(config):<br> 将请求拦截器 &#x2F; dispatchRequest() &#x2F; 响应拦截器 通过 promise 链串连起来,<br>  返回 promise</p></li><li><p>dispatchRequest(config):<br> 转换请求数据 &#x3D;&#x3D;&#x3D;&gt; 调用 xhrAdapter()发请求 &#x3D;&#x3D;&#x3D;&gt; 请求返回后转换响应数<br>  据. 返回 promise</p></li><li><p>xhrAdapter(config):<br> 创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br>  返回 promise </p></li><li><p>流程图:</p></li></ol><p><img src="/k705.github.io/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Axios%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Axios系统学习流程图"></p></blockquote><h2 id="Ⅴ-axios-的请求-响应拦截器是什么"><a href="#Ⅴ-axios-的请求-响应拦截器是什么" class="headerlink" title="Ⅴ-axios 的请求&#x2F;响应拦截器是什么?"></a>Ⅴ-axios 的请求&#x2F;响应拦截器是什么?</h2><blockquote><ol><li>请求拦截器:<br>Ⅰ- 在真正发送请求前执行的回调函数<br>Ⅱ- 可以对请求进行检查或配置进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li><li>响应拦截器<br>Ⅰ- 在请求得到响应后执行的回调函数<br>Ⅱ- 可以对响应数据进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 response<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li></ol></blockquote><h2 id="Ⅵ-axios-的请求-响应数据转换器是什么"><a href="#Ⅵ-axios-的请求-响应数据转换器是什么" class="headerlink" title="Ⅵ-axios 的请求&#x2F;响应数据转换器是什么?"></a>Ⅵ-axios 的请求&#x2F;响应数据转换器是什么?</h2><blockquote><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (utils.<span class="title function_">isObject</span>(data)) &#123;</span><br><span class="line"> <span class="title function_">setContentTypeIfUnset</span>(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.<span class="property">data</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="property">data</span>)</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅶ-response与error-的整体结构"><a href="#Ⅶ-response与error-的整体结构" class="headerlink" title="Ⅶ- response与error  的整体结构"></a>Ⅶ- response与error  的整体结构</h2><blockquote><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">data, status,statusText,headers,config,request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>error  的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">message,response,request,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅷ-如何取消未完成的请求"><a href="#Ⅷ-如何取消未完成的请求" class="headerlink" title="Ⅷ-如何取消未完成的请求?"></a>Ⅷ-如何取消未完成的请求?</h2><blockquote><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数<br>(1) 创建一个用于将来中断请求的 cancelPromise<br>(2) 并定义了一个用于取消请求的 cancel 函数<br>(3) 将 cancel 函数传递出来</li><li>调用 cancel()取消请求<br>(1) 执行 cacel 函数, 传入错误信息 message<br>(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象<br>(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,<br>失败的 reason 为 Cancel 对象</li></ol></blockquote><h1 id="三、Axios源码模拟实现"><a href="#三、Axios源码模拟实现" class="headerlink" title="三、Axios源码模拟实现"></a>三、Axios源码模拟实现</h1><h2 id="Ⅰ-axios-的创建过程模拟实现"><a href="#Ⅰ-axios-的创建过程模拟实现" class="headerlink" title="Ⅰ- axios 的创建过程模拟实现"></a>Ⅰ- axios 的创建过程模拟实现</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">defaults</span> = config; <span class="comment">//为了创建 default 默认属性</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">intercepters</span> = &#123;</span><br><span class="line">       <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">       <span class="attr">response</span>: &#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//原型添加相关的方法</span></span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送 AJAX 请求 请求的类型为 &#x27;</span> + config.<span class="property">method</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">post</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//声明函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="comment">//实例化一个对象</span></span><br><span class="line">     <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(config); <span class="comment">// context.get()  context.post()  但是不能当做函数使用 context() X</span></span><br><span class="line">     <span class="comment">//创建请求函数</span></span><br><span class="line">     <span class="keyword">let</span> instance = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(</span><br><span class="line">     context); <span class="comment">// instance 是一个函数 并且可以 instance(&#123;&#125;)  此时 instance 不能 instance.get X</span></span><br><span class="line">     <span class="comment">//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       instance[key] = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[key].<span class="title function_">bind</span>(context); <span class="comment">// this.default  this.interceptors</span></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//为 instance 函数对象添加属性 default 与 interceptors</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       instance[key] = context[key];</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> axios = <span class="title function_">createInstance</span>();</span><br><span class="line">   <span class="comment">//发送请求</span></span><br><span class="line">   <span class="comment">// axios(&#123;method:&#x27;POST&#x27;&#125;);</span></span><br><span class="line">   axios.<span class="title function_">get</span>(&#123;&#125;);</span><br><span class="line">   axios.<span class="title function_">post</span>(&#123;&#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅱ-axios发送请求过程详解"><a href="#Ⅱ-axios发送请求过程详解" class="headerlink" title="Ⅱ-axios发送请求过程详解"></a>Ⅱ-axios发送请求过程详解</h2><blockquote><ol><li>整体流程:<br> request(config) &#x3D;&#x3D;&gt; dispatchRequest(config) &#x3D;&#x3D;&gt; xhrAdapter(config)</li><li>request(config):<br> 将请求拦截器 &#x2F; dispatchRequest() &#x2F; 响应拦截器 通过 promise 链串连起来,<br> 返回 promise</li><li>dispatchRequest(config):<br> 转换请求数据 &#x3D;&#x3D;&#x3D;&gt; 调用 xhrAdapter()发请求 &#x3D;&#x3D;&#x3D;&gt; 请求返回后转换响应数<br> 据. 返回 promise</li><li>xhrAdapter(config):<br> 创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br> 返回 promise</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">// axios 发送请求   axios  Axios.prototype.request  bind</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//1. 声明构造函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//创建一个 promise 对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//声明一个数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>]; <span class="comment">// undefined 占位</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//调用 then 方法指定回调</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> result = promise.<span class="title function_">then</span>(chains[<span class="number">0</span>], chains[<span class="number">1</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//返回 promise 的结果</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//2. dispatchRequest 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//调用适配器发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//响应的结果进行转换处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//....</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">throw</span> error;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//3. adapter 适配器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;xhrAdapter 函数执行&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//发送 AJAX 请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//发送</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="title function_">send</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//绑定事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="comment">//判断成功的条件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="comment">//成功的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="title function_">resolve</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//配置对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">config</span>: config,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应体</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">data</span>: xhr.<span class="property">response</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应头</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">headers</span>: xhr.<span class="title function_">getAllResponseHeaders</span>(), <span class="comment">//字符串  parseHeaders</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">// xhr 请求对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">request</span>: xhr,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应状态码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应状态字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="comment">//失败的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败 失败的状态码为&#x27;</span> + xhr.<span class="property">status</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//4. 创建 axios 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅲ-拦截器的模拟实现"><a href="#Ⅲ-拦截器的模拟实现" class="headerlink" title="Ⅲ-拦截器的模拟实现"></a>Ⅲ-拦截器的模拟实现</h2><blockquote><ol><li>array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</li><li>思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行</li><li><code>promise = promise.then(chains.shift(), chains.shift());</code> 通过循环使用promise的then链条得到最终的结果–&gt;等式前面的<code>promise</code>将被最终的结果覆盖</li></ol></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>拦截器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求  难点与重点</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//创建一个 promise 对象</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//创建一个数组</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>];</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//处理拦截器</span></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []</span></span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               chains.<span class="title function_">unshift</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               chains.<span class="title function_">push</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">// console.log(chains);</span></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//遍历</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">while</span>(chains.<span class="property">length</span> &gt; <span class="number">0</span>)&#123; </span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//array.shift()</span></span></span><br><span class="line"><span class="language-javascript">               promise = promise.<span class="title function_">then</span>(chains.<span class="title function_">shift</span>(), chains.<span class="title function_">shift</span>());</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> promise;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//返回一个promise 队形</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">resolve</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">status</span>: <span class="number">200</span>,</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span></span></span><br><span class="line"><span class="language-javascript">               &#125;);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">      </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//创建实例</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//创建axios函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 context 属性 config interceptors 添加至 axios 函数对象身上</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           axios[key] = context[key];</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//拦截器管理器构造函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">InterceptorManager</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">fulfilled, rejected</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               fulfilled,</span></span><br><span class="line"><span class="language-javascript">               rejected</span></span><br><span class="line"><span class="language-javascript">           &#125;)</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//以下为功能测试代码</span></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 设置请求拦截器  config 配置对象</span></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 设置响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span><br><span class="line"><span class="language-javascript">       &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅳ-请求取消功能模拟实现"><a href="#Ⅳ-请求取消功能模拟实现" class="headerlink" title="Ⅳ-请求取消功能模拟实现"></a>Ⅳ-请求取消功能模拟实现</h2><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>取消请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&#x27;anonymous&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>axios取消请求<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span> 发送请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span>&gt;</span> 取消请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//原型 request 方法</span></span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="title function_">dispatchRequest</span>(config);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//dispatchRequest 函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//xhrAdapter</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//发送 AJAX 请求</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//实例化对象</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//初始化</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//处理结果</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//判断结果</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="comment">//设置为成功的状态</span></span></span><br><span class="line"><span class="language-javascript">             <span class="title function_">resolve</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span><br><span class="line"><span class="language-javascript">             &#125;);</span></span><br><span class="line"><span class="language-javascript">           &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//关于取消请求的处理</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//对 cancelToken 对象身上的 promise 对象指定成功的回调</span></span></span><br><span class="line"><span class="language-javascript">         config.<span class="property">cancelToken</span>.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">abort</span>();</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//将整体结果设置为失败</span></span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求已经被取消&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">         &#125;);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//创建 axios 函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//CancelToken 构造函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">CancelToken</span>(<span class="params">executor</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//声明一个变量</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> resolvePromise;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//为实例对象添加属性</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 resolve 赋值给 resolvePromise</span></span></span><br><span class="line"><span class="language-javascript">       resolvePromise = resolve</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//调用 executor 函数</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">executor</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//执行 resolvePromise 函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">resolvePromise</span>();</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//获取按钮 以上为模拟实现的代码</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//2.声明全局变量</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">   btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//检测上一次的请求是否已经完成</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//取消上一次的请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">cancel</span>();</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//创建 cancelToken 的值</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> cancelToken = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       cancel = c;</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//1. 添加配置对象的属性</span></span></span><br><span class="line"><span class="language-javascript">       <span class="attr">cancelToken</span>: cancelToken</span></span><br><span class="line"><span class="language-javascript">     &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 cancel 的值初始化</span></span></span><br><span class="line"><span class="language-javascript">       cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//绑定第二个事件取消请求</span></span></span><br><span class="line"><span class="language-javascript">   btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">cancel</span>();</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="四、自己对于某些问题解答与理解"><a href="#四、自己对于某些问题解答与理解" class="headerlink" title="四、自己对于某些问题解答与理解"></a>四、自己对于某些问题解答与理解</h1><h2 id="Ⅰ-axios同步与异步转换-在外部取值"><a href="#Ⅰ-axios同步与异步转换-在外部取值" class="headerlink" title="Ⅰ-axios同步与异步转换,在外部取值"></a>Ⅰ-axios同步与异步转换,在外部取值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  axios  =  <span class="built_in">require</span> (<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"> <span class="comment">//创建实例对象 </span></span><br><span class="line"> <span class="keyword">const</span> $http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:53000&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">11000</span>  <span class="comment">//请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">resolveCommon</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=$http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//打印结果: Promise &#123; &lt;pending&gt; &#125; </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">resolveAsync</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=<span class="keyword">await</span> $http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)  <span class="comment">//获得正确的值</span></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125;</span></span><br><span class="line"><span class="comment">    *  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//模拟新增数据,将上一步的结果简单加工一下</span></span><br><span class="line">   data.<span class="property">course_name</span>=data.<span class="property">course_name</span>+<span class="number">1</span></span><br><span class="line"> $http(&#123;</span><br><span class="line">   <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>:<span class="string">&quot;put&quot;</span>,</span><br><span class="line">   data</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(v)  <span class="comment">//直接打印了 需要再取出参照上一步</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">resolveCommon</span>()  <span class="comment">//调用普通promise函数</span></span><br><span class="line"><span class="title function_">resolveAsync</span>()    <span class="comment">//调用await+async</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本笔记为&lt;code&gt;尚硅谷axios入门与源码解析&lt;/code&gt;的学习笔记&lt;/p&gt;
&lt;p&gt;该课程主要讲述 ax</summary>
      
    
    
    
    
    <category term="Axios" scheme="https://k705.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>Chrome拓展</title>
    <link href="https://k705.github.io/2024/04/08/Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E8%B5%84%E6%96%99%E6%91%98%E5%BD%95%E5%8F%8A%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://k705.github.io/2024/04/08/Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E8%B5%84%E6%96%99%E6%91%98%E5%BD%95%E5%8F%8A%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:46:02.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记是各资料整合<code>摘录</code>以及后续相关笔记补充、当时纯为了方便记录,没有记录各个知识点摘录出处;非本人洪撰写(大都是摘录,加以少许个人理解),仅供本人学习使用</p><p>本人笔记地址分享:<a href="https://gitee.com/hongjilin/hongs-study-notes"><code>全部笔记</code></a></p><p>​   学习时间:2020&#x2F;12&#x2F;1启</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、资料"><a href="#一、资料" class="headerlink" title="一、资料"></a>一、资料</h1><p><a href="http://kkh86.com/it/chrome-extension-doc/extensions/getstarted.html">1.非官方中文文档</a></p><p><a href="%5B%5D(https://developer.chrome.com/docs/extensions/mv2/getstarted/)">2.官方文档(英文)</a></p><h1 id="二、核心"><a href="#二、核心" class="headerlink" title="二、核心"></a>二、核心</h1><h2 id="2-0-什么是Chrome插件"><a href="#2-0-什么是Chrome插件" class="headerlink" title="2.0. 什么是Chrome插件"></a>2.0. 什么是Chrome插件</h2><p>严格来讲，我们正在说的东西应该叫Chrome扩展(<code>Chrome Extension</code>)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。</p><p>Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个<a href="https://developer.chrome.com/extensions/crx">.crx</a>后缀的压缩包.</p><h2 id="2-1-manifest-json"><a href="#2-1-manifest-json" class="headerlink" title="2.1. manifest.json"></a>2.1. manifest.json</h2><p>这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，<code>manifest_version</code>、<code>name</code>、<code>version</code>3个是必不可少的，<code>description</code>和<code>icons</code>是推荐的。</p><p>下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳<a href="https://developer.chrome.com/extensions/manifest">这里</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 清单文件的版本，这个必须写，而且必须是2</span></span><br><span class="line"><span class="string">&quot;manifest_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="comment">// 插件的名称</span></span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line"><span class="comment">// 插件的版本</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line"><span class="comment">// 插件描述</span></span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;简单的Chrome扩展demo&quot;</span>,</span><br><span class="line"><span class="comment">// 图标，一般偷懒全部用一个尺寸的也没问题</span></span><br><span class="line"><span class="string">&quot;icons&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;16&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;48&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;128&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line"><span class="string">&quot;background&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;background.html&quot;</span></span><br><span class="line"><span class="comment">//&quot;scripts&quot;: [&quot;js/background.js&quot;]</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 浏览器右上角图标设置，browser_action、page_action、app必须三选一</span></span><br><span class="line"><span class="string">&quot;browser_action&quot;</span>: </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;这是一个示例Chrome插件&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 当某些特定页面打开才显示的图标</span></span><br><span class="line"><span class="comment">/*&quot;page_action&quot;:</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&quot;default_icon&quot;: &quot;img/icon.png&quot;,</span></span><br><span class="line"><span class="comment">&quot;default_title&quot;: &quot;我是pageAction&quot;,</span></span><br><span class="line"><span class="comment">&quot;default_popup&quot;: &quot;popup.html&quot;</span></span><br><span class="line"><span class="comment">&#125;,*/</span></span><br><span class="line"><span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line"><span class="string">&quot;content_scripts&quot;</span>: </span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],</span></span><br><span class="line"><span class="comment">// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址</span></span><br><span class="line"><span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>],</span><br><span class="line"><span class="comment">// 多个JS按顺序注入</span></span><br><span class="line"><span class="string">&quot;js&quot;</span>: [<span class="string">&quot;js/jquery-1.8.3.js&quot;</span>, <span class="string">&quot;js/content-script.js&quot;</span>],</span><br><span class="line"><span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line"><span class="string">&quot;css&quot;</span>: [<span class="string">&quot;css/custom.css&quot;</span>],</span><br><span class="line"><span class="comment">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line"><span class="string">&quot;run_at&quot;</span>: <span class="string">&quot;document_start&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 这里仅仅是为了演示content-script可以配置多个规则</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;*://*/*.png&quot;</span>, <span class="string">&quot;*://*/*.jpg&quot;</span>, <span class="string">&quot;*://*/*.gif&quot;</span>, <span class="string">&quot;*://*/*.bmp&quot;</span>],</span><br><span class="line"><span class="string">&quot;js&quot;</span>: [<span class="string">&quot;js/show-image-content-size.js&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 权限申请</span></span><br><span class="line"><span class="string">&quot;permissions&quot;</span>:</span><br><span class="line">[</span><br><span class="line"><span class="string">&quot;contextMenus&quot;</span>, <span class="comment">// 右键菜单</span></span><br><span class="line"><span class="string">&quot;tabs&quot;</span>, <span class="comment">// 标签</span></span><br><span class="line"><span class="string">&quot;notifications&quot;</span>, <span class="comment">// 通知</span></span><br><span class="line"><span class="string">&quot;webRequest&quot;</span>, <span class="comment">// web请求</span></span><br><span class="line"><span class="string">&quot;webRequestBlocking&quot;</span>,</span><br><span class="line"><span class="string">&quot;storage&quot;</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line"><span class="string">&quot;http://*/*&quot;</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line"><span class="string">&quot;https://*/*&quot;</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line"><span class="string">&quot;web_accessible_resources&quot;</span>: [<span class="string">&quot;js/inject.js&quot;</span>],</span><br><span class="line"><span class="comment">// 插件主页，这个很重要，不要浪费了这个免费广告位</span></span><br><span class="line"><span class="string">&quot;homepage_url&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line"><span class="comment">// 覆盖浏览器默认页面</span></span><br><span class="line"><span class="string">&quot;chrome_url_overrides&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 覆盖浏览器默认的新标签页</span></span><br><span class="line"><span class="string">&quot;newtab&quot;</span>: <span class="string">&quot;newtab.html&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line"><span class="string">&quot;options_page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line"><span class="comment">// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个</span></span><br><span class="line"><span class="string">&quot;options_ui&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line"><span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line"><span class="string">&quot;chrome_style&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line"><span class="string">&quot;omnibox&quot;</span>: &#123; <span class="string">&quot;keyword&quot;</span> : <span class="string">&quot;go&quot;</span> &#125;,</span><br><span class="line"><span class="comment">// 默认语言</span></span><br><span class="line"><span class="string">&quot;default_locale&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line"><span class="comment">// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line"><span class="string">&quot;devtools_page&quot;</span>: <span class="string">&quot;devtools.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>matches</code>的语法参考：<a href="https://developer.chrome.com/extensions/match_patterns">https://developer.chrome.com/extensions/match_patterns</a></p><h2 id="2-2-content-scripts"><a href="#2-2-content-scripts" class="headerlink" title="2.2. content-scripts"></a>2.2. content-scripts</h2><p>所谓<a href="https://developer.chrome.com/extensions/content_scripts">content-scripts</a>，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助<code>content-scripts</code>我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。</p><p>示例配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line"><span class="string">&quot;content_scripts&quot;</span>: </span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],</span></span><br><span class="line"><span class="comment">// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址</span></span><br><span class="line"><span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>],</span><br><span class="line"><span class="comment">// 多个JS按顺序注入</span></span><br><span class="line"><span class="string">&quot;js&quot;</span>: [<span class="string">&quot;js/jquery-1.8.3.js&quot;</span>, <span class="string">&quot;js/content-script.js&quot;</span>],</span><br><span class="line"><span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line"><span class="string">&quot;css&quot;</span>: [<span class="string">&quot;css/custom.css&quot;</span>],</span><br><span class="line"><span class="comment">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line"><span class="string">&quot;run_at&quot;</span>: <span class="string">&quot;document_start&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意，如果没有主动指定<code>run_at</code>为<code>document_start</code>（默认为<code>document_idle</code>），下面这种代码是不会生效的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我被执行了！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>content-scripts</code>和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过<code>injected js</code>来实现。<code>content-scripts</code>不能访问绝大部分<code>chrome.xxx.api</code>，除了下面这4种：</p><ul><li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li><li>chrome.i18n</li><li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li><li>chrome.storage</li></ul><p>其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。</p><p>好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。</p><h2 id="2-3-background"><a href="#2-3-background" class="headerlink" title="2.3. background"></a>2.3. background</h2><p>后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p><p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置<code>CORS</code>。</p><blockquote><p>经过测试，其实不止是background，所有的直接通过<code>chrome-extension://id/xx.html</code>这种方式打开的网页都可以无限制跨域。</p></blockquote><p>配置中，<code>background</code>可以通过<code>page</code>指定一张网页，也可以通过<code>scripts</code>直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line"><span class="string">&quot;background&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;background.html&quot;</span></span><br><span class="line"><span class="comment">//&quot;scripts&quot;: [&quot;js/background.js&quot;]</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别说明的是，虽然你可以通过<code>chrome-extension://xxx/background.html</code>直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个<code>background.html</code>，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。</p><h2 id="2-4-event-pages"><a href="#2-4-event-pages" class="headerlink" title="2.4. event-pages"></a>2.4. event-pages</h2><p>这里顺带介绍一下<a href="https://developer.chrome.com/extensions/event_pages">event-pages</a>，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个<code>event-pages</code>，在配置文件上，它与background的唯一区别就是多了一个<code>persistent</code>参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;background&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: [<span class="string">&quot;event-page.js&quot;</span>],</span><br><span class="line"><span class="string">&quot;persistent&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。</p><p>除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。</p><h2 id="2-5-popup"><a href="#2-5-popup" class="headerlink" title="2.5. popup"></a>2.5. popup</h2><p><code>popup</code>是点击<code>browser_action</code>或者<code>page_action</code>图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。<code>popup</code>可以包含任意你想要的HTML内容，并且会自适应大小。可以通过<code>default_popup</code>字段来指定popup页面，也可以调用<code>setPopup()</code>方法。</p><p>配置方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;browser_action&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;这是一个示例Chrome插件&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。</p><p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过<code>chrome.extension.getBackgroundPage()</code>获取background的window对象。</p><h2 id="2-6-injected-script"><a href="#2-6-injected-script" class="headerlink" title="2.6. injected-script"></a>2.6. injected-script</h2><p>这里的<code>injected-script</code>是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？</p><p>这是因为<code>content-script</code>有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用<code>content-script</code>中的代码（包括直接写<code>onclick</code>和<code>addEventListener</code>2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。</p><p>在<code>content-script</code>中通过DOM方式向页面注入<code>inject-script</code>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向页面注入JS</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">injectCustomJs</span>(<span class="params">jsPath</span>)</span><br><span class="line">&#123;</span><br><span class="line">jsPath = jsPath || <span class="string">&#x27;js/inject.js&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">temp.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span><br><span class="line"><span class="comment">// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js</span></span><br><span class="line">temp.<span class="property">src</span> = chrome.<span class="property">extension</span>.<span class="title function_">getURL</span>(jsPath);</span><br><span class="line">temp.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 放在页面不好看，执行完后移除掉</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你以为这样就行了？执行一下你会看到如下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span><br></pre></td></tr></table></figure><p>意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line"><span class="string">&quot;web_accessible_resources&quot;</span>: [<span class="string">&quot;js/inject.js&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于<code>inject-script</code>如何调用<code>content-script</code>中的代码，后面我会在专门的一个消息通信章节详细介绍。</p><h1 id="三、Chrome插件的8种展示形式"><a href="#三、Chrome插件的8种展示形式" class="headerlink" title="三、Chrome插件的8种展示形式"></a>三、Chrome插件的8种展示形式</h1><h2 id="3-1-browserAction-浏览器右上角"><a href="#3-1-browserAction-浏览器右上角" class="headerlink" title="3.1. browserAction(浏览器右上角)"></a>3.1. browserAction(浏览器右上角)</h2><p>通过配置<code>browser_action</code>可以在浏览器的右上角增加一个图标，一个<code>browser_action</code>可以拥有一个图标，一个<code>tooltip</code>，一个<code>badge</code>和一个<code>popup</code>。</p><p>示例配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;browser_action&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;这是一个示例Chrome插件&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-1-图标"><a href="#5-1-1-图标" class="headerlink" title="5.1.1. 图标"></a>5.1.1. 图标</h3><p><code>browser_action</code>图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中<code>default_icon</code>字段配置，也可以调用setIcon()方法。</p><h3 id="5-1-2-tooltip"><a href="#5-1-2-tooltip" class="headerlink" title="5.1.2. tooltip"></a>5.1.2. tooltip</h3><p>修改<code>browser_action</code>的manifest中<code>default_title</code>字段，或者调用<code>setTitle()</code>方法。</p><h3 id="5-1-3-badge"><a href="#5-1-3-badge" class="headerlink" title="5.1.3. badge"></a>5.1.3. badge</h3><p>所谓<code>badge</code>就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用<code>setBadgeText()</code>和<code>setBadgeBackgroundColor()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeText</span>(&#123;<span class="attr">text</span>: <span class="string">&#x27;new&#x27;</span>&#125;);</span><br><span class="line">chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeBackgroundColor</span>(&#123;<span class="attr">color</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-2-pageAction-地址栏右侧"><a href="#3-2-pageAction-地址栏右侧" class="headerlink" title="3.2. pageAction(地址栏右侧)"></a>3.2. pageAction(地址栏右侧)</h2><p>所谓<code>pageAction</code>，指的是只有当某些特定页面打开才显示的图标，它和<code>browserAction</code>最大的区别是一个始终都显示，一个只在特定情况才显示。</p><p>需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单</p><p>而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项</p><blockquote><p>具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。</p></blockquote><p>调整之后的<code>pageAction</code>我们可以简单地把它看成是可以置灰的<code>browserAction</code>。</p><ul><li>chrome.pageAction.show(tabId) 显示图标；</li><li>chrome.pageAction.hide(tabId) 隐藏图标；</li></ul><p>示例(只有打开百度才显示图标)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;page_action&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;我是pageAction&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;declarativeContent&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onInstalled</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">chrome.<span class="property">declarativeContent</span>.<span class="property">onPageChanged</span>.<span class="title function_">removeRules</span>(<span class="literal">undefined</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">chrome.<span class="property">declarativeContent</span>.<span class="property">onPageChanged</span>.<span class="title function_">addRules</span>([</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">conditions</span>: [</span><br><span class="line"><span class="comment">// 只有打开百度才显示pageAction</span></span><br><span class="line"><span class="keyword">new</span> chrome.<span class="property">declarativeContent</span>.<span class="title class_">PageStateMatcher</span>(&#123;<span class="attr">pageUrl</span>: &#123;<span class="attr">urlContains</span>: <span class="string">&#x27;baidu.com&#x27;</span>&#125;&#125;)</span><br><span class="line">],</span><br><span class="line"><span class="attr">actions</span>: [<span class="keyword">new</span> chrome.<span class="property">declarativeContent</span>.<span class="title class_">ShowPageAction</span>()]</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-3-右键菜单"><a href="#3-3-右键菜单" class="headerlink" title="3.3. 右键菜单"></a>3.3. 右键菜单</h2><p>通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过<code>chrome.contextMenus</code>API实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里</p><h3 id="3-3-1-最简单的右键菜单示例"><a href="#3-3-1-最简单的右键菜单示例" class="headerlink" title="3.3.1. 最简单的右键菜单示例"></a>3.3.1. 最简单的右键菜单示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;contextMenus&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;测试右键菜单&quot;</span>,</span><br><span class="line"><span class="attr">onclick</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&#x27;您点击了右键菜单！&#x27;</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-2-添加右键百度搜索"><a href="#3-3-2-添加右键百度搜索" class="headerlink" title="3.3.2. 添加右键百度搜索"></a>3.3.2. 添加右键百度搜索</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;contextMenus&quot;</span>， <span class="string">&quot;tabs&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;使用度娘搜索：%s&#x27;</span>, <span class="comment">// %s表示选中的文字</span></span><br><span class="line"><span class="attr">contexts</span>: [<span class="string">&#x27;selection&#x27;</span>], <span class="comment">// 只有当选中文字时才会出现此右键菜单</span></span><br><span class="line"><span class="attr">onclick</span>: <span class="keyword">function</span>(<span class="params">params</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 注意不能使用location.href，因为location是属于background的window对象</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">create</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;https://www.baidu.com/s?ie=utf-8&amp;wd=&#x27;</span> + <span class="built_in">encodeURI</span>(params.<span class="property">selectionText</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-3-语法说明"><a href="#3-3-3-语法说明" class="headerlink" title="3.3.3. 语法说明"></a>3.3.3. 语法说明</h3><p>这里只是简单列举一些常用的，完整API参见：<a href="https://developer.chrome.com/extensions/contextMenus">https://developer.chrome.com/extensions/contextMenus</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;normal&#x27;</span>， <span class="comment">// 类型，可选：[&quot;normal&quot;, &quot;checkbox&quot;, &quot;radio&quot;, &quot;separator&quot;]，默认 normal</span></span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;菜单的名字&#x27;</span>, <span class="comment">// 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span></span><br><span class="line"><span class="attr">contexts</span>: [<span class="string">&#x27;page&#x27;</span>], <span class="comment">// 上下文环境，可选：[&quot;all&quot;, &quot;page&quot;, &quot;frame&quot;, &quot;selection&quot;, &quot;link&quot;, &quot;editable&quot;, &quot;image&quot;, &quot;video&quot;, &quot;audio&quot;]，默认page</span></span><br><span class="line"><span class="attr">onclick</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, <span class="comment">// 单击时触发的方法</span></span><br><span class="line"><span class="attr">parentId</span>: <span class="number">1</span>, <span class="comment">// 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span></span><br><span class="line"><span class="attr">documentUrlPatterns</span>: <span class="string">&#x27;https://*.baidu.com/*&#x27;</span> <span class="comment">// 只在某些页面显示此右键菜单</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 删除某一个菜单项</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">remove</span>(menuItemId)；</span><br><span class="line"><span class="comment">// 删除所有自定义右键菜单</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">removeAll</span>();</span><br><span class="line"><span class="comment">// 更新某一个菜单项</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">update</span>(menuItemId, updateProperties);</span><br></pre></td></tr></table></figure><h2 id="3-4-override-覆盖特定页面"><a href="#3-4-override-覆盖特定页面" class="headerlink" title="3.4. override(覆盖特定页面)"></a>3.4. override(覆盖特定页面)</h2><p>使用<code>override</code>页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。</p><p>扩展可以替代如下页面：</p><ul><li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 <a href="chrome://history/">chrome:&#x2F;&#x2F;history</a></li><li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 <a href="chrome://newtab/">chrome:&#x2F;&#x2F;newtab</a></li><li>书签：浏览器的书签，或者直接输入 <a href="chrome://bookmarks/">chrome:&#x2F;&#x2F;bookmarks</a></li></ul><p>注意：</p><ul><li>一个扩展只能替代一个页面；</li><li>不能替代隐身窗口的新标签页；</li><li>网页必须设置title，否则用户可能会看到网页的URL，造成困扰；</li></ul><p>代码（注意，一个插件只能替代一个默认页，以下仅为演示）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;chrome_url_overrides&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;newtab&quot;</span>: <span class="string">&quot;newtab.html&quot;</span>,</span><br><span class="line"><span class="string">&quot;history&quot;</span>: <span class="string">&quot;history.html&quot;</span>,</span><br><span class="line"><span class="string">&quot;bookmarks&quot;</span>: <span class="string">&quot;bookmarks.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-devtools-开发者工具"><a href="#3-5-devtools-开发者工具" class="headerlink" title="3.5. devtools(开发者工具)"></a>3.5. devtools(开发者工具)</h2><h3 id="3-5-1-预热"><a href="#3-5-1-预热" class="headerlink" title="3.5.1. 预热"></a>3.5.1. 预热</h3><p>使用过vue的应该见过这种类型的插件：</p><p><img src="http://image.liuxianan.com/201706/20170605_181456_375_7033.png"></p><p>是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：</p><ul><li>自定义一个和多个和<code>Elements</code>、<code>Console</code>、<code>Sources</code>等同级别的面板；</li><li>自定义侧边栏(sidebar)，目前只能自定义<code>Elements</code>面板的侧边栏；</li></ul><h3 id="3-5-2-devtools扩展介绍"><a href="#3-5-2-devtools扩展介绍" class="headerlink" title="3.5.2. devtools扩展介绍"></a>3.5.2. devtools扩展介绍</h3><p>主页：<a href="https://developer.chrome.com/extensions/devtools">https://developer.chrome.com/extensions/devtools</a></p><p>每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的<code>DevTools API</code>以及有限的扩展API，这组特有的<code>DevTools API</code>只有devtools页面才可以访问，background都无权访问，这些API包括：</p><ul><li><code>chrome.devtools.panels</code>：面板相关；</li><li><code>chrome.devtools.inspectedWindow</code>：获取被审查窗口的有关信息；</li><li><code>chrome.devtools.network</code>：获取有关网络请求的信息；</li></ul><p>大部分扩展API都无法直接被<code>DevTools</code>页面调用，但它可以像<code>content-script</code>一样直接调用<code>chrome.extension</code>和<code>chrome.runtime</code>API，同时它也可以像<code>content-script</code>一样使用Message交互的方式与background页面进行通信。</p><h3 id="3-5-3-实例：创建一个devtools扩展"><a href="#3-5-3-实例：创建一个devtools扩展" class="headerlink" title="3.5.3. 实例：创建一个devtools扩展"></a>3.5.3. 实例：创建一个devtools扩展</h3><p>首先，要针对开发者工具开发插件，需要在清单文件声明如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line"><span class="string">&quot;devtools_page&quot;</span>: <span class="string">&quot;devtools.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>devtools.html</code>里面一般什么都没有，就引入一个js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/devtools.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看出来，其实真正代码是<code>devtools.js</code>，html文件是“多余”的，所以这里觉得有点坑，<code>devtools_page</code>干嘛不允许直接指定JS呢？</p><p>再来看devtools.js的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建自定义面板，同一个插件可以创建多个自定义面板</span></span><br><span class="line"><span class="comment">// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调</span></span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">panels</span>.<span class="title function_">create</span>(<span class="string">&#x27;MyPanel&#x27;</span>, <span class="string">&#x27;img/icon.png&#x27;</span>, <span class="string">&#x27;mypanel.html&#x27;</span>, <span class="keyword">function</span>(<span class="params">panel</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义面板创建成功！&#x27;</span>); <span class="comment">// 注意这个log一般看不到</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义侧边栏</span></span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">panels</span>.<span class="property">elements</span>.<span class="title function_">createSidebarPane</span>(<span class="string">&quot;Images&quot;</span>, <span class="keyword">function</span>(<span class="params">sidebar</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// sidebar.setPage(&#x27;../sidebar.html&#x27;); // 指定加载某个页面</span></span><br><span class="line">sidebar.<span class="title function_">setExpression</span>(<span class="string">&#x27;document.querySelectorAll(&quot;img&quot;)&#x27;</span>, <span class="string">&#x27;All Images&#x27;</span>); <span class="comment">// 通过表达式来指定</span></span><br><span class="line"><span class="comment">//sidebar.setObject(&#123;aaa: 111, bbb: &#x27;Hello World!&#x27;&#125;); // 直接设置显示某个对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测jQuery</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;check_jquery&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 访问被检查的页面DOM需要使用inspectedWindow</span></span><br><span class="line"><span class="comment">// 简单例子：检测被检查页面是否使用了jQuery</span></span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="built_in">eval</span>(<span class="string">&quot;jQuery.fn.jquery&quot;</span>, <span class="keyword">function</span>(<span class="params">result, isException</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (isException) html = <span class="string">&#x27;当前页面没有使用jQuery。&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> html = <span class="string">&#x27;当前页面使用了jQuery，版本为：&#x27;</span>+result;</span><br><span class="line"><span class="title function_">alert</span>(html);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开某个资源</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;open_resource&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="built_in">eval</span>(<span class="string">&quot;window.location.href&quot;</span>, <span class="keyword">function</span>(<span class="params">result, isException</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">panels</span>.<span class="title function_">openResource</span>(result, <span class="number">20</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;资源打开成功！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审查元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test_inspect&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="built_in">eval</span>(<span class="string">&quot;inspect(document.images[0])&quot;</span>, <span class="keyword">function</span>(<span class="params">result, isException</span>)&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有资源</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;get_all_resources&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="title function_">getResources</span>(<span class="keyword">function</span>(<span class="params">resources</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(resources));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-5-4-调试技巧"><a href="#3-5-4-调试技巧" class="headerlink" title="3.5.4. 调试技巧"></a>3.5.4. 调试技巧</h3><p>修改了devtools页面的代码时，需要先在 chrome:&#x2F;&#x2F;extensions 页面按下<code>Ctrl+R</code>重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。</p><p>由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 <code>chrome-extension://extid/devtools.html&quot;</code>的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。</p><h2 id="3-6-option-选项页"><a href="#3-6-option-选项页" class="headerlink" title="3.6. option(选项页)"></a>3.6. option(选项页)</h2><p>所谓<code>options</code>页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：</p><p>在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。</p><p>我们先看老版的<a href="https://developer.chrome.com/extensions/options">options</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line"><span class="string">&quot;options_page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个<code>选项</code>按钮入口，点进去就是打开一个网页，没啥好讲的。</p><p>再来看新版的<a href="https://developer.chrome.com/extensions/optionsV2">optionsV2</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;options_ui&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line"><span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line"><span class="string">&quot;chrome_style&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点注意：</p><ul><li>为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；</li><li>新版options中不能使用alert；</li><li>数据存储建议用chrome.storage，因为会随用户自动同步；</li></ul><h2 id="3-7-omnibox"><a href="#3-7-omnibox" class="headerlink" title="3.7. omnibox"></a>3.7. omnibox</h2><p><code>omnibox</code>是向用户提供搜索建议的一种方式</p><p>注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。</p><p>首先，配置文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line"><span class="string">&quot;omnibox&quot;</span>: &#123; <span class="string">&quot;keyword&quot;</span> : <span class="string">&quot;go&quot;</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>background.js</code>中注册监听事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// omnibox 演示</span></span><br><span class="line">chrome.<span class="property">omnibox</span>.<span class="property">onInputChanged</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">text, suggest</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inputChanged: &#x27;</span> + text);</span><br><span class="line"><span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(text == <span class="string">&#x27;美女&#x27;</span>) &#123;</span><br><span class="line"><span class="title function_">suggest</span>([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;中国&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“中国美女”吗？&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;日本&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“日本美女”吗？&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;泰国&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“泰国美女或人妖”吗？&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;韩国&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“韩国美女”吗？&#x27;</span>&#125;</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(text == <span class="string">&#x27;微博&#x27;</span>) &#123;</span><br><span class="line"><span class="title function_">suggest</span>([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;新浪&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;新浪&#x27;</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;腾讯&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;腾讯&#x27;</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;搜狐&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;搜索&#x27;</span> + text&#125;,</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">suggest</span>([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;百度搜索 &#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;百度搜索 &#x27;</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;谷歌搜索 &#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;谷歌搜索 &#x27;</span> + text&#125;,</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户接收关键字建议时触发</span></span><br><span class="line">chrome.<span class="property">omnibox</span>.<span class="property">onInputEntered</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inputEntered: &#x27;</span> + text);</span><br><span class="line"><span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> href = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(text.<span class="title function_">endsWith</span>(<span class="string">&#x27;美女&#x27;</span>)) href = <span class="string">&#x27;http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word=&#x27;</span> + text;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(text.<span class="title function_">startsWith</span>(<span class="string">&#x27;百度搜索&#x27;</span>)) href = <span class="string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=&#x27;</span> + text.<span class="title function_">replace</span>(<span class="string">&#x27;百度搜索 &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(text.<span class="title function_">startsWith</span>(<span class="string">&#x27;谷歌搜索&#x27;</span>)) href = <span class="string">&#x27;https://www.google.com.tw/search?q=&#x27;</span> + text.<span class="title function_">replace</span>(<span class="string">&#x27;谷歌搜索 &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> href = <span class="string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=&#x27;</span> + text;</span><br><span class="line"><span class="title function_">openUrlCurrentTab</span>(href);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId</span>(<span class="params">callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前标签打开某个链接</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openUrlCurrentTab</span>(<span class="params">url</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">getCurrentTabId</span>(<span class="function"><span class="params">tabId</span> =&gt;</span> &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">update</span>(tabId, &#123;<span class="attr">url</span>: url&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-桌面通知"><a href="#3-8-桌面通知" class="headerlink" title="3.8. 桌面通知"></a>3.8. 桌面通知</h2><p>Chrome提供了一个<code>chrome.notifications</code>API以便插件推送桌面通知，暂未找到<code>chrome.notifications</code>和HTML5自带的<code>Notification</code>的显著区别及优势。</p><p>在后台JS中，无论是使用<code>chrome.notifications</code>还是<code>Notification</code>都不需要申请权限（HTML5方式需要申请权限），直接使用即可。</p><p>最简单的通知：</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">notifications</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line"><span class="attr">iconUrl</span>: <span class="string">&#x27;img/icon.png&#x27;</span>,</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;这是标题&#x27;</span>,</span><br><span class="line"><span class="attr">message</span>: <span class="string">&#x27;您刚才点击了自定义右键菜单！&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个没有深入研究，有需要的可以去<a href="https://developer.chrome.com/extensions/notifications">官方文档</a>查看更多细节。</p><h1 id="四、5种类型的JS对比"><a href="#四、5种类型的JS对比" class="headerlink" title="四、5种类型的JS对比"></a>四、5种类型的JS对比</h1><p>Chrome插件的JS主要可以分为这5类：<code>injected script</code>、<code>content-script</code>、<code>popup js</code>、<code>background js</code>和<code>devtools js</code>，</p><h2 id="4-1-权限对比"><a href="#4-1-权限对比" class="headerlink" title="4.1. 权限对比"></a>4.1. 权限对比</h2><table><thead><tr><th>JS种类</th><th>可访问的API</th><th>DOM访问情况</th><th>JS访问情况</th><th>直接跨域</th></tr></thead><tbody><tr><td>injected script</td><td>和普通JS无任何差别，不能访问任何扩展API</td><td>可以访问</td><td>可以访问</td><td>不可以</td></tr><tr><td>content script</td><td>只能访问 extension、runtime等部分API</td><td>可以访问</td><td>不可以</td><td>不可以</td></tr><tr><td>popup js</td><td>可访问绝大部分API，除了devtools系列</td><td>不可直接访问</td><td>不可以</td><td>可以</td></tr><tr><td>background js</td><td>可访问绝大部分API，除了devtools系列</td><td>不可直接访问</td><td>不可以</td><td>可以</td></tr><tr><td>devtools js</td><td>只能访问 devtools、extension、runtime等部分API</td><td>可以</td><td>可以</td><td>不可以</td></tr></tbody></table><h2 id="4-2-调试方式对比"><a href="#4-2-调试方式对比" class="headerlink" title="4.2. 调试方式对比"></a>4.2. 调试方式对比</h2><table><thead><tr><th>JS类型</th><th>调试方式</th></tr></thead><tbody><tr><td>injected script</td><td>直接普通的F12即可</td></tr><tr><td>content-script</td><td>打开Console,如图切换</td></tr><tr><td>popup-js</td><td>popup页面右键审查元素</td></tr><tr><td>background</td><td>插件管理页点击背景页即可</td></tr><tr><td>devtools-js</td><td>暂未找到有效方法</td></tr></tbody></table><h1 id="五、消息通信"><a href="#五、消息通信" class="headerlink" title="五、消息通信"></a>五、消息通信</h1><p>通信主页：<a href="https://developer.chrome.com/extensions/messaging">https://developer.chrome.com/extensions/messaging</a></p><p>前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。</p><h2 id="5-1-互相通信概览"><a href="#5-1-互相通信概览" class="headerlink" title="5.1. 互相通信概览"></a>5.1. 互相通信概览</h2><p>注：<code>-</code>表示不存在或者无意义，或者待验证。</p><table><thead><tr><th></th><th>injected-script</th><th>content-script</th><th>popup-js</th><th>background-js</th></tr></thead><tbody><tr><td>injected-script</td><td>-</td><td>window.postMessage</td><td>-</td><td>-</td></tr><tr><td>content-script</td><td>window.postMessage</td><td>-</td><td>chrome.runtime.sendMessage chrome.runtime.connect</td><td>chrome.runtime.sendMessage chrome.runtime.connect</td></tr><tr><td>popup-js</td><td>-</td><td>chrome.tabs.sendMessage chrome.tabs.connect</td><td>-</td><td>chrome.extension. getBackgroundPage()</td></tr><tr><td>background-js</td><td>-</td><td>chrome.tabs.sendMessage chrome.tabs.connect</td><td>chrome.extension.getViews</td><td>-</td></tr><tr><td>devtools-js</td><td>chrome.devtools. inspectedWindow.eval</td><td>-</td><td>chrome.runtime.sendMessage</td><td>chrome.runtime.sendMessage</td></tr></tbody></table><h2 id="5-2-通信详细介绍"><a href="#5-2-通信详细介绍" class="headerlink" title="5.2. 通信详细介绍"></a>5.2. 通信详细介绍</h2><h3 id="5-2-1-popup和background"><a href="#5-2-1-popup和background" class="headerlink" title="5.2.1. popup和background"></a>5.2.1. popup和background</h3><p>popup可以直接调用background中的JS方法，也可以直接访问background的DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;我是background！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// popup.js</span></span><br><span class="line"><span class="keyword">var</span> bg = chrome.<span class="property">extension</span>.<span class="title function_">getBackgroundPage</span>();</span><br><span class="line">bg.<span class="title function_">test</span>(); <span class="comment">// 访问bg的函数</span></span><br><span class="line"><span class="title function_">alert</span>(bg.<span class="property">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); <span class="comment">// 访问bg的DOM</span></span><br></pre></td></tr></table></figure><blockquote><p>小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。</p></blockquote><p>至于<code>background</code>访问<code>popup</code>如下（前提是<code>popup</code>已经打开）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> views = chrome.<span class="property">extension</span>.<span class="title function_">getViews</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;popup&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(views.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(views[<span class="number">0</span>].<span class="property">location</span>.<span class="property">href</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-popup或者bg向content主动发送消息"><a href="#5-2-2-popup或者bg向content主动发送消息" class="headerlink" title="5.2.2. popup或者bg向content主动发送消息"></a>5.2.2. popup或者bg向content主动发送消息</h3><p>background.js或者popup.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>, message, <span class="keyword">function</span>(<span class="params">response</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(response);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sendMessageToContentScript</span>(&#123;<span class="attr">cmd</span>:<span class="string">&#x27;test&#x27;</span>, <span class="attr">value</span>:<span class="string">&#x27;你好，我是popup！&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">response</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;来自content的回复：&#x27;</span>+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>content-script.js</code>接收：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// console.log(sender.tab ?&quot;from a content script:&quot; + sender.tab.url :&quot;from the extension&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(request.<span class="property">cmd</span> == <span class="string">&#x27;test&#x27;</span>) <span class="title function_">alert</span>(request.<span class="property">value</span>);</span><br><span class="line"><span class="title function_">sendResponse</span>(<span class="string">&#x27;我收到了你的消息！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。</p><blockquote><p>网上有些老代码中用的是<code>chrome.extension.onMessage</code>，没有完全查清二者的区别(貌似是别名)，但是建议统一使用<code>chrome.runtime.onMessage</code>。</p></blockquote><h3 id="5-2-3-content-script主动发消息给后台"><a href="#5-2-3-content-script主动发消息给后台" class="headerlink" title="5.2.3. content-script主动发消息给后台"></a>5.2.3. content-script主动发消息给后台</h3><p>content-script.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123;<span class="attr">greeting</span>: <span class="string">&#x27;你好，我是content-script呀，我主动发消息给后台！&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到来自后台的回复：&#x27;</span> + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>background.js 或者 popup.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听来自content-script的消息</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到来自content-script的消息：&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request, sender, sendResponse);</span><br><span class="line"><span class="title function_">sendResponse</span>(<span class="string">&#x27;我是后台，我已收到你的消息：&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>content_scripts向<code>popup</code>主动发消息的前提是popup必须打开！否则需要利用background作中转；</li><li>如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；</li></ul><h3 id="5-2-4-injected-script和content-script"><a href="#5-2-4-injected-script和content-script" class="headerlink" title="5.2.4. injected script和content-script"></a>5.2.4. injected script和content-script</h3><p><code>content-script</code>和页面内的脚本（<code>injected-script</code>自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：</p><ol><li>可以通过<code>window.postMessage</code>和<code>window.addEventListener</code>来实现二者消息通讯；</li><li>通过自定义DOM事件来实现；</li></ol><p>第一种方法（推荐）：</p><p><code>injected-script</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>(&#123;<span class="string">&quot;test&quot;</span>: <span class="string">&#x27;你好！&#x27;</span>&#125;, <span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><p>content script中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>第二种方法：</p><p><code>injected-script</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customEvent = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">customEvent.<span class="title function_">initEvent</span>(<span class="string">&#x27;myCustomEvent&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fireCustomEvent</span>(<span class="params">data</span>) &#123;</span><br><span class="line">hiddenDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCustomEventDiv&#x27;</span>);</span><br><span class="line">hiddenDiv.<span class="property">innerText</span> = data</span><br><span class="line">hiddenDiv.<span class="title function_">dispatchEvent</span>(customEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fireCustomEvent</span>(<span class="string">&#x27;你好，我是普通JS！&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>content-script.js</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCustomEventDiv&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!hiddenDiv) &#123;</span><br><span class="line">hiddenDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">hiddenDiv.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(hiddenDiv);</span><br><span class="line">&#125;</span><br><span class="line">hiddenDiv.<span class="title function_">addEventListener</span>(<span class="string">&#x27;myCustomEvent&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> eventData = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCustomEventDiv&#x27;</span>).<span class="property">innerText</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到自定义事件消息：&#x27;</span> + eventData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-2-5-injected-script与popup通信"><a href="#5-2-5-injected-script与popup通信" class="headerlink" title="5.2.5. injected-script与popup通信"></a>5.2.5. injected-script与popup通信</h3><p><code>injected-script</code>无法直接和<code>popup</code>通信，必须借助<code>content-script</code>作为中间人。</p><p>&#x2F;&#x2F;TODO 示例代码有待完善。</p><h2 id="5-3-长连接和短连接"><a href="#5-3-长连接和短连接" class="headerlink" title="5.3. 长连接和短连接"></a>5.3. 长连接和短连接</h2><p>其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（<code>chrome.tabs.sendMessage</code>和<code>chrome.runtime.sendMessage</code>），一个是长连接（<code>chrome.tabs.connect</code>和<code>chrome.runtime.connect</code>）。</p><p>短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似<code>WebSocket</code>会一直建立连接，双方可以随时互发消息。</p><p>短连接上面已经有代码示例了，这里只讲一下长连接。</p><p>popup.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getCurrentTabId</span>(<span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> port = chrome.<span class="property">tabs</span>.<span class="title function_">connect</span>(tabId, &#123;<span class="attr">name</span>: <span class="string">&#x27;test-connect&#x27;</span>&#125;);</span><br><span class="line">port.<span class="title function_">postMessage</span>(&#123;<span class="attr">question</span>: <span class="string">&#x27;你是谁啊？&#x27;</span>&#125;);</span><br><span class="line">port.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;收到消息：&#x27;</span>+msg.<span class="property">answer</span>);</span><br><span class="line"><span class="keyword">if</span>(msg.<span class="property">answer</span> &amp;&amp; msg.<span class="property">answer</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;我是&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">port.<span class="title function_">postMessage</span>(&#123;<span class="attr">question</span>: <span class="string">&#x27;哦，原来是你啊！&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>content-script.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听长连接</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onConnect</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">port</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(port);</span><br><span class="line"><span class="keyword">if</span>(port.<span class="property">name</span> == <span class="string">&#x27;test-connect&#x27;</span>) &#123;</span><br><span class="line">port.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到长连接消息：&#x27;</span>, msg);</span><br><span class="line"><span class="keyword">if</span>(msg.<span class="property">question</span> == <span class="string">&#x27;你是谁啊？&#x27;</span>) port.<span class="title function_">postMessage</span>(&#123;<span class="attr">answer</span>: <span class="string">&#x27;我是你爸！&#x27;</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="六、其它补充"><a href="#六、其它补充" class="headerlink" title="六、其它补充"></a>六、其它补充</h1><h2 id="6-1-动态注入或执行JS"><a href="#6-1-动态注入或执行JS" class="headerlink" title="6.1. 动态注入或执行JS"></a>6.1. 动态注入或执行JS</h2><p>虽然在<code>background</code>和<code>popup</code>中无法直接访问页面DOM，但是可以通过<code>chrome.tabs.executeScript</code>来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。</p><p>示例<code>manifest.json</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;动态JS注入演示&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;permissions&quot;</span>: [</span><br><span class="line"><span class="string">&quot;tabs&quot;</span>, <span class="string">&quot;http://*/*&quot;</span>, <span class="string">&quot;https://*/*&quot;</span></span><br><span class="line">],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态执行JS代码</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">executeScript</span>(tabId, &#123;<span class="attr">code</span>: <span class="string">&#x27;document.body.style.backgroundColor=&quot;red&quot;&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行JS文件</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">executeScript</span>(tabId, &#123;<span class="attr">file</span>: <span class="string">&#x27;some-script.js&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-2-动态注入CSS"><a href="#6-2-动态注入CSS" class="headerlink" title="6.2. 动态注入CSS"></a>6.2. 动态注入CSS</h2><p>示例<code>manifest.json</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;动态CSS注入演示&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;permissions&quot;</span>: [</span><br><span class="line"><span class="string">&quot;tabs&quot;</span>, <span class="string">&quot;http://*/*&quot;</span>, <span class="string">&quot;https://*/*&quot;</span></span><br><span class="line">],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态执行CSS代码，TODO，这里有待验证</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">insertCSS</span>(tabId, &#123;<span class="attr">code</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行CSS文件</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">insertCSS</span>(tabId, &#123;<span class="attr">file</span>: <span class="string">&#x27;some-style.css&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-3-获取当前窗口ID"><a href="#6-3-获取当前窗口ID" class="headerlink" title="6.3. 获取当前窗口ID"></a>6.3. 获取当前窗口ID</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">windows</span>.<span class="title function_">getCurrent</span>(<span class="keyword">function</span>(<span class="params">currentWindow</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前窗口ID：&#x27;</span> + currentWindow.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-4-获取当前标签页ID"><a href="#6-4-获取当前标签页ID" class="headerlink" title="6.4. 获取当前标签页ID"></a>6.4. 获取当前标签页ID</h2><p>一般有2种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId</span>(<span class="params">callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId2</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">windows</span>.<span class="title function_">getCurrent</span>(<span class="keyword">function</span>(<span class="params">currentWindow</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">windowId</span>: currentWindow.<span class="property">id</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-本地存储"><a href="#6-5-本地存储" class="headerlink" title="6.5. 本地存储"></a>6.5. 本地存储</h2><p>本地存储建议用<code>chrome.storage</code>而不是普通的<code>localStorage</code>，区别有好几点，个人认为最重要的2点区别是：</p><ul><li><code>chrome.storage</code>是针对插件全局的，即使你在<code>background</code>中保存的数据，在<code>content-script</code>也能获取到；</li><li><code>chrome.storage.sync</code>可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；</li></ul><p>需要声明<code>storage</code>权限，有<code>chrome.storage.sync</code>和<code>chrome.storage.local</code>2种方式可供选择，使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据，第一个参数是指定要读取的key以及设置默认值</span></span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, <span class="keyword">function</span>(<span class="params">items</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="property">color</span>, items.<span class="property">age</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存成功！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-6-webRequest"><a href="#6-6-webRequest" class="headerlink" title="6.6. webRequest"></a>6.6. webRequest</h2><p>这里通过<code>beforeRequest</code>来简单演示一下它的冰山一角：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 权限申请</span></span><br><span class="line"><span class="string">&quot;permissions&quot;</span>:</span><br><span class="line">[</span><br><span class="line"><span class="string">&quot;webRequest&quot;</span>, <span class="comment">// web请求</span></span><br><span class="line"><span class="string">&quot;webRequestBlocking&quot;</span>, <span class="comment">// 阻塞式web请求</span></span><br><span class="line"><span class="string">&quot;storage&quot;</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line"><span class="string">&quot;http://*/*&quot;</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line"><span class="string">&quot;https://*/*&quot;</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="comment">// 是否显示图片</span></span><br><span class="line"><span class="keyword">var</span> showImage;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(&#123;<span class="attr">showImage</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">items</span>) &#123;</span><br><span class="line">showImage = items.<span class="property">showImage</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeRequest</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// cancel 表示取消本次请求</span></span><br><span class="line"><span class="keyword">if</span>(!showImage &amp;&amp; details.<span class="property">type</span> == <span class="string">&#x27;image&#x27;</span>) <span class="keyword">return</span> &#123;<span class="attr">cancel</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="comment">// 简单的音视频检测</span></span><br><span class="line"><span class="comment">// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span></span><br><span class="line"><span class="keyword">if</span>(details.<span class="property">type</span> == <span class="string">&#x27;media&#x27;</span>) &#123;</span><br><span class="line">chrome.<span class="property">notifications</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line"><span class="attr">iconUrl</span>: <span class="string">&#x27;img/icon.png&#x27;</span>,</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;检测到音视频&#x27;</span>,</span><br><span class="line"><span class="attr">message</span>: <span class="string">&#x27;音视频地址：&#x27;</span> + details.<span class="property">url</span>,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>]&#125;, [<span class="string">&quot;blocking&quot;</span>]);</span><br></pre></td></tr></table></figure><p>几个可能经常用到的事件使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次请求前触发，可以拿到 requestBody 数据，同时可以对本次请求作出干预修改</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeRequest</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeRequest&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;blocking&#x27;</span>, <span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;requestBody&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送header之前触发，可以拿到请求headers，也可以添加、修改、删除headers</span></span><br><span class="line"><span class="comment">// 但使用有一定限制，一些特殊头部可能拿不到或者存在特殊情况，详见官网文档</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeSendHeaders</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeSendHeaders&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;blocking&#x27;</span>, <span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;requestHeaders&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始响应触发，可以拿到服务端返回的headers</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onResponseStarted</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onResponseStarted&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;responseHeaders&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求完成触发，能拿到的数据和onResponseStarted一样，注意无法拿到responseBody</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onCompleted</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onCompleted&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;responseHeaders&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>上面示例中提到，使用<code>webRequest</code>API是无法拿到<code>responseBody</code>的，想要拿到的话只能采取一些变通方法，例如：</p><ol><li>重写<code>XmlHttpRequest</code>和<code>fetch</code>，增加自定义拦截事件，缺点是实现方式可能有点脏，重写不好的话可能影响正常页面；</li><li><code>devtools</code>的<code>chrome.devtools.network.onRequestFinished</code>API可以拿到返回的body，缺点是必须打开开发者面板；</li><li>使用<code>chrome.debugger.sendCommand</code>发送<code>Network.getResponseBody</code>命令来获取body内容，缺点也很明显，会有一个恼人的提示：</li></ol><p>上述几种方法的实现方式这个链接基本上都有，可以参考下：<a href="https://stackoverflow.com/questions/18534771/chrome-extension-how-to-get-http-response-body">https://stackoverflow.com/questions/18534771/chrome-extension-how-to-get-http-response-body</a></p><h2 id="6-7-国际化"><a href="#6-7-国际化" class="headerlink" title="6.7. 国际化"></a>6.7. 国际化</h2><p>插件根目录新建一个名为<code>_locales</code>的文件夹，再在下面新建一些语言的文件夹，如<code>en</code>、<code>zh_CN</code>、<code>zh_TW</code>，然后再在每个文件夹放入一个<code>messages.json</code>，同时必须在清单文件中设置<code>default_locale</code>。</p><p><code>_locales\en\messages.json</code>内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;pluginDesc&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;A simple chrome extension demo&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;helloWorld&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World!&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_locales\zh_CN\messages.json</code>内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;pluginDesc&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;一个简单的Chrome插件demo&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;helloWorld&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;你好啊，世界！&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>manifest.json</code>和<code>CSS</code>文件中通过<code>__MSG_messagename__</code>引入，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;__MSG_pluginDesc__&quot;</span>,</span><br><span class="line"><span class="comment">// 默认语言</span></span><br><span class="line"><span class="string">&quot;default_locale&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS中则直接<code>chrome.i18n.getMessage(&quot;helloWorld&quot;)</code>。</p><p><img src="http://image.liuxianan.com/201706/20170621_175733_172_5903.png" alt="img"></p><h1 id="七、常见API总结"><a href="#七、常见API总结" class="headerlink" title="七、常见API总结"></a>七、常见API总结</h1><p>比较常用用的一些API系列：</p><ul><li>chrome.tabs</li><li>chrome.webRequest</li><li>chrome.window</li><li>chrome.storage</li><li>chrome.contextMenus</li><li>chrome.devtools</li><li>chrome.extension</li></ul><h2 id="7-1-chrome-cookies"><a href="#7-1-chrome-cookies" class="headerlink" title="7.1. chrome.cookies"></a>7.1. chrome.cookies</h2><p>获取某个网站的所有cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://www.baidu.com&#x27;</span>;</span><br><span class="line">chrome.<span class="property">cookies</span>.<span class="title function_">getAll</span>(&#123;url&#125;, <span class="function"><span class="params">cookies</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cookies);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>清除某个网站的某个cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://www.baidu.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cookieName = <span class="string">&#x27;userName&#x27;</span>;</span><br><span class="line">chrome.<span class="property">cookies</span>.<span class="title function_">remove</span>(&#123;url, <span class="attr">name</span>: cookieName&#125;, <span class="function"><span class="params">details</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="7-2-chrome-runtime"><a href="#7-2-chrome-runtime" class="headerlink" title="7.2. chrome.runtime"></a>7.2. chrome.runtime</h2><ul><li><code>chrome.runtime.id</code>：获取插件id</li><li><code>chrome.runtime.getURL(&#39;xxx.html&#39;)</code>：获取<code>xxx.html</code>在插件中的地址</li></ul><h1 id="八、经验总结"><a href="#八、经验总结" class="headerlink" title="八、经验总结"></a>八、经验总结</h1><h2 id="8-1-查看已安装插件路径"><a href="#8-1-查看已安装插件路径" class="headerlink" title="8.1. 查看已安装插件路径"></a>8.1. 查看已安装插件路径</h2><p>查看本地已安装的插件源码路径：<code>C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions</code>，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了：</p><p><img src="http://image.liuxianan.com/201706/20170601_100200_647_6507.png" alt="img"></p><p>如何查看某个插件的ID？进入 chrome:&#x2F;&#x2F;extensions ，然后勾线开发者模式即可看到了。</p><p><img src="http://image.liuxianan.com/201706/20170601_100408_338_3095.png" alt="img"></p><blockquote><p>Mac系统插件本地缓存位于：<code>/Users/用户名/Library/Application Support/Google/Chrome/Default/Extensions</code> 文件夹</p></blockquote><h2 id="8-2-特别注意background的报错"><a href="#8-2-特别注意background的报错" class="headerlink" title="8.2. 特别注意background的报错"></a>8.2. 特别注意background的报错</h2><p>很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。</p><h2 id="8-3-如何让popup页面不关闭"><a href="#8-3-如何让popup页面不关闭" class="headerlink" title="8.3. 如何让popup页面不关闭"></a>8.3. 如何让popup页面不关闭</h2><p>在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！</p><h2 id="8-4-不支持内联JavaScript的执行"><a href="#8-4-不支持内联JavaScript的执行" class="headerlink" title="8.4. 不支持内联JavaScript的执行"></a>8.4. 不支持内联JavaScript的执行</h2><p>也就是不支持将js直接写在html中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;收藏&quot; onclick=&quot;test()&quot;/&gt;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to execute inline event handler because it violates the following Content Security Policy directive: &quot;script-src &#x27;self&#x27; blob: filesystem: chrome-extension-resource:&quot;. Either the &#x27;unsafe-inline&#x27; keyword, a hash (&#x27;sha256-...&#x27;), or a nonce (&#x27;nonce-...&#x27;) is required to enable inline execution.</span><br></pre></td></tr></table></figure><p>解决方法就是用JS绑定事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btn&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&#x27;测试&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure><p>另外，对于A标签，这样写<code>href=&quot;javascript:;&quot;</code>然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成<code>href=&quot;#&quot;</code>了。</p><p>如果这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;get_secret&quot;&gt;请求secret&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to execute JavaScript URL because it violates the following Content Security Policy directive: &quot;script-src &#x27;self&#x27; blob: filesystem: chrome-extension-resource:&quot;. Either the &#x27;unsafe-inline&#x27; keyword, a hash (&#x27;sha256-...&#x27;), or a nonce (&#x27;nonce-...&#x27;) is required to enable inline execution.</span><br></pre></td></tr></table></figure><h2 id="8-5-注入CSS的时候必须小心"><a href="#8-5-注入CSS的时候必须小心" class="headerlink" title="8.5. 注入CSS的时候必须小心"></a>8.5. 注入CSS的时候必须小心</h2><p>由于通过<code>content_scripts</code>注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。</p><p>之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！</p><p><img src="http://image.liuxianan.com/201706/20170620_175530_598_9800.png" alt="img"></p><h1 id="打包与发布"><a href="#打包与发布" class="headerlink" title="打包与发布"></a>打包与发布</h1><p>打包的话直接在插件管理页有一个打包按钮：</p><p><img src="http://image.liuxianan.com/201706/20170621_181130_362_3360.png" alt="img"></p><p>然后会生成一个<code>.crx</code>文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。</p><p><img src="http://image.liuxianan.com/201707/20170710_221653_875_3099.png" alt="img"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="12-1-官方资料"><a href="#12-1-官方资料" class="headerlink" title="12.1. 官方资料"></a>12.1. 官方资料</h2><p>推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：</p><ul><li><a href="https://developer.chrome.com/extensions">Chrome插件官方文档主页</a></li><li><a href="https://developer.chrome.com/extensions/samples">Chrome插件官方示例</a></li><li><a href="https://developer.chrome.com/extensions/manifest">manifest清单文件</a></li><li><a href="https://developer.chrome.com/extensions/permissions">permissions权限</a></li><li><a href="https://developer.chrome.com/extensions/api_index">chrome.xxx.api文档</a></li><li><a href="https://developer.chrome.com/extensions/match_patterns">模糊匹配规则语法详解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本笔记是各资料整合&lt;code&gt;摘录&lt;/code&gt;以及后续相关笔记补充、当时纯为了方便记录,没有记录各个知识点摘录出处;非本人洪撰写(大都是摘录,加以少许个人理解),仅供本人学习使用&lt;/p&gt;
&lt;p&gt;本人笔记地址分享:&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="软件" scheme="https://k705.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Css补缺</title>
    <link href="https://k705.github.io/2024/04/08/Css%E8%A1%A5%E7%BC%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/Css%E8%A1%A5%E7%BC%BA%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-10T03:08:11.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人<a href="https://gitee.com/hongjilin/hongs-study-notes">笔记地址</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、知识点详解"><a href="#一、知识点详解" class="headerlink" title="一、知识点详解"></a>一、知识点详解</h1><h2 id="Ⅰ-css3-pointer-events"><a href="#Ⅰ-css3-pointer-events" class="headerlink" title="Ⅰ-css3 pointer-events"></a>Ⅰ-css3 <code>pointer-events</code></h2><blockquote><p>此属性会阻止hover、active、onclick等触发事件</p><ol><li><h6 id="pointer-events-更像是JavaScript，它能够："><a href="#pointer-events-更像是JavaScript，它能够：" class="headerlink" title="pointer-events 更像是JavaScript，它能够："></a><code>pointer-events </code>更像是JavaScript，它能够：</h6></li></ol><ul><li>阻止用户的点击动作产生任何效果</li><li>阻止缺省鼠标指针的显示</li><li>阻止CSS里的 <code>hover </code>和 <code>active </code>状态的变化触发事件</li><li>阻止JavaScript点击动作触发的事件</li></ul><ol start="2"><li><h6 id="具体用法："><a href="#具体用法：" class="headerlink" title="具体用法："></a>具体用法：</h6></li></ol>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pointer-events</span>:  auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit</span><br></pre></td></tr></table></figure><blockquote><p>pointer-events属性有很多值，但是对于浏览器来说，<code>只有auto和none两个值可用</code>，其它的几个是针对SVG的(本身这个属性就来自于SVG技术)。</p></blockquote><ol start="3"><li><h6 id="pointer-events属性值详解"><a href="#pointer-events属性值详解" class="headerlink" title="pointer-events属性值详解"></a>pointer-events属性值详解</h6></li></ol><ul><li>auto——效果和没有定义pointer-events属性相同，鼠标不会穿透当前层。在SVG中，该值和visiblePainted的效果相同。</li><li>none——元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。</li><li>其它属性值为SVG专用，这里不再多介绍了。</li></ul></blockquote><h1 id="二、实际问题解决"><a href="#二、实际问题解决" class="headerlink" title="二、实际问题解决"></a>二、实际问题解决</h1><h2 id="Ⅰ-图片不拉伸属性-object-fit"><a href="#Ⅰ-图片不拉伸属性-object-fit" class="headerlink" title="Ⅰ-图片不拉伸属性  object-fit"></a>Ⅰ-图片不拉伸属性 <code> object-fit</code></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">object-fit</span>: cover;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-css鼠标点击的五种状态"><a href="#Ⅱ-css鼠标点击的五种状态" class="headerlink" title="Ⅱ-css鼠标点击的五种状态"></a>Ⅱ-css鼠标点击的五种状态</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  未访问时的状态（鼠标点击前显示的状态）</span><br><span class="line">  <span class="number">2</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  鼠标悬停时的状态</span><br><span class="line">  <span class="number">3</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  已访问过的状态（鼠标点击后的状态）</span><br><span class="line">  <span class="number">4</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  鼠标点击时的状态</span><br><span class="line">  <span class="number">5</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  点击后鼠标移开保持鼠标点击时的状态（只有在&lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;&lt;/<span class="selector-tag">a</span>&gt;时标签中有效）</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-阴影效果"><a href="#Ⅲ-阴影效果" class="headerlink" title="Ⅲ-阴影效果"></a>Ⅲ-阴影效果</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>:<span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#000</span>; //正常</span><br><span class="line"><span class="attribute">box-shadow</span>:inset <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#000</span>; //内阴影</span><br><span class="line"><span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">#000</span>;//拓展阴影长度</span><br><span class="line"><span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">3px</span> <span class="number">#bb0a0a</span>,</span><br><span class="line">           <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">6px</span> <span class="number">#2e56bf</span>,</span><br><span class="line">           <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">9px</span> <span class="number">#ea982e</span>;//多重阴影</span><br></pre></td></tr></table></figure><blockquote><p>逼真的阴影效果示例</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box11 shadow&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"><span class="comment">/********************************************/</span></span><br><span class="line"><span class="selector-class">.box11</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">270px</span>;</span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">1px</span> <span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>),</span><br><span class="line"><span class="number">0px</span> <span class="number">0px</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>) inset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">   <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="attribute">position</span>:absolute;</span><br><span class="line">   <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">   <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="attribute">position</span>:absolute;</span><br><span class="line">   <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">   <span class="attribute">bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">left</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">   <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="attribute">position</span>:absolute;</span><br><span class="line">   <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">   <span class="attribute">bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">left</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">   <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">15px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.7</span>);</span><br><span class="line">   <span class="attribute">transform</span>:<span class="built_in">rotate</span>(-<span class="number">3deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">   <span class="attribute">right</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">left</span>:auto;</span><br><span class="line">   <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">3deg</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-实现a标签禁用"><a href="#Ⅳ-实现a标签禁用" class="headerlink" title="Ⅳ-实现a标签禁用"></a>Ⅳ-实现a标签禁用</h2><blockquote><ol><li><p>需求分析:业务中遇到一个需求-根据当前数据类别进行权限限制,当我为新用户数据时,开放编辑操作,当我为旧用户数据时,禁用编辑操作</p></li><li><p>代码:</p><ol><li>css代码:</li></ol></li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**设置a标签禁用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">50</span>);</span><br><span class="line">  <span class="comment">/*IE滤镜，透明度50%*/</span></span><br><span class="line">  -moz-<span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="comment">/*Firefox私有，透明度50%*/</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="comment">/*其他，透明度50%*/</span></span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为pointer-events会阻止hover事件,所以在外层进行判断,同时变为行内元素</span></span><br><span class="line"><span class="selector-class">.disabledbox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.combox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.disabledbox</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>1. html部分调用代码--示例中是在:antd中table组件中试用</code></pre>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新旧渠道商标识</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CHANNELBZ</span> = &#123;</span><br><span class="line">  <span class="attr">OLD</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">NEW</span>: <span class="number">1</span></span><br><span class="line">&#125; </span><br><span class="line">....</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;推荐折扣&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;discount&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function">(<span class="params">value, item</span>) =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;item.sourceType</span> == <span class="string">CHANNELBZ.OLD</span> ? <span class="attr">style.disabledbox</span> <span class="attr">:</span> <span class="attr">style.combox</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&#123;item.sourceType</span> == <span class="string">CHANNELBZ.OLD</span> ? <span class="attr">style.disabled</span> <span class="attr">:</span> &quot;&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginLeft:</span> <span class="attr">10</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">              console.log(item.sourceType, &quot;itemmmmmm&quot;)</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            编辑</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ol start="3"><li><p>效果实现截图:</p><img src="Css补缺笔记中的图片/image-20210517184121490.png" alt="image-20210517184121490" style="zoom:80%;" /></li></ol></blockquote><h2 id="Ⅴ-实现父元素半透明，子元素不透明"><a href="#Ⅴ-实现父元素半透明，子元素不透明" class="headerlink" title="Ⅴ-实现父元素半透明，子元素不透明"></a>Ⅴ-实现父元素半透明，子元素不透明</h2><blockquote><p>CSS实现父元素半透明，子元素不透明。 很久以来大家都习惯使用opacity:0.5在新式浏览器里实现半透明，而对IE较旧的版本使用filter:Alpha(opacity&#x3D;0.5)的滤镜来实现半透明。但是这样实现的半透明有个问题，那就是这个属性会被子元素所继承。</p><p>如下代码，则子元素中也将是半透明效果，无论你将子元素的半透明值重置还是如何都不会改变这一情况。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-class">.parent</span>&#123;<span class="attribute">opacity</span>:<span class="number">0.9</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>;&#125;</span><br><span class="line">&gt;<span class="selector-class">.child</span>&#123;<span class="attribute">opacity</span>:<span class="number">1.0</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">height</span>:<span class="number">200px</span>;&#125;</span><br></pre></td></tr></table></figure><ol><li>问题效果</li></ol><img src="Css补缺笔记中的图片/image-20210616183632386.png" alt="image-20210616183632386" style="zoom:67%;" /> <ol start="2"><li>解决:其实在新的CSS3规则里面的属性 GRBA已经可以方便的实现父元素透明，而子元素不透明了。</li></ol>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用背景色透明可以限制子类不继承,防止下方按钮也变得半透明</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>) ;</span><br></pre></td></tr></table></figure>  <img src="Css补缺笔记中的图片/image-20210616183902406.png" alt="image-20210616183902406" style="zoom:67%;" /> </blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本人&lt;a href=&quot;https://gitee.com/hongjilin/hongs-study-notes&quot;&gt;笔记地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://k705.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>对象的新增方法</title>
    <link href="https://k705.github.io/2024/04/08/Es6-10%E3%80%81Es6_%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95_day11-27/"/>
    <id>https://k705.github.io/2024/04/08/Es6-10%E3%80%81Es6_%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95_day11-27/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:31:39.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="十、对象的新增方法"><a href="#十、对象的新增方法" class="headerlink" title="十、对象的新增方法"></a>十、对象的新增方法</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line"><span class="title class_">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line"><span class="title class_">Object</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign()</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign()</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p><p>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="title class_">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">obj2.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p><strong>（2）同名属性的替换</strong></p><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。</p><p>一些函数库提供<code>Object.assign()</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并。</p><p><strong>（3）数组的处理</strong></p><p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p><p><strong>（4）取值函数的处理</strong></p><p><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><code>Object.assign()</code>方法有很多用处。</p><p><strong>（1）为对象添加属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p><p><strong>（2）为对象添加方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">anotherMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line"><span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">someMethod</span> = <span class="keyword">function</span> (<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">anotherMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中。</p><p><strong>（3）克隆对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）合并多个对象</strong></p><p>将多个对象合并到某个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> =</span><br><span class="line">  (<span class="params">target, ...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> =</span><br><span class="line">  (<span class="params">...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><p><strong>（5）为属性指定默认值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line">  <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign()</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p><p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">7070</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processContent</span>(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p>该方法的实现非常容易。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">    result[key] = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(target2, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source));</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target2, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: set foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shallowMerge</span> = (<span class="params">target, source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(</span><br><span class="line">  target,</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象<code>obj</code>。</p><p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: prot,</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prot);</span><br><span class="line">obj.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">create</span>(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">  prot,</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">mix</span> = (<span class="params">object</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">      c, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> d = <span class="title function_">mix</span>(c).<span class="title function_">with</span>(a, b);</span><br><span class="line"></span><br><span class="line">d.<span class="property">c</span> <span class="comment">// &quot;c&quot;</span></span><br><span class="line">d.<span class="property">b</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line">d.<span class="property">a</span> <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p><p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p><h2 id="proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5 的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someOtherObj);</span><br><span class="line">obj.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p><p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;__proto__&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _thisObj = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">proto</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">undefined</span> || <span class="variable language_">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(proto)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">obj, proto</span>) &#123;</span><br><span class="line">  obj.<span class="property">__proto__</span> = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.<span class="property">y</span> = <span class="number">20</span>;</span><br><span class="line">proto.<span class="property">z</span> = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">obj.<span class="property">y</span> <span class="comment">// 20</span></span><br><span class="line">obj.<span class="property">z</span> <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p><p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(rec, <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，会被自动转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>) === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p><p><code>Object.values</code>只返回对象自身的可遍历属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure><p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p><p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p><p><code>Object.entries</code>的基本用途是遍历对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;one&quot;: 1</span></span><br><span class="line"><span class="comment">// &quot;two&quot;: 2</span></span><br></pre></td></tr></table></figure><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>自己实现<code>Object.entries</code>方法，非常简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数的版本</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Generator函数的版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map)</span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Symbol</title>
    <link href="https://k705.github.io/2024/04/08/Es6-11%E3%80%81Es6_Symbol_day11-27%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-11%E3%80%81Es6_Symbol_day11-27%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:31:32.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="十一、Symbol"><a href="#十一、Symbol" class="headerlink" title="十一、Symbol"></a>十一、Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是，Symbol 值可以显式转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br></pre></td></tr></table></figure><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="title class_">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>创建 Symbol 的时候，可以添加一个描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p><p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br></pre></td></tr></table></figure><p>上面的用法不是很方便。<a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">mySymbol</span> = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="keyword">function</span> (<span class="params">arg</span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">log.<span class="property">levels</span> = &#123;</span><br><span class="line">  <span class="attr">DEBUG</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;debug&#x27;</span>),</span><br><span class="line">  <span class="attr">INFO</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">  <span class="attr">WARN</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;warn&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">DEBUG</span>, <span class="string">&#x27;debug message&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">INFO</span>, <span class="string">&#x27;info message&#x27;</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_RED</span>    = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_GREEN</span>  = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getComplement</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">COLOR_RED</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">COLOR_GREEN</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">COLOR_GREEN</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">COLOR_RED</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Undefined color&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p><p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p><h2 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      area = <span class="number">.5</span> * options.<span class="property">width</span> * options.<span class="property">height</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... more code ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getArea</span>(<span class="string">&#x27;Triangle&#x27;</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">triangle</span>: <span class="string">&#x27;Triangle&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.<span class="property">triangle</span>:</span><br><span class="line">      area = <span class="number">.5</span> * options.<span class="property">width</span> * options.<span class="property">height</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getArea</span>(shapeType.<span class="property">triangle</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">triangle</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p><p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[foo] = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj) <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)</span><br><span class="line"><span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="title class_">Symbol</span>(<span class="string">&#x27;size&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable language_">this</span>[size]] = item;</span><br><span class="line">    <span class="variable language_">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sizeOf</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(x) <span class="comment">// [&#x27;0&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(x) <span class="comment">// [&#x27;0&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p><h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p><p>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="title function_">foo</span>();</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值。</p><p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = <span class="title class_">String</span>(<span class="variable language_">window</span>.<span class="property">location</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"></span><br><span class="line">iframe.<span class="property">contentWindow</span>.<span class="property">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p><h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">global</span>.<span class="property">_foo</span>) &#123;</span><br><span class="line">  <span class="variable language_">global</span>.<span class="property">_foo</span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>.<span class="property">_foo</span>;</span><br></pre></td></tr></table></figure><p>然后，加载上面的<code>mod.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">foo</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">_foo</span> = &#123; <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">foo</span>);</span><br></pre></td></tr></table></figure><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p><p>为了防止这种情况出现，我们就可以使用 Symbol。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>]) &#123;</span><br><span class="line">  <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>] = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>];</span><br></pre></td></tr></table></figure><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>[<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)] = &#123; <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p><h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="title class_">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Even</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Even</span> = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Even</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Even</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> <span class="title class_">Even</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr1, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">arr1[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr2[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr2, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]</span></span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(args);</span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(args);</span><br><span class="line">  &#125;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title function_">A1</span>();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title function_">A2</span>();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>(a1).<span class="title function_">concat</span>(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p><h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"><span class="keyword">const</span> c = a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">MyArray</span> <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="title class_">MyArray</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再来看前面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">MyArray</span> <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p><p>再看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">T1</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="title function_">r</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> <span class="variable constant_">T1</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">T2</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="title function_">r</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> <span class="variable constant_">T2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p><p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p><h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">match</span>(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="title class_">Symbol</span>.<span class="property">match</span>](<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMatcher</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">match</span>](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">indexOf</span>(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;e&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">MyMatcher</span>()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">replace</span>(searchValue, replaceValue)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">searchValue[<span class="title class_">Symbol</span>.<span class="property">replace</span>](<span class="variable language_">this</span>, replaceValue)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="title class_">Symbol</span>.<span class="property">replace</span>] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span>.<span class="title function_">replace</span>(x, <span class="string">&#x27;World&#x27;</span>) <span class="comment">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">search</span>(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="title class_">Symbol</span>.<span class="property">search</span>](<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySearch</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">search</span>](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">MySearch</span>(<span class="string">&#x27;foo&#x27;</span>)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">split</span>(separator, limit)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">separator[<span class="title class_">Symbol</span>.<span class="property">split</span>](<span class="variable language_">this</span>, limit)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySplitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">split</span>](string) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = string.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      string.<span class="title function_">substr</span>(<span class="number">0</span>, index),</span><br><span class="line">      string.<span class="title function_">substr</span>(index + <span class="variable language_">this</span>.<span class="property">value</span>.<span class="property">length</span>)</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">MySplitter</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">MySplitter</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">MySplitter</span>(<span class="string">&#x27;baz&#x27;</span>))</span><br><span class="line"><span class="comment">// &#x27;foobar&#x27;</span></span><br></pre></td></tr></table></figure><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p><h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="variable language_">this</span>[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li>Number：该场合需要转成数值</li><li>String：该场合需要转成字符串</li><li>Default：该场合可以转成数值，也可以转成字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// &#x27;3default&#x27;</span></span><br><span class="line">obj == <span class="string">&#x27;default&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">String</span>(obj) <span class="comment">// &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]: <span class="string">&#x27;Foo&#x27;</span>&#125;.<span class="title function_">toString</span>())</span><br><span class="line"><span class="comment">// &quot;[object Foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(x) <span class="comment">// &quot;[object xxx]&quot;</span></span><br></pre></td></tr></table></figure><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p><ul><li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li><li><code>Math[Symbol.toStringTag]</code>：’Math’</li><li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li><li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li><li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li><li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li><li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li><li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li><li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li><li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li><li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li><li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li><li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li><li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li><li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li><li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li><li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li></ul><h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   copyWithin: true,</span></span><br><span class="line"><span class="comment">//   entries: true,</span></span><br><span class="line"><span class="comment">//   fill: true,</span></span><br><span class="line"><span class="comment">//   find: true,</span></span><br><span class="line"><span class="comment">//   findIndex: true,</span></span><br><span class="line"><span class="comment">//   includes: true,</span></span><br><span class="line"><span class="comment">//   keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>])</span><br><span class="line"><span class="comment">// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有 unscopables 时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (<span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 unscopables 时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">unscopables</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (<span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Set 和 Map 数据结构</title>
    <link href="https://k705.github.io/2024/04/08/Es6-12%E3%80%81Es6_Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_day11-27/"/>
    <id>https://k705.github.io/2024/04/08/Es6-12%E3%80%81Es6_Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_day11-27/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:31:26.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="十二、Set-和-Map-数据结构"><a href="#十二、Set-和-Map-数据结构" class="headerlink" title="十二、Set 和 Map 数据结构"></a>十二、Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">x</span> =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.<span class="property">size</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">document</span></span><br><span class="line"> .<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"> .<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> set.<span class="title function_">add</span>(div));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br></pre></td></tr></table></figure><p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码也展示了一种去除数组重复成员的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line">set.<span class="title function_">add</span>(a);</span><br><span class="line">set.<span class="title function_">add</span>(b);</span><br><span class="line">set <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p><p>另外，两个对象总是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法的实例如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = &#123;</span><br><span class="line">  <span class="string">&#x27;width&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;height&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties[someName]) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">properties.<span class="title function_">add</span>(<span class="string">&#x27;width&#x27;</span>);</span><br><span class="line">properties.<span class="title function_">add</span>(<span class="string">&#x27;height&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties.<span class="title function_">has</span>(someName)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">values</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p><strong>（2）<code>forEach()</code></strong></p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p><strong>（3）遍历的应用</strong></p><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">ws.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.<span class="title function_">add</span>(<span class="title class_">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p><p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">add</span>(<span class="variable language_">window</span>);</span><br><span class="line">ws.<span class="title function_">add</span>(obj);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">has</span>(<span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.<span class="title function_">has</span>(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">delete</span>(<span class="variable language_">window</span>);</span><br><span class="line">ws.<span class="title function_">has</span>(<span class="variable language_">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">ws.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><p>下面是 WeakSet 的另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    foos.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在Foo的实例上调用！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">&#x27;metadata&#x27;</span>;</span><br><span class="line">data[<span class="string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="comment">// &quot;metadata&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.<span class="title function_">get</span>(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(o) <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">delete</span>(o) <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">items.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.<span class="title function_">set</span>(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>(set);</span><br><span class="line">m1.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>(m2);</span><br><span class="line">m3.<span class="title function_">get</span>(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(<span class="number">1</span>) <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">get</span>(<span class="string">&#x27;asfddfsasadf&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.<span class="title function_">get</span>([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="title function_">set</span>(k1, <span class="number">111</span>)</span><br><span class="line">.<span class="title function_">set</span>(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(k1) <span class="comment">// 111</span></span><br><span class="line">map.<span class="title function_">get</span>(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="title class_">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p><p><strong>（1）size 属性</strong></p><p><code>size</code>属性返回 Map 结构的成员总数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>（2）Map.prototype.set(key, value)</strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>（3）Map.prototype.get(key)</strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.<span class="title function_">set</span>(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure><p><strong>（4）Map.prototype.has(key)</strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>（5）Map.prototype.delete(key)</strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>（6）Map.prototype.clear()</strong></p><p><code>clear</code>方法清除所有成员，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === map.<span class="property">entries</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.<span class="title function_">keys</span>()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.<span class="title function_">values</span>()]</span><br><span class="line"><span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"></span><br><span class="line">[...map.<span class="title function_">entries</span>()]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  <span class="attr">report</span>: <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">report</span>(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToObj</span>(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><p><strong>（4）对象转为 Map</strong></p><p>对象转为 Map 可以通过<code>Object.entries()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure><p>此外，也可以自己实现一个转换函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    strMap.<span class="title function_">set</span>(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">objToStrMap</span>(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.<span class="title function_">set</span>(key, <span class="number">2</span>);</span><br><span class="line">wm1.<span class="title function_">get</span>(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.<span class="title function_">get</span>(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p><p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p><p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">  [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p><p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.<span class="title function_">get</span>(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p><p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p><h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">wm.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line">wm.<span class="property">clear</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap-的示例"><a href="#WeakMap-的示例" class="headerlink" title="WeakMap 的示例"></a>WeakMap 的示例</h3><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p><p>贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925">vtxf</a>补充了下面的例子。</p><p>首先，打开 Node 命令行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --expose-gc</span><br></pre></td></tr></table></figure><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p><p>然后，执行下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></span><br><span class="line">&gt; <span class="variable language_">global</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">21106688</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">7376896</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">4153936</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">9059</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个变量 key，指向一个 5*1024*1024 的数组</span></span><br><span class="line">&gt; <span class="keyword">let</span> key = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 WeakMap 实例的键名，也指向 key 数组</span></span><br><span class="line"><span class="comment">// 这时，key 数组实际被引用了两次，</span></span><br><span class="line"><span class="comment">// 变量 key 引用一次，WeakMap 的键名引用了第二次</span></span><br><span class="line"><span class="comment">// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1</span></span><br><span class="line">&gt; wm.<span class="title function_">set</span>(key, <span class="number">1</span>);</span><br><span class="line"><span class="title class_">WeakMap</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="variable language_">global</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时内存占用 heapUsed 增加到 45M 了</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">67538944</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">7376896</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">45782816</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">8945</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除变量 key 对数组的引用，</span></span><br><span class="line"><span class="comment">// 但没有手动清除 WeakMap 实例的键名对数组的引用</span></span><br><span class="line">&gt; key = <span class="literal">null</span>;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次执行垃圾回收</span></span><br><span class="line">&gt; <span class="variable language_">global</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存占用 heapUsed 变回 4M 左右，</span></span><br><span class="line"><span class="comment">// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">20639744</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">8425472</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">3979792</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">8956</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p><p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p><h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.<span class="title function_">set</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.<span class="title function_">get</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>));</span><br><span class="line">  logoData.<span class="property">timesClicked</span>++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><p>WeakMap 的另一个用处是部署私有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">    _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">    _action.<span class="title function_">set</span>(<span class="variable language_">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.<span class="title function_">get</span>(<span class="variable language_">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Countdown</span>(<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>));</span><br><span class="line"></span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p><h2 id="map-方法："><a href="#map-方法：" class="headerlink" title="map()方法："></a>map()方法：</h2><h3 id="map，映射，即原数组映射成一个新的数组；"><a href="#map，映射，即原数组映射成一个新的数组；" class="headerlink" title="map，映射，即原数组映射成一个新的数组；"></a>map，映射，即原数组映射成一个新的数组；</h3><p>map方法接受一个新参数，这个参数就是将原数组变成新数组的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myfun_1</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> array = [];</span><br><span class="line">  arr.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    array.<span class="title function_">push</span>(item*item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myfun_2</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> array = [];</span><br><span class="line">  arr.<span class="title function_">map</span>( <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">  array.<span class="title function_">push</span>(item*item);</span><br><span class="line"> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">myfun_1</span>(arr3);    <span class="comment">//[1,4,9,16,25]</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="title function_">myfun_1</span>(arr1);  <span class="comment">//[25,4,1,9,16]</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>];</span><br><span class="line"><span class="title function_">myfun_2</span>(arr2);  <span class="comment">//[9,16,25,1,4,36]</span></span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure><p>在实际的应用中，我们可以通过map方法得到某一个对象数组中特定属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;小明&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;小红&#x27;</span>,<span class="attr">age</span>:<span class="number">17</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;小白&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getter</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">age</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getter</span>(obj);</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"><span class="comment">//17</span></span><br><span class="line"><span class="comment">//18</span></span><br></pre></td></tr></table></figure><p>map方法的作用不难理解，即“映射”，也就是原数组被“映射”成对应新数组。下面这个例子是数值项求平方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item * item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">alert</span>(arrayOfSquares); <span class="comment">// 1, 4, 9, 16</span></span><br><span class="line">callback需要有<span class="keyword">return</span>值，如果没有，就像下面这样：</span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line">arrayOfSquares.<span class="title function_">forEach</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">数组所有项都被映射成了<span class="literal">undefined</span>：</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://k705.github.io/2024/04/08/Es6-13%E3%80%81Es6_Proxy_%E9%87%8D%E8%A6%81/"/>
    <id>https://k705.github.io/2024/04/08/Es6-13%E3%80%81Es6_Proxy_%E9%87%8D%E8%A6%81/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:51.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ-概述"></a>Ⅰ-概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">   <span class="comment">//拦截的对象,传入的对象属性,整个proxy对象</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.<span class="property">count</span></span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面是另一个拦截读取属性行为的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">time</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">title</span> <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">a</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">target.<span class="property">a</span> <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p><p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure><p>Proxy 实例也可以作为其他对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">obj.<span class="property">time</span> <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">fproxy.<span class="property">foo</span> === <span class="string">&quot;Hello, foo&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><h2 id="Ⅱ-Proxy-实例的方法"><a href="#Ⅱ-Proxy-实例的方法" class="headerlink" title="Ⅱ-Proxy 实例的方法"></a>Ⅱ-Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Prop name \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span> <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p><p><code>get</code>方法可以继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propertyKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET &#x27;</span> + propertyKey);</span><br><span class="line">    <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">obj.<span class="property">foo</span> <span class="comment">// &quot;GET foo&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = [];</span><br><span class="line">  target.<span class="title function_">push</span>(...elements);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title function_">createArray</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> funcStack = [];</span><br><span class="line">  <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">    get : <span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fnName === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funcStack.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">val, fn</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">fn</span>(val);</span><br><span class="line">        &#125;,value);</span><br><span class="line">      &#125;</span><br><span class="line">      funcStack.<span class="title function_">push</span>(<span class="variable language_">window</span>[fnName]);</span><br><span class="line">      <span class="keyword">return</span> oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oproxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">double</span> = n =&gt; n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">pow</span>    = n =&gt; n * n;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">reverseInt</span> = n =&gt; n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">reverseInt</span>.<span class="property">get</span>; <span class="comment">// 63</span></span><br></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(property);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(attrs)) &#123;</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">          child = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.<span class="title function_">appendChild</span>(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> el = dom.<span class="title function_">div</span>(&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, my name is &#x27;</span>,</span><br><span class="line">  dom.<span class="title function_">a</span>(&#123;<span class="attr">href</span>: <span class="string">&#x27;//example.com&#x27;</span>&#125;, <span class="string">&#x27;Mark&#x27;</span>),</span><br><span class="line">  <span class="string">&#x27;. I like:&#x27;</span>,</span><br><span class="line">  dom.<span class="title function_">ul</span>(&#123;&#125;,</span><br><span class="line">    dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;The web&#x27;</span>),</span><br><span class="line">    dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;Food&#x27;</span>),</span><br><span class="line">    dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;…actually that\&#x27;s it&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(el);</span><br></pre></td></tr></table></figure><p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">getReceiver</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">d.<span class="property">a</span> === d <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to get private &quot;_prop&quot; property</span></span><br><span class="line">proxy.<span class="property">_prop</span> = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to set private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><p>下面是<code>set</code>方法第四个参数的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, proxy);</span><br><span class="line"></span><br><span class="line">myObj.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">myObj.<span class="property">foo</span> === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p><p>注意，如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p><p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">    <span class="comment">// 无论有没有下面这一行，都会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p><p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;I am the target&#x27;</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am the proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">p</span>()</span><br><span class="line"><span class="comment">// &quot;I am the proxy&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice);</span><br><span class="line"><span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p><p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p><p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p><p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p><p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p><p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p><p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">score</span>: <span class="number">59</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">score</span>: <span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu1, handler);</span><br><span class="line"><span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy1</span><br><span class="line"><span class="comment">// 张三 不及格</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy2</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p><h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>construct()</code>方法可以接受三个参数。</p><ul><li><code>target</code>：目标对象。</li><li><code>args</code>：构造函数的参数数组。</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called: &#x27;</span> + args.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">1</span>)).<span class="property">value</span></span><br><span class="line"><span class="comment">// &quot;called: 1&quot;</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;construct&#x27; on proxy: trap returned non-object (&#x27;1&#x27;)</span></span><br></pre></td></tr></table></figure><p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: p is not a constructor</span></span><br></pre></td></tr></table></figure><p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p><p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, handler);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span> <span class="comment">// 不会生效</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p><p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;tar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;wat&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;_foo&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p><p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p><p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy) === <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(target)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;isExtensible&#x27; on proxy: trap result does not reflect extensibility of proxy target (which is &#x27;true&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for...in</code>循环</li></ul><p>下面是拦截<code>Object.keys()</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p><p>下面的例子是拦截第一个字符为下划线的属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">_bar</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">_prop</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">prop</span>: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p><ul><li>目标对象上不存在的属性</li><li>属性名为 Symbol 值</li><li>不可遍历（<code>enumerable</code>）的属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;secret&#x27;</span>)]: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;static&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;secret&#x27;</span>), <span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p><p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure><p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p><p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a valid property name</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p><p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap result did not include &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p><p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap returned extra keys but proxy target is non-extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;preventExtensions&#x27; on proxy: trap returned truish but the proxy target is extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p><p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called&#x27;</span>);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Changing the prototype is forbidden&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p><h2 id="Ⅲ-Proxy-revocable"><a href="#Ⅲ-Proxy-revocable" class="headerlink" title="Ⅲ-Proxy.revocable()"></a>Ⅲ-Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="Ⅳ-this-问题"><a href="#Ⅳ-this-问题" class="headerlink" title="Ⅳ-this 问题"></a>Ⅳ-this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">m</span>() <span class="comment">// false</span></span><br><span class="line">proxy.<span class="title function_">m</span>()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    _name.<span class="title function_">set</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jane&#x27;</span>);</span><br><span class="line">jane.<span class="property">name</span> <span class="comment">// &#x27;Jane&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2015-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;getDate&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.<span class="property">getDate</span>.<span class="title function_">bind</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + key;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// Hello, foo</span></span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p><h2 id="Ⅴ-实例：Web-服务的客户端"><a href="#Ⅴ-实例：Web-服务的客户端" class="headerlink" title="Ⅴ-实例：Web 服务的客户端"></a>Ⅴ-实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="title function_">createWebService</span>(<span class="string">&#x27;http://example.com/data&#x27;</span>);</span><br><span class="line"></span><br><span class="line">service.<span class="title function_">employees</span>().<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> employees = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseUrl</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">&#x27;/&#x27;</span> + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p><h2 id="Ⅵ-Proxy实现双向绑定"><a href="#Ⅵ-Proxy实现双向绑定" class="headerlink" title="Ⅵ-Proxy实现双向绑定"></a>Ⅵ-Proxy实现双向绑定</h2><blockquote><p><code>Proxy</code>就像一个代理器,当有人对目标对象进行处理(set、has、get 等等操作)的时候它会首先经过它，这时我们可以使用代码进行处理，此时<code>Proxy</code>相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。</p></blockquote><h3 id="1-Object-defineProperty"><a href="#1-Object-defineProperty" class="headerlink" title="1.Object.defineProperty"></a>1.<code>Object.defineProperty</code></h3><blockquote><p>众所周知，<code>vue</code>使用了<code>Object.defineProperty</code>来做数据劫持，它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get val&#x27;</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set val:&#x27;</span> + newVal)</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-与Object-defineProperty相比，Proxy的优势"><a href="#2-与Object-defineProperty相比，Proxy的优势" class="headerlink" title="2.与Object.defineProperty相比，Proxy的优势"></a>2.与<code>Object.defineProperty</code>相比，<code>Proxy</code>的优势</h3><blockquote><ol><li><p>数组作为特殊的对象，但Object.defineProperty无法监听数组变化。</p></li><li><p>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p></li><li><p>Proxy 有多达 13 种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。</p></li><li><p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</p></li><li><p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化</p></li></ol></blockquote><h3 id="3-手写双向绑定代码"><a href="#3-手写双向绑定代码" class="headerlink" title="3. 手写双向绑定代码"></a>3. 手写双向绑定代码</h3><blockquote><ol><li>简单实现双向绑定</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input_el&quot;</span> <span class="attr">oninput</span>=<span class="string">&quot;inputHandle(this)&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show_el&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  proxy_bind = <span class="function">(<span class="params">traget</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(traget, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">get</span>(<span class="params">obj, name</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果传入的key并没有,则赋初始值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (!obj[name]) obj[name] = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//根据传入的key进行相应属性返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//拦截的对象,拦截对象的值,传入要修改的值,(第四个参数通常不用,返回整个Proxy对象)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">set</span>(<span class="params">obj, name, val</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        obj[name] = val</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//将输入狂内容即修改的proxy对象属性渲染到页面节点上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  inputHandle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//将输入框的值赋值给proxy对象的value属性上，此处触发proxy的`set（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj_bind.<span class="property">value</span> = e.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>: <span class="string">&quot;2&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">b</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">value</span>: <span class="string">&quot;默认值&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj_bind = <span class="title function_">proxy_bind</span>(obj)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//自闭合，如果前面没有加分号 会导致压缩式合并到前面去就会报错，以防万一加分号，此处触发proxy的`get（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#input_el&quot;</span>).<span class="property">value</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>模拟vue实现完整双向绑定实现</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml">class Watcher &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(vm, key, callback) &#123;</span></span><br><span class="line"><span class="language-xml">    this.vm = vm</span></span><br><span class="line"><span class="language-xml">    this.callback = callback</span></span><br><span class="line"><span class="language-xml">    this.key = key // 被订阅的数据</span></span><br><span class="line"><span class="language-xml">    this.val = this.get() // 维护更新之前的数据</span></span><br><span class="line"><span class="language-xml">    vm.$data = this.createProxy(vm.$data)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  update(newVal) &#123;</span></span><br><span class="line"><span class="language-xml">    this.callback(newVal)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  get() &#123;</span></span><br><span class="line"><span class="language-xml">    const val = this.vm.$data[this.key]</span></span><br><span class="line"><span class="language-xml">    return val</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  createProxy(data) &#123;</span></span><br><span class="line"><span class="language-xml">    let _this = this</span></span><br><span class="line"><span class="language-xml">    let handler = &#123;</span></span><br><span class="line"><span class="language-xml">      get(target, property) &#123;</span></span><br><span class="line"><span class="language-xml">        return Reflect.get(target, property)</span></span><br><span class="line"><span class="language-xml">      &#125;,</span></span><br><span class="line"><span class="language-xml">      set(target, property, value) &#123;</span></span><br><span class="line"><span class="language-xml">        let res = null</span></span><br><span class="line"><span class="language-xml">        if (target[property] != value) &#123;</span></span><br><span class="line"><span class="language-xml">          const isOk = Reflect.set(target, property, value)</span></span><br><span class="line"><span class="language-xml">          if (_this.key === property) &#123;</span></span><br><span class="line"><span class="language-xml">            // 同一层级</span></span><br><span class="line"><span class="language-xml">            res = value</span></span><br><span class="line"><span class="language-xml">          &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">            res = _this.get()</span></span><br><span class="line"><span class="language-xml">            console.log(res)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          _this.callback(res)</span></span><br><span class="line"><span class="language-xml">          return isOk</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    return toDeepProxy(data, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    function toDeepProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">      if (!isPureObject(object)) addSubProxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      return new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function addSubProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">        for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">          if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">            if (!isPureObject(object[prop])) addSubProxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">            object[prop] = new Proxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        object = new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function isPureObject(object) &#123;</span></span><br><span class="line"><span class="language-xml">        if (typeof object !== &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">          return false</span></span><br><span class="line"><span class="language-xml">        &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">          for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">            if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">              return false</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        return true</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">class Vue &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(data) &#123;</span></span><br><span class="line"><span class="language-xml">    // 将所有data最外层属性代理到实例上</span></span><br><span class="line"><span class="language-xml">    this.$data = data</span></span><br><span class="line"><span class="language-xml">    Object.keys(data).forEach(key =&gt; this.$proxy(key))</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $watch(key, cb) &#123;</span></span><br><span class="line"><span class="language-xml">    new Watcher(this, key, cb)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $proxy(key) &#123;</span></span><br><span class="line"><span class="language-xml">    Reflect.defineProperty(this, key, &#123;</span></span><br><span class="line"><span class="language-xml">      configurable: true,</span></span><br><span class="line"><span class="language-xml">      enumerable: true,</span></span><br><span class="line"><span class="language-xml">      get: () =&gt; this.$data[key],</span></span><br><span class="line"><span class="language-xml">      set: val =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        this._data[key] = val</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const p = document.getElementById(&#x27;p&#x27;)</span></span><br><span class="line"><span class="language-xml">const input = document.getElementById(&#x27;input&#x27;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const data = new Vue(&#123; text: &#123; a: &#x27;&#x27; &#125; &#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">input.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span></span><br><span class="line"><span class="language-xml">  data.text.a = e.target.value</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">data.$watch(&#x27;text&#x27;, content =&gt; p.innerHTML = content.a)</span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Reflect</title>
    <link href="https://k705.github.io/2024/04/08/Es6-14%E3%80%81Es6_Reflect_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-14%E3%80%81Es6_Reflect_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:40.148Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p><p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&#x27;assign&#x27;</span> <span class="keyword">in</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;property &#x27;</span> + name + <span class="string">&#x27; on &#x27;</span> + target + <span class="string">&#x27; set to &#x27;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete&#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has&#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Reflect</code>对象一共有 13 个静态方法。</p><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p><h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;bar&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="number">1</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="literal">false</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">1</span>, myReceiverObject);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// set</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="literal">false</span>, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> myObject <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p><h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">delete</span> myObj.<span class="property">foo</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(myObj, <span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p><p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p><h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Greeting</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.construct 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Greeting</span>, [<span class="string">&#x27;张三&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p><h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> <span class="title class_">FancyThing</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">myObj.<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;), <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(youngest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">min</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">max</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>, youngest, []);</span><br></pre></td></tr></table></figure><h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*…*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p><p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, prop, descriptor</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, prop, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// &#123;value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">foo</span> <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p><h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myObject, <span class="string">&#x27;hidden&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;hidden&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;hidden&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p><h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 环境</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;baz&#x27;</span>)]: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bing&#x27;</span>)]: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(myObject)</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(myObject)</span><br><span class="line"><span class="comment">//[Symbol(baz), Symbol(bing)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(myObject)</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, Symbol(baz), Symbol(bing)]</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p><h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">observe</span>(print);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br></pre></td></tr></table></figure><p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p><p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>ES全系统详细学习笔记</title>
    <link href="https://k705.github.io/2024/04/08/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:13:14.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>本笔记是本人<code>ES全系统详细学习笔记</code>,将ES系列全部梳理一遍,包括新特性等,后续ES系列也会不间断的补充至此笔记中,主要方便本人后续查阅用,如果要专门学习,建议直接看阮一峰的ES6文档学习</p><p>观阅或查阅的资料:[<a href="https://www.bookstack.cn/read/es6-3rd/sidebar.md">阮一峰的ES6文档</a>]、[<a href="https://www.bilibili.com/video/BV1uK411H7on?share_source=copy_web">尚硅谷Web前端ES6教程, 涵盖ES6-ES11</a>]、华为云的 <a href="https://www.huaweicloud.com/articles/dcc4c743622e8a481b33b65d27990c95.html">[js高手之路] es6系列教程</a> ; [<a href="https://juejin.cn/user/2330620350432110">JowayYoung的1.5万字概括ES6全部特性(已更新ES2020)</a>]、<a href="https://daimajiaoliu.com/daima/4ed4f6a37900410">ES6系列教程第二篇–Iterator 详解</a>;W3Cschool的<a href="https://www.w3cschool.cn/escript6/">ES6 中文教程</a>;博客园的<a href="https://www.cnblogs.com/waitforyou/p/7080591.html">JavaScript ES6 Symbol.hasInstance的理解. </a>;简书的<a href="https://www.jianshu.com/p/e375ba1cfc47">JS数组reduce()方法详解及高级技巧</a></p><p>笔记中每部分都会首先给出[<code>概括总结</code>],总结概括此部分知识点,然后再于下方给出知识点详解</p><p>必要的预备前置知识点:  <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0">JavaScript基础以及进阶知识点</a> –&gt;其中 [ 进阶 ] 笔记部分需要重点掌握</p><p>除此笔记外大家可以看我其他笔记 :<strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master">全栈笔记</a><strong>、</strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a><strong>、</strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">编程_前端开发学习笔记</a><strong>、</strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">编程_后台服务端学习笔记</a></strong> 、**<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java">Java</a>** 、**<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nodejs">Nodejs</a>** 、**<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0">JavaScript笔记</a><strong>、</strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0">编程工具使用笔记</a>** 、**<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%8F%8A%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ES6及后续版本学习笔记</a>** 、**<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88">Vue笔记整合</a>** 、**<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0">React笔记</a><strong>、</strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">微信小程序学习笔记</a><strong>、</strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chrome%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Chrome开发使用及学习笔记</a>** 以及许多其他笔记就不一一例举了</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、ECMAScript引出"><a href="#一、ECMAScript引出" class="headerlink" title="一、ECMAScript引出"></a>一、ECMAScript引出</h1><blockquote><p>JS基础要会再看这个,不然容易造成基础不牢的后果,此部分<code>类似JS语法糖</code>,请相信我不会害你的</p><p>必要的预备前置知识点:  <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0">JavaScript基础以及进阶知识点</a> –&gt;其中 [ 进阶 ] 笔记部分需要重点掌握</p></blockquote><h2 id="1、什么是-ECMA和ECMAScript"><a href="#1、什么是-ECMA和ECMAScript" class="headerlink" title="1、什么是 ECMA和ECMAScript"></a>1、什么是 ECMA和ECMAScript</h2><blockquote><p><code>ECMA</code>（European Computer Manufacturers Association）中文名称为欧洲计算机制 造商协会, 这个组织的目标是评估、开发和认可电信和计算机标准. 1994 年后该 组织改名为 Ecma 国际. </p><p><code>ECMAScript</code> 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言. </p></blockquote><h2 id="2、ECMA-262"><a href="#2、ECMA-262" class="headerlink" title="2、ECMA-262"></a>2、ECMA-262</h2><blockquote><p>Ecma 国际制定了许多标准, 而 ECMA-262 只是其中的一个, 所有标准列表查看 –&gt;<a href="https://www.ecma-international.org/publications-and-standards/standards/">点我传送</a></p></blockquote><h3 id="Ⅰ-ECMA-262-历史"><a href="#Ⅰ-ECMA-262-历史" class="headerlink" title="Ⅰ-ECMA-262 历史"></a>Ⅰ-ECMA-262 历史</h3><blockquote><p>ECMA-262（ECMAScript）历史版本查看网址: –&gt;<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">点我传送</a></p><table><thead><tr><th align="center">版数</th><th align="center">年份</th><th>内容</th></tr></thead><tbody><tr><td align="center">第 1 版</td><td align="center">1997 年</td><td>制定了语言的基本语法</td></tr><tr><td align="center">第 2 版</td><td align="center">1998 年</td><td>较小改动</td></tr><tr><td align="center">第 3 版</td><td align="center">1999 年</td><td>引入正则、异常处理、格式化输出等. IE 开始支持</td></tr><tr><td align="center">第 4 版</td><td align="center">2007 年</td><td>过于激进, 未发布</td></tr><tr><td align="center">第 5 版</td><td align="center">2009 年</td><td>引入严格模式、JSON , 扩展对象、数组、原型、字符串、日期方法</td></tr><tr><td align="center"><code>第 6 版</code></td><td align="center"><code>2015 年</code></td><td>模块化、面向对象语法、 Promise、箭头函数、let、 const、数组解构赋值等等<br />因为发布内容很多,堪称里程碑,所以我们目前通常主要学这个</td></tr><tr><td align="center">第 7 版</td><td align="center">2016 年</td><td>幂运算符、数组扩展、 Async&#x2F;await 关键字</td></tr><tr><td align="center">第 8 版</td><td align="center">2017 年</td><td>Async&#x2F;await、字符串扩展</td></tr><tr><td align="center">第 9 版</td><td align="center">2018 年</td><td>对象解构赋值、正则扩展</td></tr><tr><td align="center">第 10 版</td><td align="center">2019 年</td><td>扩展对象、数组方法</td></tr><tr><td align="center">ES.next</td><td align="center">动态指向下一个版本</td><td><code>后续学到我会进行补充</code></td></tr></tbody></table><p><code>注: 从 ES6 开始, 每年发布一个版本, 版本号比年份最后一位大 1</code></p><p>所以有些文章上提到的<code>ES7</code>(实质上是<code>ES2016</code>)、<code>ES8</code>(实质上是<code>ES2017</code>)、<code>ES9</code>(实质上是<code>ES2018</code>)、<code>ES10</code>(实质上是<code>ES2019</code>)、<code>ES11</code>(实质上是<code>ES2020</code>), 实质上都是一些不规范的概念. 从ES1到ES6 , 每个标准都是花了好几年甚至十多年才制定下来, 你一个ES6到ES7 , ES7到ES8 , 才用了一年, 按照这样的定义下去, 那不是很快就ES20了. 用正确的概念来说ES6目前涵盖了<strong>ES2015</strong>、<strong>ES2016</strong>、<strong>ES2017</strong>、<strong>ES2018</strong>、<strong>ES2019</strong>、<strong>ES2020</strong>. </p></blockquote><h3 id="Ⅱ-谁在维护-ECMA-262"><a href="#Ⅱ-谁在维护-ECMA-262" class="headerlink" title="Ⅱ-谁在维护 ECMA-262"></a>Ⅱ-谁在维护 ECMA-262</h3><blockquote><p>TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会. 其会员都是公司（<code>其中主要是浏览器厂商</code>:有苹果、谷歌、微软、因特尔等）. TC39 定期 召开会议, 会议由会员公司的代表与特邀专家出席</p></blockquote><h2 id="3、为什么要重点学习-ES6"><a href="#3、为什么要重点学习-ES6" class="headerlink" title="3、为什么要重点学习 ES6"></a>3、为什么要重点学习 ES6</h2><blockquote><ul><li>ES6 的版本变动内容最多, 具有里程碑意义</li><li>ES6 加入许多新的语法特性, 编程实现更简单、高效</li><li>ES6 是前端发展趋势, 就业必备技能</li><li>实际上ES系列的知识点基本上都要掌握(我们常说的ES6,实际上大多也泛指所有ES系列知识点),才能写出逼格更高的代码:dog:</li></ul></blockquote><h2 id="4、ES6-兼容性"><a href="#4、ES6-兼容性" class="headerlink" title="4、ES6 兼容性"></a>4、ES6 兼容性</h2><blockquote><p>可以查看gitHub上的这个图–&gt;<a href="http://kangax.github.io/compat-table/es6/">点我传送</a></p></blockquote><h1 id="二、ECMASript-系列-新特性"><a href="#二、ECMASript-系列-新特性" class="headerlink" title="二、ECMASript 系列 新特性"></a>二、ECMASript 系列 新特性</h1><blockquote><p>想要查看更权威的官方ES6文档,可以看 <a href="https://www.bookstack.cn/books/es6-3rd">阮一峰 ECMAScript 6 (ES6) 标准入门教程</a></p><p>此部分将记录由 <strong>ES6提出以及后续补充的</strong> ,但不仅限于 ES6新增内容, 比如 <strong>Promise</strong>是ES6提出的,但是例如<code>Promise.allSettled()</code> 该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入,我仍然会收录在此部分笔记而不是记录在<strong>ES11</strong>新特性中</p></blockquote><h2 id="1、ES6更新的内容概括"><a href="#1、ES6更新的内容概括" class="headerlink" title="1、ES6更新的内容概括"></a>1、ES6更新的内容概括</h2><blockquote><p><strong>表达式</strong>: 声明、解构赋值</p><p><strong>内置对象</strong>: 字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect</p><p><strong>语句与运算</strong>: Class、Module、Iterator</p><p><strong>异步编程</strong>: Promise、Generator、Async</p></blockquote><h2 id="2、let和const命令、作用域"><a href="#2、let和const命令、作用域" class="headerlink" title="2、let和const命令、作用域"></a>2、let和const命令、作用域</h2><blockquote><p>注意:<code>不存在变量提升</code></p><p><code>var</code>命令会发生“变量提升”现象, 即变量可以在声明之前使用, 值为 <strong>undefined</strong> . 这种现象多多少少是有些奇怪的, 按照一般的逻辑, 变量应该在声明语句之后才可以使用. </p><p>为了纠正这种现象, <code>let</code>、<code>const</code>命令改变了语法行为, 它所声明的变量一定要在声明后使用, 否则报错</p></blockquote><h3 id="Ⅰ-概括与总结"><a href="#Ⅰ-概括与总结" class="headerlink" title="Ⅰ-概括与总结"></a>Ⅰ-概括与总结</h3><blockquote><blockquote><p>声明</p></blockquote><ul><li><strong>const命令</strong>: 声明常量</li><li><strong>let命令</strong>: 声明变量</li></ul><blockquote><p>作用</p></blockquote><ol><li>作用域</li></ol><ul><li><strong>全局作用域</strong></li><li><strong>函数作用域</strong>: <code>function() &#123;&#125;</code></li><li><strong>块级作用域</strong>: <code>&#123;&#125;</code></li></ul><ol start="2"><li>作用范围</li></ol><ul><li><code>var命令</code>在全局代码中执行</li><li><code>const命令</code>和<code>let命令</code>只能在代码块中执行</li></ul><ol start="3"><li>赋值使用</li></ol><ul><li><code>const命令</code>声明常量后必须立马赋值</li><li><code>let命令</code>声明变量后可立马赋值或使用时赋值</li></ul><ol start="4"><li>声明方法: <code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></li></ol><blockquote><p>重点难点</p></blockquote><ul><li>不允许重复声明</li><li>未定义就使用会报错: <code>const命令</code>和<code>let命令</code>不存在变量提升</li><li>暂时性死区: 在代码块内使用<code>const命令</code>和<code>let命令</code>声明变量之前, 该变量都不可用</li></ul><p>下一节为赋值解构的概括总结  –&gt;<a href="#3%E3%80%81%E8%B5%8B%E5%80%BC%E8%A7%A3%E6%9E%84">点我传送</a></p></blockquote><h3 id="Ⅱ-let关键字命令"><a href="#Ⅱ-let关键字命令" class="headerlink" title="Ⅱ-let关键字命令"></a>Ⅱ-let关键字命令</h3><blockquote><p>let 关键字用来声明变量, 使用 let 声明的变量有几个特点:  </p><ul><li>不允许重复声明 </li><li>块级作用域 </li><li>不存在变量提升 </li><li>不影响作用域链</li></ul><p>应用场景: 声明重复赋值的变量时可以用这个,如果你不是要求很高的话,基本上都能用let进行声明(var声明的可以都用这个替代了)</p></blockquote><h3 id="Ⅲ-const关键字命令"><a href="#Ⅲ-const关键字命令" class="headerlink" title="Ⅲ-const关键字命令"></a>Ⅲ-const关键字命令</h3><blockquote><p>const 关键字用来声明常量 , const 声明有以下特点:</p><ul><li>不允许重复声明 </li><li><code>值不允许修改</code></li><li>不存在变量提升 </li><li>块级作用域 </li><li>声明必须赋初始值</li><li>标识符一般为大写</li></ul><p>注意: <code>对象属性修改和数组元素变化不会触发 const 错误</code> </p><blockquote><p><code>const</code>实际上保证的, <code>并不是变量的值不得改动, 而是变量指向的那个内存地址所保存的数据不得改动</code>. </p><p>对于简单类型的数据（数值、字符串、布尔值）, 值就保存在变量指向的那个内存地址, 因此等同于常量. 但对于复合类型的数据（主要是对象和数组）, 变量指向的内存地址, 保存的只是一个指向实际数据的指针, <code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址）, 至于它指向的数据结构是不是可变的, 就完全不能控制了. 因此, 将一个对象声明为常量必须非常小心. </p></blockquote><p>应用场景: 声明对象类型、确定不会再次赋值的变量使用 const , 其他的可以用let</p></blockquote><h3 id="Ⅳ-ES6-声明变量的六种方法"><a href="#Ⅳ-ES6-声明变量的六种方法" class="headerlink" title="Ⅳ-ES6 声明变量的六种方法"></a>Ⅳ-ES6 声明变量的六种方法</h3><blockquote><p>ES5 只有两种声明变量的方法: <code>var</code>命令和<code>function</code>命令. ES6 除了添加<code>let</code>和<code>const</code>命令, 后面还会提到, 另外两种声明变量的方法: <code>import</code>命令和<code>class</code>命令. 所以 , ES6 一共有 6 种声明变量的方法. </p></blockquote><h3 id="Ⅴ-块级作用域"><a href="#Ⅴ-块级作用域" class="headerlink" title="Ⅴ-块级作用域"></a>Ⅴ-块级作用域</h3><h4 id="①-为什么需要块级作用域？"><a href="#①-为什么需要块级作用域？" class="headerlink" title="① 为什么需要块级作用域？"></a>① 为什么需要块级作用域？</h4><blockquote><p>ES5 只有全局作用域和函数作用域, 没有块级作用域, 这带来很多不合理的场景. </p><p>第一种场景, 内层变量可能会覆盖外层变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">var</span> tmp = <span class="string">&#x27;努力学习的汪&#x27;</span>; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/*********** 上面写法实际上等于这样 **********************/</span></span><br><span class="line">&gt;<span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> tmp = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tmp); <span class="comment">//所以这里打印是undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;  tmp = <span class="string">&#x27;努力学习的汪&#x27;</span>; &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码的原意是, <code>if</code>代码块的外部使用外层的<code>tmp</code>变量, 内部使用内层的<code>tmp</code>变量. 但是, 函数 [ <code>f</code> ] 执行后, 输出结果为 <strong>undefined</strong> , 原因在于变量提升, 导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量. </p><p>第二种场景, 用来计数的循环变量泄露为全局变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(s[i]);&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>i</code>只用来控制循环, 但是循环结束后, 它并没有消失, 泄露成了全局变量. </p></blockquote><h4 id="②-ES6-的块级作用域"><a href="#②-ES6-的块级作用域" class="headerlink" title="② ES6 的块级作用域"></a>② ES6 的块级作用域</h4><blockquote><p><code>let</code>实际上为 JavaScript 新增了块级作用域. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="keyword">let</span> n = <span class="number">10</span>; &#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 5</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的函数有两个代码块, 都声明了变量<code>n</code>, 运行后输出 5. 这表示外层代码块不受内层代码块的影响. 如果两次都使用<code>var</code>定义变量<code>n</code>, 最后输出的值才是 10. </p><p>ES6 允许块级作用域的任意嵌套. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;&#123;&#123;&#123;</span><br><span class="line"> &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(insane); <span class="comment">// 报错 因为外层不能取到内层数据</span></span><br><span class="line">&gt;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域, 每一层都是一个单独的作用域. <code>第四层作用域无法读取第五层作用域的内部变量</code>. </p><p>内层作用域可以定义外层作用域的同名变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;&#123;&#123;&#123;</span><br><span class="line"> <span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"> &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125; <span class="comment">//可以这样命名,不会报错</span></span><br><span class="line">&gt;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>块级作用域的出现, 实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了. –&gt;<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">对于IIFE不懂的可以看本人JS进阶笔记,点我跳转</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// IIFE 写法</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> tmp ;</span><br><span class="line">      ...</span><br><span class="line">&gt;&#125;());</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 块级作用域写法</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">let</span> tmp ;</span><br><span class="line">      ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-块级作用域与函数声明"><a href="#③-块级作用域与函数声明" class="headerlink" title="③ 块级作用域与函数声明"></a>③ 块级作用域与函数声明</h4><blockquote><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题. </p><p>ES5 规定, 函数只能在顶层作用域和函数作用域之中声明, 不能在块级作用域声明. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 情况一</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况二</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面两种函数声明, 根据 ES5 的规定都是非法的. </p><p>但是, 浏览器没有遵守这个规定, 为了兼容以前的旧代码, 还是支持在块级作用域之中声明函数, 因此上面两种情况实际都能运行, 不会报错. </p><p>ES6 引入了块级作用域, 明确允许在块级作用域之中声明函数. ES6 规定, 块级作用域之中, 函数声明语句的行为类似于<code>let</code>, 在块级作用域之外不可引用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125;&#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br></pre></td></tr></table></figure><p>上面代码在 ES5 中运行, 会得到“**我在里面!**”, 因为在<code>if</code>内声明的函数 [ f ] 会被提升到函数头部, 实际运行的代码如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 环境</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br></pre></td></tr></table></figure><p>ES6 就完全不一样了, 理论上会得到“**我在外面!**”. 因为块级作用域内声明的函数类似于<code>let</code>, 对作用域之外没有影响. 但是, 如果你真的在 ES6 浏览器中运行一下上面的代码, 是会报错的, 这是为什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125; &#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面的代码在 ES6 浏览器中, 都会报错. </p><p>原来, 如果改变了块级作用域内声明的函数的处理规则, 显然会对老代码产生很大影响. 为了减轻因此产生的不兼容问题 , ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定, 浏览器的实现可以不遵守上面的规定, 有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>. </p><ul><li>允许在块级作用域内声明函数. </li><li>函数声明类似于<code>var</code>, 即会提升到全局作用域或函数作用域的头部. </li><li>同时, 函数声明还会提升到所在的块级作用域的头部.</li></ul><p>注意, 上面三条规则只对 ES6 的浏览器实现有效, 其他环境的实现不用遵守, 还是将块级作用域的函数声明当作<code>let</code>处理. </p><p>根据这三条规则, 浏览器的 ES6 环境中, 块级作用域内声明的函数, 行为类似于<code>var</code>声明的变量. 上面的栗子实际运行的代码如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在外面!&#x27;</span>); &#125;</span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我在里面!&#x27;</span>); &#125;&#125;</span><br><span class="line"> <span class="title function_">f</span>();</span><br><span class="line">&gt;&#125;());</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大, 应该避免在块级作用域内声明函数. 如果确实需要, 也应该写成函数表达式, 而不是函数声明语句. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 块级作用域内部的函数声明语句, 建议不要使用</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> a; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 块级作用域内部, 优先使用函数表达式</span></span><br><span class="line">&gt;&#123;</span><br><span class="line"> <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line"> <span class="keyword">let</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>另外, 还有一个需要注意的地方. ES6 的块级作用域必须有大括号, 如果没有大括号 , JavaScript 引擎就认为不存在块级作用域. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 第一种写法, 报错</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第二种写法, 不报错</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 第一种写法没有大括号, 所以不存在块级作用域, 而<code>let</code>只能出现在当前作用域的顶层, 所以报错. 第二种写法有大括号, 所以块级作用域成立. </p><p>函数声明也是如此, 严格模式下, 函数只能声明在当前作用域的顶层. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 不报错</span></span><br><span class="line">&gt;<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、赋值解构"><a href="#3、赋值解构" class="headerlink" title="3、赋值解构"></a>3、赋值解构</h2><blockquote><p>ES6 允许按照一定模式, <code>从数组和对象中提取值, 对变量进行赋值</code>, 这被称为解构（Destructuring）. </p><p>本质上, 这种写法属于“<code>模式匹配</code>”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值</p></blockquote><h3 id="Ⅰ-概括总结"><a href="#Ⅰ-概括总结" class="headerlink" title="Ⅰ-概括总结"></a>Ⅰ-概括总结</h3><blockquote><ol><li><strong>字符串解构</strong>: <code>const [a, b, c, d, e] = &quot;hello&quot;</code></li><li><strong>数值解构</strong>: <code>const &#123; toString: s &#125; = 123</code></li><li><strong>布尔解构</strong>: <code>const &#123; toString: b &#125; = true</code></li><li><strong>对象解构</strong></li></ol><ul><li>形式: <code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li><li>默认: <code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li><li>改名: <code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li></ul><ol start="5"><li><strong>数组解构</strong></li></ol><ul><li>规则: 数据结构具有<code>Iterator接口</code>可采用数组形式的解构赋值</li><li>形式: <code>const [x, y] = [1, 2]</code></li><li>默认: <code>const [x, y = 2] = [1]</code></li></ul><ol start="6"><li><strong>函数参数解构</strong></li></ol><ul><li>数组解构: <code>function Func([x = 0, y = 1]) &#123;&#125;</code></li><li>对象解构: <code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li></ul><blockquote><p><code>应用场景</code> </p></blockquote><ul><li>交换变量值: <code>[x, y] = [y, x]</code></li><li>返回函数多个值: <code>const [x, y, z] = Func()</code></li><li>定义函数参数: <code>Func([1, 2])</code></li><li>提取JSON数据: <code>const &#123; name, version &#125; = packageJson</code></li><li>定义函数参数默认值: <code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>遍历Map结构: <code>for (let [k, v] of Map) &#123;&#125;</code></li><li>输入模块指定属性和方法: <code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li></ul><blockquote><p> ** <code>重点难点</code> **</p></blockquote><ul><li>匹配模式: 只要等号两边的模式相同, 左边的变量就会被赋予对应的值</li><li>解构赋值规则: 只要等号右边的值不是对象或数组, 就先将其转为对象</li><li>解构默认值生效条件: 属性值严格等于 <strong>undefined</strong> </li><li>解构遵循匹配模式</li><li>解构不成功时变量的值等于 <strong>undefined</strong> </li><li><strong>undefined</strong> 和 <strong>null</strong> 无法转为对象, 因此无法进行解构</li></ul><p>下一节为字符串的拓展概括  –&gt;<a href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%93%E5%B1%95">点我传送</a></p></blockquote><h3 id="Ⅱ-基本用法"><a href="#Ⅱ-基本用法" class="headerlink" title="Ⅱ-基本用法"></a>Ⅱ-基本用法</h3><h4 id="①-基本用法举例"><a href="#①-基本用法举例" class="headerlink" title="① 基本用法举例"></a>① 基本用法举例</h4><blockquote><p>以前, 为变量赋值, 只能直接指定值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>ES6 允许写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>上面代码表示, 可以从数组中提取值, 按照对应位置, 对变量赋值. </p><p>本质上, 这种写法属于“模式匹配”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值. 下面是一些使用嵌套数组进行解构的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];<span class="comment">//foo : 1 bar : 2 baz : 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];<span class="comment">//third : &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//x : 1 y : 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="comment">//head : 1 tail : [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];<span class="comment">//x : &quot;a&quot; y : undefined z : []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功, 变量的值就等于 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [foo] = [];</span><br><span class="line">&gt;<span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>以上两种情况都属于解构不成功, <code>foo</code>的值都会等于 <strong>undefined</strong> . </p><p>另一种情况是不完全解构, 即等号左边的模式, 只匹配一部分的等号右边的数组. 这种情况下, 解构依然可以成功. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//x : 1  y : 2 </span></span><br><span class="line">&gt;<span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];<span class="comment">//a : 1 b : 2 d : 4</span></span><br></pre></td></tr></table></figure><p>上面两个栗子, 都属于不完全解构, 但是可以成功. </p><p>如果等号的右边不是数组（或者严格地说, 不是可遍历的结构, 参见《Iterator》一章）, 那么将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="title class_">NaN</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面的语句都会报错, 因为等号右边的值, 要么转为对象以后不具备 Iterator 接口（前五个表达式）, 要么本身就不具备 Iterator 接口（最后一个表达式）. </p><p><code>对于 Set 结构, 也可以使用数组的解构赋值</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">&gt;x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>事实上, 只要某种数据结构具有 Iterator 接口, 都可以采用数组形式的解构赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">fibs</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">yield</span> a;</span><br><span class="line">   [a, b] = [b, a + b];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = <span class="title function_">fibs</span>();</span><br><span class="line">&gt;sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>fibs</code>是一个 Generator 函数（详见《Generator 函数》）, 原生具有 Iterator 接口. 解构赋值会依次从这个接口获取值. </p></blockquote><h4 id="②-默认值"><a href="#②-默认值" class="headerlink" title="② 默认值"></a>② 默认值</h4><blockquote><p>解构赋值允许指定默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];<span class="comment">//foo = true</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>注意 , ES6 内部使用严格相等运算符（<code>===</code>）, 判断一个位置是否有值. 所以, 只有当一个数组成员严格等于 <strong>undefined</strong> , 默认值才会生效. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">//x = 1</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];<span class="comment">//x = null</span></span><br></pre></td></tr></table></figure><p>上面代码中, 如果一个数组成员是 <strong>null</strong> , 默认值就不会生效, 因为 <strong>null</strong> 不严格等于 <strong>undefined</strong> . </p><p>如果默认值是一个表达式, 那么这个表达式是惰性求值的, 即只有在用到的时候, 才会求值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaa&#x27;</span>);&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="title function_">f</span>()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>上面代码中, 因为<code>x</code>能取到值, 所以函数 [ f ] 根本不会执行. 上面的代码其实等价于下面的代码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x;</span><br><span class="line">&gt;<span class="keyword">if</span> ([<span class="number">1</span>] === <span class="literal">undefined</span>) &#123; x = <span class="title function_">f</span>()&#125; </span><br><span class="line">&gt;<span class="keyword">else</span> &#123; x = [<span class="number">1</span>]; &#125;</span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量, 但该变量必须已经声明. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line">&gt;<span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure><p>上面最后一个表达式之所以会报错, 是因为<code>x</code>用<code>y</code>做默认值时, <code>y</code>还没有声明. </p></blockquote><h4 id="③-ES6小知识点-连续赋值解构-重命名"><a href="#③-ES6小知识点-连续赋值解构-重命名" class="headerlink" title="③ ES6小知识点:连续赋值解构+重命名"></a>③ ES6小知识点:<code>连续赋值解构</code>+重命名</h4><blockquote><p>此写法也是本人常用写法,挺好用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> &#123;a&#125; = obj; <span class="comment">//传统解构赋值</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;b&#125;&#125; = obj; <span class="comment">//连续解构赋值</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123;<span class="attr">a</span>:&#123;<span class="attr">b</span>:value&#125;&#125; = obj; <span class="comment">//连续解构赋值+重命名</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-对象的赋值解构"><a href="#Ⅲ-对象的赋值解构" class="headerlink" title="Ⅲ-对象的赋值解构"></a>Ⅲ-对象的赋值解构</h3><blockquote><p><code>此处应用的非常多</code>,需要多查阅</p></blockquote><h4 id="①-基本用法"><a href="#①-基本用法" class="headerlink" title="① 基本用法"></a>① 基本用法</h4><blockquote><p>解构不仅可以用于数组, 还可以用于对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//foo = &quot;aaa&quot;; bar = &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure><p>对象的解构与数组有一个重要的不同. <code>数组的元素是按次序排列的, 变量的取值由它的位置决定；而对象的属性没有次序, 变量必须与属性同名, 才能取到正确的值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//foo = &quot;aaa&quot; ; bar = &quot;bbb&quot;</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//baz = undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的第一个栗子, 等号左边的两个变量的次序, 与等号右边两个同名属性的次序不一致, 但是对取值完全没有影响. 第二个栗子的变量没有对应的同名属性, 导致取不到值, 最后等于 <strong>undefined</strong> . </p><p>如果解构失败, 变量的值等于 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;<span class="comment">//foo = undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 等号右边的对象没有<code>foo</code>属性, 所以变量<code>foo</code>取不到值, 所以等于 <strong>undefined</strong> . </p><p>对象的解构赋值, 可以很方便地将现有对象的方法, 赋值到某个变量. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="title class_">Math</span>;</span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123; log &#125; = <span class="variable language_">console</span>;</span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>上面代码的例一将<code>Math</code>对象的对数、正弦、余弦三个方法, 赋值到对应的变量上, 使用起来就会方便很多. 例二将<code>console.log</code>赋值到<code>log</code>变量. </p><p>如果变量名与属性名不一致, 必须写成下面这样–&gt;<code>取别名</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;<span class="comment">//baz = &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;<span class="comment">//f = &#x27;hello&#x27; ; l = &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>这实际上说明, 对象的解构赋值是下面形式的简写（详见《对象的扩展》）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说, 对象的解构赋值的内部机制, 是先找到同名属性, 然后再赋给对应的变量. 真正被赋值的是后者, 而不是前者. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="comment">//baz = &quot;aaa&quot;;</span></span><br><span class="line">&gt;<span class="comment">//foo = error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>foo</code>是匹配的模式, <code>baz</code>才是变量. 真正被赋值的是变量<code>baz</code>, 而不是模式<code>foo</code>. </p><p>与数组一样, 解构也可以用于嵌套结构的对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="attr">p</span>: [<span class="string">&#x27;Hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;]</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">&gt;<span class="comment">//x == &quot;Hello&quot;</span></span><br><span class="line">&gt;<span class="comment">//y == &quot;World&quot;</span></span><br></pre></td></tr></table></figure><p>注意, 这时<code>p</code>是模式, 不是变量, 因此不会被赋值. 如果<code>p</code>也要作为变量赋值, 可以写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="attr">p</span>: [ <span class="string">&#x27;Hello&#x27;</span>, &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;]</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">&gt;<span class="comment">//x == &quot;Hello&quot;</span></span><br><span class="line">&gt;<span class="comment">//y == &quot;World&quot;</span></span><br><span class="line">&gt;<span class="comment">//p == [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br></pre></td></tr></table></figure><p>下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> node = &#123;</span><br><span class="line"> <span class="attr">loc</span>: &#123; </span><br><span class="line">     <span class="attr">start</span>: &#123; <span class="attr">line</span>: <span class="number">1</span>, <span class="attr">column</span>: <span class="number">5</span> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">&gt;<span class="comment">//line == 1</span></span><br><span class="line">&gt;<span class="comment">//loc  == Object &#123;start: Object&#125;</span></span><br><span class="line">&gt;<span class="comment">//start == Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码有三次解构赋值, 分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值. 注意, 最后一次对<code>line</code>属性的解构赋值之中, 只有<code>line</code>是变量, <code>loc</code>和<code>start</code>都是模式, 不是变量. </p><p>下面是嵌套赋值的栗子. –&gt;<code>注意:外部包着一层()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [];</span><br><span class="line">&gt;(&#123; <span class="attr">foo</span>: obj.<span class="property">prop</span>, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&gt;<span class="comment">//因为 JavaScript 引擎会将`&#123;x&#125;`理解成一个代码块, 从而发生语法错误. `只有不将大括号写在行首`, 避免 JavaScript 将其解释为代码块, 才能解决这个问题. </span></span><br><span class="line">&gt;<span class="comment">//obj == &#123;prop:123&#125;</span></span><br><span class="line">&gt;<span class="comment">//arr == [true]</span></span><br></pre></td></tr></table></figure><p>如果解构模式是嵌套的对象, 而且子对象所在的父属性不存在, 那么将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, 等号左边对象的<code>foo</code>属性, 对应一个子对象. 该子对象的<code>bar</code>属性, 解构时会报错. 原因很简单, 因为<code>foo</code>这时等于 <strong>undefined</strong> , 再取子属性就会报错. </p><p>注意, 对象的解构赋值可以取到继承的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj1, obj2);<span class="comment">//Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  null</span></span><br><span class="line">&gt;<span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">&gt;foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>obj1</code>的原型对象是<code>obj2</code>. <code>foo</code>属性不是<code>obj1</code>自身的属性, 而是继承自<code>obj2</code>的属性, 解构赋值可以取到这个属性. </p><p>注:<code>Object.setPrototypeOf()</code>详解,不知道此方法的同学们看这里 –&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">点我传送</a></p></blockquote><h4 id="②-默认值-1"><a href="#②-默认值-1" class="headerlink" title="② 默认值"></a>② 默认值</h4><blockquote><p>对象的解构也可以指定默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;<span class="comment">//x == 3</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="comment">//x == 1</span></span><br><span class="line">&gt;<span class="comment">//y == 5</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;<span class="comment">//y == 3</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;<span class="comment">//y == 5</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;<span class="comment">//msg == &quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure><p>默认值生效的条件是, 对象的属性值严格等于 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;<span class="comment">//x == 3</span></span><br><span class="line">&gt;<span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;<span class="comment">//x == null</span></span><br></pre></td></tr></table></figure><p>上面代码中, 属性<code>x</code>等于 <strong>null</strong> , 因为 <strong>null</strong> 与 <strong>undefined</strong> 不严格相等, 所以是个有效的赋值, 导致默认值<code>3</code>不会生效. –&gt;[原因上面讲过](#② 默认值)</p></blockquote><h4 id="③-注意点"><a href="#③-注意点" class="headerlink" title="③ 注意点"></a>③ 注意点</h4><blockquote><p>（1）如果要将一个已经声明的变量用于解构赋值, 必须非常小心. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 错误的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> x;</span><br><span class="line">&gt;&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面代码的写法会报错, 因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个代码块, 从而发生语法错误. <code>只有不将大括号写在行首</code>, 避免 JavaScript 将其解释为代码块, 才能解决这个问题. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正确的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> x;</span><br><span class="line">&gt;(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>上面代码将整个解构赋值语句, <code>放在一个圆括号里面, 就可以正确执行</code>. 关于圆括号与解构赋值的关系, 参见下文. </p><p>（2）解构赋值允许等号左边的模式之中, 不放置任何变量名. 因此, 可以写出非常古怪的赋值表达式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">&gt;(&#123;&#125; = <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">&gt;(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>上面的表达式虽然毫无意义, 但是语法是合法的, 可以执行. </p><p>（3）<code>由于数组本质是特殊的对象, 因此可以对数组进行对象属性的解构</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.<span class="property">length</span> - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">&gt;<span class="comment">//first == 1</span></span><br><span class="line">&gt;<span class="comment">//last == 3</span></span><br></pre></td></tr></table></figure><p>上面代码对数组进行对象解构. 数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>, <code>[arr.length - 1]</code>就是<code>2</code>键, 对应的值是<code>3</code>. 方括号这种写法, 属于“属性名表达式”（详见《对象的扩展》）. </p></blockquote><h3 id="Ⅳ-字符串的赋值结构"><a href="#Ⅳ-字符串的赋值结构" class="headerlink" title="Ⅳ-字符串的赋值结构"></a>Ⅳ-字符串的赋值结构</h3><blockquote><p>字符串也可以解构赋值. 这是因为此时, 字符串被转换成了一个类似数组的对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">//a == &quot;h&quot; ;b  == &quot;e&quot; ; c == &quot;l&quot; ; d == &quot;l&quot; ;e == &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个<code>length</code>属性, 因此还可以对这个属性解构赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;length : len&#125; = <span class="string">&#x27;hello&#x27;</span>;<span class="comment">//len == 5</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-数值和布尔值的解构赋值"><a href="#Ⅴ-数值和布尔值的解构赋值" class="headerlink" title="Ⅴ-数值和布尔值的解构赋值"></a>Ⅴ-数值和布尔值的解构赋值</h3><blockquote><p>解构赋值时, 如果等号右边是数值和布尔值, 则会先转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">&gt;s === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">&gt;s === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 数值和布尔值的包装对象都有<code>toString</code>属性, 因此变量<code>s</code>都能取到值. </p><p>解构赋值的规则是, 只要等号右边的值不是对象或数组, 就先将其转为对象. 由于 <strong>undefined</strong> 和 <strong>null</strong> 无法转为对象, 所以对它们进行解构赋值, 都会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅵ-函数参数的解构赋值"><a href="#Ⅵ-函数参数的解构赋值" class="headerlink" title="Ⅵ-函数参数的解构赋值"></a>Ⅵ-函数参数的解构赋值</h3><blockquote><p>函数的参数也可以使用解构赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">[x, y]</span>)&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&gt;<span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>add</code>的参数表面上是一个数组, 但在传入参数的那一刻, 数组参数就被解构成变量<code>x</code>和<code>y</code>. 对于函数内部的代码来说, 它们能感受到的参数就是<code>x</code>和<code>y</code>. </p><p>下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">map</span>(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line">&gt;<span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123;  <span class="keyword">return</span> [x, y];&#125;</span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>move</code>的参数是一个对象, 通过对这个对象进行解构, 得到变量<code>x</code>和<code>y</code>的值. 如果解构失败, <code>x</code>和<code>y</code>等于默认值. </p><p>注意, 下面的写法会得到不一样的结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> [x, y];</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">&gt;<span class="title function_">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><p>上面代码是为函数<code>move</code>的参数指定默认值, 而不是为变量<code>x</code>和<code>y</code>指定默认值, 所以会得到与前一种写法不同的结果. </p><p><strong>undefined</strong> 就会触发函数参数的默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line">&gt;<span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅶ-数组的赋值解构"><a href="#Ⅶ-数组的赋值解构" class="headerlink" title="Ⅶ-数组的赋值解构"></a>Ⅶ-数组的赋值解构</h3><blockquote><p>可以实现<code>一行代码实现两个变量的互换</code>  –&gt;<code>[x,y]=[y,x]</code></p><p>下面举一个冒泡排序的栗子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">bSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> len = arr.<span class="property">length</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 相邻元素两两对比，元素交换，大的元素交换到后面</span></span><br><span class="line">       <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">           [arr[j],arr[j+<span class="number">1</span>]]=[arr[j+<span class="number">1</span>],arr[j]]</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//举个数组</span></span><br><span class="line">&gt;myArr = [<span class="number">20</span>,<span class="number">18</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">35</span>];</span><br><span class="line">&gt;<span class="comment">//使用函数</span></span><br><span class="line">&gt;<span class="title function_">bSort</span>(myArr)</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅷ-圆括号问题"><a href="#Ⅷ-圆括号问题" class="headerlink" title="Ⅷ-圆括号问题"></a>Ⅷ-圆括号问题</h3><blockquote><p>解构赋值虽然很方便, 但是解析起来并不容易. 对于编译器来说, <code>一个式子到底是模式, 还是表达式</code>, 没有办法从一开始就知道, 必须解析到（或解析不到）等号才能知道. </p><p>由此带来的问题是, 如果模式中出现圆括号怎么处理. ES6 的规则是, 只要有可能导致解构的歧义, 就不得使用圆括号. </p><p>但是, 这条规则实际上不那么容易辨别, 处理起来相当麻烦. 因此, 建议只要有可能, 就不要在模式中放置圆括号. </p></blockquote><h4 id="①-不能使用圆括号的情况"><a href="#①-不能使用圆括号的情况" class="headerlink" title="① 不能使用圆括号的情况"></a>① 不能使用圆括号的情况</h4><blockquote><p>以下三种解构赋值不得使用圆括号. </p><p>（1）<code>变量声明</code>语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 全部报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;(<span class="attr">x</span>: c)&#125; = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>上面 6 个语句都会报错, <code>因为它们都是变量声明语句</code>, 模式不能使用圆括号. </p><p>（2）函数参数</p><p>函数参数也属于变量声明, 因此不能带有圆括号. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[(z)]</span>) &#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[z,(x)]</span>) &#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>（3）赋值语句的模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 全部报错</span></span><br><span class="line">&gt;(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>上面代码将整个模式放在圆括号之中, 导致报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><p>上面代码将一部分模式放在圆括号之中, 导致报错. </p></blockquote><h4 id="②-可以使用圆括号的情况"><a href="#②-可以使用圆括号的情况" class="headerlink" title="② 可以使用圆括号的情况"></a>② 可以使用圆括号的情况</h4><blockquote><p>可以使用圆括号的情况只有一种: 赋值语句的非模式部分, 可以使用圆括号. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">&gt;(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">&gt;[(<span class="built_in">parseInt</span>.<span class="property">prop</span>)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>上面三行语句都可以正确执行, 因为<code>首先它们都是赋值语句, 而不是声明语句</code>；其次它们的圆括号都不属于模式的一部分. 第一行语句中, 模式是取数组的第一个成员, 跟圆括号无关；第二行语句中, 模式是<code>p</code>, 而不是<code>d</code>；第三行语句与第一行语句的性质一致. </p></blockquote><h3 id="Ⅸ-具体应用场景举例"><a href="#Ⅸ-具体应用场景举例" class="headerlink" title="Ⅸ-具体应用场景举例"></a>Ⅸ-具体应用场景举例</h3><blockquote><p>变量的解构赋值用途很多</p></blockquote><h4 id="①-交换变量的值"><a href="#①-交换变量的值" class="headerlink" title="① 交换变量的值"></a>① 交换变量的值</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">&gt;[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p>上面代码交换变量<code>x</code>和<code>y</code>的值, 这样的写法不仅简洁, 而且易读, 语义非常清晰. </p></blockquote><h4 id="②-从函数返回多个值"><a href="#②-从函数返回多个值" class="headerlink" title="② 从函数返回多个值"></a>② 从函数返回多个值</h4><blockquote><p>函数只能返回一个值, 如果要返回多个值, 只能将它们放在数组或对象里返回. 有了解构赋值, 取出这些值就非常方便. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 返回一个数组</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; &#125;</span><br><span class="line">&gt;<span class="keyword">let</span> [a, b, c] = <span class="title function_">example</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 返回一个对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="number">1</span>,<span class="attr">bar</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; foo, bar &#125; = <span class="title function_">example</span>();</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-函数参数的定义"><a href="#③-函数参数的定义" class="headerlink" title="③ 函数参数的定义"></a>③ 函数参数的定义</h4><blockquote><p>解构赋值可以方便地将一组参数与变量名对应起来. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 参数是一组有次序的值</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, z]</span>) &#123; ... &#125;</span><br><span class="line">&gt;<span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 参数是一组无次序的值</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">&#123;x, y, z&#125;</span>) &#123; ... &#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-提取-JSON-数据"><a href="#④-提取-JSON-数据" class="headerlink" title="④  提取 JSON 数据"></a>④  提取 JSON 数据</h4><blockquote><p>解构赋值对提取 JSON 对象中的数据, 尤其有用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> jsonData = &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line"> <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line"> <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(id, status, number);</span><br><span class="line">&gt;<span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p>上面代码可以快速提取 JSON 数据的值. </p></blockquote><h4 id="⑤-函数参数的默认值"><a href="#⑤-函数参数的默认值" class="headerlink" title="⑤  函数参数的默认值"></a>⑤  函数参数的默认值</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;jQuery.<span class="property">ajax</span> = <span class="keyword">function</span> (<span class="params">url, &#123;</span></span><br><span class="line"><span class="params"> <span class="keyword">async</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params"> beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params"> cache = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params"> complete = <span class="keyword">function</span> () &#123;&#125;,</span></span><br><span class="line"><span class="params"> crossDomain = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params"> <span class="variable language_">global</span> = <span class="literal">true</span>,</span></span><br><span class="line"><span class="params"> // ... more config</span></span><br><span class="line"><span class="params">&gt;&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line"> <span class="comment">// ... do stuff</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>指定参数的默认值, 就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句. </p></blockquote><h4 id="⑥-遍历-Map-结构"><a href="#⑥-遍历-Map-结构" class="headerlink" title="⑥ 遍历 Map 结构"></a>⑥ 遍历 Map 结构</h4><blockquote><p>任何部署了 Iterator 接口的对象, 都可以用<code>for...of</code>循环遍历. Map 结构原生支持 Iterator 接口, 配合变量的解构赋值, 获取键名和键值就非常方便. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// first is hello</span></span><br><span class="line">&gt;<span class="comment">// second is world</span></span><br></pre></td></tr></table></figure><p>如果只想获取键名, 或者只想获取键值, 可以写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 获取键名</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 获取键值</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑦-输入模块的指定方法"><a href="#⑦-输入模块的指定方法" class="headerlink" title="⑦ 输入模块的指定方法"></a>⑦ 输入模块的指定方法</h4><blockquote><p>加载模块时, 往往需要指定输入哪些方法. 解构赋值使得输入语句非常清晰. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> &#123; <span class="title class_">SourceMapConsumer</span>, <span class="title class_">SourceNode</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="4、字符串的拓展"><a href="#4、字符串的拓展" class="headerlink" title="4、字符串的拓展"></a>4、字符串的拓展</h2><h3 id="Ⅰ-概括总结-1"><a href="#Ⅰ-概括总结-1" class="headerlink" title="Ⅰ-概括总结"></a>Ⅰ-概括总结</h3><blockquote><ul><li><p><strong>Unicode表示法</strong>: <code>大括号包含</code>表示Unicode字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</p></li><li><p><strong>字符串遍历</strong>: 可通过 [ for-of ] 遍历字符串</p></li><li><p><strong>字符串模板</strong>: 可单行可多行可插入变量的增强版字符串</p></li><li><p><strong>标签模板</strong>: 函数参数的特殊调用</p></li><li><p><strong>String.raw()</strong>: 返回把字符串所有变量替换且对斜杠进行转义的结果</p></li><li><p><strong>String.fromCodePoint()</strong>: 返回码点对应字符</p></li><li><p><strong>codePointAt()</strong>: 返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</p></li><li><p><strong>normalize()</strong>: 把字符的不同表示方法统一为同样形式, 返回<code>新字符串</code>(Unicode正规化)</p></li><li><p><strong>repeat()</strong>: 把字符串重复n次, 返回<code>新字符串</code></p></li><li><p><strong>matchAll()</strong>: 返回正则表达式在字符串的所有匹配</p></li><li><p><strong>includes()</strong>: 是否存在指定字符串</p></li><li><p><strong>startsWith()</strong>: 是否存在字符串头部指定字符串</p></li><li><p><strong>endsWith()</strong>: 是否存在字符串尾部指定字符串</p></li><li><p>以上扩展方法均可作用于由<code>4个字节储存</code>的<code>Unicode字符</code>上</p></li></ul></blockquote><h3 id="Ⅱ-模板字符串"><a href="#Ⅱ-模板字符串" class="headerlink" title="Ⅱ-模板字符串"></a>Ⅱ-模板字符串</h3><blockquote><p>模板字符串（template string）是增强版的字符串, 用反引号[ &#96;  ]标识. 它可以当作普通字符串使用, 也可以用来定义多行字符串, 或者在字符串中嵌入变量. </p><p>嵌入变量使用[<code>$&#123;变量名&#125;</code>]:如果大括号中的值不是字符串, 将按照一般的规则转为字符串. 比如, 大括号中是一个对象, 将默认调用对象的<code>toString</code>方法. 如果大括号内部是一个字符串, 将会原样输出. </p></blockquote><h4 id="①-字符串中可以出现换行符"><a href="#①-字符串中可以出现换行符" class="headerlink" title="① 字符串中可以出现换行符"></a>① 字符串中可以出现换行符</h4><blockquote><p>字符串中可以出现换行符:如果使用模板字符串表示多行字符串, 所有的空格和缩进都会被保留在输出之中. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//代码中, 所有模板字符串的空格和换行, 都是被保留的, 比如`&lt;ul&gt;`标签前面会有一个换行. 如果你不想要这个换行, 可以使用`trim`方法消除它. </span></span><br><span class="line">&gt;$(<span class="string">&#x27;#list&#x27;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&gt;&lt;ul&gt;</span></span><br><span class="line"><span class="string"> &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string"> &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&gt;&lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt;`</span>.<span class="title function_">trim</span>());</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-可以使用-xxx-形式输出变量"><a href="#②-可以使用-xxx-形式输出变量" class="headerlink" title="② 可以使用 ${xxx} 形式输出变量"></a>② 可以使用 ${xxx} 形式输出变量</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">authorize</span>(<span class="params">user, action</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (!user.<span class="title function_">hasPrivilege</span>(action)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(</span><br><span class="line">     <span class="comment">// 传统写法为</span></span><br><span class="line">     <span class="comment">// &#x27;User &#x27;</span></span><br><span class="line">     <span class="comment">// + user.name</span></span><br><span class="line">     <span class="comment">// + &#x27; is not authorized to do &#x27;</span></span><br><span class="line">     <span class="comment">// + action</span></span><br><span class="line">     <span class="comment">// + &#x27;.&#x27;</span></span><br><span class="line">     <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-大括号内部可以放入任意的-JavaScript-表达式"><a href="#③-大括号内部可以放入任意的-JavaScript-表达式" class="headerlink" title="③ 大括号内部可以放入任意的 JavaScript 表达式"></a>③ 大括号内部可以放入任意的 JavaScript 表达式</h4><blockquote><p>括号内部可以放入任意的 JavaScript 表达式, 可以进行运算, 以及引用对象属性. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span><span class="comment">// &quot;1 + 2 = 3&quot;</span></span><br><span class="line">&gt;<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span><span class="comment">// &quot;1 + 4 = 5&quot;</span></span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;<span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span><span class="comment">// &quot;3&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-模板字符串之中还能调用函数"><a href="#④-模板字符串之中还能调用函数" class="headerlink" title="④ 模板字符串之中还能调用函数."></a>④ 模板字符串之中还能调用函数.</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;&#125;</span><br><span class="line">&gt;<span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line">&gt;<span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-字符串嵌套"><a href="#⑤-字符串嵌套" class="headerlink" title="⑤ 字符串嵌套"></a>⑤ 字符串嵌套</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">tmpl</span> = addrs =&gt; <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;table&gt;</span></span><br><span class="line"><span class="string"> <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string"> `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string"> &lt;/table&gt;</span></span><br><span class="line"><span class="string">&gt;`</span>;</span><br></pre></td></tr></table></figure><p>上面代码中, 模板字符串的变量之中, 又嵌入了另一个模板字符串, 使用方法如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> data = [</span><br><span class="line">   &#123; <span class="attr">first</span>: <span class="string">&#x27;&lt;Jane&gt;&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Bond&#x27;</span> &#125;,</span><br><span class="line">   &#123; <span class="attr">first</span>: <span class="string">&#x27;Lars&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;&lt;Croft&gt;&#x27;</span> &#125;,</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">tmpl</span>(data));</span><br><span class="line">&gt;<span class="comment">/**下面是打印结果</span></span><br><span class="line"><span class="comment">&gt;&lt;table&gt;</span></span><br><span class="line"><span class="comment">  &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"> &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">  &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身, 在需要时执行, 可以写成函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">func</span> = (<span class="params">name</span>) =&gt; <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&gt;<span class="title function_">func</span>(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 模板字符串写成了一个函数的返回值. 执行这个函数, 就相当于执行这个模板字符串了. </p></blockquote><h3 id="Ⅲ-标签模板"><a href="#Ⅲ-标签模板" class="headerlink" title="Ⅲ-标签模板"></a>Ⅲ-标签模板</h3><blockquote><p>模板字符串的功能, 不仅仅是上面这些. 它可以紧跟在一个函数名后面, 该函数将被调用来处理这个模板字符串. 这被称为“<code>标签模板</code>”功能（tagged template&#96;）.   –&gt;反正我是很少用到,可阅读性较差</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`hello`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="title function_">alert</span>([<span class="string">&#x27;hello&#x27;</span>])</span><br></pre></td></tr></table></figure></blockquote><h4 id="①-简单实例"><a href="#①-简单实例" class="headerlink" title="① 简单实例"></a>① 简单实例</h4><blockquote><p>标签模板其实不是模板, 而是函数调用的一种特殊形式. <code>[标签]指的就是函数</code>, 紧跟在后面的模板字符串就是它的参数. </p><p>但是, 如果模板字符里面有变量, 就不是简单的调用了, 而是会将模板字符串先处理成多个参数, 再调用函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>,  <span class="string">&#x27; &#x27;</span>  ], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 模板字符串前面有一个标识名<code>tag</code>, 它是一个函数. 整个表达式的返回值, 就是<code>tag</code>函数处理模板字符串后的返回值. </p><p>函数<code>tag</code>依次会接收到多个参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, value1, value2</span>)&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">stringArr, ...values</span>)&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>tag</code>函数的第一个参数是一个数组, <code>该数组的成员是模板字符串中那些没有变量替换的部分</code>, 也就是说, 变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间, 以此类推. </p><p><code>tag</code>函数的其他参数, 都是模板字符串各个变量被替换后的值. 由于本例中, 模板字符串含有两个变量, 因此<code>tag</code>会接受到<code>value1</code>和<code>value2</code>两个参数. </p><p><code>tag</code>函数所有参数的实际值如下. </p><ul><li>第一个参数: <code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li><li>第二个参数: 15</li><li>第三个参数: 50</li></ul><p>也就是说, <code>tag</code>函数实际上以下面的形式调用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">tag</span>([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>我们可以按照需要编写<code>tag</code>函数的代码. 下面是<code>tag</code>函数的一种写法, 以及运行结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">s, v1, v2</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">0</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">1</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="number">2</span>]);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v1);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v2);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line">&gt;<span class="comment">// &quot;Hello &quot;</span></span><br><span class="line">&gt;<span class="comment">// &quot; world &quot;</span></span><br><span class="line">&gt;<span class="comment">// &quot;&quot;</span></span><br><span class="line">&gt;<span class="comment">// 15</span></span><br><span class="line">&gt;<span class="comment">// 50</span></span><br><span class="line">&gt;<span class="comment">// &quot;OK&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-稍微复杂的栗子"><a href="#②-稍微复杂的栗子" class="headerlink" title="② 稍微复杂的栗子"></a>② 稍微复杂的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">passthru</span>(<span class="params">literals</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="keyword">while</span> (i &lt; literals.<span class="property">length</span>) &#123;</span><br><span class="line"> result += literals[i++];</span><br><span class="line">   <span class="keyword">if</span> (i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    result += <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br><span class="line"> </span><br><span class="line">&gt;msg <span class="comment">// &quot;The total is 30 (31.5 with tax)&quot;</span></span><br></pre></td></tr></table></figure><p>上面这个栗子展示了, 如何将各个参数按照原来的位置拼合回去. </p><p><code>passthru</code>函数采用 rest 参数的写法如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">passthru</span>(<span class="params">literals, ...values</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> index;</span><br><span class="line"> <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.<span class="property">length</span>; index++) &#123;</span><br><span class="line"> output += literals[index] + values[index];</span><br><span class="line"> &#125;</span><br><span class="line">   output += literals[index]</span><br><span class="line"> <span class="keyword">return</span> output;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用, 就是过滤 HTML 字符串, 防止用户输入恶意内容. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> message =</span><br><span class="line">&gt;<span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">SaferHTML</span>(<span class="params">templateData</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> arg = <span class="title class_">String</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">   s += arg.<span class="title function_">replace</span>(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">      .<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">          .<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">&gt;&#125;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>sender</code>变量往往是用户提供的, 经过<code>SaferHTML</code>函数处理, 里面的特殊字符都会被转义. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line">&gt;<span class="keyword">let</span> message = <span class="title class_">SaferHTML</span><span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">&gt;message</span><br><span class="line">&gt;<span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-用作多语言转换（国际化处理）"><a href="#③-用作多语言转换（国际化处理）" class="headerlink" title="③ 用作多语言转换（国际化处理）"></a>③ 用作多语言转换（国际化处理）</h4><blockquote><p>标签模板的另一个应用, 就是多语言转换（国际化处理）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line">&gt;<span class="comment">// &quot;欢迎访问xxx , 您是第xxxx位访问者！&quot;</span></span><br></pre></td></tr></table></figure><p>模板字符串本身并不能取代 Mustache 之类的模板库, 因为没有条件判断和循环处理功能, 但是通过标签函数, 你可以自己添加这些功能. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line">&gt;<span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line">&gt;<span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;ul&gt;</span></span><br><span class="line"><span class="string">   #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">     &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">   #end</span></span><br><span class="line"><span class="string"> &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&gt;`</span>;</span><br></pre></td></tr></table></figure><p>除此之外, 你甚至可以使用标签模板, 在 JavaScript 语言之中嵌入其他语言. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;jsx<span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt;</span></span><br><span class="line"><span class="string">   &lt;input</span></span><br><span class="line"><span class="string">     ref=&#x27;input&#x27;</span></span><br><span class="line"><span class="string">     onChange=&#x27;<span class="subst">$&#123;<span class="variable language_">this</span>.handleChange&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">     defaultValue=&#x27;<span class="subst">$&#123;<span class="variable language_">this</span>.state.value&#125;</span>&#x27; /&gt;</span></span><br><span class="line"><span class="string">     <span class="subst">$&#123;<span class="variable language_">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">&gt;`</span></span><br></pre></td></tr></table></figure><p>上面的代码通过<code>jsx</code>函数, 将一个 DOM 字符串转为 React 对象. </p><p>下面则是一个假想的栗子, 通过<code>java</code>函数, 在 JavaScript 代码之中运行 Java 代码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;java<span class="string">`</span></span><br><span class="line"><span class="string">&gt;class HelloWorldApp &#123;</span></span><br><span class="line"><span class="string"> public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">   System.out.println(&quot;Hello World!&quot;); // Display the string.</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&gt;&#125;</span></span><br><span class="line"><span class="string">&gt;`</span></span><br><span class="line">&gt;<span class="title class_">HelloWorldApp</span>.<span class="title function_">main</span>();</span><br></pre></td></tr></table></figure><p>模板处理函数的第一个参数（模板字符串数组）, 还有一个<code>raw</code>属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">console</span>.<span class="property">log</span><span class="string">`123`</span></span><br><span class="line">&gt;<span class="comment">// [&quot;123&quot;, raw: Array[1]]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>console.log</code>接受的参数, 实际上是一个数组. 该数组有一个<code>raw</code>属性, 保存的是转义后的原字符串. </p><p>请看下面的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">strings</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(strings.<span class="property">raw</span>[<span class="number">0</span>]);</span><br><span class="line"> <span class="comment">// strings.raw[0] 为 &quot;First line\\nSecond line&quot;</span></span><br><span class="line"> <span class="comment">// 打印输出 &quot;First line\nSecond line&quot;</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>tag</code>函数的第一个参数<code>strings</code>, 有一个<code>raw</code>属性, 也指向一个数组. 该数组的成员与<code>strings</code>数组完全一致. 比如, <code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>, 那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>. 两者唯一的区别, 就是字符串里面的斜杠都被转义了. 比如 , strings.raw 数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符, 而不是换行符. 这是为了方便取得转义之前的原始模板而设计的. </p></blockquote><h2 id="5、数值的拓展"><a href="#5、数值的拓展" class="headerlink" title="5、数值的拓展"></a>5、数值的拓展</h2><h3 id="Ⅰ-概括总结-2"><a href="#Ⅰ-概括总结-2" class="headerlink" title="Ⅰ- 概括总结"></a>Ⅰ- 概括总结</h3><blockquote><p><strong>二进制表示法</strong>: <code>0b或0B开头</code>表示二进制(<code>0bXX</code>或<code>0BXX</code>)</p><p><strong>八进制表示法</strong>: <code>0o或0O开头</code>表示二进制(<code>0oXX</code>或<code>0OXX</code>)</p><p><strong>指数运算符</strong>:其实这是<code>ES2016</code> 新增的 ,指数运算符（<code>**</code>）.  –&gt;详见下方</p><p><strong>Number.EPSILON</strong>: 数值最小精度</p><p><strong>Number.MIN_SAFE_INTEGER</strong>: 最小安全数值(<code>-2^53</code>)</p><p><strong>Number.MAX_SAFE_INTEGER</strong>: 最大安全数值(<code>2^53</code>)</p><p><strong>Number.parseInt()</strong>: 返回转换值的整数部分</p><p><strong>Number.parseFloat()</strong>: 返回转换值的浮点数部分</p><p><strong>Number.isFinite()</strong>: 是否为有限数值</p><p><strong>Number.isNaN()</strong>: 是否为NaN</p><p><strong>Number.isInteger()</strong>: 是否为整数</p><p><strong>Number.isSafeInteger()</strong>: 是否在数值安全范围内</p><p><strong>Math.trunc()</strong>: 返回数值整数部分</p><p><strong>Math.sign()</strong>: 返回数值类型(<code>正数1</code>、<code>负数-1</code>、<code>零0</code>)</p><p><strong>Math.cbrt()</strong>: 返回数值立方根</p><p><strong>Math.clz32()</strong>: 返回数值的32位无符号整数形式</p><p><strong>Math.imul()</strong>: 返回两个数值相乘</p><p><strong>Math.fround()</strong>: 返回数值的32位单精度浮点数形式</p><p><strong>Math.hypot()</strong>: 返回所有数值平方和的平方根</p><p><strong>Math.expm1()</strong>: 返回<code>e^n - 1</code></p><p><strong>Math.log1p()</strong>: 返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</p><p><strong>Math.log10()</strong>: 返回以10为底的n的对数</p><p><strong>Math.log2()</strong>: 返回以2为底的n的对数</p><p><strong>Math.sinh()</strong>: 返回n的双曲正弦</p><p><strong>Math.cosh()</strong>: 返回n的双曲余弦</p><p><strong>Math.tanh()</strong>: 返回n的双曲正切</p><p><strong>Math.asinh()</strong>: 返回n的反双曲正弦</p><p><strong>Math.acosh()</strong>: 返回n的反双曲余弦</p><p><strong>Math.atanh()</strong>: 返回n的反双曲正切</p></blockquote><h3 id="Ⅱ-指数运算符"><a href="#Ⅱ-指数运算符" class="headerlink" title="Ⅱ - 指数运算符"></a>Ⅱ - 指数运算符</h3><blockquote><p>ES2016 新增了一个指数运算符（<code>**</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>这个运算符的一个特点是右结合, 而不是常见的左结合. 多个指数运算符连用时, 是从最右边开始计算的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 相当于 2 ** (3 ** 2)</span></span><br><span class="line">&gt;<span class="number">2</span> ** <span class="number">3</span> ** <span class="number">2</span></span><br><span class="line">&gt;<span class="comment">// 512</span></span><br></pre></td></tr></table></figure><p>上面代码中, 首先计算的是第二个指数运算符, 而不是第一个. </p><p>指数运算符可以与等号结合, 形成一个新的赋值运算符（<code>**=</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="number">1.5</span>;</span><br><span class="line">&gt;a **= <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">&gt;b **= <span class="number">3</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="6、函数的拓展"><a href="#6、函数的拓展" class="headerlink" title="6、函数的拓展"></a>6、函数的拓展</h2><blockquote><p><code>对于JS来说函数部分是重中之重的基础</code>,相对而言篇幅占比也会较大</p></blockquote><h3 id="Ⅰ-概括总结-3"><a href="#Ⅰ-概括总结-3" class="headerlink" title="Ⅰ- 概括总结"></a>Ⅰ- 概括总结</h3><blockquote><blockquote><p><strong>Ⅰ- 参数默认值</strong>: 为函数参数指定默认值</p></blockquote><ul><li>形式: <code>function Func(x = 1, y = 2) &#123;&#125;</code></li><li>参数赋值: 惰性求值(函数调用后才求值)</li><li>参数位置: 尾参数</li><li>参数作用域: 函数作用域</li><li>声明方式: 默认声明, 不能用<code>const</code>或<code>let</code>再次声明</li><li>length: 返回没有指定默认值的参数个数</li><li>与解构赋值默认值结合: <code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li><li>应用<ol><li>指定某个参数不得省略, 省略即抛出错误: <code>function Func(x = throwMissing()) &#123;&#125;</code></li><li>将参数默认值设为 <strong>undefined</strong> , 表明此参数可省略: <code>Func(undefined, 1)</code></li></ol></li></ul><blockquote><p><strong>Ⅱ - 箭头函数(&#x3D;&gt;)</strong>: 函数简写  –&gt;<code>重点</code></p></blockquote><ul><li>无参数: <code>() =&gt; &#123;&#125;</code></li><li>单个参数: <code>x =&gt; &#123;&#125;</code></li><li>多个参数: <code>(x, y) =&gt; &#123;&#125;</code></li><li>解构参数: <code>(&#123;x, y&#125;) =&gt; &#123;&#125;</code></li><li>嵌套使用: ** <code>部署管道机制</code> ** –&gt;不懂的详见下方</li><li>this指向固定化<ul><li>并非因为内部有绑定 [ this ] 的机制, 而是根本没有自己的 [ this ] , 导致内部的 [ this ] 就是外层代码块的 [ this ] </li><li>因为没有 [ this ] , 因此不能用作构造函数</li></ul></li></ul><blockquote><p><strong>Ⅲ - rest&#x2F;spread参数(…)</strong>: 返回函数多余参数</p></blockquote><ul><li>形式: 以数组的形式存在, 之后不能再有其他参数</li><li>作用: 代替<code>Arguments对象</code></li><li>length: 返回没有指定默认值的参数个数但不包括<code>rest/spread参数</code></li></ul><blockquote><p><strong>Ⅳ - 严格模式</strong>: 在严格条件下运行JS</p></blockquote><ul><li>应用: 只要函数参数使用默认值、解构赋值、扩展运算符, 那么函数内部就不能显式设定为严格模式</li></ul><blockquote><p><strong>Ⅴ - name属性</strong>: 返回函数的函数名</p></blockquote><ul><li>将匿名函数赋值给变量: <code>空字符串</code>(<strong>ES5</strong>)、<code>变量名</code>(<strong>ES6</strong>)</li><li>将具名函数赋值给变量: <code>函数名</code>(<strong>ES5和ES6</strong>)</li><li>bind返回的函数: <code>bound 函数名</code>(<strong>ES5和ES6</strong>)</li><li>Function构造函数返回的函数实例: <code>anonymous</code>(<strong>ES5和ES6</strong>)</li></ul><blockquote><p><strong>Ⅵ - 尾调用优化</strong>: 只保留内层函数的调用帧</p></blockquote><ul><li>尾调用<ul><li>定义: 某个函数的最后一步是调用另一个函数</li><li>形式: <code>function f(x) &#123; return g(x); &#125;</code></li></ul></li><li>尾递归<ul><li>定义: 函数尾调用自身</li><li>作用: 只要使用尾递归就不会发生栈溢出, 相对节省内存</li><li>实现: 把所有用到的内部变量改写成函数的参数并使用参数默认值</li></ul></li></ul><blockquote><p><strong>Ⅶ - 箭头函数常见误区的正解</strong></p></blockquote><ol><li>函数体内的 [ this ] 是<code>定义时所在的对象</code>而不是<code>使用时所在的对象</code></li><li>可让 [ this ] 指向固定化, 这种特性很有利于封装回调函数</li><li>不可当作<code>构造函数</code>, 因此箭头函数不可使用<code>new命令</code></li><li>不可使用<code>yield命令</code>, 因此箭头函数不能用作<code>Generator函数</code></li><li>不可使用<code>Arguments对象</code>, 此对象在函数体内不存在(可用<code>rest/spread参数</code>代替)</li><li>返回对象时必须在对象外面加上括号</li></ol></blockquote><h3 id="Ⅱ-函数参数的默认值"><a href="#Ⅱ-函数参数的默认值" class="headerlink" title="Ⅱ - 函数参数的默认值"></a>Ⅱ - 函数参数的默认值</h3><h4 id="①-基本用法-1"><a href="#①-基本用法-1" class="headerlink" title="①  基本用法"></a>①  基本用法</h4><blockquote><p>ES6 之前, 不能直接为函数的参数指定默认值, 只能采用变通的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> y = y || <span class="string">&#x27;World&#x27;</span>; <span class="comment">//[或],当y为undefined时,将其赋值</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello World  --&gt;参数`y`等于空字符, 结果被改为默认值</span></span><br></pre></td></tr></table></figure><p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值, 如果没有, 则指定默认值为<code>World</code>. 这种写法的缺点在于, 如果参数<code>y</code>赋值了, 但是对应的布尔值为<code>false</code>, 则该赋值不起作用. 就像上面代码的最后一行, 参数<code>y</code>等于空字符, 结果被改为默认值. </p><p>为了避免这个问题, 通常需要先判断一下参数<code>y</code>是否被赋值, 如果没有, 再等于默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>) &#123;  y = <span class="string">&#x27;World&#x27;</span>; &#125;</span><br></pre></td></tr></table></figure><p>ES6 允许为函数的参数设置默认值, 即直接写在参数定义的后面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);&#125;</span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">&gt;<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>可以看到 , ES6 的写法比 ES5 简洁许多, 而且非常自然. 下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">&gt;p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>除了简洁 , ES6 的写法还有两个好处: </p><ul><li>首先, 阅读代码的人, 可以立刻意识到哪些参数是可以省略的, 不用查看函数体或文档；</li><li>其次, 有利于将来的代码优化, 即使未来的版本在对外接口中, 彻底拿掉这个参数, 也不会导致以前的代码无法运行.</li></ul><p>参数变量是默认声明的, 所以不能用<code>let</code>或<code>const</code>再次声明,否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line"> <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>使用参数默认值时, 函数不能有同名参数</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 不报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) &#123;&#125;</span><br><span class="line">&gt;<span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure><p>另外, 一个容易忽略的地方是, 参数默认值不是传值的, 而是每次都重新计算默认值表达式的值. 也就是说, 参数默认值是惰性求值的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(p);&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 100</span></span><br><span class="line">&gt;x = <span class="number">100</span>;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>p</code>的默认值是<code>x + 1</code>. 这时, 每次调用函数<code>foo</code>, 都会重新计算<code>x + 1</code>, 而不是默认<code>p</code>等于 100. </p></blockquote><h4 id="②-与解构赋值默认值结合使用"><a href="#②-与解构赋值默认值结合使用" class="headerlink" title="② 与解构赋值默认值结合使用"></a>② 与解构赋值默认值结合使用</h4><blockquote><p>参数默认值可以与解构赋值的默认值, 结合起来使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">&gt;<span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">&gt;<span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码只使用了对象的解构赋值默认值, 没有使用函数参数的默认值. 只有当函数<code>foo</code>的参数是一个对象时, 变量<code>x</code>和<code>y</code>才会通过解构赋值生成. 如果函数<code>foo</code>调用时没提供参数, 变量<code>x</code>和<code>y</code>就不会生成, 从而报错. 通过提供函数参数的默认值, 就可以避免这种情况. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>上面代码指定, 如果没有提供参数, 函数<code>foo</code>的参数默认为一个空对象. </p><p>下面是另一个解构赋值默认值的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中, 如果函数<code>fetch</code>的第二个参数是一个对象, 就可以为它的三个属性设置默认值. 这种写法不能省略第二个参数, 如果结合函数参数的默认值, 就可以省略第二个参数. 这时, 就出现了双重默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(method);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>fetch</code>没有第二个参数时, 函数参数的默认值就会生效, 然后才是解构赋值的默认值生效, 变量<code>method</code>才会取到默认值<code>GET</code>. </p><p>作为练习, 请问下面两种写法有什么差别？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 写法一</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) &#123; <span class="keyword">return</span> [x, y]; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 写法二</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) &#123; <span class="keyword">return</span> [x, y]; &#125;</span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值, 区别是写法一函数参数的默认值是空对象, 但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象, 但是没有设置对象解构赋值的默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 函数没有参数的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>() <span class="comment">// [0, 0]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// x 有值 , y 无值的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">m1</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">&gt;<span class="title function_">m2</span>(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-参数默认值的位置"><a href="#③-参数默认值的位置" class="headerlink" title="③  参数默认值的位置"></a>③  参数默认值的位置</h4><blockquote><p>通常情况下, 定义了默认值的参数, 应该是函数的尾参数. 因为这样比较容易看出来, 到底省略了哪些参数. 如果非尾部的参数设置默认值, 实际上这个参数是没法省略的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) &#123; <span class="keyword">return</span> [x, y];&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) &#123; <span class="keyword">return</span> [x, y, z];&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 有默认值的参数都不是尾参数. 这时, 无法只省略该参数, 而不省略它后面的参数, 除非显式输入 <strong>undefined</strong> . </p><p>如果传入 <strong>undefined</strong> , 将触发该参数等于默认值,  <strong>null</strong> 则没有这个效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y); &#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>x</code>参数对应 <strong>undefined</strong> , 结果触发了默认值, <code>y</code>参数等于 <strong>null</strong> , 就没有触发默认值. </p></blockquote><h4 id="④-函数的-length-属性"><a href="#④-函数的-length-属性" class="headerlink" title="④ 函数的 length 属性"></a>④ 函数的 length 属性</h4><blockquote><p>指定了默认值以后, 函数的<code>length</code>属性, 将返回没有指定默认值的参数个数. 也就是说, <code>指定了默认值后 , length属性将失真</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中, [ length ]属性的返回值, 等于函数的参数个数减去指定了默认值的参数个数. 比如, 上面最后一个函数, 定义了 3 个参数, 其中有一个参数<code>c</code>指定了默认值, 因此[ length ]属性等于<code>3</code>减去<code>1</code>, 最后得到<code>2</code>. </p><p>这是因为<code>length</code>属性的含义是, 该函数预期传入的参数个数. 某个参数指定默认值以后, 预期传入的参数个数就不包括这个参数了. 同理, 后文的 rest 参数也不会计入[ length ]属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">...args</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果设置了<code>默认值的参数不是尾参数</code>, 那么[ length ]属性也不再计入后面的参数了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 0</span></span><br><span class="line">&gt;(<span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) &#123;&#125;).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-作用域"><a href="#⑤-作用域" class="headerlink" title="⑤  作用域"></a>⑤  作用域</h4><blockquote><p>一旦设置了参数的默认值, 函数进行声明初始化时, 参数会形成一个单独的作用域（context）. 等到初始化结束, 这个作用域就会消失. 这种语法行为, 在不设置参数默认值时, 是不会出现的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y = x</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(y); &#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>y</code>的默认值等于变量<code>x</code>. 调用函数 [ f ] 时, 参数形成一个单独的作用域. 在这个作用域里面, 默认值变量<code>x</code>指向第一个参数<code>x</code>, 而不是全局变量<code>x</code>, 所以输出是<code>2</code>. </p><p>再看下面的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数 [ f ] 调用时, 参数<code>y = x</code>形成一个单独的作用域. 这个作用域里面, 变量<code>x</code>本身没有定义, 所以指向外层的全局变量<code>x</code>. 函数调用时, 函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>. </p><p>如果此时, 全局变量<code>x</code>不存在, 就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>下面这样写, 也会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = x</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>x = x</code>形成一个单独作用域. 实际执行的是<code>let x = x</code>, 由于暂时性死区的原因, 这行代码会报错”x 未定义“. </p><p>如果参数的默认值是一个函数, 该函数的作用域也遵守这个规则. 请看下面的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> foo = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">func = () =&gt; foo</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">bar</span>(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数, 返回值为变量<code>foo</code>. 函数参数形成的单独作用域里面, 并没有定义变量<code>foo</code>, 所以<code>foo</code>指向外层的全局变量<code>foo</code>, 因此输出<code>outer</code>. </p><p>如果写成下面这样, 就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">func = () =&gt; foo</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">bar</span>() <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 匿名函数里面的<code>foo</code>指向函数外层, 但是函数外层并没有声明变量<code>foo</code>, 所以就报错了. </p><p>下面是一个更复杂的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"> <span class="title function_">y</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="comment">//x == 1</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>foo</code>的参数形成一个单独作用域. 这个作用域里面, 首先声明了变量<code>x</code>, 然后声明了变量<code>y</code>, <code>y</code>的默认值是一个匿名函数. 这个匿名函数内部的变量<code>x</code>, 指向同一个作用域的第一个参数<code>x</code>. 函数<code>foo</code>内部又声明了一个内部变量<code>x</code>, 该变量与第一个参数<code>x</code>由于不是同一个作用域, 所以不是同一个变量, 因此执行<code>y</code>后, 内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变. </p><p>如果将<code>var x = 3</code>的<code>var</code>去除, 函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>, 与匿名函数内部的<code>x</code>是一致的, 所以最后输出的就是<code>2</code>, 而外层的全局变量<code>x</code>依然不受影响. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) &#123;</span><br><span class="line"> x = <span class="number">3</span>;</span><br><span class="line"> <span class="title function_">y</span>();</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br><span class="line">&gt;<span class="comment">//x== 1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-应用"><a href="#⑥-应用" class="headerlink" title="⑥ 应用"></a>⑥ 应用</h4><blockquote><p>利用参数默认值, 可以指定某一个参数不得省略, 如果省略就抛出一个错误. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">throwIfMissing</span>(<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) &#123;  <span class="keyword">return</span> mustBeProvided; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>()</span><br><span class="line">&gt;<span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>foo</code>函数, 如果调用的时候没有参数, 就会调用默认值<code>throwIfMissing</code>函数, 从而抛出一个错误. </p><p>从上面代码还可以看到, 参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号）, 这表明参数的默认值不是在定义时执行, 而是在运行时执行. 如果参数已经赋值, 默认值中的函数就不会运行. </p><p>另外, 可以将参数默认值设为 <strong>undefined</strong> , 表明这个参数是可以省略的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">optional = <span class="literal">undefined</span></span>) &#123; ··· &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-箭头函数-重点"><a href="#Ⅲ-箭头函数-重点" class="headerlink" title="Ⅲ - 箭头函数 (重点)"></a>Ⅲ - 箭头函数 (<code>重点</code>)</h3><blockquote><p>ES6最常见用法,这个必须要会</p></blockquote><h4 id="①-基本用法-2"><a href="#①-基本用法-2" class="headerlink" title="① 基本用法"></a>① 基本用法</h4><blockquote><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">f</span> = v =&gt; v;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">v</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> v;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数不需要参数或需要多个参数, 就使用一个圆括号代表参数部分. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="number">5</span>;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; num1 + num2;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>如果箭头函数的代码块部分多于一条语句, 就要使用大括号将它们括起来, 并且使用<code>return</code>语句返回. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">sum</span> = (<span class="params">num1, num2</span>) =&gt; &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure><p><code>由于大括号被解释为代码块, 所以如果箭头函数直接返回一个对象, 必须在对象外面加上括号, 否则会报错</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">getTempItem</span> = id =&gt; &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 不报错</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">getTempItem</span> = id =&gt; (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>下面是一种特殊情况, 虽然可以运行, 但会得到错误的结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt;<span class="title function_">foo</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 原始意图是返回一个对象<code>&#123; a: 1 &#125;</code>, 但是由于引擎认为大括号是代码块, 所以执行了一行语句<code>a: 1</code>. 这时, <code>a</code>可以被解释为语句的标签, 因此实际执行的语句是<code>1;</code>, 然后函数就结束了, 没有返回值. </p><p>如果箭头函数只有一行语句, 且不需要返回值, 可以采用下面的写法, 就不用写大括号了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; <span class="keyword">void</span> <span class="title function_">doesNotReturn</span>();</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">full</span> = (<span class="params">&#123; first, last &#125;</span>) =&gt; first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">full</span>(<span class="params">person</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">last</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>箭头函数使得表达更加简洁. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">isEven</span> = n =&gt; n % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">//类型 boolean</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">square</span> = n =&gt; n * n;  <span class="comment">//类型 number</span></span><br></pre></td></tr></table></figure><p>上面代码只用了两行, 就定义了两个简单的工具函数. 如果不用箭头函数, 可能就要占用多行, 而且还不如现在这样写醒目. </p><p>箭头函数的一个用处是简化回调函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正常函数写法</span></span><br><span class="line">&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x * x;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 箭头函数写法</span></span><br><span class="line">&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>另一个栗子是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正常函数写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> result = values.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> a - b;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 箭头函数写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> result = values.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>下面是 rest 参数与箭头函数结合的栗子(<code>个人觉得很好用</code>). </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">numbers</span> = (<span class="params">...nums</span>) =&gt; nums;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">numbers</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">headAndTail</span> = (<span class="params">head, ...tail</span>) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">headAndTail</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-使用注意点"><a href="#②-使用注意点" class="headerlink" title="② 使用注意点"></a>② 使用注意点</h4><blockquote><p>箭头函数有几个使用注意点. </p><p>（1）函数体内的 [ this ] 对象, 就是定义时所在的对象, 而不是使用时所在的对象. </p><p>（2）不可以当作构造函数, 也就是说, 不可以使用<code>new</code>命令, 否则会抛出一个错误. </p><p>（3）不可以使用<code>arguments</code>对象, 该对象在函数体内不存在. 如果要用, <code>可以用 rest 参数代替</code>. </p><p>（4）不可以使用<code>yield</code>命令, 因此箭头函数<code>不能用作 Generator 函数</code>. –&gt;此类型函数在后方知识点会给出详解</p><blockquote><p>以下是详解举栗</p></blockquote><p>上面四点中, 第一点尤其值得注意. <code>[this]对象的指向是可变的, 但是在箭头函数中, 它是固定的</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">&gt;foo.<span class="title function_">call</span>(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;); <span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>setTimeout()</code>的参数是一个箭头函数, 这个箭头函数的定义生效是在<code>foo</code>函数生成时, 而它的真正执行要等到 100 毫秒后. 如果是普通函数, 执行时 [ this ] 应该指向全局对象<code>window</code>, 这时应该输出<code>21</code>. 但是, 箭头函数导致 [ this ] 总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>）, 所以打印出来的是<code>42</code>. </p><p>箭头函数可以让<code>setTimeout</code>里面的 [ this ] , 绑定定义时所在的作用域, 而不是指向运行时所在的作用域. 下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">s1</span> = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">s2</span> = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">// 箭头函数</span></span><br><span class="line">&gt;<span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">s1</span>++, <span class="number">1000</span>);</span><br><span class="line">&gt;<span class="comment">// 普通函数</span></span><br><span class="line">&gt;<span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">s2</span>++;</span><br><span class="line">&gt;&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> timer = <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s1: &#x27;</span>, timer.<span class="property">s1</span>), <span class="number">3100</span>);</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;s2: &#x27;</span>, timer.<span class="property">s2</span>), <span class="number">3100</span>);</span><br><span class="line">&gt;<span class="comment">// s1: 3</span></span><br><span class="line">&gt;<span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Timer</code>函数内部设置了两个定时器, 分别使用了箭头函数和普通函数. 前者的 [ this ] 绑定定义时所在的作用域（即<code>Timer</code>函数）, 后者的 [ this ] 指向运行时所在的作用域（即全局对象）. 所以, 3100 毫秒之后, <code>timer.s1</code>被更新了 3 次, 而<code>timer.s2</code>一次都没更新. </p><p><code>箭头函数可以让[this指向]固定化, 这种特性很有利于封装回调函数</code>. 下面是一个栗子 , DOM 事件的回调函数封装在一个对象里面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line">&gt;<span class="attr">id</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">&gt;<span class="attr">init</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line"><span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">doSomething</span>(event.<span class="property">type</span>), <span class="literal">false</span>);</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;<span class="attr">doSomething</span>: <span class="keyword">function</span>(<span class="params">type</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>init</code>方法中, 使用了箭头函数, 这导致这个箭头函数里面的 [ this ] , 总是指向<code>handler</code>对象. 否则, 回调函数运行时, <code>this.doSomething</code>这一行会报错, 因为此时 [ this ] 指向<code>document</code>对象. </p><p>[ this ] 指向的固定化, 并不是因为箭头函数内部有绑定 [ this ] 的机制, 实际原因是箭头函数根本没有自己的 [ this ] , 导致内部的 [ this ] 就是外层代码块的 [ this ] . 正是因为它没有 [ this ] , 所以也就不能用作构造函数. </p><p>所以, 箭头函数转成 ES5 的代码如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, _this.<span class="property">id</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 转换后的 ES5 版本清楚地说明了, 箭头函数里面根本没有自己的 [ this ] , 而是引用外层的 [ this ] . </p><p>请问下面的代码之中有几个 [ this ] ？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;id:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> f = foo.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> t1 = f.<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line">&gt;<span class="keyword">var</span> t2 = <span class="title function_">f</span>().<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line">&gt;<span class="keyword">var</span> t3 = <span class="title function_">f</span>()().<span class="title function_">call</span>(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure><p>上面代码之中, 只有一个 [ this ] , 就是函数<code>foo</code>的 [ this ] , 所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果. 因为所有的内层函数都是箭头函数, 都没有自己的 [ this ] , 它们的 [ this ] 其实都是最外层<code>foo</code>函数的 [ this ] . </p><p>除了 [ this ] , 以下三个变量在箭头函数之中也是不存在的, 指向外层函数的对应变量: <code>arguments</code>、<code>super</code>、<code>new.target</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;args:&#x27;</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&gt;&#125;, <span class="number">100</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">foo</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line">&gt;<span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 箭头函数内部的变量<code>arguments</code>, 其实是函数<code>foo</code>的<code>arguments</code>变量. </p><p>另外, 由于箭头函数没有自己的 [ this ] , 所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变 [ this ] 的指向. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> [</span><br><span class="line">&gt;(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">x</span>).<span class="title function_">bind</span>(&#123; <span class="attr">x</span>: <span class="string">&#x27;inner&#x27;</span> &#125;)()</span><br><span class="line">&gt;];</span><br><span class="line">&gt;&#125;).<span class="title function_">call</span>(&#123; <span class="attr">x</span>: <span class="string">&#x27;outer&#x27;</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [&#x27;outer&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 箭头函数没有自己的 [ this ] , 所以<code>bind</code>方法无效, 内部的 [ this ] 指向外部的 [ this ] . </p><p>长期以来 , JavaScript 语言的 [ this ] 对象一直是一个令人头痛的问题, 在对象方法中使用 [ this ] , 必须非常小心. <code>箭头函数&#39;绑定[this]&#39;, 很大程度上解决了这个困扰. </code></p></blockquote><h4 id="③-不适用场合"><a href="#③-不适用场合" class="headerlink" title="③ 不适用场合"></a>③ 不适用场合</h4><blockquote><p>由于箭头函数使得 [ this ] 从“动态”变成“静态”, 下面两个场合不应该使用箭头函数. </p><p>第一个场合是定义对象的方法, 且该方法内部包括 [ this ] . </p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="keyword">const</span> cat = &#123;</span><br><span class="line"> <span class="attr">lives</span>: <span class="number">9</span>,</span><br><span class="line"> <span class="attr">jumps</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">lives</span>--;&#125;</span><br><span class="line">&gt;&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>cat.jumps()</code>方法是一个箭头函数, 这是错误的. 调用<code>cat.jumps()</code>时, 如果是普通函数, 该方法内部的 [ this ] 指向<code>cat</code>；如果写成上面那样的箭头函数, 使得 [ this ] 指向全局对象, 因此不会得到预期结果. 这是<code>因为对象不构成单独的作用域</code>, 导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域. </p></blockquote><p>第二个场合是需要动态 [ this ] 的时候, 也不应使用箭头函数. </p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">&gt;&gt;button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&gt;&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码运行时, 点击按钮会报错, 因为<code>button</code>的监听函数是一个箭头函数, 导致里面的 [ this ] 就是全局对象. 如果改成普通函数,  [ this ] 就会动态指向被点击的按钮对象. </p></blockquote><p>另外, 如果函数体很复杂, 有许多行, 或者函数内部有大量的读写操作, 不单纯是为了计算值, 这时也不应该使用箭头函数, 而是要使用普通函数, 这样可以提高代码可读性</p></blockquote><h4 id="④-嵌套的箭头函数"><a href="#④-嵌套的箭头函数" class="headerlink" title="④ 嵌套的箭头函数"></a>④ 嵌套的箭头函数</h4><blockquote><p>箭头函数内部, 还可以再使用箭头函数. 下面是一个 ES5 语法的多重嵌套函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="keyword">function</span> (<span class="params">array</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="keyword">function</span> (<span class="params">afterValue</span>) &#123;</span><br><span class="line">     array.<span class="title function_">splice</span>(array.<span class="title function_">indexOf</span>(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">     <span class="keyword">return</span> array;</span><br><span class="line">   &#125;&#125;;</span><br><span class="line"> &#125;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">insert</span>(<span class="number">2</span>).<span class="title function_">into</span>([<span class="number">1</span>, <span class="number">3</span>]).<span class="title function_">after</span>(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面这个函数, 可以使用箭头函数改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">insert</span> = (<span class="params">value</span>) =&gt; (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</span><br><span class="line"> array.<span class="title function_">splice</span>(array.<span class="title function_">indexOf</span>(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line"> <span class="keyword">return</span> array;</span><br><span class="line">&gt;&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">insert</span>(<span class="number">2</span>).<span class="title function_">into</span>([<span class="number">1</span>, <span class="number">3</span>]).<span class="title function_">after</span>(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-部署管道机制-pipeline"><a href="#a-部署管道机制-pipeline" class="headerlink" title="a) 部署管道机制 (pipeline)"></a>a) 部署管道机制 (pipeline)</h5><blockquote><p>下面是一个部署管道机制 (pipeline)的栗子 : <code>即前一个函数的输出是后一个函数的输入</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">pipeline</span> = (<span class="params">...funcs</span>) =&gt;</span><br><span class="line"> <span class="function"><span class="params">val</span> =&gt;</span> funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="title function_">b</span>(a), val);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">plus1</span> = a =&gt; a + <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">mult2</span> = a =&gt; a * <span class="number">2</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> addThenMult = <span class="title function_">pipeline</span>(plus1, mult2);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">addThenMult</span>(<span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差, 也可以采用下面的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">plus1</span> = a =&gt; a + <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">mult2</span> = a =&gt; a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">mult2</span>(<span class="title function_">plus1</span>(<span class="number">5</span>))</span><br><span class="line">&gt;<span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>箭头函数还有一个功能, 就是可以很方便地改写 λ 演算. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// λ演算的写法</span></span><br><span class="line">&gt;fix = λf.(λx.<span class="title function_">f</span>(λv.<span class="title function_">x</span>(x)(v)))(λx.<span class="title function_">f</span>(λv.<span class="title function_">x</span>(x)(v)))</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6的写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">fix</span> = f =&gt; (<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">x</span>(x)(v)))</span><br><span class="line">              (<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">x</span>(x)(v)));</span><br></pre></td></tr></table></figure><p>上面两种写法, 几乎是一一对应的. 由于 λ 演算对于计算机科学非常重要, 这使得我们可以用 ES6 作为替代工具, 探索计算机科学. </p></blockquote><h5 id="b-高阶函数"><a href="#b-高阶函数" class="headerlink" title="b) 高阶函数"></a>b) 高阶函数</h5><blockquote><p>在我的理解中,实际上高阶函数本质上就与  [ 部署管道机制 ] 殊途同归,此处列出是为了更好做对比,防止以后遇到混淆</p><p>所谓高阶函数:<code>就是一个函数就可以接收另一个函数作为参数, 或者是返回一个函数</code>–&gt;常见的高阶函数有map、reduce、filter、sort等</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> <span class="variable constant_">ADD</span> =<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123; <span class="keyword">return</span> a+b &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">调用: <span class="title function_">ADD</span>(<span class="number">2</span>)(<span class="number">3</span>)即可获得结果</span><br></pre></td></tr></table></figure><blockquote><p>map</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;map接受一个函数作为参数, 不改变原来的数组, 只是返回一个全新的数组</span><br><span class="line">&gt;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item = <span class="number">2</span>)<span class="comment">// 输出[1,1,1,1,1]</span></span><br></pre></td></tr></table></figure><blockquote><p>reduce</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;reduce也是返回一个全新的数组. reduce接受一个函数作为参数, 这个函数要有两个形参, 代表数组中的前两项 , reduce会将这个函数的结果与数组中的第三项再次组成这个函数的两个形参以此类推进行累积操作</span><br><span class="line">&gt;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&gt;<span class="keyword">var</span> arr2 = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span> a+b)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr2) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><blockquote><p>filter</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;filter返回过滤后的数组. filter也接收一个函数作为参数, 这个函数将作用于数组中的每个元素, 根据该函数每次执行后返回的布尔值来保留结果, 如果是<span class="literal">true</span>就保留, 如果是<span class="literal">false</span>就过滤掉（这点与map要区分）</span><br><span class="line">&gt;<span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr3 = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)<span class="comment">// [2,4]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-函数柯里化"><a href="#c-函数柯里化" class="headerlink" title="c) 函数柯里化"></a>c) 函数柯里化</h5><blockquote><p>此处列出是因为此知识点常与箭头函数搭配使用,而很多同学其实有在用却都不懂这个概念(大多数教程都不会刻意去普及概念),所以我觉得在此处列出,会对很多同学有所帮助,也能形成关联性更强的知识体系</p><blockquote><p>截取自网上的正解图例</p></blockquote><p> <img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210415161137977.png" alt="image-20210415161137977"></p><blockquote><p>关键就是<code>理解柯里化</code>, 其实可以把它理解成, 柯里化后, <code>将第一个参数变量存在函数里面了(闭包)</code>, 然后本来需要n个参数的函数可以变成只需要剩下的（n - 1个）参数就可以调用, 比如</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br><span class="line">&gt;<span class="keyword">let</span> add2 = <span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">&gt;------------ 一般调用 ------------------------</span><br><span class="line">&gt;<span class="comment">//本来完成 add 这个操作, 应该是这样调用</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y</span><br><span class="line">&gt;<span class="title function_">add</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&gt;------------- 柯里化后调用  ---------------------</span><br><span class="line">&gt;<span class="comment">// 而现在 add2 函数完成同样操作只需要一个参数, 这在函数式编程中广泛应用. </span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y</span><br><span class="line">&gt;<span class="keyword">let</span> add2 = <span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line">&gt;<span class="comment">//详细解释一下, 就是 add2 函数 等价于 有了 x 这个闭包变量的 y =&gt; x + y 函数,并且此时 x = 2 , 所以此时调用</span></span><br><span class="line">&gt;<span class="title function_">add2</span>(<span class="number">3</span>) === <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-从-ES6-高阶箭头函数理解函数柯里化以及-部署管道机制"><a href="#d-从-ES6-高阶箭头函数理解函数柯里化以及-部署管道机制" class="headerlink" title="d) 从 ES6 高阶箭头函数理解函数柯里化以及 [ 部署管道机制 ]"></a>d) 从 ES6 高阶箭头函数理解函数柯里化以及 [ 部署管道机制 ]</h5><blockquote><ol><li>首先看到了这样的一个栗子:</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">add</span> = a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> a + b</span><br></pre></td></tr></table></figure><ol start="2"><li>以上是一个很简单的相加函数, 把它转化成 ES5 的写法如下</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">b</span>) &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> add3 = <span class="title function_">add</span>(<span class="number">3</span>) <span class="comment">//add3表示一个指向函数的变量 可以当成函数调用名来用</span></span><br><span class="line">&gt;<span class="title function_">add3</span>(<span class="number">4</span>) === <span class="number">3</span> + <span class="number">4</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>再简化一下, 可以写成如下形式:</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> add = <span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> param = a;</span><br><span class="line">   <span class="keyword">var</span> innerFun = <span class="keyword">function</span>(<span class="params">b</span>) &#123; <span class="keyword">return</span> param + b; &#125;</span><br><span class="line">   <span class="keyword">return</span> innerFun;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>虽然好像没什么意义, 但是很显然上述使用了闭包, 而且该函数的返回值是一个函数. 其实, 这就是<code>高阶函数的定义: 以函数为参数或者返回值是函数的函数. </code></li></ol><p> <img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210415160945789.png" alt="image-20210415160945789"> </p></blockquote><h3 id="Ⅳ-rest-参数-常用"><a href="#Ⅳ-rest-参数-常用" class="headerlink" title="Ⅳ - rest 参数 (常用)"></a>Ⅳ - rest 参数 (<code>常用</code>)</h3><blockquote><p>ES6 引入 rest 参数（形式为<code>...变量名</code>）, 用于获取函数的多余参数, 这样就不需要使用<code>arguments</code>对象了. rest 参数搭配的变量是一个数组, 该变量将多余的参数放入数组中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">...values</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">   sum += val;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>add</code>函数是一个求和函数, 利用 rest 参数, 可以向该函数传入任意数目的参数. </p><p>下面是一个 rest 参数代替<code>arguments</code>变量的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// arguments变量的写法</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sortNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>).<span class="title function_">sort</span>();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// rest参数的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">sortNumbers</span> = (<span class="params">...numbers</span>) =&gt; numbers.<span class="title function_">sort</span>();</span><br></pre></td></tr></table></figure><p>上面代码的两种写法, 比较后可以发现 , rest 参数的写法更自然也更简洁. </p><p><code>arguments</code>对象不是数组, 而是一个类似数组的对象. 所以为了使用数组的方法, 必须使用<code>Array.prototype.slice.call</code>先将其转为数组. <code>rest 参数就不存在这个问题, 它就是一个真正的数组, 数组特有的方法都可以使用</code>. 下面是一个利用 rest 参数改写数组<code>push</code>方法的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line"> items.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">   array.<span class="title function_">push</span>(item);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> a = [];</span><br><span class="line">&gt;<span class="title function_">push</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>注意 , rest 参数之后不能再有其他参数（即只能是最后一个参数）, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, ...b, c</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>函数的<code>length</code>属性, 不包括 rest 参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">a</span>) &#123;&#125;).<span class="property">length</span>  <span class="comment">// 1</span></span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">...a</span>) &#123;&#125;).<span class="property">length</span>  <span class="comment">// 0</span></span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params">a, ...b</span>) &#123;&#125;).<span class="property">length</span>  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-严格模式"><a href="#Ⅴ-严格模式" class="headerlink" title="Ⅴ - 严格模式"></a>Ⅴ - 严格模式</h3><blockquote><p>从 ES5 开始, 函数内部可以设定为严格模式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>ES2016 做了一点修改, <code>规定只要函数参数使用了默认值、解构赋值、或者扩展运算符, 那么函数内部就不能显式设定为严格模式, 否则会报错</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> doSomething = <span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">doSomething</span> = (<span class="params">...a</span>) =&gt; &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="comment">// 报错</span></span><br><span class="line"> <span class="title function_">doSomething</span>(<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">   <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">   <span class="comment">// code</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>这样规定的原因是, 函数内部的严格模式, 同时适用于函数体和函数参数. 但是, 函数执行的时候, 先执行函数参数, 然后再执行函数体. 这样就有一个不合理的地方, 只有从函数体之中, 才能知道参数是否应该以严格模式执行, 但是参数却应该先于函数体执行. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">value = <span class="number">070</span></span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>value</code>的默认值是八进制数<code>070</code>, 但是严格模式下不能用前缀<code>0</code>表示八进制, 所以应该报错. 但是实际上 , JavaScript 引擎会先成功执行<code>value = 070</code>, 然后进入函数体内部, 发现需要用严格模式执行, 这时才会报错. </p><p>虽然可以先解析函数体代码, 再执行参数代码, 但是这样无疑就增加了复杂性. 因此, 标准索性禁止了这种用法, 只要参数使用了默认值、解构赋值、或者扩展运算符, 就不能显式指定严格模式. </p><p>两种方法可以规避这种限制. 第一种是设定全局性的严格模式, 这是合法的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line"> <span class="comment">// code</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>第二种是把函数包在一个无参数的立即执行函数里面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> doSomething = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">value = <span class="number">42</span></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> value;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;());</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅵ-name-属性"><a href="#Ⅵ-name-属性" class="headerlink" title="Ⅵ - name 属性"></a>Ⅵ - name 属性</h3><blockquote><p>函数的<code>name</code>属性, 返回该函数的函数名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;foo.<span class="property">name</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><p>这个属性早就被浏览器广泛支持, 但是直到 ES6 , 才将其写入了标准. </p><p>需要注意的是 , ES6 对这个属性的行为做出了一些修改. 如果将一个匿名函数赋值给一个变量 , ES5 的<code>name</code>属性, 会返回空字符串, 而 ES6 的<code>name</code>属性会返回实际的函数名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量 [ f ] 等于一个匿名函数 , ES5 和 ES6 的<code>name</code>属性返回的值不一样. </p><p>如果将一个具名函数赋值给一个变量, 则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> bar = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p><code>Function</code>构造函数返回的函数实例, <code>name</code>属性的值为<code>anonymous</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">new</span> <span class="title class_">Function</span>).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数, <code>name</code>属性值会加上<code>bound</code>前缀. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&gt;foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅶ-尾调用优化"><a href="#Ⅶ-尾调用优化" class="headerlink" title="Ⅶ - 尾调用优化"></a>Ⅶ - 尾调用优化</h3><blockquote><p>此处如果看不懂可以暂时跳过或者粗略看下,此部分一般情况不会用到:</p><p>尾调用优化默认关闭,各大浏览器（除了<code>safari</code>）根本就没部署尾调用优化；</p></blockquote><h4 id="①-什么是尾调用"><a href="#①-什么是尾调用" class="headerlink" title="① 什么是尾调用?"></a>① 什么是尾调用?</h4><blockquote><p>尾调用（Tail Call）是函数式编程的一个重要概念, 本身非常简单, 一句话就能说清楚, 就是指某个函数的最后一步是调用另一个函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">g</span>(x);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 函数 [ f ] 的最后一步是调用函数 [ g ] , 这就叫尾调用. </p><p>以下三种情况, 都不属于尾调用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 情况一</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> y = <span class="title function_">g</span>(x);</span><br><span class="line"> <span class="keyword">return</span> y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况二</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">g</span>(x) + <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况三</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="title function_">g</span>(x);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 情况一是调用函数 [ g ] 之后, 还有赋值操作, 所以不属于尾调用, 即使语义完全一样. 情况二也属于调用后还有操作, 即使写在一行内. <code>情况三等同于下面的代码</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="title function_">g</span>(x);</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>尾调用不一定出现在函数尾部, 只要是最后一步操作即可</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">m</span>(x)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">n</span>(x);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>m</code>和<code>n</code>都属于尾调用, 因为它们都是函数 [ f ] 的最后一步操作</p></blockquote><h4 id="②-尾调用优化"><a href="#②-尾调用优化" class="headerlink" title="② 尾调用优化"></a>② 尾调用优化</h4><blockquote><p>尾调用之所以与其他调用不同, 就在于它的特殊的调用位置. </p><p>我们知道, <code>函数调用会在内存形成一个&#39;调用记录&#39;, 又称 [调用帧 (call frame)]</code>, 保存调用位置和内部变量等信息. 如果在函数 [ A ] 的内部调用函数 [ B ] , 那么在 [ A ] 的调用帧上方, 还会形成一个 [ B ] 的调用帧. 等到 [ B ] 运行结束, 将结果返回到 [ A ] ,  [ B ] 的调用帧才会消失. 如果函数 [ B ] 内部还调用函数 [ C ] , 那就还有一个 [ C ] 的调用帧, 以此类推. <code>所有的调用帧, 就形成一个[调用栈 (call stack)]</code>. </p><p>尾调用由于是函数的最后一步操作, 所以不需要保留外层函数的调用帧, 因为调用位置、内部变量等信息都不会再用到了, <code>只要直接用内层函数的调用帧, 取代外层函数的调用帧就可以了</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">g</span>(m + n);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="title function_">g</span>(<span class="number">3</span>);&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title function_">g</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 如果函数 [ g ] 不是尾调用, 函数 [  f  ] 就需要保存内部变量<code>m</code>和<code>n</code>的值、 [ g ] 的调用位置等信息. 但由于调用 [ g ] 之后, 函数 [ <code>f</code> ] 就结束了, 所以执行到最后一步, 完全可以删除<code>f(x)</code>的调用帧, 只保留<code>g(3)</code>的调用帧. </p><p><code>这就叫做[尾调用优化 (Tail call optimization)]</code>:即只保留内层函数的调用帧. 如果所有函数都是尾调用, 那么完全可以做到每次执行时, 调用帧只有一项, 这将大大节省内存. 这就是“尾调用优化”的意义. </p><p>注意, 只有不再用到外层函数的内部变量, 内层函数的调用帧才会取代外层函数的调用帧, 否则就无法进行“尾调用优化”. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">addOne</span>(<span class="params">a</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params">b</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> b + one;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">inner</span>(a);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化, 因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>. </p></blockquote><h4 id="③-尾递归"><a href="#③-尾递归" class="headerlink" title="③ 尾递归"></a>③ 尾递归</h4><blockquote><p>函数调用自身, 称为递归. 如果尾调用自身, 就称为尾递归. </p><p><code>递归非常耗费内存</code>, 因为需要同时保存成千上百个调用帧, 很容易发生[ 栈溢出错误 (stack overflow)]. <code>但对于尾递归来说, 由于只存在一个调用帧, 所以永远不会发生&#39;栈溢出&#39;错误</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> n * <span class="title function_">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码是一个阶乘函数, 计算<code>n</code>的阶乘, 最多需要保存<code>n</code>个调用记录, 复杂度 O(n) . </p><p>如果改写成尾递归, 只保留一个调用记录, 复杂度 O(1) . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>还有一个比较著名的栗子, 就是计算 Fibonacci 数列, 也能充分说明尾递归优化的重要性. </p><p>非尾递归的 Fibonacci 数列实现如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Fibonacci</span> (n) &#123;</span><br><span class="line"> <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>) + <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Fibonacci</span>(<span class="number">10</span>) <span class="comment">// 89</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci</span>(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci</span>(<span class="number">500</span>) <span class="comment">// 超时</span></span><br></pre></td></tr></table></figure><p>尾递归优化过的 Fibonacci 数列实现如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Fibonacci2</span> (n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Fibonacci2</span> (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Fibonacci2</span>(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci2</span>(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line">&gt;<span class="title class_">Fibonacci2</span>(<span class="number">10000</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>由此可见, [ 尾调用优化 ]对递归操作意义重大, 所以一些函数式编程语言将其写入了语言规格. ES6 亦是如此, 第一次明确规定, 所有 ECMAScript 的实现, 都必须部署 [ 尾调用优化 ]. 这就是说, <code>ES6 中只要使用尾递归, 就不会发生栈溢出 (或者层层递归造成的超时), 相对节省内存</code>. </p></blockquote><h4 id="④-递归函数的改写"><a href="#④-递归函数的改写" class="headerlink" title="④ 递归函数的改写"></a>④ 递归函数的改写</h4><blockquote><p>尾递归的实现, 往往需要改写递归函数, 确保最后一步只调用自身. 做到这一点的方法, 就是把所有用到的内部变量改写成函数的参数. 比如上面的栗子, 阶乘函数 factorial 需要用到一个中间变量<code>total</code>, 那就把这个中间变量改写成函数的参数. 这样做的缺点就是不太直观, 第一眼很难看出来 : 为什么计算<code>5</code>的阶乘, 需要传入两个参数<code>5</code>和<code>1</code>？</p><p>两个方法可以解决这个问题. 方法一是在尾递归函数之外, 再提供一个正常形式的函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123; <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码通过一个正常形式的阶乘函数<code>factorial</code>, 调用尾递归函数<code>tailFactorial</code>, 看起来就正常多了. </p><p>函数式编程有一个概念, 叫做<code>柯里化 (currying)</code>, 意思是将多参数的函数转换成单参数的形式. 这里也可以使用柯里化. –&gt;不懂的看上方[④ 嵌套的箭头函数中的函数柯里化](#④ 嵌套的箭头函数 ) </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn, n</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, m, n);</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tailFactorial</span>(<span class="params">n, total</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">tailFactorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> factorial = <span class="title function_">currying</span>(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码通过柯里化, 将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>. </p><p>第二种方法就简单多了, 就是采用 ES6 的函数默认值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">factorial</span>(n - <span class="number">1</span>, n * total);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">factorial</span>(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码中, 参数<code>total</code>有默认值<code>1</code>, 所以调用时不用提供这个值. </p><p>总结一下, 递归本质上是一种循环操作. 纯粹的函数式编程语言没有循环操作命令, 所有的循环都用递归实现, 这就是为什么尾递归对这些语言极其重要. 对于其他支持“尾调用优化”的语言（比如 Lua , ES6）, <code>只需要知道循环可以用递归代替, 而一旦使用递归, 就最好使用尾递归</code>. </p></blockquote><h4 id="⑤-严格模式"><a href="#⑤-严格模式" class="headerlink" title="⑤ 严格模式"></a>⑤ 严格模式</h4><blockquote><p><code>ES6 的尾调用优化只在严格模式下开启, 正常模式是无效的</code>. </p><p>这是因为在正常模式下, 函数内部有两个变量, 可以跟踪函数的调用栈. </p><ul><li><code>func.arguments</code>: 返回调用时函数的参数. </li><li><code>func.caller</code>: 返回调用当前函数的那个函数.</li></ul><p>尾调用优化发生时, 函数的调用栈会改写, 因此上面两个变量就会失真. 严格模式禁用这两个变量, 所以尾调用模式仅在严格模式下生效. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">restricted</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"> restricted.<span class="property">caller</span>;    <span class="comment">// 报错</span></span><br><span class="line"> restricted.<span class="property">arguments</span>; <span class="comment">// 报错</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">restricted</span>();</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-利用-循环-替换-尾递归-优化的实现"><a href="#⑥-利用-循环-替换-尾递归-优化的实现" class="headerlink" title="⑥ 利用 循环 替换 尾递归 优化的实现"></a>⑥ 利用 循环 替换 尾递归 优化的实现</h4><blockquote><p>尾递归优化只在严格模式下生效, 那么正常模式下, 或者那些不支持该功能的环境中, 有没有办法也使用尾递归优化呢？回答是可以的, 就是自己实现尾递归优化. </p><p>它的原理非常简单. 尾递归之所以需要优化, 原因是调用栈太多, 造成溢出, 那么只要减少调用栈, 就不会溢出. 怎么做可以减少调用栈呢？<code>就是采用 [循环] 换掉 [递归]</code>. </p><p>下面是一个正常的递归函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (y &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>  <span class="keyword">return</span> x;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">&gt;<span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br><span class="line">&gt;<span class="comment">// 未捕获的RangeError:最大调用堆栈大小超过(…)  </span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>sum</code>是一个递归函数, 参数<code>x</code>是需要累加的值, 参数<code>y</code>控制递归次数. 一旦指定<code>sum</code>递归 100000 次, 就会报错, 提示超出调用栈的最大次数. </p></blockquote><h5 id="a-蹦床函数"><a href="#a-蹦床函数" class="headerlink" title="a)  蹦床函数"></a>a)  蹦床函数</h5><blockquote><p>蹦床函数（trampoline）可以将递归执行转为循环执行. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">trampoline</span>(<span class="params">f</span>) &#123;</span><br><span class="line"> <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="title class_">Function</span>) &#123; f = <span class="title function_">f</span>();&#125;</span><br><span class="line"> <span class="keyword">return</span> f;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面就是蹦床函数的一个实现, 它接受一个函数<code>f</code>作为参数. 只要<code>f</code>执行后返回一个函数, 就继续执行. </p><p>注意:<code>这里是返回一个函数, 然后执行该函数, 而不是函数里面调用函数, 这样就避免了递归执行, 从而就消除了调用栈过大的问题</code>. </p><p>然后, 要做的就是将原来的递归函数, 改写为每一步返回另一个函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (y &gt; <span class="number">0</span>)  <span class="keyword">return</span> sum.<span class="title function_">bind</span>(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>sum</code>函数的每次执行, 都会返回自身的另一个版本. </p><p>现在, 使用蹦床函数执行<code>sum</code>, 就不会发生调用栈溢出. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">trampoline</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line">&gt;<span class="comment">// 100001</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-真正的尾递归优化"><a href="#b-真正的尾递归优化" class="headerlink" title="b) 真正的尾递归优化"></a>b) 真正的尾递归优化</h5><blockquote><p>蹦床函数并不是真正的尾递归优化, 下面的实现才是. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tco</span>(<span class="params">f</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> value;</span><br><span class="line"> <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">accumulator</span>(<span class="params"></span>) &#123;</span><br><span class="line">   accumulated.<span class="title function_">push</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">   <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">     active = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">while</span> (accumulated.<span class="property">length</span>) &#123;</span><br><span class="line">       value = f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, accumulated.<span class="title function_">shift</span>());</span><br><span class="line">     &#125;</span><br><span class="line">     active = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> sum = <span class="title function_">tco</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (y &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="title function_">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">return</span> x</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">&gt;<span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>tco</code>函数是尾递归优化的实现, 它的奥妙就在于状态变量<code>active</code>. 默认情况下, 这个变量是不激活的. 一旦进入尾递归优化的过程, 这个变量就激活了. 然后, 每一轮递归<code>sum</code>返回的都是 <strong>undefined</strong> , 所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数, 总是有值的, 这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行. 这样就很巧妙地将“递归”改成了“循环”, 而后一轮的参数会取代前一轮的参数, 保证了调用栈只有一层. </p></blockquote><h4 id="⑦-尾调用优化默认关闭"><a href="#⑦-尾调用优化默认关闭" class="headerlink" title="⑦ 尾调用优化默认关闭"></a>⑦ 尾调用优化默认关闭</h4><blockquote><p>看到这想必一定很好奇, 既然尾调用优化如此高效, 为何都默认关闭了这个特性呢？答案分为两方面: </p><ol><li>** <code>隐式优化问题</code> **: 由于引擎消除尾递归是隐式的, 函数是否符合尾调用而被消除了尾递归很难被程序员自己辨别；</li><li>** <code>调用栈丢失问题</code> **: 尾调用优化要求除掉尾调用执行时的调用堆栈, 这将导致执行流中的堆栈信息丢失.</li></ol><p>Chrome下使用尾递归写法的方法依旧出现调用栈溢出的原因在于: </p><ol><li>直接原因:  各大浏览器（除了<code>safari</code>）根本就没部署尾调用优化；</li><li>根本原因:  尾调用优化依旧有隐式优化和调用栈丢失的问题；</li></ol><p>既然尾调用优化是默认关闭的, 是不是说尾调用没什么用了呢？</p><blockquote><p>其实不然, 尾调用是函数式编程一个重要的概念, 合理的应用尾调用可以大大提高我们代码的可读性和可维护性, 相比带来的一点性能损失, 写更优雅更易读的代码更为的重要</p></blockquote></blockquote><h2 id="7、对象的拓展"><a href="#7、对象的拓展" class="headerlink" title="7、对象的拓展"></a>7、对象的拓展</h2><h3 id="Ⅰ-概括总结-4"><a href="#Ⅰ-概括总结-4" class="headerlink" title="Ⅰ- 概括总结"></a>Ⅰ- 概括总结</h3><blockquote><blockquote><p><strong>对象的新增方法与用法</strong></p></blockquote><ol><li><strong>简洁表示法</strong>: 直接写入变量和函数作为对象的属性和方法(<code>&#123; prop, method() &#123;&#125; &#125;</code>)</li><li><strong>属性名表达式</strong>: 字面量定义对象时使用<code>[]</code>定义键(<code>[prop]</code>, 不能与上同时使用)</li><li><strong>方法的name属性</strong>: 返回方法函数名 –&gt;此处与函数很像,因为本质上函数就是一种特殊对象</li></ol><ul><li>取值函数(getter)和存值函数(setter): <code>get/set 函数名</code>(属性的描述对象在<code>get</code>和<code>set</code>上)</li><li>bind返回的函数: <code>bound 函数名</code></li><li>Function构造函数返回的函数实例: <code>anonymous</code></li></ul><ol start="4"><li><strong>属性的可枚举性和遍历</strong>: 描述对象的<code>enumerable</code></li><li><strong>super关键字</strong>: 指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li><li><strong>Object.is()</strong>: 对比两值是否相等</li><li><strong>Object.assign()</strong>: 合并对象(浅拷贝), 返回原对象  (<code>常用</code>)</li><li><strong>Object.getPrototypeOf()</strong>: 返回对象的原型对象</li><li><strong>Object.setPrototypeOf()</strong>: 设置对象的原型对象</li><li><strong><strong>proto</strong></strong>: 返回或设置对象的原型对象</li></ol><blockquote><p><strong>属性遍历</strong></p></blockquote><ol><li>描述: <code>自身</code>、<code>可继承</code>、<code>可枚举</code>、<code>非枚举</code>、<code>Symbol</code></li><li>遍历</li></ol><ul><li>[ for-in ] : 遍历对象<code>自身可继承可枚举</code>属性</li><li>[Object.keys()] : 返回对象<code>自身可枚举</code>属性键 [ key ] 组成的数组</li><li>[Object.getOwnPropertyNames()] : 返回对象<code>自身非Symbol</code>属性键 [ key ] 组成的数组</li><li><code>Object.getOwnPropertySymbols()</code>: 返回对象<code>自身Symbol</code>属性键 [ key ] 组成的数组</li><li><code>Reflect.ownKeys()</code>: 返回对象<code>自身全部</code>属性键 [ key ] 组成的数组</li></ul><ol start="3"><li>规则</li></ol><ul><li>首先遍历所有数值键, 按照数值升序排列</li><li>其次遍历所有字符串键, 按照加入时间升序排列</li><li>最后遍历所有Symbol键, 按照加入时间升序排列</li></ul></blockquote><h3 id="Ⅱ-属性的简洁表示"><a href="#Ⅱ-属性的简洁表示" class="headerlink" title="Ⅱ - 属性的简洁表示"></a>Ⅱ - 属性的简洁表示</h3><h4 id="①-属性的简写"><a href="#①-属性的简写" class="headerlink" title="① 属性的简写"></a>① 属性的简写</h4><blockquote><p>ES6 允许在大括号里面, 直接写入变量和函数, 作为对象的属性和方法. 这样的书写更加简洁. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">&gt;<span class="comment">//baz == &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>foo</code>直接写在大括号里面. 这时, 属性名就是变量名, 属性值就是变量值. 下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> &#123;x, y&#125;;&#125;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-方法的简写"><a href="#②-方法的简写" class="headerlink" title="② 方法的简写"></a>② 方法的简写</h4><blockquote><p>除了属性简写, 方法也可以简写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> o = &#123;</span><br><span class="line">&gt;<span class="title function_">method</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> o = &#123;</span><br><span class="line">&gt;<span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>; &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个实际的栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> birth = <span class="string">&#x27;2000/01/01&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">&gt;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&gt;<span class="comment">//等同于birth: birth</span></span><br><span class="line">&gt;birth,</span><br><span class="line">&gt;<span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">&gt;<span class="title function_">hello</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>); &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值, 将会非常方便. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getPoint</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">getPoint</span>()</span><br><span class="line">&gt;<span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-简洁写法在CommonJS-模块的应用"><a href="#③-简洁写法在CommonJS-模块的应用" class="headerlink" title="③ 简洁写法在CommonJS 模块的应用"></a>③ 简洁写法在CommonJS 模块的应用</h4><blockquote><p>CommonJS 模块输出一组变量, 就非常合适使用简洁写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getItem</span> (key) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>; <span class="comment">//属性名表达式+三元表达式</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">setItem</span> (key, value) &#123;</span><br><span class="line">&gt;ms[key] = value;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">clear</span> () &#123;</span><br><span class="line">&gt;ms = &#123;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = &#123; getItem, setItem, clear &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">&gt;<span class="attr">getItem</span>: getItem,</span><br><span class="line">&gt;<span class="attr">setItem</span>: setItem,</span><br><span class="line">&gt;<span class="attr">clear</span>: clear</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-简洁写法在-属性-赋值器-和-取值器-中的应用"><a href="#④-简洁写法在-属性-赋值器-和-取值器-中的应用" class="headerlink" title="④ 简洁写法在 属性 赋值器 和 取值器 中的应用"></a>④ 简洁写法在 属性 赋值器 和 取值器 中的应用</h4><blockquote><p>属性的赋值器（setter）和取值器（getter）, 事实上也是采用这种写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> cart = &#123;</span><br><span class="line">&gt;<span class="attr">_wheels</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">&gt;get wheels () &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_wheels</span>;</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;set wheels (value) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">_wheels</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;数值太小了！&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">_wheels</span> = value;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-简洁写法在打印对象时的应用"><a href="#⑤-简洁写法在打印对象时的应用" class="headerlink" title="⑤ 简洁写法在打印对象时的应用"></a>⑤ 简洁写法在打印对象时的应用</h4><blockquote><p>简洁写法在打印对象时也很有用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> user = &#123;<span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(user, foo)</span><br><span class="line">&gt;<span class="comment">// &#123;name: &quot;test&quot;&#125; &#123;bar: &quot;baz&quot;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;user, foo&#125;)</span><br><span class="line">&gt;<span class="comment">// &#123;user: &#123;name: &quot;test&quot;&#125;, foo: &#123;bar: &quot;baz&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>console.log</code>直接输出<code>user</code>和<code>foo</code>两个对象时, 就是两组键值对, 可能会混淆. 把它们放在大括号里面输出, 就变成了对象的简洁表示法, 每组键值对前面会打印对象名, 这样就比较清晰了. </p><p>注意, 简写的对象方法不能用作构造函数, 会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="params"></span>) &#123;<span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">new</span> obj.<span class="title function_">f</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>f</code>是一个简写的对象方法, 所以<code>obj.f</code>不能当作构造函数使用. </p></blockquote><h3 id="Ⅲ-方法的-name-属性"><a href="#Ⅲ-方法的-name-属性" class="headerlink" title="Ⅲ - 方法的 name 属性"></a>Ⅲ - 方法的 name 属性</h3><blockquote><p>与函数拓展中的name差不多,可以稍微过一眼即可</p><p>函数的<code>name</code>属性, 返回函数名. 对象方法也是函数, 因此也有<code>name</code>属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> person = &#123;</span><br><span class="line"> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;person.<span class="property">sayName</span>.<span class="property">name</span>   <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 方法的<code>name</code>属性返回函数名（即方法名）. </p><p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>）, 则<code>name</code>属性不是在该方法上面, 而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面, 返回值是方法名前加上<code>get</code>和<code>set</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">foo</span>() &#123;&#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;obj.<span class="property">foo</span>.<span class="property">name</span></span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//返回指定对象上一个自有属性对应的属性描述符. （自有属性指的是直接赋予该对象的属性, 不需要从原型链上进行查找的属性）</span></span><br><span class="line"></span><br><span class="line">&gt;descriptor.<span class="property">get</span>.<span class="property">name</span> <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">&gt;descriptor.<span class="property">set</span>.<span class="property">name</span> <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure><p>有两种特殊情况: <code>bind</code>方法创造的函数, <code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数, <code>name</code>属性返回<code>anonymous</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span> <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> doSomething = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;doSomething.<span class="title function_">bind</span>().<span class="property">name</span> <span class="comment">// &quot;bound doSomething&quot;</span></span><br></pre></td></tr></table></figure><p>如果对象的方法是一个 Symbol 值, 那么<code>name</code>属性返回的是这个 Symbol 值的描述. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> key1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> key2 = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [key1]() &#123;&#125;,</span><br><span class="line"> [key2]() &#123;&#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;obj[key1].<span class="property">name</span> <span class="comment">// &quot;[description]&quot;</span></span><br><span class="line">&gt;obj[key2].<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>key1</code>对应的 Symbol 值有描述, <code>key2</code>没有. </p></blockquote><h3 id="Ⅳ-属性的可枚举性和遍历"><a href="#Ⅳ-属性的可枚举性和遍历" class="headerlink" title="Ⅳ - 属性的可枚举性和遍历"></a>Ⅳ - 属性的可枚举性和遍历</h3><h4 id="①-可枚举性"><a href="#①-可枚举性" class="headerlink" title="① 可枚举性"></a>① 可枚举性</h4><blockquote><p>对象的每个属性都有一个描述对象（Descriptor）, 用来控制该属性的行为.   [ Object.getOwnPropertyDescriptor ] 方法可以获取该属性的描述对象.   –&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">详见,点我传送</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">//  &#123;</span></span><br><span class="line">&gt;<span class="comment">//    value: 123,</span></span><br><span class="line">&gt;<span class="comment">//    writable: true,</span></span><br><span class="line">&gt;<span class="comment">//    enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//    configurable: true</span></span><br><span class="line">&gt;<span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><p>描述对象的<code> [ enumerable ] 属性, 称为“可枚举性”</code>, 如果该属性为 [ false ], 就表示某些操作会忽略当前属性. </p><p>目前, 有四个操作会忽略<code>enumerable</code>为 [ false ] 的属性. </p><ol><li><strong>for…in循环</strong>: 只遍历对象自身的和继承的可枚举的属性. </li><li><strong>Object.keys()</strong>: 返回对象自身的所有可枚举的属性的键名. </li><li><strong>JSON.stringify()</strong>: 只串行化对象自身的可枚举的属性. </li><li><strong>Object.assign()</strong>:  忽略<code>enumerable</code>为<code>false</code>的属性, 只拷贝对象自身的可枚举的属性.</li></ol><p>这四个操作之中, 前三个是 ES5 就有的, 最后一个 [ Object.assign() ] 是 ES6 新增的. 其中, 只有<code>for...in</code>会返回继承的属性, 其他三个方法都会忽略继承的属性, 只处理对象自身的属性. 实际上, 引入“可枚举”（<code>enumerable</code>）这个概念的最初目的, 就是让某些属性可以规避掉<code>for...in</code>操作, 不然所有内部属性和方法都会被遍历到. 比如, 对象原型的<code>toString</code>方法, 以及数组的<code>length</code>属性, 就通过“可枚举性”, 从而避免被<code>for...in</code>遍历到. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;toString&#x27;</span>).<span class="property">enumerable</span></span><br><span class="line">&gt;<span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>([], <span class="string">&#x27;length&#x27;</span>).<span class="property">enumerable</span></span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>, 因此<code>for...in</code>不会遍历到这两个继承自原型的属性. </p><p>另外 , ES6 规定, 所有 Class 的原型的方法都是不可枚举的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="keyword">class</span> &#123;<span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;&#125;.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;foo&#x27;</span>).<span class="property">enumerable</span></span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>总的来说, 操作中引入继承的属性会让问题复杂化, 大多数时候, 我们只关心对象自身的属性. 所以, <code>尽量不要用 [ for...in ] 循环, 而用 [ Object.keys() ] 代替</code>. </p></blockquote><h4 id="②-属性的遍历方法"><a href="#②-属性的遍历方法" class="headerlink" title="② 属性的遍历方法"></a>② 属性的遍历方法</h4><blockquote><p>ES6 一共有 5 种方法可以遍历对象的属性. </p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）. </p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组, 包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名. </p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组, 包含对象自身的所有属性（不含 Symbol 属性, 但是包括不可枚举属性）的键名. </p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组, 包含对象自身的所有 Symbol 属性的键名. </p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组, 包含对象自身的（不含继承的）所有键名, 不管键名是 Symbol 或字符串, 也不管是否可枚举. </p><p>以上的 5 种方法遍历对象的键名, 都遵守同样的属性遍历的次序规则. </p><ol><li>首先遍历所有数值键, 按照数值升序排列. </li><li>其次遍历所有字符串键, 按照加入时间升序排列. </li><li>最后遍历所有 Symbol 键, 按照加入时间升序排列.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(&#123; [<span class="title class_">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line">&gt;<span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Reflect.ownKeys</code>方法返回一个数组, 包含了参数对象的所有属性. 这个数组的属性次序是这样的, 首先是数值属性<code>2</code>和<code>10</code>, 其次是字符串属性<code>b</code>和<code>a</code>, 最后是 Symbol 属性. </p></blockquote><h3 id="Ⅴ-super-关键字"><a href="#Ⅴ-super-关键字" class="headerlink" title="Ⅴ- super 关键字"></a>Ⅴ- super 关键字</h3><blockquote><p>我们知道, <code>this</code>关键字总是指向函数所在的当前对象 , ES6 又新增了另一个类似的关键字 [ super ], <code>指向当前对象的原型对象</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proto = &#123; <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line"> <span class="title function_">find</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line">&gt;obj.<span class="title function_">find</span>() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>obj.find()</code>方法之中, 通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性. </p><p>注意, <code>super</code>关键字表示原型对象时, 只能用在对象的方法之中, 用在其他地方都会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="function">() =&gt;</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">foo</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面三种<code>super</code>的用法都会报错, 因为对于 JavaScript 引擎来说, 这里的<code>super</code>都没有用在对象的方法之中. 第一种写法是<code>super</code>用在属性里面, 第二种和第三种写法是<code>super</code>用在一个函数里面, 然后赋值给<code>foo</code>属性. 目前, 只有对象方法的简写法可以让 JavaScript 引擎确认, 定义的是对象的方法. </p><p>JavaScript 引擎内部, <code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proto = &#123;</span><br><span class="line"> <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">x</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line"> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>.<span class="title function_">foo</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line"></span><br><span class="line">&gt;obj.<span class="title function_">foo</span>() <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法, 但是绑定的<code>this</code>却还是当前对象<code>obj</code>, 因此输出的就是<code>world</code>. </p></blockquote><h3 id="Ⅵ-对象的拓展运算符"><a href="#Ⅵ-对象的拓展运算符" class="headerlink" title="Ⅵ -  对象的拓展运算符  ( ... )"></a>Ⅵ -  对象的拓展运算符  ( <code>...</code> )</h3><blockquote><h6 id="解构赋值的拷贝是浅拷贝-即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用-而不是这个值的副本"><a href="#解构赋值的拷贝是浅拷贝-即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用-而不是这个值的副本" class="headerlink" title="解构赋值的拷贝是浅拷贝, 即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用, 而不是这个值的副本."></a><code>解构赋值的拷贝是浅拷贝</code>, 即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用, 而不是这个值的副本.</h6><p>所以如果你想实现深拷贝,而里面的属性是对象,那么就不应该用赋值解构,除非第一层就是字符串,因为如果属性是对应,它存的对应属性就是引用类型</p><p>它相当于创建了一个新的对象,但是对象属性仍是之前的引用地址,会造成错误</p><p>可以使用 <code>JSON.parse()</code> 代替实现深拷贝 只是没有原型了</p></blockquote><h4 id="①-对象的赋值解构"><a href="#①-对象的赋值解构" class="headerlink" title="① 对象的赋值解构"></a>① 对象的赋值解构</h4><blockquote><p>对象的解构赋值用于从一个对象取值, 相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性, 分配到指定的对象上面. 所有的键和它们的值, 都会拷贝到新对象上面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">&gt;<span class="comment">//x == 1</span></span><br><span class="line">&gt;<span class="comment">//y == 2</span></span><br><span class="line">&gt;<span class="comment">//z == &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量 [ z ] 是解构赋值所在的对象. 它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>）, 将它们连同值一起拷贝过来. </p><p>由于解构赋值要求等号右边是一个对象, 所以如果等号右边是 <strong>undefined</strong> 或 <strong>null</strong> , 就会报错, 因为它们无法转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; ...z &#125; = <span class="literal">null</span>; <span class="comment">// 运行时错误</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; ...z &#125; = <span class="literal">undefined</span>; <span class="comment">// 运行时错误</span></span><br></pre></td></tr></table></figure><p>解构赋值必须是最后一个参数, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; ...x, y, z &#125; = someObject; <span class="comment">// 句法错误</span></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; x, ...y, ...z &#125; = someObject; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure><p>上面代码中, 解构赋值不是最后一个参数, 所以会报错. </p><p>注意 : <code>解构赋值的拷贝是浅拷贝</code>, 即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用, 而不是这个值的副本. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">&gt;obj.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>; <span class="comment">//对原对象进行修改操作</span></span><br><span class="line">&gt;x.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2  赋值解构出来的[x]对应的值也同样进行了修改</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>x</code>是解构赋值所在的对象, 拷贝了对象<code>obj</code>的<code>a</code>属性. <code>a</code>属性引用了一个对象, 修改这个对象的值, 会影响到解构赋值对它的引用. </p></blockquote><h4 id="②-扩展运算符的解构赋值"><a href="#②-扩展运算符的解构赋值" class="headerlink" title="② 扩展运算符的解构赋值"></a>② 扩展运算符的解构赋值</h4><blockquote><p>另外, 扩展运算符的解构赋值, 不能复制继承自原型对象的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;o2.<span class="property">__proto__</span> = o1;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">&gt;o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">&gt;o3.<span class="property">a</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>o3</code>复制了<code>o2</code>, 但是只复制了<code>o2</code>自身的属性, 没有复制它的原型对象<code>o1</code>的属性. </p><p>下面是另一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">&gt;o.<span class="property">z</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> &#123; x, ...newObj &#125; = o;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123; y, z &#125; = newObj;</span><br><span class="line">&gt;x <span class="comment">// 1</span></span><br><span class="line">&gt;y <span class="comment">// undefined</span></span><br><span class="line">&gt;z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>x</code>是单纯的解构赋值, 所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值, 只能读取对象<code>o</code>自身的属性, 所以变量<code>z</code>可以赋值成功, 变量<code>y</code>取不到值. ES6 规定, 变量声明语句之中, 如果使用解构赋值, 扩展运算符后面必须是一个变量名, 而不能是一个解构赋值表达式, 所以上面代码引入了中间变量<code>newObj</code>, 如果写成下面这样会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">&gt;<span class="comment">// SyntaxError: ... must be followed by an identifier in declaration contexts</span></span><br><span class="line">&gt;<span class="comment">// SyntaxError:… 在声明上下文中必须后跟标识符  </span></span><br></pre></td></tr></table></figure><p>解构赋值的一个用处, 是扩展某个函数的参数, 引入其他操作. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">&gt;<span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">baseFunction</span>(restConfig);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数, 函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展, 能够接受多余的参数, 并且保留原始函数的行为. </p></blockquote><h4 id="③-扩展运算符"><a href="#③-扩展运算符" class="headerlink" title="③ 扩展运算符"></a>③ 扩展运算符</h4><blockquote><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性, 拷贝到当前对象之中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">&gt;<span class="comment">// n == &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure><p>由于数组是特殊的对象, 所以对象的扩展运算符也可以用于数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> foo = &#123; ...[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] &#125;;</span><br><span class="line">&gt;foo</span><br><span class="line">&gt;<span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空对象, 则没有任何效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line">&gt;<span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>如果扩展运算符后面不是对象, 则会自动将其转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(1)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="number">1</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 扩展运算符后面是整数<code>1</code>, 会自动转为数值的包装对象<code>Number&#123;1&#125;</code>. 由于该对象没有自身属性, 所以返回一个空对象. </p><p>下面的栗子都是类似的道理. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(true)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="literal">true</span>&#125; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(undefined)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="literal">undefined</span>&#125; <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 &#123;...Object(null)&#125;</span></span><br><span class="line">&gt;&#123;...<span class="literal">null</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>但是, 如果扩展运算符后面是字符串, 它会自动转成一个类似数组的对象, 因此返回的不是空对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;...<span class="string">&#x27;hello&#x27;</span>&#125;</span><br><span class="line">&gt;<span class="comment">// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>对象的扩展运算符等同于使用 [ Object.assign() ] 方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于 浅拷贝</span></span><br><span class="line">&gt;<span class="keyword">let</span> aClone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><p>上面的栗子只是拷贝了对象实例的属性, 如果想完整克隆一个对象, 还拷贝对象原型的属性, 可以采用下面的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 写法一</span></span><br><span class="line">&gt;<span class="keyword">const</span> clone1 = &#123;</span><br><span class="line"> <span class="attr">__proto__</span>: <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj), <span class="comment">//利用[getPrototypeOf]获取原型,将其附加到自身原型上</span></span><br><span class="line"> ...obj</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写法二</span></span><br><span class="line">&gt;<span class="keyword">const</span> clone2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)),</span><br><span class="line"> obj</span><br><span class="line">&gt;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 写法三</span></span><br><span class="line">&gt;<span class="keyword">const</span> clone3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure><p>上面代码中, 写法一的 [  [ <code>__proto__</code> ]  ] 属性在非浏览器的环境不一定部署, 因此推荐使用写法二和写法三. </p><p>扩展运算符可以用于合并两个对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> ab = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure><p>如果用户自定义的属性, 放在扩展运算符后面, 则扩展运算符内部的同名属性会被覆盖掉. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithOverrides = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中,<code>a</code>对象的 [ x ] 属性和 [ y ] 属性, <code>拷贝到新对象后会被同名的 [x,y] 属性覆盖掉</code>. </p><p>这用来修改现有对象部分的属性就很方便了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> newVersion = &#123;</span><br><span class="line"> ...previousVersion,</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;New Name&#x27;</span> <span class="comment">//  重写name属性</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>newVersion</code>对象自定义了<code>name</code>属性, 其他属性全部复制自<code>previousVersion</code>对象. </p><p>如果把自定义属性放在扩展运算符前面, 就变成了设置新对象的默认属性值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;; <span class="comment">//如果a中没有 x、y 属性,则相当于赋默认值.有则覆盖</span></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithDefaults = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">let</span> aWithDefaults = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br></pre></td></tr></table></figure><p>与数组的扩展运算符一样, 对象的扩展运算符后面可以跟表达式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> ...(x &gt; <span class="number">1</span> ? &#123;<span class="attr">a</span>: <span class="number">1</span>&#125; : &#123;&#125;),</span><br><span class="line"> <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>扩展运算符的参数对象之中, 如果有取值函数<code>get</code>, 这个函数是会执行的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = &#123;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">x</span>() &#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;not throw yet&#x27;</span>);&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&gt;<span class="keyword">let</span> aWithXGetter = &#123; ...a &#125;; <span class="comment">// 报错  --&gt;因为[get]会自动执行,就不是赋值解构操作了</span></span><br></pre></td></tr></table></figure><p>上面栗子中, 取值函数<code>get</code>在扩展<code>a</code>对象时会自动执行, 导致报错. </p></blockquote><h3 id="Ⅶ-对象的新增方法"><a href="#Ⅶ-对象的新增方法" class="headerlink" title="Ⅶ -  对象的新增方法"></a>Ⅶ -  对象的新增方法</h3><blockquote><p>本来不想将这些新增方法<code>摘录</code>举例至此,但后面开发(源码学习)过程中发现这些方法应用频繁,所以还是罗列出来,</p><p>同时并不止是es6部分,而是将ES系列常用的都列举于此,此部分相对容易混淆,可以先看一遍,在自己开发过程使用到的时候再去巩固及加深理解</p></blockquote><h4 id="①-Object-is"><a href="#①-Object-is" class="headerlink" title="① Object.is()"></a>① Object.is()</h4><blockquote><p>ES5 比较两个值是否相等, 只有两个运算符: 相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）. 它们都有缺点, 前者会自动转换数据类型, 后者的<code>NaN</code>不等于自身, 以及<code>+0</code>等于<code>-0</code>. JavaScript 缺乏一种运算, 在所有环境中, 只要两个值是一样的, 它们就应该相等. </p><p>ES6 提出“Same-value equality”（同值相等）算法, 用来解决这个问题.  [ Object.is ] 就是部署这个算法的新方法. 它用来比较两个值是否严格相等, 与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个: 一是<code>+0</code>不等于<code>-0</code>, 二是<code>NaN</code>等于自身. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line">&gt;<span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码, 部署 [ Object.is ] . –&gt;其实就是将无法判断的两个特殊清空特殊处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">     <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">     <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 针对NaN的情况</span></span><br><span class="line">   <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Object-assign"><a href="#②-Object-assign" class="headerlink" title="② Object.assign()"></a>② Object.assign()</h4><blockquote><p>开发中常能见到,这个方法还是要着重了解的,需要注意的就是此方法为:** <code>浅拷贝</code> **</p></blockquote><h5 id="a-基本用法"><a href="#a-基本用法" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><p>[ Object.assign() ] 方法用于对象的合并, 将源对象（source）的所有可枚举属性, 复制到目标对象（target）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">&gt;target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>[ Object.assign() ] 方法的第一个参数是目标对象, 后面的参数都是源对象. </p><p>注意: 如果目标对象与源对象有同名属性, 或多个源对象有同名属性, 则<code>后面的属性会覆盖前面的属性</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">&gt;target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数,  [ Object.assign() ] 会直接返回该参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象, 则会先转成对象, 然后返回. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>由于 <strong>undefined</strong> 和 <strong>null</strong> 无法转成对象, 所以如果它们作为参数, 就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数）, 那么处理规则有所不同. 首先, 这些参数都会转成对象, 如果无法转成对象, 就会跳过. 这意味着, 如果 <strong>undefined</strong> 和 <strong>null</strong> 不在首参数, 就不会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数, 也不会报错. 但是, 除了字符串会以数组形式, 拷贝入目标对象, 其他值都不会产生效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, v1, v2, v3);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值, 结果只有字符串合入目标对象（以字符数组的形式）, 数值和布尔值都会被忽略. 这是因为只有字符串的包装对象, 会产生可枚举属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line">&gt;<span class="title class_">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line">&gt;<span class="title class_">Object</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 布尔值、数值、字符串分别转成对应的包装对象, 可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面, 这个属性是不会被 [ Object.assign() ] 拷贝的. 只有字符串的包装对象, 会产生可枚举的实义属性, 那些属性则会被拷贝. </p><p>[ Object.assign() ] 拷贝的属性是有限制的, 只拷贝源对象的自身属性（不拷贝继承属性）, 也不拷贝不可枚举的属性（<code>enumerable: false</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"> &#125;)</span><br><span class="line">&gt;)</span><br><span class="line">&gt;<span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ Object.assign() ] 要拷贝的对象只有一个不可枚举属性<code>invisible</code>, 这个属性并没有被拷贝进去. </p><p>属性名为 Symbol 值的属性, 也会被 [ Object.assign() ] 拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="title class_">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line">&gt;<span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-注意点"><a href="#b-注意点" class="headerlink" title="b) 注意点"></a>b) 注意点</h5><h6 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="( 1 ) 浅拷贝"></a>( 1 ) 浅拷贝</h6><blockquote><p>[ Object.assign() ] 方法实行的是浅拷贝, 而不是深拷贝. 也就是说, 如果源对象某个属性的值是对象, 那么目标对象拷贝得到的是这个对象的引用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">&gt;obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">&gt;obj2.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中, 源对象<code>obj1</code>的<code>a</code>属性的值是一个对象,  [ Object.assign() ] 拷贝得到的是这个对象的引用. 这个对象的任何变化, 都会反映到目标对象上面. </p></blockquote><h6 id="2-同名属性的替换"><a href="#2-同名属性的替换" class="headerlink" title="( 2 ) 同名属性的替换"></a>( 2 ) 同名属性的替换</h6><blockquote><p>对于这种嵌套的对象, 一旦遇到同名属性,  [ Object.assign() ] 的处理方法是替换, 而不是添加. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line">&gt;<span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line">&gt;<span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了, 而不会得到 <strong>{ a: { b: ‘hello’, d: ‘e’ } }</strong> 的结果. 这通常不是开发者想要的, 需要特别小心. </p><p>一些函数库提供 [ Object.assign() ] 的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法）, 可以得到深拷贝的合并. </p></blockquote><h6 id="3-数组的处理"><a href="#3-数组的处理" class="headerlink" title="( 3 ) 数组的处理"></a>( 3 ) 数组的处理</h6><blockquote><p>[ Object.assign() ] 可以用来处理数组, 但是会把数组视为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">&gt;<span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ Object.assign() ] 把数组视为属性名为 0、1、2 的对象, 因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>. </p></blockquote><h6 id="4-取值函数的处理"><a href="#4-取值函数的处理" class="headerlink" title="( 4 ) 取值函数的处理"></a>( 4 ) 取值函数的处理</h6><blockquote><p>[ Object.assign() ] 只能进行值的复制, 如果要复制的值是一个取值函数, 那么将求值后再复制. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> source = &#123;  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line">&gt;<span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>source</code>对象的<code>foo</code>属性是一个取值函数,  [ Object.assign() ] 不会复制这个取值函数, 只会拿到值以后, 将这个值复制过去</p></blockquote><h5 id="c-常见用途"><a href="#c-常见用途" class="headerlink" title="c) 常见用途"></a>c) 常见用途</h5><h6 id="1-为对象添加属性"><a href="#1-为对象添加属性" class="headerlink" title="( 1 ) 为对象添加属性"></a>( 1 ) 为对象添加属性</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;   <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;) &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过 [ Object.assign() ] 方法, 将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例. </p></blockquote><h6 id="2-为对象添加方法"><a href="#2-为对象添加方法" class="headerlink" title="( 2 ) 为对象添加方法"></a>( 2 ) 为对象添加方法</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line"> <span class="title function_">someMethod</span>(<span class="params">arg1, arg2</span>) &#123;&#125;,</span><br><span class="line"> <span class="title function_">anotherMethod</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于下面的写法</span></span><br><span class="line">&gt;<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">someMethod</span> = <span class="keyword">function</span> (<span class="params">arg1, arg2</span>) &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">anotherMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法, 直接将两个函数放在大括号中, 再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中. </p></blockquote><h6 id="3-克隆对象"><a href="#3-克隆对象" class="headerlink" title="( 3 ) 克隆对象"></a>( 3 ) 克隆对象</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123; <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin) &#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象, 就得到了原始对象的克隆. </p><p>不过, 采用这种方法克隆, 只能克隆原始对象自身的值, 不能克隆它继承的值. 如果想要保持继承链, 可以采用下面的代码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> originProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(origin);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(originProto), origin);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>[ Object.getPrototypeOf() ] 方法:返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）. </p></blockquote><h6 id="4-合并多个对象"><a href="#4-合并多个对象" class="headerlink" title="( 4 ) 合并多个对象"></a>( 4 ) 合并多个对象</h6><blockquote><p>将多个对象合并到某个对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">merge</span> =(<span class="params">target, ...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象, 可以改写上面函数, 对一个空对象合并. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">merge</span> =(<span class="params">...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure></blockquote><h6 id="5-为属性指定默认值"><a href="#5-为属性指定默认值" class="headerlink" title="( 5 ) 为属性指定默认值"></a>( 5 ) 为属性指定默认值</h6><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line"> <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line"> options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options); <span class="comment">//利用其如果有同名属性,后面属性值会覆盖前面属性值的特性实现</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(options);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,  [ DEFAULTS ] 对象是默认值,  <strong>options</strong>  对象是用户提供的参数.  [ Object.assign() ] 方法将 [ DEFAULTS ] 和 <strong>options</strong> 合并成一个新对象, 如果两者有同名属性, 则 <strong>options</strong> 的属性值会覆盖 [ DEFAULTS ] 的属性值. </p><p>注意, 由于存在浅拷贝的问题,  [ DEFAULTS ] 对象和 <strong>options</strong>  对象的所有属性的值, 最好都是简单类型, 不要指向另一个对象. 否则,  [ DEFAULTS ] 对象的该属性很可能不起作用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line"> <span class="attr">url</span>: &#123;</span><br><span class="line">   <span class="attr">host</span>: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">   <span class="attr">port</span>: <span class="number">7070</span></span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line"> options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options); <span class="comment">//利用其如果有同名属性,后面属性值会覆盖前面属性值的特性实现</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(options);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">processContent</span>(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line">&gt;<span class="comment">// &#123;</span></span><br><span class="line">&gt;<span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line">&gt;<span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变. 实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>, 所以<code>url.host</code>就不存在了. </p></blockquote><h4 id="③-getOwnPropertyDescriptors"><a href="#③-getOwnPropertyDescriptors" class="headerlink" title="③ getOwnPropertyDescriptors()"></a>③ getOwnPropertyDescriptors()</h4><blockquote><p>此方法在开发前期基本很少用到,在源码阅读的时候比较容易遇到</p></blockquote><h5 id="a-基本用法-1"><a href="#a-基本用法-1" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><p>ES5 的  [ Object.getOwnPropertyDescriptor() ] 方法用来获取一个对象的所有自身属性的描述符. . ES2017 引入了 [ Object.getOwnPropertyDescriptors() ] 方法, 返回指定对象所有自身属性（非继承属性）的描述对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">&gt;<span class="comment">// &#123; foo:</span></span><br><span class="line">&gt;<span class="comment">//    &#123; value: 123,</span></span><br><span class="line">&gt;<span class="comment">//      writable: true,</span></span><br><span class="line">&gt;<span class="comment">//      enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//      configurable: true &#125;,</span></span><br><span class="line">&gt;<span class="comment">//   bar:</span></span><br><span class="line">&gt;<span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line">&gt;<span class="comment">//      set: undefined,</span></span><br><span class="line">&gt;<span class="comment">//      enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//      configurable: true &#125;</span></span><br><span class="line">&gt;<span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ Object.getOwnPropertyDescriptors() ] 方法返回一个对象, 所有原对象的属性名都是该对象的属性名, 对应的属性值就是该属性的描述对象. </p></blockquote><h5 id="b-方法的实现"><a href="#b-方法的实现" class="headerlink" title="b) 方法的实现"></a>b) 方法的实现</h5><blockquote><p>该方法的实现非常容易. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组. </span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">&gt;result[key] = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-此方法引入目的与常用用法"><a href="#c-此方法引入目的与常用用法" class="headerlink" title="c) 此方法引入目的与常用用法"></a>c) 此方法引入目的与常用用法</h5><h6 id="1-解决-Object-assign-无法正确拷贝-get-属性和-set-属性的问题"><a href="#1-解决-Object-assign-无法正确拷贝-get-属性和-set-属性的问题" class="headerlink" title="( 1 ) 解决 [ Object.assign() ] 无法正确拷贝 [ get ] 属性和 [set ] 属性的问题."></a>( 1 ) 解决 [ Object.assign() ] 无法正确拷贝 [ get ] 属性和 [set ] 属性的问题.</h6><blockquote><p>该方法的引入目的, 主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> source = &#123;</span><br><span class="line">&gt;<span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">assign</span>(target1, source);  <span class="comment">//结果该属性的值变成了 undefined . </span></span><br><span class="line">&gt;<span class="comment">//此时获取其属性信息进行查看</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#123; value: undefined,</span></span><br><span class="line">&gt;<span class="comment">//   writable: true,</span></span><br><span class="line">&gt;<span class="comment">//   enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>source</code>对象的<code>foo</code>属性的值是一个赋值函数, <code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象, 结果该属性的值变成了 <strong>undefined</strong> . 这是因为<code>Object.assign</code>方法总是拷贝一个属性的值, 而不会拷贝它背后的赋值方法或取值方法. </p><p>这时,  [ Object.getOwnPropertyDescriptors() ] 方法配合<code>Object.defineProperties()</code>方法, 就可以实现正确拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> source = &#123;</span><br><span class="line">&gt;<span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//1. Object.defineProperties()方法直接在一个对象上定义新的属性或修改现有属性, 并返回该对象. </span></span><br><span class="line">&gt;<span class="comment">//2. 先将[source]属性获取出来,配合 [ Object.defineProperties() ]方法实现正确拷贝</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(target2, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source));</span><br><span class="line">&gt;<span class="comment">//此时再次获取其属性信息进行查看</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target2, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#123; get: undefined,</span></span><br><span class="line">&gt;<span class="comment">//   set: [Function: set foo],</span></span><br><span class="line">&gt;<span class="comment">//   enumerable: true,</span></span><br><span class="line">&gt;<span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 两个对象合并的逻辑可以写成一个函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//其实就是用[ Object.defineProperties() ]方法返回的数据再用 [Object.defineProperties()]方法进行修改或定义属性</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">shallowMerge</span> = (<span class="params">target, source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(</span><br><span class="line">&gt;target,</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h6 id="2-将对象属性克隆到一个新对象-–-浅拷贝"><a href="#2-将对象属性克隆到一个新对象-–-浅拷贝" class="headerlink" title="( 2 ) 将对象属性克隆到一个新对象  –&gt; 浅拷贝"></a>( 2 ) 将对象属性克隆到一个新对象  –&gt; <code>浅拷贝</code></h6><blockquote><p>[ Object.getOwnPropertyDescriptors() ] 方法的另一个用处, 是配合<code>Object.create()</code>方法, 将对象属性克隆到一个新对象. 这属于浅拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//该Object.create()方法创建一个新对象, 使用现有对象作为新创建对象的原型( proto ). </span></span><br><span class="line">&gt;<span class="comment">//Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值）. </span></span><br><span class="line">&gt;<span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 或者 --&gt;本质上一摸一样,只是用了箭头函数的方式写了,更简洁明了</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">shallowClone</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象<code>obj</code>. </p></blockquote><h6 id="3-继承对象"><a href="#3-继承对象" class="headerlink" title="( 3 ) 继承对象"></a>( 3 ) 继承对象</h6><blockquote><p>另外,  [ Object.getOwnPropertyDescriptors() ] 方法可以实现一个对象继承另一个对象. 以前, 继承另一个对象, 常常写成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line">&gt;<span class="attr">__proto__</span>: prot,</span><br><span class="line">&gt;<span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>ES6 规定 [  [ <code>__proto__</code> ]  ] 只有浏览器要部署, 其他环境不用部署. 如果去除 [  [ <code>__proto__</code> ]  ] , 上面代码就要改成下面这样. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//该Object.create()方法创建一个新对象, 使用现有对象作为新创建对象的原型( proto ). </span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prot);</span><br><span class="line">&gt;obj.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">create</span>(prot),</span><br><span class="line">&gt;&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>有了 [ Object.getOwnPropertyDescriptors() ] , 我们就有了另一种写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">&gt;prot,</span><br><span class="line">&gt;<span class="comment">//获取对象原型属性</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(&#123;<span class="attr">foo</span>: <span class="number">123</span>&#125;)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h6 id="4-实现-Mixin（混入）模式"><a href="#4-实现-Mixin（混入）模式" class="headerlink" title="( 4 ) 实现 Mixin（混入）模式"></a>( 4 ) 实现 Mixin（混入）模式</h6><blockquote><p>[ Object.getOwnPropertyDescriptors() ] 也可以用来实现 Mixin（混入）模式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> <span class="title function_">mix</span> = (<span class="params">object</span>) =&gt; (&#123;</span><br><span class="line">&gt;<span class="attr">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.<span class="title function_">reduce</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">&gt;c, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(mixin)</span><br><span class="line">&gt;), object)</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// multiple mixins example</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> d = <span class="title function_">mix</span>(c).<span class="title function_">with</span>(a, b);</span><br><span class="line"></span><br><span class="line">&gt;d.<span class="property">c</span> <span class="comment">// &quot;c&quot;</span></span><br><span class="line">&gt;d.<span class="property">b</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line">&gt;d.<span class="property">a</span> <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码返回一个新的对象<code>d</code>, 代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作. </p><p>出于完整性的考虑,  [ Object.getOwnPropertyDescriptors() ] 进入标准以后, 以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法. </p></blockquote><h4 id="④-proto-属性及其读、写操作"><a href="#④-proto-属性及其读、写操作" class="headerlink" title="④   [ __proto__ ]  属性及其读、写操作"></a>④   [ <code>__proto__</code> ]  属性及其读、写操作</h4><blockquote><p>JavaScript 语言的对象继承是通过原型链实现的. ES6 提供了更多原型对象的操作方法. </p></blockquote><h5 id="a-proto-属性"><a href="#a-proto-属性" class="headerlink" title="a)   [ __proto__ ]  属性"></a>a)   [ <code>__proto__</code> ]  属性</h5><blockquote><p>[  <code>__proto__</code>  ] 属性（前后各两个下划线）, 用来读取或设置当前对象的原型对象（prototype）. 目前, 所有浏览器（包括 IE11）都部署了这个属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// es5 的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;obj.<span class="property">__proto__</span> = someOtherObj;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// es6 的写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someOtherObj);</span><br><span class="line">&gt;obj.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文, 而是写入了附录, 原因是  [ <code>__proto__</code> ]  前后的双下划线, 说明它本质上是一个<strong>内部属性</strong>, 而不是一个正式的对外的 API，只是由于浏览器广泛支持, 才被加入了 ES6. 标准明确规定, 只有浏览器必须部署这个属性, 其他运行环境不一定需要部署, 而且新的代码最好认为这个属性是不存在的. 因此, 无论从语义的角度, 还是从兼容性的角度, 都不要使用这个属性, 而是使用下面的[ Object.setPrototypeOf() ]（<code>写操作</code>）、[ Object.getPrototypeOf() ]（<code>读操作</code>）、<code>Object.create()</code>（生成操作）代替. </p><p>实现上,  [  <code>__proto__</code>  ] 调用的是<code>Object.prototype.__proto__</code>, 具体实现如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;__proto__&#x27;</span>, &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> _thisObj = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(_thisObj);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">proto</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">undefined</span> || <span class="variable language_">this</span> === <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">   <span class="keyword">if</span> (!<span class="title function_">isObject</span>(<span class="variable language_">this</span>))  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="title function_">isObject</span>(proto)) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">   <span class="keyword">let</span> status = <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, proto);</span><br><span class="line">   <span class="keyword">if</span> (!status)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Object</span>(value) === value;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了 [  [ <code>__proto__</code> ]  ] 属性, 该属性的值就是对象的原型. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line">&gt;<span class="comment">// null</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-Object-setPrototypeOf-–-写操作"><a href="#b-Object-setPrototypeOf-–-写操作" class="headerlink" title="b) Object.setPrototypeOf()  –&gt;写操作"></a>b) Object.setPrototypeOf()  –&gt;写操作</h5><blockquote><p>[ Object.setPrototypeOf() ] 方法的作用与 [ <code>__proto__</code> ] 相同, 用来设置一个对象的原型对象（prototype）, 返回参数对象本身. 它是 ES6 正式推荐的设置原型对象的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 格式</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 用法</span></span><br><span class="line">&gt;<span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">obj, proto</span>) &#123;</span><br><span class="line"> obj.<span class="property">__proto__</span> = proto;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line"></span><br><span class="line">&gt;proto.<span class="property">y</span> = <span class="number">20</span>;</span><br><span class="line">&gt;proto.<span class="property">z</span> = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">&gt;obj.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">&gt;obj.<span class="property">y</span> <span class="comment">// 20</span></span><br><span class="line">&gt;obj.<span class="property">z</span> <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型, 所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性. </p><p>如果第一个参数不是对象, 会自动转为对象. 但是由于返回的还是第一个参数, 所以这个操作不会产生任何效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于 <strong>undefined</strong> 和 <strong>null</strong> 无法转为对象, 所以如果第一个参数是 <strong>undefined</strong> 或 <strong>null</strong> , 就会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-Object-getPrototypeOf"><a href="#c-Object-getPrototypeOf" class="headerlink" title="c) Object.getPrototypeOf()"></a>c) Object.getPrototypeOf()</h5><blockquote><p>该方法与 [ Object.setPrototypeOf() ] 方法配套, 用于读取一个对象的原型对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure><p>下面是一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> rec = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span><span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(rec, <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象, 会被自动转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>)</span><br><span class="line">&gt;<span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>) === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数是 <strong>undefined</strong> 或 <strong>null</strong> , 它们无法转为对象, 所以会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">undefined</span>)</span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-对象的keys-、values-、entries-方法"><a href="#⑤-对象的keys-、values-、entries-方法" class="headerlink" title="⑤  对象的keys()、values()、entries() 方法"></a>⑤  对象的keys()、values()、entries() 方法</h4><blockquote><p>这三个方法不得不说挺常用的,所以此处虽不是ES6的,但仍然在此处先给出 –&gt; 推测有的同学会只看ES6部分就不继续看了:dog:</p></blockquote><h5 id="a-Object-keys"><a href="#a-Object-keys" class="headerlink" title="a) Object.keys()"></a>a) Object.keys()</h5><blockquote><p>ES5 引入了<code>Object.keys</code>方法, 返回一个数组, 成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的 [ Object.values() ] 和 [ Object.entries() ] , 作为遍历一个对象的补充手段, 供<code>for...of</code>循环使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3&#125;</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-Object-values"><a href="#b-Object-values" class="headerlink" title="b) Object.values()"></a>b) Object.values()</h5><blockquote><p>[ Object.values() ] 方法返回一个数组, 成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p>返回数组的成员顺序, 与本章的《属性的遍历》部分介绍的排列规则一致. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 属性名为数值的属性, 是按照数值大小, 从小到大遍历的, 因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>. </p><p>[ Object.values() ] 只返回对象自身的可遍历属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ Object.create() ] 方法的第二个参数添加的对象属性（属性<code>p</code>）, 如果不显式声明, 默认是不可遍历的, 因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>,  [ Object.values() ] 不会返回这个属性. 只要把<code>enumerable</code>改成<code>true</code>,  [ Object.values() ] 就会返回属性<code>p</code>的值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>:</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure><p>[ Object.values() ] 会过滤属性名为 Symbol 值的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果 [ Object.values() ] 方法的参数是一个字符串, 会返回各个字符组成的一个数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 字符串会先转成一个类似数组的对象. 字符串的每个字符, 就是该对象的一个属性. 因此,  [ Object.values() ] 返回每个属性的键值, 就是各个字符组成的一个数组. </p><p>如果参数不是对象,  [ Object.values() ] 会先将其转为对象. 由于数值和布尔值的包装对象, 都不会为实例添加非继承的属性. 所以,  [ Object.values() ] 会返回空数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-Object-entries"><a href="#c-Object-entries" class="headerlink" title="c) Object.entries()"></a>c) Object.entries()</h5><blockquote><p>[ Object.entries() ] 方法返回一个数组, 成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line">&gt;<span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><p>除了返回值不一样, 该方法的行为与 [ Object.values() ] 基本一致. </p><p>如果原对象的属性名是一个 Symbol 值, 该属性会被忽略. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">entries</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 原对象有两个属性,  [ Object.entries() ] 只输出属性名非 Symbol 值的属性. 将来可能会有<code>Reflect.ownEntries()</code>方法, 返回对象自身的所有属性. </p><p>[ Object.entries() ] 的基本用途是遍历对象的属性. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">   <span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// &quot;one&quot;: 1</span></span><br><span class="line">&gt;<span class="comment">// &quot;two&quot;: 2</span></span><br></pre></td></tr></table></figure><p>[ Object.entries() ] 方法的另一个用处是, 将对象转为真正的<code>Map</code>结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line">&gt;map <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>自己实现 [ Object.entries() ] 方法, 非常简单. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// Generator函数的版本</span></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">   <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 非Generator函数的版本</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> arr = [];</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">   arr.<span class="title function_">push</span>([key, obj[key]]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> arr;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-Object-fromEntries"><a href="#⑥-Object-fromEntries" class="headerlink" title="⑥ Object.fromEntries()"></a>⑥ Object.fromEntries()</h4><blockquote><p><code>Object.fromEntries()</code>方法是 [ Object.entries() ] 的逆操作, 用于将一个键值对数组转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line"> [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">&gt;])</span><br><span class="line">&gt;<span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的主要目的, 是将键值对的数据结构还原为对象, 因此特别适合将 Map 结构转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line">&gt;<span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map)</span><br><span class="line">&gt;<span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的一个用处是配合<code>URLSearchParams</code>对象, 将查询字符串转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>))</span><br><span class="line">&gt;<span class="comment">// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="8、数组的拓展"><a href="#8、数组的拓展" class="headerlink" title="8、数组的拓展"></a>8、数组的拓展</h2><blockquote><p>对于前端而言,数组的操作是最频繁的,因为从服务端获取到的基本都是数组格式数据,其中方法最好是认真掌握</p></blockquote><h3 id="Ⅰ-概括与总结-1"><a href="#Ⅰ-概括与总结-1" class="headerlink" title="Ⅰ- 概括与总结"></a>Ⅰ- 概括与总结</h3><blockquote><blockquote><p><strong>新增的拓展</strong></p></blockquote><ul><li><strong>扩展运算符(…)</strong>: 转换数组为用逗号分隔的参数序列(<code>[...arr]</code>, 相当于<code>rest/spread参数</code>的逆运算)</li><li><strong>Array.from()</strong>: 转换具有 [ Iterator接口 ] 的数据结构为真正数组, 返回新数组</li></ul><ol><li>类数组对象: <code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code></li><li>可遍历对象: <code>String</code>、<code>Set结构</code>、<code>Map结构</code>、<code>Generator函数</code></li></ol><ul><li><strong>Array.of()</strong>: 转换一组值为真正数组, 返回新数组</li><li><strong>实例方法</strong></li></ul><ol><li><strong>copyWithin()</strong>: 把指定位置的成员复制到其他位置, 返回原数组</li><li><strong>find()</strong>: 返回第一个符合条件的成员</li><li><strong>findIndex()</strong>: 返回第一个符合条件的成员索引值</li><li><strong>fill()</strong>: 根据指定值填充整个数组, 返回原数组</li><li><strong>keys()</strong>: 返回以索引值为遍历器的对象</li><li><strong>values()</strong>: 返回以属性值为遍历器的对象</li><li><strong>entries()</strong>: 返回以索引值和属性值为遍历器的对象</li><li><strong>其他</strong>:毕竟只是概述,不过多列举,详细看下方</li></ol><ul><li><strong>其他常用方法</strong>:此处将数组常用方法在下方详细部分列出 (不仅是ES6)</li><li><strong>数组空位</strong>: ES6明确将数组空位转为 <strong>undefined</strong> (空位处理规不一, 建议避免出现)</li></ul><blockquote><p><strong>扩展运算符在数组中的应用</strong></p></blockquote><ul><li>克隆数组: <code>const arr = [...arr1]</code></li><li>合并数组: <code>const arr = [...arr1, ...arr2]</code></li><li>拼接数组: <code>arr.push(...arr1)</code></li><li>代替apply: <code>Math.max.apply(null, [x, y])</code> &#x3D;&gt; <code>Math.max(...[x, y])</code></li><li>转换字符串为数组: <code>[...&quot;hello&quot;]</code></li><li>转换类数组对象为数组: <code>[...Arguments, ...NodeList]</code></li><li>转换可遍历对象为数组: <code>[...String, ...Set, ...Map, ...Generator]</code></li><li>与数组解构赋值结合: <code>const [x, ...rest/spread] = [1, 2, 3]</code></li><li>计算Unicode字符长度: <code>Array.from(&quot;hello&quot;).length</code> &#x3D;&gt; <code>[...&quot;hello&quot;].length</code></li></ul><blockquote><p><strong>重点难点</strong></p></blockquote><ul><li>使用[ keys() ]、[ values() ]、[ entries() ]返回的遍历器对象, 可用 [ for-of ] 自动遍历或<code>next()</code>手动遍历</li></ul></blockquote><h3 id="Ⅱ-扩展运算符"><a href="#Ⅱ-扩展运算符" class="headerlink" title="Ⅱ - 扩展运算符"></a>Ⅱ - 扩展运算符</h3><h4 id="①-含义"><a href="#①-含义" class="headerlink" title="①  含义"></a>①  含义</h4><blockquote><p>扩展运算符（spread）是三个点（<code>...</code>）. 它好比 <code>rest 参数的逆运算</code>, 将一个数组转为用逗号分隔的参数序列. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt;<span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line">&gt;<span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">&gt;[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line">&gt;<span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure><p><code>该运算符主要用于函数调用</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">push</span>(<span class="params">array, ...items</span>) &#123;</span><br><span class="line"> array.<span class="title function_">push</span>(...items);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">&gt;<span class="title function_">add</span>(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>array.push(...items)</code>和<code>add(...numbers)</code>这两行, 都是函数的调用, 它们都使用了扩展运算符. 该运算符将一个数组, 变为参数序列. </p><p>扩展运算符与正常的函数参数可以结合使用, 非常灵活. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v, w, x, y, z</span>) &#123; &#125;</span><br><span class="line">&gt;<span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">&gt;<span class="title function_">f</span>(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>扩展运算符后面还可以放置表达式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [</span><br><span class="line"> ...(x &gt; <span class="number">0</span> ? [<span class="string">&#x27;a&#x27;</span>] : []),</span><br><span class="line"> <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">&gt;];</span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空数组, 则不产生任何效果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...[], <span class="number">1</span>]</span><br><span class="line">&gt;<span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><p>注意, <code>只有函数调用时, 扩展运算符才可以放在圆括号中</code>, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&gt;<span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>((...[<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line">&gt;<span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&gt;<span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure><p>上面三种情况, 扩展运算符都放在圆括号里面, 但是前两种情况会报错, 因为扩展运算符所在的括号不是函数调用. </p></blockquote><h4 id="②-替代函数的-apply-方法"><a href="#②-替代函数的-apply-方法" class="headerlink" title="② 替代函数的 apply 方法"></a>② 替代函数的 apply 方法</h4><blockquote><p>由于扩展运算符可以展开数组, 所以不再需要<code>apply</code>方法, 将数组转为函数的参数了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的写法</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;f.<span class="title function_">apply</span>(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6的写法</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="title function_">f</span>(...args);</span><br></pre></td></tr></table></figure><p>下面是扩展运算符取代<code>apply</code>方法的一个实际的栗子, 应用<code>Math.max</code>方法, 简化求出一个数组最大元素的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的写法</span></span><br><span class="line">&gt;<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的写法</span></span><br><span class="line">&gt;<span class="title class_">Math</span>.<span class="title function_">max</span>(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 由于 JavaScript 不提供求数组最大元素的函数, 所以只能套用<code>Math.max</code>函数, 将数组转为一个参数序列, 然后求最大值. 有了扩展运算符以后, 就可以直接用<code>Math.max</code>了. </p><p>另一个栗子是通过<code>push</code>函数, 将一个数组添加到另一个数组的尾部. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5的 写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">push</span>.<span class="title function_">apply</span>(arr1, arr2);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure><p>上面代码的 ES5 写法中, <code>push</code>方法的参数不能是数组, 所以只好通过<code>apply</code>方法变通使用<code>push</code>方法. 有了扩展运算符, 就可以直接将数组传入<code>push</code>方法. </p><p>下面是另外一个栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;<span class="keyword">new</span> (<span class="title class_">Date</span>.<span class="property">bind</span>.<span class="title function_">apply</span>(<span class="title class_">Date</span>, [<span class="literal">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-扩展运算符的应用"><a href="#③-扩展运算符的应用" class="headerlink" title="③ 扩展运算符的应用"></a>③ 扩展运算符的应用</h4><h5 id="a-复制数组"><a href="#a-复制数组" class="headerlink" title="a) 复制数组"></a>a) 复制数组</h5><blockquote><p>数组是复合的数据类型, 直接复制的话, 只是复制了指向底层数据结构的指针, 而不是克隆一个全新的数组 [<code> 浅拷贝</code>]. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">&gt;a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">&gt;a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>a2</code>并不是<code>a1</code>的克隆, 而是指向同一份数据的另一个指针. 修改<code>a2</code>, 会直接导致<code>a1</code>的变化. </p><p>ES5 只能用变通方法来复制数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> a2 = a1.<span class="title function_">concat</span>();</span><br><span class="line"></span><br><span class="line">&gt;a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">&gt;a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>a1</code>会返回原数组的克隆, 再修改<code>a2</code>就不会对<code>a1</code>产生影响. </p><p>扩展运算符提供了复制数组的简便写法.  –&gt;这样就不会造成影响</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&gt;<span class="comment">// 写法一</span></span><br><span class="line">&gt;<span class="keyword">const</span> a2 = [...a1];</span><br><span class="line">&gt;<span class="comment">// 写法二</span></span><br><span class="line">&gt;<span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p>上面的两种写法, <code>a2</code>都是<code>a1</code>的克隆. </p><p><code>注意</code>:如果内部是引用数据类型,是不会改动到内部的引用,不懂的继续看下面 [ 合并数组 ] 的举例</p></blockquote><h5 id="b-合并数组"><a href="#b-合并数组" class="headerlink" title="b) 合并数组"></a>b) 合并数组</h5><blockquote><p>扩展运算符提供了数组合并的新写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5 的合并数组</span></span><br><span class="line">&gt;arr1.<span class="title function_">concat</span>(arr2, arr3);</span><br><span class="line">&gt;<span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的合并数组</span></span><br><span class="line">&gt;[...arr1, ...arr2, ...arr3]</span><br><span class="line">&gt;<span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>不过, 这两种方法都是浅拷贝 ( 指的是内部数据如 { foo: 1 } 是存地址 ) , 使用的时候需要注意. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a1 = [&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;];</span><br><span class="line">&gt;<span class="keyword">const</span> a2 = [&#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> a3 = a1.<span class="title function_">concat</span>(a2);</span><br><span class="line">&gt;<span class="keyword">const</span> a4 = [...a1, ...a2];</span><br><span class="line"></span><br><span class="line">&gt;a3[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br><span class="line">&gt;a4[<span class="number">0</span>] === a1[<span class="number">0</span>] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>[ a3 ] 和 [ a4 ] 是用两种不同方法合并而成的新数组, 但是它们的成员都是对原数组成员的引用, 这就是浅拷贝</code>. 如果修改了引用指向的值, 会同步反映到新数组. </p></blockquote><h5 id="c-与解构赋值结合"><a href="#c-与解构赋值结合" class="headerlink" title="c) 与解构赋值结合"></a>c) 与解构赋值结合</h5><blockquote><p>扩展运算符可以与解构赋值结合起来, 用于生成数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5</span></span><br><span class="line">&gt;a = list[<span class="number">0</span>], rest = list.<span class="title function_">slice</span>(<span class="number">1</span>) <span class="comment">//此处是先取出第一个,然后从下标1处将其后的数据截取出</span></span><br><span class="line">&gt;<span class="comment">// ES6</span></span><br><span class="line">&gt;[a, ...rest] = list</span><br></pre></td></tr></table></figure><p>下面是另外一些栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="comment">//first == 1</span></span><br><span class="line">&gt;<span class="comment">//rest  == [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">&gt;<span class="comment">//first == undefined</span></span><br><span class="line">&gt;<span class="comment">//rest  == []</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">&gt;<span class="comment">//first  == &quot;foo&quot;</span></span><br><span class="line">&gt;<span class="comment">//rest   == []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值, 只能放在参数的最后一位, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-字符串"><a href="#d-字符串" class="headerlink" title="d) 字符串"></a>d) 字符串</h5><blockquote><p>扩展运算符还可以将字符串转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line">&gt;<span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><p>上面的写法, 有一个重要的好处, 那就是能够正确识别四个字节的 Unicode 字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>.<span class="property">length</span> <span class="comment">// 4</span></span><br><span class="line">&gt;[...<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>].<span class="property">length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符, 识别为 2 个字符, 采用扩展运算符就没有这个问题. 因此, 正确返回字符串长度的函数, 可以像下面这样写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">length</span>(<span class="params">str</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> [...str].<span class="property">length</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">length</span>(<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>凡是涉及到操作四个字节的 Unicode 字符的函数, 都有这个问题. 因此, 最好都用扩展运算符改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> str = <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;y\uDE80\uD83Dx&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;[...str].<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;y\uD83D\uDE80x&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 如果不用扩展运算符, 字符串的<code>reverse</code>操作就不正确. </p></blockquote><h5 id="e-实现了-Iterator-接口的对象"><a href="#e-实现了-Iterator-接口的对象" class="headerlink" title="e) 实现了 Iterator 接口的对象"></a>e) 实现了 Iterator 接口的对象</h5><blockquote><p>任何定义了遍历器（Iterator）接口的对象 [此处不懂可以跳过先看下方,有给出详情], 都可以用扩展运算符转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中, <code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象. 它不是数组, 而是一个类似数组的对象. 这时, 扩展运算符可以将其转为真正的数组, 原因就在于<code>NodeList</code>对象实现了 Iterator . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>*() &#123;</span><br><span class="line"> <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">let</span> num = <span class="variable language_">this</span>.<span class="title function_">valueOf</span>();</span><br><span class="line"> <span class="keyword">while</span> (i &lt; num) &#123;  <span class="keyword">yield</span> i++; &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="number">5</span>]) <span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 先定义了<code>Number</code>对象的遍历器接口, 扩展运算符将<code>5</code>自动转成<code>Number</code>实例以后, 就会调用这个接口, 就会返回自定义的结果. </p><p>对于那些没有部署 Iterator 接口的类似数组的对象, 扩展运算符就无法将其转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line"> <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure><p>上面代码中, <code>arrayLike</code>是一个类似数组的对象, 但是没有部署 Iterator 接口, 扩展运算符就会报错. 这时, 可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组.<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p></blockquote><h5 id="f-Map-和-Set-结构，Generator-函数"><a href="#f-Map-和-Set-结构，Generator-函数" class="headerlink" title="f) Map 和 Set 结构，Generator 函数"></a>f) Map 和 Set 结构，Generator 函数</h5><blockquote><p>扩展运算符内部调用的是数据结构的 Iterator 接口, 因此只要具有 Iterator 接口的对象, 都可以使用扩展运算符, 比如 Map 结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后, 返回一个遍历器对象, 因此也可以使用扩展运算符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> go = <span class="keyword">function</span>*()&#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;[...<span class="title function_">go</span>()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>go</code>是一个 Generator 函数, 执行后返回的是一个遍历器对象, 对这个遍历器对象执行扩展运算符, 就会将内部遍历得到的值, 转为一个数组. </p><p>如果对没有 Iterator 接口的对象, 使用扩展运算符, 将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure></blockquote><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h5 id="f-Map-和-Set-结构，Generator-函数-1"><a href="#f-Map-和-Set-结构，Generator-函数-1" class="headerlink" title="f) Map 和 Set 结构，Generator 函数"></a>f) Map 和 Set 结构，Generator 函数</h5><blockquote><p>扩展运算符内部调用的是数据结构的 Iterator 接口, 因此只要具有 Iterator 接口的对象, 都可以使用扩展运算符, 比如 Map 结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line"> [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line"> [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator 函数运行后, 返回一个遍历器对象, 因此也可以使用扩展运算符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> go = <span class="keyword">function</span>*()&#123;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;[...<span class="title function_">go</span>()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>go</code>是一个 Generator 函数, 执行后返回的是一个遍历器对象, 对这个遍历器对象执行扩展运算符, 就会将内部遍历得到的值, 转为一个数组. </p><p>如果对没有 Iterator 接口的对象, 使用扩展运算符, 将会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Array-from"><a href="#Ⅲ-Array-from" class="headerlink" title="Ⅲ - Array.from()"></a>Ⅲ - Array.from()</h3><blockquote><p>对于还没有部署该方法的浏览器, 可以用<code>Array.prototype.slice</code>方法替代. </p></blockquote><h4 id="①-简单举例"><a href="#①-简单举例" class="headerlink" title="① 简单举例"></a>① 简单举例</h4><blockquote><p><code>Array.from</code>方法用于将两类对象转为真正的数组: 类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）. </p><p>下面是一个类似数组的对象, <code>Array.from</code>将它转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">&gt;<span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">&gt;<span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">&gt;<span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES5的写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr1 = [].<span class="property">slice</span>.<span class="title function_">call</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// ES6的写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-实际应用场景举栗"><a href="#②-实际应用场景举栗" class="headerlink" title="② 实际应用场景举栗"></a>② 实际应用场景举栗</h4><blockquote><p>实际应用中, 常见的类似数组的对象是 DOM 操作返回的 NodeList 集合, 以及函数内部的<code>arguments</code>对象. <code>Array.from</code>都可以将它们转为真正的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// NodeList对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> ps = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(ps).<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> p.<span class="property">textContent</span>.<span class="property">length</span> &gt; <span class="number">100</span>;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// arguments对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>querySelectorAll</code>方法返回的是一个类似数组的对象, 可以将这个对象转为真正的数组, 再使用<code>filter</code>方法. </p><p>只要是部署了 Iterator 接口的数据结构, <code>Array.from</code>都能将其转为数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(namesSet) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 字符串和 Set 结构都具有 Iterator 接口, 因此可以被<code>Array.from</code>转为真正的数组. </p><p>如果参数是一个真正的数组, <code>Array.from</code>会返回一个一模一样的新数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>值得提醒的是, 扩展运算符（<code>...</code>）也可以将某些数据结构转为数组 (上面有提到). </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// arguments对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>];</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// NodeList对象</span></span><br><span class="line">&gt;[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-不适用场景"><a href="#③-不适用场景" class="headerlink" title="③ 不适用场景"></a>③ 不适用场景</h4><blockquote><p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>）, 如果一个对象没有部署这个接口, 就无法转换. </p><p><code>Array.from</code>方法还支持类似数组的对象. 所谓类似数组的对象, 本质特征只有一点, 即必须有<code>length</code>属性. 因此, 任何有<code>length</code>属性的对象, 都可以通过<code>Array.from</code>方法转为数组, 而此时扩展运算符就无法转换. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line">&gt;<span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Array.from</code>返回了一个具有三个成员的数组, 每个位置的值都是 <strong>undefined</strong> . 扩展运算符转换不了这个对象. </p><p>对于还没有部署该方法的浏览器, 可以用<code>Array.prototype.slice</code>方法替代. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> toArray = (<span class="function">() =&gt;</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="property">from</span> ? <span class="title class_">Array</span>.<span class="property">from</span> : <span class="function"><span class="params">obj</span> =&gt;</span> [].<span class="property">slice</span>.<span class="title function_">call</span>(obj)</span><br><span class="line">&gt;)();</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-第二个参数的作用"><a href="#④-第二个参数的作用" class="headerlink" title="④ 第二个参数的作用"></a>④ 第二个参数的作用</h4><blockquote><p><code>Array.from</code>还可以接受第二个参数, 作用类似于数组的<code>map</code>方法, 用来对每个元素进行处理, 将处理后的值放入返回的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike).<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line">&gt;<span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p>下面的栗子是取出一组 DOM 节点的文本内容. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> spans = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;span.name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// map()</span></span><br><span class="line">&gt;<span class="keyword">let</span> names1 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.<span class="property">textContent</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Array.from()</span></span><br><span class="line">&gt;<span class="keyword">let</span> names2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.<span class="property">textContent</span>)</span><br></pre></td></tr></table></figure><p>下面的栗子将数组中布尔值为<code>false</code>的成员转为<code>0</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n || <span class="number">0</span>)</span><br><span class="line">&gt;<span class="comment">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure><p>另一个栗子是返回各种数据的类型. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">typesOf</span> () &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">typeof</span> value)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">typesOf</span>(<span class="literal">null</span>, [], <span class="title class_">NaN</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;object&#x27;, &#x27;object&#x27;, &#x27;number&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果<code>map</code>函数里面用到了<code>this</code>关键字, 还可以传入<code>Array.from</code>的第三个参数, 用来绑定<code>this</code>. </p><p><code>Array.from()</code>可以将各种值转为真正的数组, 并且还提供<code>map</code>功能. 这实际上意味着, 只要有一个原始的数据结构, 你就可以先对它的值进行处理, 然后转成规范的数组结构, 进而就可以使用数量众多的数组方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, <span class="function">() =&gt;</span> <span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [&#x27;jack&#x27;, &#x27;jack&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Array.from</code>的第一个参数指定了第二个参数运行的次数. 这种特性可以让该方法的用法变得非常灵活. </p><p><code>Array.from()</code>的另一个应用是: 将字符串转为数组, 然后返回字符串的长度. 因为它能正确处理各种 Unicode 字符, 可以避免 JavaScript 将大于<code>\uFFFF</code>的 Unicode 字符, 算作两个字符的 bug. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">countSymbols</span>(<span class="params">string</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(string).<span class="property">length</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-Array-of"><a href="#Ⅳ-Array-of" class="headerlink" title="Ⅳ- Array.of ( )"></a>Ⅳ- Array.of ( )</h3><h4 id="①-基本使用"><a href="#①-基本使用" class="headerlink" title="① 基本使用"></a>① 基本使用</h4><blockquote><p>[ Array.of ]方法用于将一组值, 转换为数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="property">length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的, 是弥补数组构造函数<code>Array()</code>的不足. 因为参数个数的不同, 会导致<code>Array()</code>的行为有差异. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>() <span class="comment">// []</span></span><br><span class="line">&gt;<span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Array</code>方法没有参数、一个参数、三个参数时, 返回结果都不一样. 只有当参数个数不少于 2 个时, <code>Array()</code>才会返回由参数组成的新数组. 参数个数只有一个时, 实际上是指定数组的长度. </p><p>[ Array.of ]基本上可以用来替代<code>Array()</code>或<code>new Array()</code>, 并且不存在由于参数不同而导致的重载. 它的行为非常统一. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>() <span class="comment">// []</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>[ Array.of ]总是返回参数值组成的数组. 如果没有参数, 就返回一个空数组. </p></blockquote><h4 id="②-原生模拟-Array-of"><a href="#②-原生模拟-Array-of" class="headerlink" title="② 原生模拟 [ Array.of ]"></a>② 原生模拟 [ Array.of ]</h4><blockquote><p><code>Array.of</code>方法可以用下面的代码模拟实现. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ArrayOf</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-数组的实例方法"><a href="#Ⅴ-数组的实例方法" class="headerlink" title="Ⅴ- 数组的实例方法"></a>Ⅴ- 数组的实例方法</h3><blockquote><p>所谓实例方法,简单来说就是实例化后可以用 <code>[数组].方法名()</code>的方式调用的一类方法,其中有几个很常用,可以重点理解</p></blockquote><h4 id="①-数组实例的-copyWithin"><a href="#①-数组实例的-copyWithin" class="headerlink" title="①  数组实例的 copyWithin()"></a>①  数组实例的 copyWithin()</h4><blockquote><p>数组实例的 [ copyWithin() ] 方法, 在当前数组内部, 将指定位置的成员复制到其他位置（会覆盖原有成员）, 然后返回当前数组. 也就是说, 使用这个方法, <code>会修改当前数组</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">copyWithin</span>(target, start = <span class="number">0</span>, end = <span class="variable language_">this</span>.<span class="property">length</span>)</span><br></pre></td></tr></table></figure><p>它接受三个参数. </p><ul><li>target（必需）: 从该位置开始替换数据. 如果为负值, 表示倒数. </li><li>start（可选）: 从该位置开始读取数据, 默认为 0. 如果为负值, 表示从末尾开始计算. </li><li>end（可选）: 到该位置前停止读取数据, 默认等于数组长度. 如果为负值, 表示从末尾开始计算.</li></ul><p>这三个参数都应该是数值, 如果不是, 会自动转为数值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">&gt;<span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5）, 复制到从 0 号位开始的位置, 结果覆盖了原来的 1 和 2. </p><p>下面是更多栗子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//从三号位开始读取,到四号位结束,得到[4],将其替换到0号位</span></span><br><span class="line">&gt;<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// -2相当于3号位, -1相当于4号位</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">copyWithin</span>(<span class="number">0</span>, -<span class="number">2</span>, -<span class="number">1</span>) <span class="comment">//从倒数2号位开始读取,到倒数一号位结束,得到[4],将其替换到0号位</span></span><br><span class="line">&gt;<span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">&gt;[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">&gt;<span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 将2号位到数组结束, 复制到0号位</span></span><br><span class="line">&gt;<span class="keyword">let</span> i32a = <span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;i32a.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&gt;<span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line">&gt;<span class="comment">// 需要采用下面的写法</span></span><br><span class="line">&gt;[].<span class="property">copyWithin</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&gt;<span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-数组实例的-find-和-findIndex"><a href="#②-数组实例的-find-和-findIndex" class="headerlink" title="② 数组实例的 find() 和 findIndex()"></a>② 数组实例的 find() 和 findIndex()</h4><blockquote><p>数组实例的 [ find ] 方法, 用于找出第一个符合条件的数组成员. 它的参数是一个回调函数, 所有数组成员依次执行该回调函数, 直到找出第一个返回值为<code>true</code>的成员, 然后返回该成员. 如果没有符合条件的成员, 则返回 <strong>undefined</strong> . </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].<span class="title function_">find</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line">&gt;<span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>上面代码找出数组中第一个小于 0 的成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&gt;&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面代码中, [ find ] 方法的回调函数可以接受三个参数, 依次为<code>当前的值、当前的位置和原数组</code>. </p><p>数组实例的 [ findIndex] 方法的用法与 [ find ] 方法非常类似, 返回第一个符合条件的数组成员的位置, 如果所有成员都不符合条件, 则返回<code>-1</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].<span class="title function_">findIndex</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&gt;&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以接受第二个参数, 用来绑定回调函数的<code>this</code>对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">v</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> v &gt; <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">&gt;[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].<span class="title function_">find</span>(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure><p>上面的代码中,  [ find ] 函数接收了第二个参数<code>person</code>对象, 回调函数中的<code>this</code>对象指向<code>person</code>对象. </p><p>另外, 这两个方法都可以发现<code>NaN</code>, 弥补了数组的 [ indexOf ] 方法的不足. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">y</span> =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, y)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ indexOf ] 方法无法识别数组的<code>NaN</code>成员, 但是 [ findIndex] 方法可以借助 [ Object.is ] 方法做到. </p></blockquote><h4 id="③-数组实例的-entries-，keys-和-values"><a href="#③-数组实例的-entries-，keys-和-values" class="headerlink" title="③ 数组实例的 entries()，keys() 和 values()"></a>③ 数组实例的 entries()，keys() 和 values()</h4><blockquote><p>ES6 提供三个新的方法——[ entries() ], [ keys() ] 和 [ values() ]——用于遍历数组. 它们都返回一个遍历器对象.可以用<code>for...of</code>循环进行遍历, 唯一的区别是[ keys() ]是对键名的遍历、[ values() ]是对键值的遍历, [ entries() ]是对键值对的遍历. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">keys</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(index);&#125;</span><br><span class="line">&gt;<span class="comment">// 0</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">values</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(elem);&#125;</span><br><span class="line">&gt;<span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&gt;<span class="comment">// &#x27;b&#x27;</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">entries</span>()) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, elem);&#125;</span><br><span class="line">&gt;<span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line">&gt;<span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>for...of</code>循环, 可以手动调用遍历器对象的<code>next</code>方法, 进行遍历. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> entries = letter.<span class="title function_">entries</span>();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(entries.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-数组实例的-includes"><a href="#④-数组实例的-includes" class="headerlink" title="④ 数组实例的 includes()"></a>④ 数组实例的 includes()</h4><blockquote><p>[ Array.prototype.includes ] 方法返回一个布尔值, 表示某个数组是否包含给定的值, 与字符串的 [ includes ] 方法类似. ES2016 引入了该方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>该方法的第二个参数表示搜索的起始位置, 默认为<code>0</code>. 如果第二个参数为负数, 则表示倒数的位置, 如果这时它大于数组长度（比如第二个参数为<code>-4</code>, 但数组长度为<code>3</code>）, 则会重置为从<code>0</code>开始. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>没有该方法之前, 我们通常使用数组的 [ indexOf ] 方法, 检查是否包含某个值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(el) !== -<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>[ indexOf ] 方法有两个缺点, 一是不够语义化, 它的含义是找到参数值的第一个出现位置, 所以要去比较是否不等于<code>-1</code>, 表达起来不够直观. 二是, 它内部使用严格相等运算符（<code>===</code>）进行判断, 这会导致对<code>NaN</code>的误判. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)</span><br><span class="line">&gt;<span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>[ includes ] 使用的是不一样的判断算法, 就没有这个问题. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面代码用来检查当前环境是否支持该方法, 如果不支持, 部署一个简易的替代版本. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> contains = (<span class="function">() =&gt;</span></span><br><span class="line"> <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span></span><br><span class="line">   ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.<span class="title function_">includes</span>(value)</span><br><span class="line">   : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.<span class="title function_">some</span>(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">&gt;)();</span><br><span class="line">&gt;<span class="title function_">contains</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;baz&#x27;</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>另外，Map 和 Set 数据结构有一个<code>has</code>方法, 需要注意与 [ includes ] 区分. </p><ul><li>Map 结构的<code>has</code>方法, 是用来查找键名的, 比如 [ Map.prototype.has(key) ] 、 [ WeakMap.prototype.has(key) ] 、 [ Reflect.has(target, propertyKey) ] . </li><li>Set 结构的<code>has</code>方法, 是用来查找值的, 比如 [ Set.prototype.has(value) ] 、 [ WeakSet.prototype.has(value) ] .</li></ul></blockquote><h4 id="⑤-数组实例的-flat-，flatMap"><a href="#⑤-数组实例的-flat-，flatMap" class="headerlink" title="⑤ 数组实例的 flat()，flatMap()"></a>⑤ 数组实例的 flat()，flatMap()</h4><blockquote><p>数组的成员有时还是数组, <code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”, 变成一维的数组. 该方法返回一个新数组, 对原数据没有影响. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].<span class="title function_">flat</span>()</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 原数组的成员里面有一个数组,  [ flat() ] 方法将子数组的成员取出来, 添加在原来的位置. </p><p>[ flat() ] 默认只会“拉平”一层, 如果想要“拉平”多层的嵌套数组, 可以将 [ flat() ] 方法的参数写成一个整数, 表示想要拉平的层数, 默认为1. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>()</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].<span class="title function_">flat</span>(<span class="number">2</span>)</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ flat() ] 的参数为2，表示要“拉平”两层的嵌套数组. </p><p>如果不管有多少层嵌套, 都要转成一维数组, 可以用<code>Infinity</code>关键字作为参数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>(<span class="title class_">Infinity</span>)</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p><code>如果原数组有空位,  [ flat() ] 方法会跳过空位</code>.  –&gt; 这个可以用作去除数组中空位,特殊场景好用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">flat</span>()</span><br><span class="line">&gt;<span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure><p>[ flatMap() ] 方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>）, 然后对返回值组成的数组执行 [ flat() ] 方法. 该方法返回一个新数组, 不改变原数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">&gt;[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line">&gt;<span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><p>[ flatMap() ] 只能展开一层数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">flatMap</span>(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line">&gt;<span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 遍历函数返回的是一个双层的数组, 但是默认只能展开一层, 因此 [ flatMap() ] 返回的还是一个嵌套数组. </p><p>[ flatMap() ] 方法的参数是一个遍历函数, 该函数可以接受三个参数, 分别是当前数组成员、当前数组成员的位置（从零开始）、原数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr.<span class="title function_">flatMap</span>(<span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">currentValue[, index[, array]]</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;[, thisArg])</span><br></pre></td></tr></table></figure><p>[ flatMap() ] 方法还可以有第二个参数, 用来绑定遍历函数里面的<code>this</code>. </p></blockquote><h4 id="⑥-数组实例的-filter-–-常用"><a href="#⑥-数组实例的-filter-–-常用" class="headerlink" title="⑥ 数组实例的 filter() –&gt;常用"></a>⑥ 数组实例的 filter() –&gt;<code>常用</code></h4><blockquote><p><code>此方法非常常用</code>,一定要掌握的</p><p><code>filter()</code> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素.  不会改变原有数组</p></blockquote><h5 id="a-筛选对象数组中符合条件的"><a href="#a-筛选对象数组中符合条件的" class="headerlink" title="a) 筛选对象数组中符合条件的"></a>a) 筛选对象数组中符合条件的</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">Arr</span> = [</span><br><span class="line"> &#123; <span class="attr">look</span>: <span class="string">&#x27;帅&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;@hongjilin&#x27;</span>&#125;,</span><br><span class="line"> &#123; <span class="attr">look</span>: <span class="string">&#x27;很帅&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>&#125;</span><br><span class="line">&gt;]</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Arr</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">name</span> === <span class="string">&#x27;努力学习的汪&#x27;</span> )) <span class="comment">//&#123; look: &#x27;很帅&#x27;, name: &#x27;努力学习的汪&#x27; &#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-筛选对象数组中不符合条件的"><a href="#b-筛选对象数组中不符合条件的" class="headerlink" title="b) 筛选对象数组中不符合条件的"></a>b) 筛选对象数组中不符合条件的</h5><blockquote><p>同样操作上面的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Arr</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">look</span> !== <span class="string">&#x27;很帅&#x27;</span> )) <span class="comment">//&#123; look: &#x27;帅&#x27;, name: &#x27;@hongjilin&#x27;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-去除数组中的空字符串、undefined、null"><a href="#c-去除数组中的空字符串、undefined、null" class="headerlink" title="c) 去除数组中的空字符串、undefined、null"></a>c) 去除数组中的空字符串、undefined、null</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> undefinedArr = [<span class="string">&#x27;这是undefined数组&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="literal">undefined</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="literal">undefined</span>]</span><br><span class="line">&gt;<span class="keyword">const</span> nullArr = [<span class="string">&#x27;这是null数组&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="literal">null</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="literal">null</span>]</span><br><span class="line">&gt;<span class="keyword">const</span> stringArr = [<span class="string">&#x27;这是空字符串数组&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="string">&#x27;&#x27;</span>] <span class="comment">//空字符串里面不能包含空格</span></span><br><span class="line">&gt;<span class="keyword">let</span> newArr =[] <span class="comment">//定义一个新数组来测试承接</span></span><br><span class="line">&gt;<span class="comment">//过滤 undefined</span></span><br><span class="line">&gt;newArr= undefinedArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)  <span class="comment">//log: [&quot;这是undefined数组&quot;, &quot;2&quot;, &quot;努力学习的汪&quot;]</span></span><br><span class="line">&gt;<span class="comment">//过滤 null</span></span><br><span class="line">&gt;newArr = nullArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">//log: [&quot;这是null数组&quot;, &quot;2&quot;, &quot;努力学习的汪&quot;]</span></span><br><span class="line">&gt;<span class="comment">//过滤空字符串</span></span><br><span class="line">newArr = stringArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">//log: [&quot;这是空字符串数组&quot;, &quot;2&quot;, &quot;努力学习的汪&quot;]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-筛选字符串、数字数组符合条件项"><a href="#d-筛选字符串、数字数组符合条件项" class="headerlink" title="d) 筛选字符串、数字数组符合条件项"></a>d) 筛选字符串、数字数组符合条件项</h5><blockquote><p>其实与上方对象数组筛选差不多,但稍微还是有所差别,举例出来,方便理解</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> numberArr = [<span class="number">20</span>,<span class="number">30</span>,<span class="number">50</span>, <span class="number">96</span>,<span class="number">50</span>]</span><br><span class="line">&gt;<span class="keyword">const</span> stringArr = [<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;44&#x27;</span>,<span class="string">&#x27;42&#x27;</span>]</span><br><span class="line">&gt;<span class="keyword">let</span> newArr = []</span><br><span class="line">&gt;<span class="comment">//筛选数组中符合条件项</span></span><br><span class="line">&gt;newArr= numberArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;<span class="number">40</span>)  </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)   <span class="comment">//log: [50, 96, 50]</span></span><br><span class="line">&gt;<span class="comment">//过滤字符串数组符合条件项</span></span><br><span class="line">&gt;<span class="comment">//item.indexOf(&#x27;2&#x27;)是查找字符串中含有[&#x27;2&#x27;]的下标,当不含有时,返回-1</span></span><br><span class="line">&gt;newArr = stringArr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">indexOf</span>(<span class="string">&#x27;2&#x27;</span>)&lt;<span class="number">0</span>) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)   <span class="comment">//log: [&quot;10&quot;, &quot;44&quot;]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="e-数组去重"><a href="#e-数组去重" class="headerlink" title="e) 数组去重"></a>e) 数组去重</h5><blockquote><p>可以利用 [ filter ] 方法实现去重,当然去重方式非常多,这里也是一种思路</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">2</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">x, index,self</span>)=&gt;</span>self.<span class="title function_">indexOf</span>(x)===index)  </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]</span></span><br></pre></td></tr></table></figure><p>这里列一个ES6提供的去重新方法 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//具体详情在下方 [Set] 相关知识点笔记中会给出</span></span><br><span class="line">&gt;<span class="keyword">const</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="title class_">NaN</span>,<span class="title class_">NaN</span>]</span><br><span class="line">&gt;<span class="keyword">let</span> res=<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));<span class="comment">//&#123;1,2,&quot;1&quot;,null,undefined,NaN&#125;</span></span><br><span class="line">&gt;<span class="comment">//or</span></span><br><span class="line">&gt;<span class="keyword">let</span> newarr=[...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑦-数组实例的-map-–-常用"><a href="#⑦-数组实例的-map-–-常用" class="headerlink" title="⑦ 数组实例的 map() –&gt;常用"></a>⑦ 数组实例的 map() –&gt;<code>常用</code></h4><blockquote><p>定义: 对数组中的每个元素进行处理, 得到新的数组；</p><p>特点: 不改变原有数据的结构和数据</p></blockquote><h5 id="a-常用方法举例"><a href="#a-常用方法举例" class="headerlink" title="a) 常用方法举例"></a>a) 常用方法举例</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> newArray = array.<span class="title function_">map</span>( <span class="function"><span class="params">value</span> =&gt;</span> value + <span class="number">1</span> ); <span class="comment">//此处用的箭头函数写法,看不懂的要回头看前方函数部分</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">//log: [2, 4, 7, 10]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(array);    <span class="comment">//log: [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-类似方法"><a href="#b-类似方法" class="headerlink" title="b) 类似方法"></a>b) 类似方法</h5><blockquote><p>类似效果实现方法:  for in , for , foreach</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> newArray2 = [];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> array) &#123; newArray2.<span class="title function_">push</span>(array[i] + <span class="number">1</span>)&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> newArray3 = [];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123; newArray3.<span class="title function_">push</span>(array[i] + <span class="number">1</span>)&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> newArray4 = [];</span><br><span class="line">&gt;array.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">key</span>) &#123; newArray4.<span class="title function_">push</span>(key * key)&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray2); <span class="comment">//log: [2, 4, 7, 10]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray3); <span class="comment">//log: [2, 4, 7, 10]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArray4); <span class="comment">//log: [1, 9, 36, 81]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(array);<span class="comment">//log: [1, 3, 6, 9]</span></span><br></pre></td></tr></table></figure><p>与上述方法的区别:</p><ul><li>.map()方法使用return，进行回调；其他方法可不需要. </li><li>.map()方法直接对数组的每个元素进行操作, 返回相同数组长度的数组；其他方法可扩展数组的长度. </li><li>.map() 不会对空数组进行检测.</li></ul></blockquote><h5 id="c-与-filter-区别"><a href="#c-与-filter-区别" class="headerlink" title="c) 与 filter() 区别"></a>c) 与 filter() 区别</h5><blockquote><p> [ filter() ] 主要用作筛选,并不会对数组中元素进行处理,只会根据匹配条件返回数组中符合条件元素;</p><p>[ map() ] 常用作将符合条件的元素进行加工,再返回出去的场景</p></blockquote><h4 id="⑧-数组实例的-reduce-–-常用"><a href="#⑧-数组实例的-reduce-–-常用" class="headerlink" title="⑧ 数组实例的 reduce() –&gt;常用"></a>⑧ 数组实例的 reduce() –&gt;<code>常用</code></h4><blockquote><p>reduce()方法可以搞定的东西，for循环，或者forEach方法有时候也可以搞定，那为啥要用reduce()？</p><p>这个问题，之前我也想过，要说原因还真找不到,但我觉得是：<strong>通往成功的道路有很多，但是总有一条路是最捷径的，亦或许reduce()逼格更高…</strong></p></blockquote><h5 id="a-语法"><a href="#a-语法" class="headerlink" title="a) 语法"></a>a) 语法</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;arr.<span class="title function_">reduce</span>(callback,[initialValue])</span><br></pre></td></tr></table></figure><p><code>reduce</code>为数组中的而每一个元素一次执行回调函数,不包括数组中被删除或从未被赋值的元素,接受四个参数: 初始值(或上一次回调函数的返回值)、当前元素值、当前索引、调用reduce的数组</p><ol><li>callback(执行数组中每个值的函数,包括四个参数)</li></ol><ul><li><code>previousValue</code>: 上一次调用回调返回的值,如果是第一次则为提供的初始值(initialValue)</li><li><code>currentValue</code>: 数组中当前被处理的元素</li><li><code>index</code>: 当前元素在数组中的索引</li><li><code>array</code>: 调用reduce的数组</li></ul><ol start="2"><li>initialValue(作为第一次调用的第一个参数)</li></ol></blockquote><h5 id="b-实例解析initialValue"><a href="#b-实例解析initialValue" class="headerlink" title="b) 实例解析initialValue"></a>b) 实例解析initialValue</h5><blockquote><p>先说得出的结论:</p><ol><li>如果没有提供<code>initialValue(初始值)</code>,reduce会从索引1的地方开始执行callback方法,跳过第一个索引.如果提供<code>initialValue</code>,则从索引0开始</li><li>一般来说要写上初始值更安全,否则空数组会出现报错</li></ol></blockquote><h6 id="1-举个栗子1"><a href="#1-举个栗子1" class="headerlink" title="(1) 举个栗子1:"></a>(1) 举个栗子1:</h6><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev,cur,index,arr</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(prev,cur,index)</span><br><span class="line">   <span class="comment">// 每次对数据进行累加</span></span><br><span class="line"> <span class="keyword">return</span> prev+cur   </span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr, sum);</span><br></pre></td></tr></table></figure><p>我们看到,<code>index</code>(打印结果中第三位)是从**<code>1</code>**开始的,第一次的prev的值是数组的第一个值.数组长度是4,但是reduce函数循环3次</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20220115142512156.png" alt="image-20220115142512156"> </p></blockquote><h6 id="2-接着看栗子2"><a href="#2-接着看栗子2" class="headerlink" title="(2) 接着看栗子2:"></a>(2) 接着看栗子2:</h6><blockquote><p>本质上就是加了第二个参数,赋予其默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//本质上就是加了第二个参数,赋予其默认值</span></span><br><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev,cur,index,arr</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(prev,cur,index)</span><br><span class="line">   <span class="comment">// 每次对数据进行累加</span></span><br><span class="line"> <span class="keyword">return</span> prev+cur   </span><br><span class="line">&gt;&#125;,<span class="number">0</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr, sum);</span><br></pre></td></tr></table></figure><p>我们可以看到:<code>index</code>是从0开始的,第一次的eprev的值是我们设置的初始值0,数组长度是4,reduce循环4次</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20220115143008922.png" alt="image-20220115143008922"> </p></blockquote><h6 id="3-结论1"><a href="#3-结论1" class="headerlink" title="(3) 结论1:"></a>(3) 结论1:</h6><blockquote><p><strong>如果没有提供<code>initialValue(初始值)</code>,reduce会从索引1的地方开始执行callback方法,跳过第一个索引.如果提供<code>initialValue</code>,则从索引0开始</strong></p><p>那么有同学可能会问了:既然没给初始值,他会从索引1开始,那么如果我遍历的数组为空,那他不会报错吗?那就引出了下面的栗子3,别急我们继续往下看</p></blockquote><h6 id="4-栗子3-如果数组为空"><a href="#4-栗子3-如果数组为空" class="headerlink" title="(4) 栗子3:如果数组为空?"></a>(4) 栗子3:如果数组为空?</h6><blockquote><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20220115144013667.png" alt="image-20220115144013667"></p><p><strong>所以一般来说我们提供初始值更安全</strong></p></blockquote><h5 id="c-reduce的简单用法"><a href="#c-reduce的简单用法" class="headerlink" title="c) reduce的简单用法"></a>c) reduce的简单用法</h5><blockquote><p>最简单的就是我们常用的数组求和、乘积</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span>  arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)</span><br><span class="line">&gt;<span class="keyword">const</span> mul = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x*y)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>( sum ); <span class="comment">//求和，10</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>( mul ); <span class="comment">//求乘积，24</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-reduce的高级用法"><a href="#d-reduce的高级用法" class="headerlink" title="d) reduce的高级用法"></a>d) reduce的高级用法</h5><h6 id="1-计算数组中每个元素出现的次数"><a href="#1-计算数组中每个元素出现的次数" class="headerlink" title="(1) 计算数组中每个元素出现的次数"></a>(1) 计算数组中每个元素出现的次数</h6><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> names = [<span class="string">&#x27;Jelyn&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hong&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="string">&#x27;Jelyn&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> nameInfo = names.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(cur <span class="keyword">in</span> pre)&#123;</span><br><span class="line">    <span class="comment">//如果当前项,是pre对象的属性key,则将其value+1</span></span><br><span class="line">   pre[cur]++</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//如果当前项不存在对象key中,则将此项作为其对象key,且给定初始值1</span></span><br><span class="line">   pre[cur] = <span class="number">1</span> </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> pre</span><br><span class="line">&gt;&#125;,&#123;&#125;)<span class="comment">//给定初始值空对象</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(nameInfo);<span class="comment">//&#123;Jelyn: 2, 努力学习的汪: 3, hong: 1&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="2-数组去重"><a href="#2-数组去重" class="headerlink" title="(2) 数组去重"></a>(2) 数组去重</h6><blockquote><ul><li><code>includes()</code>:用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</li><li><code>concat()</code> : 用于连接两个或多个数组;且不会更改现有数组，而是返回一个新数组，其中包含已连接数组的值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> names = [<span class="string">&#x27;Jelyn&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hong&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="string">&#x27;Jelyn&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> newArr = names.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="comment">//如果 当前项不存在于 pre中</span></span><br><span class="line">   <span class="keyword">if</span>(!pre.<span class="title function_">includes</span>(cur))&#123;</span><br><span class="line">   <span class="comment">//则将 当前项并入 pre数组中</span></span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(cur)</span><br><span class="line">    <span class="comment">// 也可使用push</span></span><br><span class="line">   <span class="comment">//pre.push(cur);  return pre ;</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//如果存在于pre中,则不并入,将pre原样返回,进入下次循环</span></span><br><span class="line">     <span class="keyword">return</span> pre</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;,[])</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);<span class="comment">//[&#x27;Jelyn&#x27;, &#x27;努力学习的汪&#x27;, &#x27;hong&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h6 id="3-将二维数组转化成一维"><a href="#3-将二维数组转化成一维" class="headerlink" title="(3)  将二维数组转化成一维"></a>(3)  将二维数组转化成一维</h6><blockquote><p>首先,最简单的方法是使用上面讲过的<code>flat()</code>方法,他能拉平一层数组,但这里再写个使用reduce实现的栗子</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20220115155344679.png" alt="image-20220115155344679"> </p></blockquote><h6 id="4-将多维转换成一维"><a href="#4-将多维转换成一维" class="headerlink" title="(4) 将多维转换成一维"></a>(4) 将多维转换成一维</h6><blockquote><p>与上面的一样,可以用<code>flat</code>实现,所以遇到这种情况还是用flat好</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20220115155702841.png" alt="image-20220115155702841"></p></blockquote><h6 id="5-对象数组去重-–-常用"><a href="#5-对象数组去重-–-常用" class="headerlink" title="(5) 对象数组去重 –&gt;常用"></a>(5) 对象数组去重 –&gt;<code>常用</code></h6><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;   </span><br><span class="line">&gt;<span class="keyword">const</span> arr = [</span><br><span class="line">       &#123; <span class="attr">id</span>: <span class="string">&#x27;17011300&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span><br><span class="line">       &#123; <span class="attr">id</span>: <span class="string">&#x27;170113001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;Jelyn&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span><br><span class="line">       &#123; <span class="attr">id</span>: <span class="string">&#x27;17011300&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span><br><span class="line">       &#123; <span class="attr">id</span>: <span class="string">&#x27;17011300&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;18&#x27;</span> &#125;,</span><br><span class="line">       &#123; <span class="attr">id</span>: <span class="string">&#x27;999&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>, <span class="attr">age</span>: <span class="string">&#x27;28&#x27;</span> &#125;</span><br><span class="line">     ]</span><br><span class="line">&gt;<span class="keyword">const</span> temp = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">item, next</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (obj[next.<span class="property">id</span>] &amp;&amp; next.<span class="property">id</span>) &#123; <span class="keyword">return</span> item &#125; <span class="keyword">else</span> obj[next.<span class="property">id</span>] = <span class="literal">true</span> &amp;&amp; item.<span class="title function_">push</span>(next)</span><br><span class="line">       <span class="keyword">return</span> item</span><br><span class="line">     &#125;, [])</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(temp)</span><br></pre></td></tr></table></figure><h6 id="解析"><a href="#解析" class="headerlink" title="解析:"></a>解析:</h6><ol><li>当首次进入时,必定为空,这时就进入了else中,在此处给这个属性加上一个value,同时将这个next存入数组中</li><li>当后续进入时,如果 id重复,则在上轮中已经给他赋值了true,所以此处就判断到重复值,此时将item直接抛出</li><li>当后续进入时,如果 id 不重复,就重复第一步</li><li><code>&amp;&amp; next.id</code> 如果加了,则不会筛选没有 id 的数据,如果去除,则会过滤</li></ol><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20220115160957448.png" alt="image-20220115160957448"> </p></blockquote><h4 id="⑨-数组实例的-some-、every"><a href="#⑨-数组实例的-some-、every" class="headerlink" title="⑨ 数组实例的 some() 、every()"></a>⑨ 数组实例的 some() 、every()</h4><blockquote><p><strong>some()</strong> : 方法测试数组中是不是至少有1个元素通过了被提供的函数测试. 它返回的是一个Boolean类型的值. </p><p><strong>every()</strong>: 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试. 它返回一个布尔值. </p></blockquote><h3 id="Ⅵ-数组的空位"><a href="#Ⅵ-数组的空位" class="headerlink" title="Ⅵ - 数组的空位"></a>Ⅵ - 数组的空位</h3><blockquote><p>数组的空位指, 数组的某一个位置没有任何值. 比如, <code>Array</code>构造函数返回的数组都是空位. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Array(3)</code>返回一个具有 3 个空位的数组. </p><p>注意, 空位不是<strong>undefined</strong>, 一个位置的值等于<strong>undefined</strong>, 依然是有值的. <code>空位是没有任何值</code>, [ in ]运算符可以说明这一点. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line">&gt;<span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码说明, 第一个数组的 0 号位置是有值的, 第二个数组的 0 号位置没有值. </p><p>ES5 对空位的处理, 已经很不一致了, <strong>大多数情况下会忽略空位</strong>. </p><ul><li>forEach(), filter(), reduce(),  every()  和 some() 都会跳过空位. </li><li>map() 会跳过空位, 但会保留这个值</li><li>join()  和 toString() 会将空位视为 undefined , 而 <strong>undefined</strong> 和 <strong>null</strong>会被处理成空字符串.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// forEach方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// filter方法</span></span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// every方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reduce方法</span></span><br><span class="line">&gt;[<span class="number">1</span>,,<span class="number">2</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// some方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">some</span>(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// map方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// join方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].<span class="title function_">join</span>(<span class="string">&#x27;#&#x27;</span>) <span class="comment">// &quot;#a##&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// toString方法</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].<span class="title function_">toString</span>() <span class="comment">// &quot;,a,,&quot;</span></span><br></pre></td></tr></table></figure><p>ES6 则是明确将空位转为 <strong>undefined</strong>. </p><p><code>Array.from</code>方法会将数组的空位, 转为 <strong>undefined</strong>, 也就是说, 这个方法不会忽略空位. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">&gt;<span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><p>扩展运算符（<code>...</code>）也会将空位转为 <strong>undefined</strong>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line">&gt;<span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure><p><code>copyWithin()</code>会连空位一起拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,,].<span class="title function_">copyWithin</span>(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,&quot;a&quot;,,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p><code>fill()</code>会将空位视为正常的数组位置. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p><code>for...of</code>循环也会遍历空位. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [, ,];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 1</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中, 数组<code>arr</code>有两个空位, <code>for...of</code>并没有忽略它们. 如果改成<code>map</code>方法遍历, 空位是会跳过的. </p><p>[ entries() ]、[ keys() ]、[ values() ]、<code>find()</code>和<code>findIndex()</code>会将空位处理成 <strong>undefined</strong>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// entries()</span></span><br><span class="line">&gt;[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">entries</span>()] <span class="comment">// [[0,undefined], [1,&quot;a&quot;]]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// keys()</span></span><br><span class="line">&gt;[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">keys</span>()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// values()</span></span><br><span class="line">&gt;[...[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">values</span>()] <span class="comment">// [undefined,&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// find()</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// findIndex()</span></span><br><span class="line">&gt;[,<span class="string">&#x27;a&#x27;</span>].<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>由于空位的处理规则非常不统一, 所以建议避免出现空位. </p></blockquote><h3 id="Ⅶ-Array-prototype-sort-的排序稳定性"><a href="#Ⅶ-Array-prototype-sort-的排序稳定性" class="headerlink" title="Ⅶ - Array.prototype.sort() 的排序稳定性"></a>Ⅶ - Array.prototype.sort() 的排序稳定性</h3><blockquote><p>排序稳定性（stable sorting）是排序算法的重要属性, 指的是排序关键字相同的项目, 排序前后的顺序不变. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [</span><br><span class="line"> <span class="string">&#x27;peach&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;straw&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;apple&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;spork&#x27;</span></span><br><span class="line">&gt;];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">stableSorting</span> = (<span class="params">s1, s2</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;arr.<span class="title function_">sort</span>(stableSorting)</span><br><span class="line">&gt;<span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码对数组<code>arr</code>按照首字母进行排序. 排序结果中, <code>straw</code>在<code>spork</code>的前面, 跟原始顺序一致, 所以排序算法<code>stableSorting</code>是稳定排序. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">unstableSorting</span> = (<span class="params">s1, s2</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt;= s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;arr.<span class="title function_">sort</span>(unstableSorting)</span><br><span class="line">&gt;<span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 排序结果是<code>spork</code>在<code>straw</code>前面, 跟原始顺序相反, 所以排序算法<code>unstableSorting</code>是不稳定的. </p><p>常见的排序算法之中, 插入排序、合并排序、冒泡排序等都是稳定的, 堆排序、快速排序等是不稳定的. 不稳定排序的主要缺点是, 多重排序时可能会产生问题. 假设有一个姓和名的列表, 要求按照“姓氏为主要关键字, 名字为次要关键字”进行排序. 开发者可能会先按名字排序, 再按姓氏进行排序. 如果排序算法是稳定的, 这样就可以达到“先姓氏, 后名字”的排序效果. 如果是不稳定的, 就不行. </p><p>早先的 ECMAScript 没有规定, <code>Array.prototype.sort()</code>的默认排序算法是否稳定, 留给浏览器自己决定, 这导致某些实现是不稳定的. <a href="https://github.com/tc39/ecma262/pull/1340">ES2019</a> 明确规定, <code>Array.prototype.sort()</code>的默认排序算法必须稳定. 这个规定已经做到了, 现在 JavaScript 各个主要实现的默认排序算法都是稳定的. </p></blockquote><h2 id="9、正则的拓展"><a href="#9、正则的拓展" class="headerlink" title="9、正则的拓展"></a>9、正则的拓展</h2><blockquote><p>首先要学好正则基础再来看此部分(或者直接暂时跳过),不然的话,大概率你会在这里看不下去的!!!</p><p>如果对于正则技术不是很急需的也可以先跳过,相对而言ES6正则刚需没那么大</p><p>对于正则基础笔记本人也有进行详细且系统的梳理,需要的可以去看看       –&gt;  <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">正则表达式学习笔记</a></strong> </p></blockquote><h3 id="Ⅰ-概括与总结-2"><a href="#Ⅰ-概括与总结-2" class="headerlink" title="Ⅰ- 概括与总结"></a>Ⅰ- 概括与总结</h3><blockquote><ul><li><strong>变更RegExp构造函数入参</strong>: 允许首参数为<code>正则对象</code>, 尾参数为<code>正则修饰符</code>(返回的正则表达式会忽略原正则表达式的修饰符)</li><li><strong>正则方法调用变更</strong>: 字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></li><li><strong>u修饰符</strong>: Unicode模式修饰符, 正确处理大于 [ \uFFFF ] 的 [ Unicode字符 ]</li><li><code>点字符</code>(.)</li><li><code>Unicode表示法</code></li><li><code>量词</code></li><li><code>预定义模式</code></li><li><code>i修饰符</code></li><li><code>转义</code></li><li><strong>y修饰符</strong>: 粘连修饰符, 确保匹配必须从剩余的第一个位置开始全局匹配(与<code>g修饰符</code>作用类似)</li><li><strong>unicode</strong>: 是否设置<code>u修饰符</code></li><li><strong>sticky</strong>: 是否设置<code>y修饰符</code></li><li><strong>flags</strong>: 返回正则表达式的修饰符</li></ul><blockquote><p>重点难点</p></blockquote><ul><li><code>y修饰符</code>隐含头部匹配标志<code>^</code></li><li>单单一个<code>y修饰符</code>对<code>match()</code>只能返回第一个匹配, 必须与<code>g修饰符</code>联用才能返回所有匹配</li></ul></blockquote><h3 id="Ⅱ-RegExp-构造函数"><a href="#Ⅱ-RegExp-构造函数" class="headerlink" title="Ⅱ - RegExp 构造函数"></a>Ⅱ - RegExp 构造函数</h3><blockquote><p>在 ES5 中, <code>RegExp</code>构造函数的参数有两种情况. </p><p>第一种情况是, 参数是字符串, 这时第二个参数表示正则表达式的修饰符（flag 标志）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><p>第二种情况是, 参数是一个正则表示式, 这时会返回一个原有正则表达式的拷贝. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><p>但是，ES5 不允许此时使用第二个参数添加修饰符, 否则会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为. 如果<code>RegExp</code>构造函数第一个参数是一个正则对象, 那么可以使用第二个参数指定修饰符. 而且, 返回的正则表达式会忽略原有的正则表达式的修饰符, 只使用新指定的修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>).<span class="property">flags</span></span><br><span class="line">&gt;<span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 原有正则对象的修饰符是<code>ig</code>, 它会被第二个参数<code>i</code>覆盖. </p></blockquote><h3 id="Ⅲ-字符串的正则方法"><a href="#Ⅲ-字符串的正则方法" class="headerlink" title="Ⅲ -  字符串的正则方法"></a>Ⅲ -  字符串的正则方法</h3><blockquote><p>字符串对象共有 4 个方法, 可以使用正则表达式: <code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>. </p><p>ES6 将这 4 个方法, 在语言内部全部调用<code>RegExp</code>的实例方法, 从而做到所有与正则相关的方法, 全都定义在<code>RegExp</code>对象上. </p><ul><li>[ String.prototype.match ] 调用 <code>RegExp.prototype[Symbol.match]</code></li><li>[ String.prototype.replace ]  调用 <code>RegExp.prototype[Symbol.replace]</code></li><li>[ String.prototype.search ]  调用 <code>RegExp.prototype[Symbol.search]</code></li><li>[ String.prototype.split ]  调用 <code>RegExp.prototype[Symbol.split]</code></li></ul></blockquote><h3 id="Ⅳ-u-修饰符"><a href="#Ⅳ-u-修饰符" class="headerlink" title="Ⅳ -  u 修饰符"></a>Ⅳ -  u 修饰符</h3><blockquote><p>ES6 对正则表达式添加了<code>u</code>修饰符, 含义为“Unicode 模式”, 用来正确处理大于<code>\uFFFF</code>的 Unicode 字符. 也就是说, 会正确处理四个字节的 UTF-16 编码. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\uD83D/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^\uD83D/</span>.<span class="title function_">test</span>(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>\uD83D\uDC2A</code>是一个四个字节的 UTF-16 编码, 代表一个字符. 但是，ES5 不支持四个字节的 UTF-16 编码, 会将其识别为两个字符, 导致第二行代码结果为<code>true</code>. 加了<code>u</code>修饰符以后，ES6 就会识别其为一个字符, 所以第一行代码结果为<code>false</code>. </p><p>一旦加上<code>u</code>修饰符号, 就会修改下面这些正则表达式的行为:</p></blockquote><h4 id="①-点字符"><a href="#①-点字符" class="headerlink" title="① 点字符"></a>① 点字符</h4><blockquote><p>点（<code>.</code>）字符在正则表达式中, 含义是除了换行符以外的任意单个字符. 对于码点大于<code>0xFFFF</code>的 Unicode 字符, 点字符不能识别, 必须加上<code>u</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line">&gt;<span class="regexp">/^.$/</span>.<span class="title function_">test</span>(s) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^.$/u</span>.<span class="title function_">test</span>(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示, 如果不添加<code>u</code>修饰符, 正则表达式就会认为字符串为两个字符, 从而匹配失败. </p></blockquote><h4 id="②-Unicode-字符表示法"><a href="#②-Unicode-字符表示法" class="headerlink" title="② Unicode 字符表示法"></a>② Unicode 字符表示法</h4><blockquote><p>ES6 新增了使用大括号表示 Unicode 字符, 这种表示法在正则表达式中必须加上<code>u</code>修饰符, 才能识别当中的大括号, 否则会被解读为量词. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/\u&#123;61&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/\u&#123;61&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/\u&#123;20BB7&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表示, 如果不加<code>u</code>修饰符, 正则表达式无法识别<code>\u&#123;61&#125;</code>这种表示法, 只会认为这匹配 61 个连续的<code>u</code>. </p></blockquote><h4 id="③-量词"><a href="#③-量词" class="headerlink" title="③ 量词"></a>③ 量词</h4><blockquote><p>使用<code>u</code>修饰符后, 所有量词都会正确识别码点大于<code>0xFFFF</code>的 Unicode 字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/a&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/a&#123;2&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="regexp">/𠮷&#123;2&#125;/</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/𠮷&#123;2&#125;/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-预定义模式"><a href="#④-预定义模式" class="headerlink" title="④ 预定义模式"></a>④ 预定义模式</h4><blockquote><p><code>u</code>修饰符也影响到预定义模式, 能否正确识别码点大于<code>0xFFFF</code>的 Unicode 字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/^\S$/</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/^\S$/u</span>.<span class="title function_">test</span>(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>\S</code>是预定义模式, 匹配所有非空白字符. 只有加了<code>u</code>修饰符, 它才能正确匹配码点大于<code>0xFFFF</code>的 Unicode 字符. </p><p>利用这一点, 可以写出一个正确返回字符串长度的函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">codePointLength</span>(<span class="params">text</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> result = text.<span class="title function_">match</span>(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line"> <span class="keyword">return</span> result ? result.<span class="property">length</span> : <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;𠮷𠮷&#x27;</span>;</span><br><span class="line">&gt;s.<span class="property">length</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="title function_">codePointLength</span>(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-i-修饰符"><a href="#⑤-i-修饰符" class="headerlink" title="⑤ i 修饰符"></a>⑤ i 修饰符</h4><blockquote><p>有些 Unicode 字符的编码不同, 但是字型很相近, 比如, <code>\u004B</code>与<code>\u212A</code>都是大写的<code>K</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/[a-z]/i</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="regexp">/[a-z]/iu</span>.<span class="title function_">test</span>(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 不加<code>u</code>修饰符, 就无法识别非规范的<code>K</code>字符. </p></blockquote><h4 id="⑥-转义"><a href="#⑥-转义" class="headerlink" title="⑥ 转义"></a>⑥ 转义</h4><blockquote><p>没有<code>u</code>修饰符的情况下, 正则中没有定义的转义（如逗号的转义<code>\,</code>）无效, 而在<code>u</code>模式会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/\,/</span> <span class="comment">// /\,/</span></span><br><span class="line">&gt;<span class="regexp">/\,/u</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中, 没有<code>u</code>修饰符时, 逗号前面的反斜杠是无效的, 加了<code>u</code>修饰符就报错. </p></blockquote><h4 id="⑦-RegExp-prototype-unicode-属性"><a href="#⑦-RegExp-prototype-unicode-属性" class="headerlink" title="⑦ RegExp.prototype.unicode 属性"></a>⑦ RegExp.prototype.unicode 属性</h4><blockquote><p>正则实例对象新增<code>unicode</code>属性, 表示是否设置了<code>u</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="property">unicode</span> <span class="comment">// false</span></span><br><span class="line">&gt;r2.<span class="property">unicode</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 正则表达式是否设置了<code>u</code>修饰符, 可以从<code>unicode</code>属性看出来. </p></blockquote><h3 id="Ⅴ-y-修饰符"><a href="#Ⅴ-y-修饰符" class="headerlink" title="Ⅴ -  y 修饰符"></a>Ⅴ -  y 修饰符</h3><blockquote><p>提前剧透, <code>y</code>修饰符号相当于 <code>/g</code>隐含了头部匹配的标志<code>^</code>. 带着这个思维就相对容易理解下方的<code>粘连</code>一次</p></blockquote><h4 id="①-正常使用举例说明"><a href="#①-正常使用举例说明" class="headerlink" title="① 正常使用举例说明"></a>① 正常使用举例说明</h4><blockquote><p>除了<code>u</code>修饰符，ES6 还为正则表达式添加了<code>y</code>修饰符, 叫做“粘连”（sticky）修饰符. 实际上相当于默认加了一个<code>^</code></p><p><code>y</code>修饰符的作用与<code>g</code>修饰符类似, 也是全局匹配, 后一次匹配都从上一次匹配成功的下一个位置开始. 不同之处在于, <code>g</code>修饰符只要剩余位置中存在匹配就可, 而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始, 这也就是“粘连”的涵义. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]  --&gt;此时剩余字符串[_aa_a]</span></span><br><span class="line">&gt;r2.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa&quot;]  --&gt;此时剩余字符串[_aa_a]</span></span><br><span class="line"></span><br><span class="line">&gt;r1.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">&gt;r2.<span class="title function_">exec</span>(s) <span class="comment">// null     --&gt;y必须从第一个位置开始匹配,实际上相当于默认加了一个`^`,所以匹配不到</span></span><br></pre></td></tr></table></figure><p>上面代码有两个正则表达式, 一个使用<code>g</code>修饰符, 另一个使用<code>y</code>修饰符. 这两个正则表达式各执行了两次, 第一次执行的时候, 两者行为相同, 剩余字符串都是<code>_aa_a</code>. 由于<code>g</code>修饰没有位置要求, 所以第二次执行会返回结果, 而<code>y</code>修饰符要求匹配必须从头部开始, 所以返回<code>null</code>. </p><p>如果改一下正则表达式, 保证每次都能头部匹配, <code>y</code>修饰符就会返回结果了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">&gt;r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aaa_&quot;]</span></span><br><span class="line">&gt;r.<span class="title function_">exec</span>(s) <span class="comment">// [&quot;aa_&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码每次匹配, 都是从剩余字符串的头部开始. </p></blockquote><h4 id="②-使用lastIndex属性进行说明"><a href="#②-使用lastIndex属性进行说明" class="headerlink" title="② 使用lastIndex属性进行说明"></a>② 使用<code>lastIndex</code>属性进行说明</h4><blockquote><p>使用<code>lastIndex</code>属性, 可以更好地说明<code>y</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/g</span>;</span><br><span class="line">&gt;<span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 匹配成功</span></span><br><span class="line">&gt;<span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">&gt;match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br><span class="line">&gt;<span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>lastIndex</code>属性指定每次搜索的开始位置, <code>g</code>修饰符从这个位置开始向后搜索, 直到发现匹配为止. </p><p><code>y</code>修饰符同样遵守<code>lastIndex</code>属性, 但是要求必须在<code>lastIndex</code>指定的位置发现匹配. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/y</span>;</span><br><span class="line">&gt;<span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">2</span>;</span><br><span class="line">&gt;<span class="comment">// 不是粘连, 匹配失败</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line">&gt;<span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> = <span class="number">3</span>;</span><br><span class="line">&gt;<span class="comment">// 3号位置是粘连, 匹配成功</span></span><br><span class="line">&gt;<span class="keyword">const</span> match = <span class="variable constant_">REGEX</span>.<span class="title function_">exec</span>(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">&gt;match.<span class="property">index</span> <span class="comment">// 3</span></span><br><span class="line">&gt;<span class="variable constant_">REGEX</span>.<span class="property">lastIndex</span> <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>实际上, <code>y</code>修饰符号隐含了头部匹配的标志<code>^</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/b/y</span>.<span class="title function_">exec</span>(<span class="string">&#x27;aba&#x27;</span>)<span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>上面代码由于不能保证头部匹配, 所以返回<code>null</code>. <code>y</code>修饰符的设计本意, 就是让头部匹配的标志<code>^</code>在全局匹配中都有效. </p></blockquote><h4 id="③-使用字符串对象的replace方法的举例"><a href="#③-使用字符串对象的replace方法的举例" class="headerlink" title="③ 使用字符串对象的replace方法的举例"></a>③ 使用字符串对象的<code>replace</code>方法的举例</h4><blockquote><p>下面是字符串对象的<code>replace</code>方法的例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">REGEX</span> = <span class="regexp">/a/gy</span>;</span><br><span class="line">&gt;<span class="string">&#x27;aaxa&#x27;</span>.<span class="title function_">replace</span>(<span class="variable constant_">REGEX</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;--xa&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 最后一个<code>a</code>因为不是出现在下一次匹配的头部, 所以不会被替换. </p><p>单单一个<code>y</code>修饰符对<code>match</code>方法, 只能返回第一个匹配, 必须与<code>g</code>修饰符联用, 才能返回所有匹配. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line">&gt;<span class="string">&#x27;a1a2a3&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure><p><code>y</code>修饰符的一个应用, 是从字符串提取 token（词元）, <code>y</code>修饰符确保了匹配之间不会有漏掉的字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">TOKEN_Y</span> = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">TOKEN_G</span>  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> result = [];</span><br><span class="line"> <span class="keyword">let</span> match;</span><br><span class="line"> <span class="keyword">while</span> (match = <span class="variable constant_">TOKEN_REGEX</span>.<span class="title function_">exec</span>(str)) &#123;</span><br><span class="line">   result.<span class="title function_">push</span>(match[<span class="number">1</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 如果字符串里面没有非法字符, <code>y</code>修饰符与<code>g</code>修饰符的提取结果是一样的. 但是, 一旦出现非法字符, 两者的行为就不一样了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_Y</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27; ]</span></span><br><span class="line">&gt;<span class="title function_">tokenize</span>(<span class="variable constant_">TOKEN_G</span>, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>g</code>修饰符会忽略非法字符, 而<code>y</code>修饰符不会, 这样就很容易发现错误. </p></blockquote><h4 id="④-RegExp-prototype-sticky-属性"><a href="#④-RegExp-prototype-sticky-属性" class="headerlink" title="④ RegExp.prototype.sticky 属性"></a>④ RegExp.prototype.sticky 属性</h4><blockquote><p>与<code>y</code>修饰符相匹配，ES6 的正则实例对象多了<code>sticky</code>属性, 表示是否设置了<code>y</code>修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">&gt;r.<span class="property">sticky</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅵ-s-修饰符-dotAll-模式"><a href="#Ⅵ-s-修饰符-dotAll-模式" class="headerlink" title="Ⅵ - s 修饰符: dotAll 模式"></a>Ⅵ - s 修饰符: dotAll 模式</h3><blockquote><p>正则表达式中, 点（<code>.</code>）是一个特殊字符, 代表任意的单个字符, 但是有两个例外. 一个是四个字节的 UTF-16 字符, 这个可以用<code>u</code>修饰符解决；另一个是行终止符（line terminator character）. </p><p>所谓行终止符, 就是该字符表示一行的终结. 以下四个字符属于“行终止符”. </p><ul><li>U+000A 换行符（<code>\n</code>）</li><li>U+000D 回车符（<code>\r</code>）</li><li>U+2028 行分隔符（line separator）</li><li>U+2029 段分隔符（paragraph separator）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中, 因为<code>.</code>不匹配<code>\n</code>, 所以正则表达式返回<code>false</code>. </p><p>但是, 很多时候我们希望匹配的是任意单个字符, 这时有一种变通的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo[^]bar/</span>.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种解决方案毕竟不太符合直觉,  <a href="https://github.com/tc39/proposal-regexp-dotall-flag">ES2018</a> 引入<code>s</code>修饰符, 使得<code>.</code>可以匹配任意单个字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/foo.bar/</span>s.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这被称为<code>dotAll</code>模式, 即点（dot）代表一切字符. 所以, 正则表达式还引入了一个<code>dotAll</code>属性, 返回一个布尔值, 表示该正则表达式是否处在<code>dotAll</code>模式. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line">&gt;<span class="comment">// 另一种写法</span></span><br><span class="line">&gt;<span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line">&gt;re.<span class="title function_">test</span>(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;re.<span class="property">dotAll</span> <span class="comment">// true</span></span><br><span class="line">&gt;re.<span class="property">flags</span> <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure><p><code>/s</code>修饰符和多行修饰符<code>/m</code>不冲突, 两者一起使用的情况下, <code>.</code>匹配所有字符, 而<code>^</code>和<code>$</code>匹配每一行的行首和行尾. </p></blockquote><h3 id="Ⅶ-RegExp-prototype-flags-属性"><a href="#Ⅶ-RegExp-prototype-flags-属性" class="headerlink" title="Ⅶ - RegExp.prototype.flags 属性"></a>Ⅶ - RegExp.prototype.flags 属性</h3><blockquote><p>ES6 为正则表达式新增了<code>flags</code>属性, 会返回正则表达式的修饰符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 的 source 属性</span></span><br><span class="line">&gt;<span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">&gt;<span class="regexp">/abc/ig</span>.<span class="property">source</span></span><br><span class="line">&gt;<span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 的 flags 属性</span></span><br><span class="line">&gt;<span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">&gt;<span class="regexp">/abc/ig</span>.<span class="property">flags</span></span><br><span class="line">&gt;<span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅷ-Unicode-属性类"><a href="#Ⅷ-Unicode-属性类" class="headerlink" title="Ⅷ - Unicode 属性类"></a>Ⅷ - Unicode 属性类</h3><blockquote><p>ES2018 <a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">引入</a>了一种新的类的写法<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>, 允许正则表达式匹配符合 Unicode 某种属性的所有字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">&gt;regexGreekSymbol.<span class="title function_">test</span>(<span class="string">&#x27;π&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>\p&#123;Script=Greek&#125;</code>指定匹配一个希腊文字母, 所以匹配<code>π</code>成功. </p><p>Unicode 属性类要指定属性名和属性值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyName</span>=<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure><p>对于某些属性, 可以只写属性名, 或者只写属性值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyName</span>&#125;</span><br><span class="line">&gt;\p&#123;<span class="title class_">UnicodePropertyValue</span>&#125;</span><br></pre></td></tr></table></figure><p><code>\P&#123;…&#125;</code>是<code>\p&#123;…&#125;</code>的反向匹配, 即匹配不满足条件的字符. </p><p>注意, 这两种类只对 Unicode 有效, 所以使用的时候一定要加上<code>u</code>修饰符. 如果不加<code>u</code>修饰符, 正则表达式使用<code>\p</code>和<code>\P</code>会报错，ECMAScript 预留了这两个类. </p><p>由于 Unicode 的各种属性非常多, 所以这种新的类的表达能力非常强. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 属性类指定匹配所有十进制字符, 可以看到各种字型的十进制字符都会匹配成功. </p><p><code>\p&#123;Number&#125;</code>甚至能匹配罗马数字. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 匹配所有数字</span></span><br><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;²³¹¼½¾&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;㉛㉜㉝&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;regex.<span class="title function_">test</span>(<span class="string">&#x27;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>下面是其他一些例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 匹配所有空格</span></span><br><span class="line">&gt;\p&#123;<span class="title class_">White</span>_Space&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配各种文字的所有字母, 等同于 Unicode 版的 \w</span></span><br><span class="line">&gt;[\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配各种文字的所有非字母的字符, 等同于 Unicode 版的 \W</span></span><br><span class="line">&gt;[^\p&#123;<span class="title class_">Alphabetic</span>&#125;\p&#123;<span class="title class_">Mark</span>&#125;\p&#123;<span class="title class_">Decimal</span>_Number&#125;\p&#123;<span class="title class_">Connector</span>_Punctuation&#125;\p&#123;<span class="title class_">Join</span>_Control&#125;]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配 Emoji</span></span><br><span class="line">&gt;<span class="regexp">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line">&gt;<span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">&gt;regexArrows.<span class="title function_">test</span>(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅸ-具名组匹配"><a href="#Ⅸ-具名组匹配" class="headerlink" title="Ⅸ - 具名组匹配"></a>Ⅸ - 具名组匹配</h3><h4 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h4><blockquote><p>正则表达式使用圆括号进行组匹配. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br></pre></td></tr></table></figure><p>上面代码中, 正则表达式里面有三组圆括号. 使用<code>exec</code>方法, 就可以将这三组匹配结果提取出来. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">&gt;<span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">&gt;<span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>组匹配的一个问题是, 每一组的匹配含义不容易看出来, 而且只能用数字序号（比如<code>matchObj[1]</code>）引用, 要是组的顺序变了, 引用的时候就必须修改序号. </p><p>ES2018 引入了<a href="https://github.com/tc39/proposal-regexp-named-groups">具名组匹配</a>（Named Capture Groups）, 允许为每一个组匹配指定一个名字, 既便于阅读代码, 又便于引用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_DATE</span> = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_DATE</span>.<span class="title function_">exec</span>(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> year = matchObj.<span class="property">groups</span>.<span class="property">year</span>; <span class="comment">// 1999</span></span><br><span class="line">&gt;<span class="keyword">const</span> month = matchObj.<span class="property">groups</span>.<span class="property">month</span>; <span class="comment">// 12</span></span><br><span class="line">&gt;<span class="keyword">const</span> day = matchObj.<span class="property">groups</span>.<span class="property">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><p>上面代码中, “具名组匹配”在圆括号内部, 模式的头部添加 [ “问号 + 尖括号 + 组名” ] （<code>?&lt;year&gt;</code>）, 然后就可以在<code>exec</code>方法返回结果的<code>groups</code>属性上引用该组名. 同时, 数字序号（<code>matchObj[1]</code>）依然有效. </p><p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的. 如果组的顺序变了, 也不用改变匹配后的处理代码. </p><p>如果具名组没有匹配, 那么对应的<code>groups</code>对象属性会是<code>undefined</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_OPT_A</span> = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> matchObj = <span class="variable constant_">RE_OPT_A</span>.<span class="title function_">exec</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;matchObj.<span class="property">groups</span>.<span class="property">as</span> <span class="comment">// undefined</span></span><br><span class="line">&gt;<span class="string">&#x27;as&#x27;</span> <span class="keyword">in</span> matchObj.<span class="property">groups</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 具名组<code>as</code>没有找到匹配, 那么<code>matchObj.groups.as</code>属性值就是<code>undefined</code>, 并且<code>as</code>这个键名在<code>groups</code>是始终存在的. </p></blockquote><h4 id="②-解构赋值和替换"><a href="#②-解构赋值和替换" class="headerlink" title="② 解构赋值和替换"></a>② 解构赋值和替换</h4><blockquote><p>有了具名组匹配以后, 可以使用解构赋值直接从匹配结果上为变量赋值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.<span class="title function_">exec</span>(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">&gt;one  <span class="comment">// foo</span></span><br><span class="line">&gt;two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>字符串替换时, 使用<code>$&lt;组名&gt;</code>引用具名组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>replace</code>方法的第二个参数是一个字符串, 而不是正则表达式. </p><p><code>replace</code>方法的第二个参数也可以是函数, 该函数的参数序列如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">&#x27;2015-01-02&#x27;</span>.<span class="title function_">replace</span>(re, <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture1, <span class="comment">// 第一个组匹配 2015</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture2, <span class="comment">// 第二个组匹配 01</span></span></span></span><br><span class="line"><span class="params"><span class="function">  capture3, <span class="comment">// 第三个组匹配 02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  position, <span class="comment">// 匹配开始的位置 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">  S, <span class="comment">// 原字符串 2015-01-02</span></span></span></span><br><span class="line"><span class="params"><span class="function">  groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>具名组匹配在原来的基础上, 新增了最后一个函数参数: 具名组构成的一个对象. 函数内部可以直接对这个对象进行解构赋值. </p></blockquote><h4 id="③-引用"><a href="#③-引用" class="headerlink" title="③ 引用"></a>③ 引用</h4><blockquote><p>如果要在正则表达式内部引用某个“具名组匹配”, 可以使用<code>\k&lt;组名&gt;</code>的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>数字引用（<code>\1</code>）依然有效. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这两种引用语法还可以同时使用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">RE_TWICE</span> = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable constant_">RE_TWICE</span>.<span class="title function_">test</span>(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅹ-String-prototype-matchAll"><a href="#Ⅹ-String-prototype-matchAll" class="headerlink" title="Ⅹ - String.prototype.matchAll()"></a>Ⅹ - String.prototype.matchAll()</h3><blockquote><p>如果一个正则表达式在字符串里面有多个匹配, 现在一般使用<code>g</code>修饰符或<code>y</code>修饰符, 在循环里面逐一取出. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> matches = [];</span><br><span class="line">&gt;<span class="keyword">var</span> match;</span><br><span class="line">&gt;<span class="keyword">while</span> (match = regex.<span class="title function_">exec</span>(string)) &#123;</span><br><span class="line"> matches.<span class="title function_">push</span>(match);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;matches</span><br><span class="line">&gt;<span class="comment">// [</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],</span></span><br><span class="line">&gt;<span class="comment">//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>while</code>循环取出每一轮的正则匹配, 一共三轮. </p><p><a href="https://github.com/tc39/proposal-string-matchall">ES2020</a> 增加了<code>String.prototype.matchAll()</code>方法, 可以一次性取出所有匹配. 不过, 它返回的是一个遍历器（Iterator）, 而不是数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.<span class="title function_">matchAll</span>(regex)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(match);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line">&gt;<span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 由于<code>string.matchAll(regex)</code>返回的是遍历器, 所以可以用<code>for...of</code>循环取出. 相对于返回数组, 返回遍历器的好处在于, 如果匹配结果是一个很大的数组, 那么遍历器比较节省资源. </p><p>遍历器转为数组是非常简单的, 使用<code>...</code>运算符和<code>Array.from()</code>方法就可以了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 转为数组的方法一</span></span><br><span class="line">&gt;[...string.<span class="title function_">matchAll</span>(regex)]</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 转为数组的方法二</span></span><br><span class="line">&gt;<span class="title class_">Array</span>.<span class="title function_">from</span>(string.<span class="title function_">matchAll</span>(regex))</span><br></pre></td></tr></table></figure></blockquote><h2 id="10、Symbol"><a href="#10、Symbol" class="headerlink" title="10、Symbol"></a>10、Symbol</h2><h3 id="Ⅰ-概述与总结"><a href="#Ⅰ-概述与总结" class="headerlink" title="Ⅰ- 概述与总结"></a>Ⅰ- 概述与总结</h3><blockquote><p>ES5 的对象属性名都是字符串, 这容易造成属性名的冲突. 比如, 你使用了一个他人提供的对象, 但又想为这个对象添加新的方法（mixin 模式）, 新方法的名字就有可能与现有方法产生冲突. 如果有一种机制, 保证每个属性的名字都是独一无二的就好了, 这样就从根本上防止属性名的冲突. 这就是 ES6 引入<code>Symbol</code>的原因. </p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>, 表示独一无二的值. 它是 JavaScript 语言的<code>第七种数据类型</code>, 前六种是: <code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）. </p><ol><li>定义: 独一无二的值,类似于一种标识唯一性的ID</li><li>声明: <code>const set = Symbol(str)</code></li><li>入参: 字符串(可选)</li><li>方法:</li></ol><ul><li><strong>Symbol()</strong>: 创建以参数作为描述的<code>Symbol值</code>(不登记在全局环境)</li><li><strong>Symbol.for()</strong>: 创建以参数作为描述的<code>Symbol值</code>, 如存在此参数则返回原有的<code>Symbol值</code>(先搜索后创建, 登记在全局环境)</li><li><strong>Symbol.keyFor()</strong>: 返回已登记的<code>Symbol值</code>的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li><li><strong>Object.getOwnPropertySymbols()</strong>: 返回对象中所有用作属性名的<code>Symbol值</code>的数组</li></ul><ol start="5"><li>内置</li></ol><ul><li><strong>Symbol.hasInstance</strong>: 指向一个内部方法, 当其他对象使用<code>instanceof运算符</code>判断是否为此对象的实例时会调用此方法</li><li><strong>Symbol.isConcatSpreadable</strong>: 指向一个布尔, 定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li><li><strong>Symbol.species</strong>: 指向一个构造函数, 当实例对象使用自身构造函数时会调用指定的构造函数</li><li><strong>Symbol.match</strong>: 指向一个函数, 当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li><li><strong>Symbol.replace</strong>: 指向一个函数, 当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li><li><strong>Symbol.search</strong>: 指向一个函数, 当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li><li><strong>Symbol.split</strong>: 指向一个函数, 当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li><li><strong>Symbol.iterator</strong>: 指向一个默认遍历器方法, 当实例对象执行 [ for-of ] 时会调用指定的默认遍历器</li><li><strong>Symbol.toPrimitive</strong>: 指向一个函数, 当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li><li><strong>Symbol.toStringTag</strong>: 指向一个函数, 当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li><li><strong>Symbol.unscopables</strong>: 指向一个对象, 指定使用<code>with</code>时哪些属性会被<code>with环境</code>排除</li></ul><blockquote><p>数据类型</p></blockquote><ul><li><strong>Undefined</strong></li><li><strong>Null</strong></li><li><strong>String</strong></li><li><strong>Number</strong></li><li><strong>Boolean</strong></li><li><strong>Object</strong>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li><li><strong>Symbol</strong></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt">bigint</a>,   –&gt;<strong>BigInt</strong> 是一种数字类型的数据</li></ul><blockquote><p>应用场景</p></blockquote><ol><li><p>唯一化对象属性名: 属性名属于Symbol类型, 就都是独一无二的, 可保证不会与其他属性名产生冲突</p></li><li><p>消除<code>魔术字符串</code>: 在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</p></li></ol><ul><li><p>魔术字符串指的是, 在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值. 风格良好的代码, 应该尽量消除魔术字符串, 改由含义清晰的变量代替. </p></li><li><pre><code class="js">function getResults(param)&#123;    if(param == &#39;努力学习的汪&#39;) console.log(&#39;魔术字符串&#39;)&#125;// 函数中赋值 &#39;努力学习的汪&#39;,所以 &#39;努力学习的汪&#39; 这个字符串就是魔术字符串getResults(&#39;努力学习的汪&#39;)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;3. 遍历属性名: 无法通过 [ for-in ] 、 [ for-of ] 、 [Object.keys()] 、 [Object.getOwnPropertyNames()] 、`JSON.stringify()`返回, 只能通过`Object.getOwnPropertySymbols`返回</span><br><span class="line"></span><br><span class="line">&gt;4. 启用模块的Singleton模式: 调用一个类在任何时候返回同一个实例(`window`和`global`), 使用`Symbol.for()`来模拟全局的`Singleton模式`</span><br><span class="line"></span><br><span class="line">&gt;&gt; 重点难点</span><br><span class="line"></span><br><span class="line">&gt;- `Symbol()`生成一个原始类型的值不是对象, 因此`Symbol()`前不能使用`new命令`</span><br><span class="line">&gt;- `Symbol()`参数表示对当前`Symbol值`的描述, 相同参数的`Symbol()`返回值不相等</span><br><span class="line">&gt;- `Symbol值`不能与其他类型的值进行运算</span><br><span class="line">&gt;- `Symbol值`可通过`String()`或`toString()`显式转为字符串</span><br><span class="line">&gt;- `Symbol值`作为对象属性名时, 此属性是公开属性, 但不是私有属性</span><br><span class="line">&gt;- `Symbol值`作为对象属性名时, 只能用方括号运算符(`[]`)读取, 不能用点运算符(`.`)读取</span><br><span class="line">&gt;- `Symbol值`作为对象属性名时, 不会被常规方法遍历得到, 可利用此特性为对象定义`非私有但又只用于内部的方法`</span><br><span class="line"></span><br><span class="line">### Ⅱ - 举个简单的例子</span><br><span class="line"></span><br><span class="line">Symbol 值通过`Symbol`函数生成. 这就是说, 对象的属性名现在可以有两种类型, 一种是原来就有的字符串, 另一种就是新增的 Symbol 类型. 凡是属性名属于 Symbol 类型, 就都是独一无二的, 可以保证不会与其他属性名产生冲突. </span><br><span class="line"></span><br><span class="line">注意, `Symbol`函数前不能使用`new`命令, 否则会报错. 这是因为生成的 Symbol 是一个原始类型的值, 不是对象. 也就是说, 由于 Symbol 值不是对象, 所以不能添加属性. 基本上, 它是一种`类似于字符串的数据类型`. </span><br><span class="line"></span><br><span class="line">`Symbol`函数可以接受一个字符串作为参数, 表示对 Symbol 实例的描述, 主要是为了在控制台显示, 或者转为字符串时, 比较容易区分. </span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">let s1 = Symbol(&#x27;努力学习的汪&#x27;);</span><br><span class="line">let s2 = Symbol(&#x27;hongjilin&#x27;);</span><br><span class="line"></span><br><span class="line">s1 // Symbol(努力学习的汪)  注意:此处是 Symbol 值</span><br><span class="line">s2 // Symbol(hongjilin)</span><br><span class="line"></span><br><span class="line">s1.toString() // &quot;Symbol(努力学习的汪)&quot; 注意 此处是字符串</span><br><span class="line">s2.toString() // &quot;Symbol(hongjilin)&quot;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826181302853.png" alt="image-20210826181302853">  </p><p>上面代码中, <code>s1</code>和<code>s2</code>是两个 Symbol 值. 如果不加参数, 它们在控制台的输出都是<code>Symbol()</code>, 不利于区分. 有了参数以后, 就等于为它们加上了描述, 输出的时候就能够分清, 到底是哪一个值. </p><p>如果 Symbol 的参数是一个对象, 就会调用该对象的<code>toString</code>方法, 将其转为字符串, 然后才生成一个 Symbol 值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)  --&gt; [ Symbol 值 ]</span></span><br></pre></td></tr></table></figure><p>注意, <code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述, 因此相同参数的<code>Symbol</code>函数的返回值是不相等的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826181625657.png" alt="image-20210826181625657"> </p><p>上面代码中, <code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值, 而且参数相同, 但是它们是不相等的. </p><p>Symbol 值不能与其他类型的值进行运算, 会报错. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是，Symbol 值可以显式转为字符串. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br></pre></td></tr></table></figure><p>另外，Symbol 值也可以转为布尔值, 但是不能转为数值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="title class_">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;&#125;</span><br><span class="line"><span class="title class_">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Symbol-prototype-description"><a href="#Ⅲ-Symbol-prototype-description" class="headerlink" title="Ⅲ - Symbol.prototype.description"></a>Ⅲ - Symbol.prototype.description</h3><blockquote><p>创建 Symbol 的时候, 可以添加一个描述. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, <code>sym</code>的描述就是字符串<code>努力学习的汪</code>. </p><p>但是, 读取这个描述需要将 Symbol 显式转为字符串, 即下面的写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">String</span>(sym) <span class="comment">// &quot;Symbol(努力学习的汪)&quot;</span></span><br><span class="line">&gt;sym.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(努力学习的汪)&quot;</span></span><br></pre></td></tr></table></figure><p>上面的用法不是很方便. <a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>, 直接返回 Symbol 的描述. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;sym.<span class="property">description</span> <span class="comment">// &quot;努力学习的汪&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826183246668.png" alt="image-20210826183246668"> </p></blockquote><h3 id="Ⅳ-作为属性名的-Symbol"><a href="#Ⅳ-作为属性名的-Symbol" class="headerlink" title="Ⅳ - 作为属性名的 Symbol"></a>Ⅳ - 作为属性名的 Symbol</h3><h4 id="①-举个栗子"><a href="#①-举个栗子" class="headerlink" title="① 举个栗子:"></a>① 举个栗子:</h4><blockquote><p>由于每一个 Symbol 值都是不相等的, 这意味着 Symbol 值可以作为标识符, 用于对象的属性名, 就能保证不会出现同名的属性. 这对于一个对象由多个模块构成的情况非常有用, 能防止某一个键被不小心改写或覆盖. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第一种写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">&gt;a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第二种写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;</span><br><span class="line"> [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 第三种写法</span></span><br><span class="line">&gt;<span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">&gt;a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和 [ Object.defineProperty ] , 将对象的属性名指定为一个 Symbol 值. </p></blockquote><h4 id="②-不能用点运算符"><a href="#②-不能用点运算符" class="headerlink" title="② 不能用点运算符"></a>② 不能用点运算符</h4><blockquote><p>注意，Symbol 值作为对象属性名时, 不能用点运算符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//不可这样用,这样用就没效果了</span></span><br><span class="line">&gt;a.<span class="property">mySymbol</span> = <span class="string">&#x27;努力学习的汪!&#x27;</span>; <span class="comment">//因为点运算符后面总是字符串, 所以不会读取`mySymbol`作为标识名所指代的那个值, 导致`a`的属性名实际上是一个字符串, 而不是一个 Symbol 值. </span></span><br><span class="line">&gt;a[mySymbol] <span class="comment">// undefined     --&gt;此处以 创建的Symbol值 作为key名进行读取</span></span><br><span class="line">&gt;a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;努力学习的汪!&quot;  --&gt;此处就是字符串作为key名进行读取</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210826183751378.png" alt="image-20210826183751378"> </p><p>上面代码中, 因为点运算符后面总是字符串, 所以不会读取<code>mySymbol</code>作为标识名所指代的那个值, 导致<code>a</code>的属性名实际上是一个字符串, 而不是一个 Symbol 值. </p><p>同理, 在对象的内部, 使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line">&gt;[s]: <span class="keyword">function</span> (<span class="params">arg</span>) &#123; ... &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 如果<code>s</code>不放在方括号中, 该属性的键名就是字符串<code>s</code>, 而不是<code>s</code>所代表的那个 Symbol 值. </p><p>采用增强的对象写法, 上面代码的<code>obj</code>对象可以写得更简洁一些. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line">&gt;[s](arg) &#123; ... &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Symbol-类型用于定义常量"><a href="#③-Symbol-类型用于定义常量" class="headerlink" title="③ Symbol 类型用于定义常量"></a>③ Symbol 类型用于定义常量</h4><blockquote><p>Symbol 类型还可以用于定义一组常量, 保证这组常量的值都是不相等的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> log = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;log.<span class="property">levels</span> = &#123;</span><br><span class="line">&gt;<span class="attr">DEBUG</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;debug&#x27;</span>),</span><br><span class="line">&gt;<span class="attr">INFO</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">&gt;<span class="attr">WARN</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;warn&#x27;</span>)</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">DEBUG</span>, <span class="string">&#x27;debug message&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">INFO</span>, <span class="string">&#x27;info message&#x27;</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">COLOR_RED</span>    = <span class="title class_">Symbol</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">COLOR_GREEN</span>  = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getComplement</span>(<span class="params">color</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">switch</span> (color) &#123;</span><br><span class="line">&gt;<span class="keyword">case</span> <span class="attr">COLOR_RED</span>:</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable constant_">COLOR_GREEN</span>;</span><br><span class="line">&gt;<span class="keyword">case</span> <span class="attr">COLOR_GREEN</span>:</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable constant_">COLOR_RED</span>;</span><br><span class="line">&gt;<span class="attr">default</span>:</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Undefined color&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>常量使用 Symbol 值最大的好处, 就是其他任何值都不可能有相同的值了, 因此可以保证上面的<code>switch</code>语句会按设计的方式工作. </p><p>还有一点需要注意，Symbol 值作为属性名时, 该属性还是公开属性, 不是私有属性. </p></blockquote><h4 id="④-应用实例-消除魔术字符串"><a href="#④-应用实例-消除魔术字符串" class="headerlink" title="④ 应用实例:消除魔术字符串"></a>④ 应用实例:消除魔术字符串</h4><h5 id="a-魔术字符串"><a href="#a-魔术字符串" class="headerlink" title="a) 魔术字符串"></a>a) 魔术字符串</h5><blockquote><p>魔术字符串指的是, 在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值. 风格良好的代码, 应该尽量消除魔术字符串, 改由含义清晰的变量代替. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getResults</span>(<span class="params">param</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(param == <span class="string">&#x27;努力学习的汪&#x27;</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;魔术字符串&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 函数中赋值 &#x27;努力学习的汪&#x27;,所以 &#x27;努力学习的汪&#x27; 这个字符串就是魔术字符串</span></span><br><span class="line">&gt;<span class="title function_">getResults</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面代码中, 字符串<code>Triangle</code>就是一个魔术字符串. 它多次出现, 与代码形成“强耦合”, 不利于将来的修改和维护. </p></blockquote><h5 id="b-常用的消除魔术字符串的方法"><a href="#b-常用的消除魔术字符串的方法" class="headerlink" title="b) 常用的消除魔术字符串的方法"></a>b) 常用的消除魔术字符串的方法</h5><blockquote><p>常用的消除魔术字符串的方法, 就是把它写成一个变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> name=<span class="string">&#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getResults</span>(<span class="params">param</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(param == name) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;消除魔术字符串&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">getResults</span>(name) <span class="comment">//消除魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中, 我们把<code>努力学习的汪</code>写成 [ name ] 属性, 这样就消除了强耦合. </p></blockquote><h5 id="c-改用Symbol值"><a href="#c-改用Symbol值" class="headerlink" title="c) 改用Symbol值"></a>c) 改用Symbol值</h5><blockquote><p>如果仔细分析, 可以发现<code>shapeType.triangle</code>等于哪个值并不重要, 只要确保不会跟其他<code>shapeType</code>属性的值冲突即可. 因此, 这里就很适合改用 Symbol 值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> name=<span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getResults</span>(<span class="params">param</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(param == name) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Symbol消除魔术字符串&#x27;</span>)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">getResults</span>(name)  <span class="comment">// Symbol消除魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中, 除了将<code>努力学习的汪</code>的值设为一个 Symbol，其他地方都不用修改. </p></blockquote><h3 id="Ⅴ-属性名的遍历"><a href="#Ⅴ-属性名的遍历" class="headerlink" title="Ⅴ - 属性名的遍历"></a>Ⅴ - 属性名的遍历</h3><h4 id="①-概念引出"><a href="#①-概念引出" class="headerlink" title="①  概念引出"></a>①  概念引出</h4><blockquote><p>Symbol 作为属性名, 遍历对象的时候, 该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中, 也不会被 [Object.keys()] 、 [Object.getOwnPropertyNames()] 、<code>JSON.stringify()</code>返回. </p><p>但是, 它也不是私有属性, 有一个<code>Object.getOwnPropertySymbols()</code>方法, 可以获取指定对象的所有 Symbol 属性名. 该方法返回一个数组, 成员是当前对象的所有用作属性名的 Symbol 值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&gt;obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line">&gt;objectSymbols<span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例, 可以获取所有 Symbol 属性名. </p></blockquote><h4 id="②-获取Symbol键名方式"><a href="#②-获取Symbol键名方式" class="headerlink" title="② 获取Symbol键名方式"></a>② 获取Symbol键名方式</h4><blockquote><p>下面是另一个例子, <code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> name = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> obj=&#123;</span><br><span class="line">   [name]:<span class="string">&#x27;Symbol:努力学习的汪&#x27;</span>,  <span class="comment">//赋一个Symbol属性</span></span><br><span class="line">   <span class="attr">other</span>:<span class="string">&#x27;正常属性&#x27;</span>   <span class="comment">//给一个正常属性做对比</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ for --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">//只打印一个 other</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ Object.keys --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> objKeys=<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)  <span class="comment">//打印一个 [ &quot;other&quot; ]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(objKeys) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ Object.getOwnPropertyNames --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">PropertyNames</span>=<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) <span class="comment">// 打印一个 [ &quot;other&quot; ]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PropertyNames</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ Object.getOwnPropertySymbols --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">PropertySymbols</span>= <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj) <span class="comment">// [Symbol(name)]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PropertySymbols</span>)</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830141637812.png" alt="image-20210830141637812"> 上面代码中, 使用<code>for...in</code>循环和 [Object.getOwnPropertyNames()] 方法都得不到 Symbol 键名, 需要使用<code>Object.getOwnPropertySymbols()</code>方法. </p></blockquote><h4 id="③-获取所有类型的键名"><a href="#③-获取所有类型的键名" class="headerlink" title="③ 获取所有类型的键名"></a>③ 获取所有类型的键名</h4><blockquote><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名, 包括常规键名和 Symbol 键名. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">enum</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">nonEnum</span>: <span class="number">3</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)</span><br><span class="line">&gt;<span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-利用特性-营造-非私有的内部方法的效果"><a href="#④-利用特性-营造-非私有的内部方法的效果" class="headerlink" title="④ 利用特性 营造 非私有的内部方法的效果"></a>④ 利用特性 营造 非私有的内部方法的效果</h4><blockquote><p>由于以 Symbol 值作为键名, 不会被常规方法遍历得到. 我们可以利用这个特性, 为对象定义一些非私有的、但又希望只用于内部的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> size = <span class="title class_">Symbol</span>(<span class="string">&#x27;私有&#x27;</span>); <span class="comment">//可以 Symbol(&#x27;字符串&#x27;),也可以不要Symbol(),但加了会更有辨识度</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Collection</span> &#123; <span class="comment">//注意,此类中的所有size属性都是指的上方  Symbol(&#x27;私有&#x27;)</span></span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>[size] = <span class="number">0</span>; <span class="comment">//此处构造函数初始化时 给 [size]进行了初始化赋值--&gt;[Symbol(&#x27;私有&#x27;)]=0</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">add</span>(<span class="params">item</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>[<span class="variable language_">this</span>[size]] = item; <span class="comment">//此时 1. 先取出 this[size] 的值,此时为0,作为新的key,存入item </span></span><br><span class="line">   <span class="variable language_">this</span>[size]++;   <span class="comment">//此时 this[size] == 1 </span></span><br><span class="line">   <span class="comment">//第一次调用 log:Collection &#123;0: &quot;调用一次添加&quot;, Symbol(私有): 1&#125;  </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="title function_">sizeOf</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> instance[size];  <span class="comment">// 返回传入实例中的 size 属性</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 先获取初始化时数据 --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的size属性值&#x27;</span>,<span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x)) <span class="comment">// 此时的size属性值 0</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x)        <span class="comment">//Collection &#123;Symbol(私有): 0&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 调用一次添加 --------------&#x27;</span>)</span><br><span class="line">&gt;x.<span class="title function_">add</span>(<span class="string">&#x27;调用一次添加&#x27;</span>); <span class="comment">//调用一次添加</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的size属性值&#x27;</span>,<span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x)) <span class="comment">//此时的size属性值 1</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//Collection &#123;0: &quot;调用一次添加&quot;, Symbol(私有): 1&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 调用两次添加 --------------&#x27;</span>)</span><br><span class="line">&gt;x.<span class="title function_">add</span>(<span class="string">&#x27;调用2次添加&#x27;</span>); <span class="comment">//第二次调用</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;此时的size属性值&#x27;</span>,<span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x)) <span class="comment">// 此时的size属性值 2</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// Collection &#123;0: &quot;调用一次添加&quot;, 1: &quot;调用2次添加&quot;, Symbol(私有): 2&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------ 查看不同方法取出的key --------------&#x27;</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(x)) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(x)) <span class="comment">// [&quot;0&quot;, &quot;1&quot;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(x)) <span class="comment">// [Symbol(私有)]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830145632266.png" alt="image-20210830145632266"> 上面代码中, 对象<code>x</code>的<code>size</code>属性是一个 Symbol 值, 所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它. 这就造成了一种非私有的内部方法的效果. </p></blockquote><h3 id="Ⅵ-Symbol-for-，Symbol-keyFor"><a href="#Ⅵ-Symbol-for-，Symbol-keyFor" class="headerlink" title="Ⅵ - Symbol.for()，Symbol.keyFor()"></a>Ⅵ - Symbol.for()，Symbol.keyFor()</h3><h4 id="①-Symbol-for"><a href="#①-Symbol-for" class="headerlink" title="① Symbol.for()"></a>① Symbol.for()</h4><blockquote><p>有时, 我们希望重新使用同一个 Symbol 值, <code>Symbol.for()</code>方法可以做到这一点. 它接受一个字符串作为参数, 然后搜索有没有以该参数作为名称的 Symbol 值. 如果有, 就返回这个 Symbol 值, 否则就新建一个以该字符串为名称的 Symbol 值, 并将其注册到全局. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;hongjilin&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;hongjilin&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> h1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> h2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2 ,h1 === h2)</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830150415159.png" alt="image-20210830150415159"> 上面代码中, <code>s1</code>和<code>s2</code>都是 Symbol 值, 但是它们都是由同样参数的<code>Symbol.for</code>方法生成的, 所以实际上是同一个值. </p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法, 都会生成新的 Symbol. 它们的区别是 : </p><blockquote><ul><li>前者会被登记在全局环境中供搜索, 后者不会. </li><li><code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值, 而是会先检查给定的<code>key</code>是否已经存在, 如果不存在才会新建一个值. </li><li>如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次, 每次都会返回同一个 Symbol 值;</li><li>但是调用<code>Symbol(&quot;cat&quot;)</code>30 次, 会返回 30 个不同的 Symbol 值.</li></ul></blockquote></blockquote><h4 id="②-Symbol-keyFor"><a href="#②-Symbol-keyFor" class="headerlink" title="② Symbol.keyFor()"></a>② Symbol.keyFor()</h4><blockquote><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1)) <span class="comment">// &quot;努力学习的汪&quot;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830151409178.png" alt="image-20210830151409178"> 上面代码中, 变量<code>s2</code>属于未登记的 Symbol 值, 所以返回<code>undefined</code>. </p><p>注意, <code>Symbol.for()</code>为 Symbol 值登记的名字, 是全局环境的, 不管有没有在全局环境运行. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>); <span class="comment">//在函数内部:局部作用域中运行</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> x = <span class="title function_">foo</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> y = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830151530178.png" alt="image-20210830151530178"> 上面代码中, <code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的, 但是生成的 Symbol 值是登记在全局环境的. 所以, 第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值. </p><p><code>Symbol.for()</code>的这个全局登记特性, 可以用在不同的 iframe 或 service worker 中取到同一个值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">&gt;iframe.<span class="property">src</span> = <span class="title class_">String</span>(<span class="variable language_">window</span>.<span class="property">location</span>);</span><br><span class="line">&gt;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"></span><br><span class="line">&gt;iframe.<span class="property">contentWindow</span>.<span class="property">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe 窗口生成的 Symbol 值, 可以在主页面得到. </p></blockquote><h3 id="Ⅶ-应用实例-模块的-Singleton-模式"><a href="#Ⅶ-应用实例-模块的-Singleton-模式" class="headerlink" title="Ⅶ - 应用实例: 模块的 Singleton 模式"></a>Ⅶ - 应用实例: 模块的 Singleton 模式</h3><h4 id="①-模块的-Singleton-模式"><a href="#①-模块的-Singleton-模式" class="headerlink" title="① 模块的 Singleton 模式"></a>① 模块的 Singleton 模式</h4><blockquote><p>Singleton 模式指的是调用一个类, 任何时候返回的都是同一个实例. </p><p>对于 Node 来说, 模块文件可以看成是一个类. 怎么保证每次执行这个模块文件, 返回的都是同一个实例呢？</p><p>很容易想到, 可以把实例放到顶层对象<code>global</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// mod.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">userName</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">if</span> (!<span class="variable language_">global</span>.<span class="property">_userName</span>)  <span class="variable language_">global</span>.<span class="property">_userName</span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>.<span class="property">_userName</span>;</span><br></pre></td></tr></table></figure><p>然后, 加载上面的<code>mod.js</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">foo</span>);<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例. </p><p>但是, 这里有一个问题, 全局变量<code>global._foo</code>是可写的, 任何文件都可以修改. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="variable language_">global</span>.<span class="property">_userName</span> = &#123; <span class="attr">userName</span>: <span class="string">&#x27;不努力学习的单身汪&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">userName</span>); <span class="comment">// 不努力学习的单身汪</span></span><br></pre></td></tr></table></figure><p>上面的代码, 会使得加载<code>mod.js</code>的脚本都失真. </p></blockquote><h4 id="②-Symbol-for-的应用"><a href="#②-Symbol-for-的应用" class="headerlink" title="②  Symbol.for() 的应用"></a>②  Symbol.for() 的应用</h4><blockquote><p>为了防止这种情况出现, 我们就可以使用 Symbol. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// mod.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;userName&#x27;</span>); <span class="comment">//此处使用Symbol.for()进行生成,目的为多次加载此js,生成的symbol都相同</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">userName</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">if</span> (!<span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>])  <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>] = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&gt;<span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>];</span><br></pre></td></tr></table></figure><p>上面代码中, 可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖, 但还是可以被改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//仍可以改写,但通常不会被无意间覆盖.会写出这个代码通常就是故意要覆盖的</span></span><br><span class="line">&gt;<span class="variable language_">global</span>[<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;userName&#x27;</span>)] = &#123; <span class="attr">userName</span>: <span class="string">&#x27;不努力学习的单身汪&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Symbol-的应用"><a href="#③-Symbol-的应用" class="headerlink" title="③ Symbol() 的应用"></a>③ Symbol() 的应用</h4><blockquote><p>如果键名使用<code>Symbol</code>方法生成, 那么外部将无法引用这个值, 当然也就无法改写. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// mod.js</span></span><br><span class="line">&gt;<span class="comment">//不使用Symbol.for(),而是直接使用Symbol(),这样就确保不会被改写,理解吃力的话要重新看下上面的方法描述</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;userName&#x27;</span>); </span><br><span class="line">&gt;<span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>. 但这样也有一个问题:</p><blockquote><p>就是如果多次执行这个脚本, 每次得到的<code>FOO_KEY</code>都是不一样的. 虽然 Node 会将脚本的执行结果缓存, 一般情况下, 不会多次执行同一个脚本, 但是用户可以手动清除缓存, 所以也不是绝对可靠. </p></blockquote></blockquote><h3 id="Ⅷ-内置的-Symbol-值"><a href="#Ⅷ-内置的-Symbol-值" class="headerlink" title="Ⅷ - 内置的 Symbol 值"></a>Ⅷ - 内置的 Symbol 值</h3><blockquote><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值, 指向语言内部使用的方法. </p><p>对于新手来说用的很少,可以暂时先跳过此部分,此处举例几个</p></blockquote><h4 id="①-Symbol-hasInstance"><a href="#①-Symbol-hasInstance" class="headerlink" title="① Symbol.hasInstance"></a>① Symbol.hasInstance</h4><h5 id="a-方法介绍"><a href="#a-方法介绍" class="headerlink" title="a) 方法介绍"></a>a) 方法介绍</h5><blockquote><p>对象的 [Symbol.hasInstance] 属性, 指向一个内部方法. 当其他对象使用instanceof运算符, 判断是否为该对象的实例时, 会调用这个方法. 比如, <code>foo instanceof Foo</code>在语言内部, 实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>()) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">TestClass</span>()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830161934219.png" alt="image-20210830161934219"></p></blockquote><h5 id="b-举个栗子"><a href="#b-举个栗子" class="headerlink" title="b) 举个栗子"></a>b) 举个栗子</h5><blockquote><p>下面是另一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">   <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="title class_">Array</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](obj) &#123; <span class="comment">//静态方法</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>()); <span class="comment">// true //我是调用的动态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>]([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,]));<span class="comment">//true //我是调用的动态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">//true 我是调用静态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](<span class="number">2</span>));<span class="comment">//true 我是调用了静态方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(x <span class="keyword">instanceof</span> <span class="title class_">MyClass</span>); <span class="comment">//false 因为修改了静态方法(不传入值返回肯定是false). x本身就是MyClass的实例, 如果注释了静态方法就会返回true. </span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830162419619.png" alt="image-20210830162419619"></p></blockquote><h4 id="②-Symbol-isConcatSpreadable"><a href="#②-Symbol-isConcatSpreadable" class="headerlink" title="② Symbol.isConcatSpreadable"></a>② Symbol.isConcatSpreadable</h4><blockquote><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值, 表示该对象用于<code>Array.prototype.concat()</code>时, 是否可以展开. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr1 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr1, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">&gt;arr1[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">&gt;arr2[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr2, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码说明, 数组的默认行为是可以展开, <code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>. 该属性等于<code>true</code>时, 也有展开的效果. </p><p>类似数组的对象正好相反, 默认不展开. 它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>, 才可以展开. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;obj[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">&gt;[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(args);</span><br><span class="line">   <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(args);</span><br><span class="line"> &#125;</span><br><span class="line"> get [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title function_">A1</span>();</span><br><span class="line">&gt;a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">&gt;a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title function_">A2</span>();</span><br><span class="line">&gt;a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">&gt;a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">&gt;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>(a1).<span class="title function_">concat</span>(a2)</span><br><span class="line">&gt;<span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p>上面代码中, 类<code>A1</code>是可展开的, 类<code>A2</code>是不可展开的, 所以使用<code>concat</code>时有不一样的结果. </p><p>注意, <code>Symbol.isConcatSpreadable</code>的位置差异, <code>A1</code>是定义在实例上, <code>A2</code>是定义在类本身, 效果相同. </p></blockquote><h4 id="③-其他"><a href="#③-其他" class="headerlink" title="③ 其他"></a>③ 其他</h4><blockquote><p>几个内置方法不常用,需要时可以往上查阅,便暂不赘述</p></blockquote><h2 id="11、Set-数据结构"><a href="#11、Set-数据结构" class="headerlink" title="11、Set 数据结构"></a>11、Set 数据结构</h2><blockquote><p><code>常用</code></p></blockquote><h3 id="Ⅰ-概括与总结-3"><a href="#Ⅰ-概括与总结-3" class="headerlink" title="Ⅰ - 概括与总结"></a>Ⅰ - 概括与总结</h3><h4 id="①-Set"><a href="#①-Set" class="headerlink" title="① Set"></a>① Set</h4><blockquote><ul><li>定义: 类似于数组的数据结构, 成员值都是唯一且没有重复的值</li><li>声明: <code>const set = new Set(arr)</code></li><li>入参: 具有<code>Iterator接口</code>的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数, 返回Set</li><li><strong>size</strong>: 返回实例成员总数</li><li>方法</li><li><strong>add()</strong>: 添加值, 返回实例</li><li><strong>delete()</strong>: 删除值, 返回布尔</li><li><strong>has()</strong>: 检查值, 返回布尔</li><li><strong>clear()</strong>: 清除所有成员</li><li><strong>keys()</strong>: 返回以属性值为遍历器的对象</li><li><strong>values()</strong>: 返回以属性值为遍历器的对象</li><li><strong>entries()</strong>: 返回以属性值和属性值为遍历器的对象</li><li><strong>forEach()</strong>: 使用回调函数遍历每个成员</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>去重字符串: <code>[...new Set(str)].join(&quot;&quot;)</code></li><li>去重数组: <code>[...new Set(arr)]</code>或<code>Array.from(new Set(arr))</code></li><li>集合数组</li><li>声明: <code>const a = new Set(arr1)</code></li><li>并集: <code>new Set([...a, ...b])</code></li><li>交集: <code>new Set([...a].filter(v =&gt; b.has(v)))</code>  &#x2F;&#x2F;此处的has指的是set自带的方法</li><li>差集: <code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li><li>映射集合</li><li>声明: <code>let set = new Set(arr)</code></li><li>映射: <code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li></ul><blockquote><p>重点难点</p></blockquote><ul><li>遍历顺序: 插入顺序</li><li>没有键只有值, 可认为键和值两值相等</li><li>添加多个<code>NaN</code>时, 只会存在一个<code>NaN</code></li><li>添加相同的对象时, 会认为是不同的对象</li><li>添加值时不会发生类型转换(<code>5 !== &quot;5&quot;</code>)</li><li><code>keys()</code>和<code>values()</code>的行为完全一致, <code>entries()</code>返回的遍历器同时包括键和值且两值相等</li></ul></blockquote><h4 id="②-WeakSet"><a href="#②-WeakSet" class="headerlink" title="② WeakSet"></a>② WeakSet</h4><blockquote><ul><li>定义: 和Set结构类似, 成员值只能是对象</li><li>声明: <code>const set = new WeakSet(arr)</code></li><li>入参: 具有<code>Iterator接口</code>的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数, 返回WeakSet</li><li>方法</li><li><strong>add()</strong>: 添加值, 返回实例</li><li><strong>delete()</strong>: 删除值, 返回布尔</li><li><strong>has()</strong>: 检查值, 返回布尔</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>储存DOM节点: DOM节点被移除时自动释放此成员, 不用担心这些节点从文档移除时会引发内存泄漏</li><li>临时存放一组对象或存放跟对象绑定的信息: 只要这些对象在外部消失, 它在<code>WeakSet结构</code>中的引用就会自动消去</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>成员都是<code>弱引用</code>, 垃圾回收机制不考虑<code>WeakSet结构</code>对此成员的引用</li><li>成员不适合引用, 它会随时消失, 因此ES6规定<code>WeakSet结构不可遍历</code></li><li>其他对象不再引用成员时, 垃圾回收机制会自动回收此成员所占用的内存, 不考虑此成员是否还存在于<code>WeakSet结构</code>中</li></ul></blockquote><h3 id="Ⅱ-基本用法-1"><a href="#Ⅱ-基本用法-1" class="headerlink" title="Ⅱ -  基本用法"></a>Ⅱ -  基本用法</h3><h4 id="①-基础示例"><a href="#①-基础示例" class="headerlink" title="① 基础示例"></a>① 基础示例</h4><blockquote><p>ES6 提供了新的数据结构 Set. 它类似于数组, 但是成员的值都是唯一的, 没有重复的值. </p><p><code>Set</code>本身是一个构造函数, 用来生成 Set 数据结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;[<span class="string">&#x27;努&#x27;</span>,<span class="string">&#x27;努&#x27;</span>,<span class="string">&#x27;力&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;的&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>,<span class="string">&#x27;汪&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> s.<span class="title function_">add</span>(item));</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s) <span class="comment">//Set(5) &#123;&quot;努&quot;, &quot;力&quot;, &quot;学习&quot;, &quot;的&quot;, &quot;汪&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830172842921.png" alt="image-20210830172842921"><br>上面代码通过<code>add()</code>方法向 Set 结构加入成员, 结果表明 Set 结构不会添加重复的值. </p></blockquote><h4 id="②-接受一个数组作为参数"><a href="#②-接受一个数组作为参数" class="headerlink" title="② 接受一个数组作为参数"></a>② 接受一个数组作为参数</h4><blockquote><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数, 用来初始化. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...set]) <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="property">size</span>) <span class="comment">// 5</span></span><br><span class="line">&gt;<span class="comment">// 例三</span></span><br><span class="line">&gt;<span class="keyword">const</span> setDiv = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(setDiv.<span class="property">size</span>) <span class="comment">// 这个就根据你的当前页面梳理而定</span></span><br><span class="line">&gt;<span class="comment">// 类似于</span></span><br><span class="line">&gt;<span class="keyword">const</span> setDIV = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;<span class="variable language_">document</span></span><br><span class="line">.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">.<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> setDIV.<span class="title function_">add</span>(div));</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(setDiv.<span class="property">size</span>) <span class="comment">// 这个就根据你的当前页面梳理而定</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830173525573.png" alt="image-20210830173525573"> 上面代码中, 例一和例二都是<code>Set</code>函数接受数组作为参数, 例三是接受类似数组的对象作为参数. </p></blockquote><h4 id="③-用于数组或字符串去重"><a href="#③-用于数组或字符串去重" class="headerlink" title="③ 用于数组或字符串去重"></a>③ 用于数组或字符串去重</h4><blockquote><p>上面代码也展示了一种去除数组重复成员的方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 去除数组的重复成员</span></span><br><span class="line">&gt;[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于, 去除字符串里面的重复字符. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-不会发生类型转换"><a href="#④-不会发生类型转换" class="headerlink" title="④ 不会发生类型转换"></a>④ 不会发生类型转换</h4><blockquote><p>向 Set 加入值的时候, 不会发生类型转换, 所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值. Set 内部判断两个值是否不同, 使用的算法叫做“Same-value-zero equality”, 它类似于精确相等运算符（<code>===</code>）, 主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身, 而精确相等运算符认为<code>NaN</code>不等于自身. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line">&gt;set.<span class="title function_">add</span>(a);</span><br><span class="line">&gt;set.<span class="title function_">add</span>(b);</span><br><span class="line">&gt;set <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两次<code>NaN</code>, 但是只会加入一个. 这表明, 在 Set 内部, 两个<code>NaN</code>是相等的. </p><p>另外, 两个对象总是不相等的. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(set,set.<span class="property">size</span>) <span class="comment">//Set(1) &#123;&#123;…&#125;&#125; 1</span></span><br><span class="line">&gt;set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(set,set.<span class="property">size</span>) <span class="comment">//Set(2) &#123;&#123;…&#125;, &#123;…&#125;&#125; 2</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830173927525.png" alt="image-20210830173927525"> </p></blockquote><h4 id="⑤-判断数组中是否有对象重复"><a href="#⑤-判断数组中是否有对象重复" class="headerlink" title="⑤ 判断数组中是否有对象重复"></a>⑤ 判断数组中是否有对象重复</h4><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 级别与代号 是否重复,如果重复则不予通过</span></span><br><span class="line"><span class="keyword">const</span> tempLists =  [</span><br><span class="line">    &#123;<span class="attr">itemLevelName</span>:<span class="string">&#x27;Ⅱ&#x27;</span>,<span class="attr">itemCode</span>:<span class="string">&#x27;UT&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">itemLevelName</span>:<span class="string">&#x27;Ⅰ&#x27;</span>,<span class="attr">itemCode</span>:<span class="string">&#x27;UT&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">itemLevelName</span>:<span class="string">&#x27;Ⅱ&#x27;</span>,<span class="attr">itemCode</span>:<span class="string">&#x27;UT&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 项目代号与级别名称如果都相同,则认为是重复对象</span></span><br><span class="line"><span class="keyword">const</span> tempSetArr = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">tempLists.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 利用Set数组的唯一性,将级别名称与代号名称拼接,加入后如果重复则不会加入</span></span><br><span class="line">  tempSetArr.<span class="title function_">add</span>(<span class="string">`<span class="subst">$&#123;item.itemLevelName&#125;</span><span class="subst">$&#123;item.itemCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 判断去重后的数组长度是否与当前界面上的长度一致,如果不一致,则输入的内容重复了,校验不通过</span></span><br><span class="line"><span class="keyword">if</span> (tempSetArr.<span class="property">size</span> !== tempLists.<span class="property">length</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&#x27;列表不可有重复项，请修改后重新提交&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Set-实例的属性和方法"><a href="#Ⅲ-Set-实例的属性和方法" class="headerlink" title="Ⅲ - Set 实例的属性和方法"></a>Ⅲ - Set 实例的属性和方法</h3><blockquote><p>Set 结构的实例有以下属性. </p><ul><li><code>Set.prototype.constructor</code>: 构造函数, 默认就是<code>Set</code>函数. </li><li><code>Set.prototype.size</code>: 返回<code>Set</code>实例的成员总数.</li></ul><p>Set 实例的方法分为两大类: 操作方法（用于操作数据）和遍历方法（用于遍历成员）. 下面先介绍四个操作方法. </p><ul><li><code>Set.prototype.add(value)</code>: 添加某个值, 返回 Set 结构本身. </li><li><code>Set.prototype.delete(value)</code>: 删除某个值, 返回一个布尔值, 表示删除是否成功. </li><li><code>Set.prototype.has(value)</code>: 返回一个布尔值, 表示该值是否为<code>Set</code>的成员. </li><li><code>Set.prototype.clear()</code>: 清除所有成员, 没有返回值.</li></ul><p>上面这些属性和方法的实例如下. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> s=<span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">&gt;s.<span class="title function_">add</span>(<span class="number">6</span>).<span class="title function_">add</span>(<span class="number">6</span>).<span class="title function_">add</span>(<span class="string">&#x27;努力&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;学习的汪&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;学习的汪&#x27;</span>);<span class="comment">// 注意 [6] [学习的汪] 被加入了两次</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s,s.<span class="property">size</span>) <span class="comment">// Set(3) &#123;6, &quot;努力&quot;, &quot;学习的汪&quot;&#125; 3</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="number">6</span>))  <span class="comment">//true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="string">&#x27;努力&#x27;</span>))  <span class="comment">//true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="string">&#x27;努力学习的单身汪&#x27;</span>))  <span class="comment">//false</span></span><br><span class="line">&gt;<span class="comment">//删除 [ 6 ]</span></span><br><span class="line">&gt;s.<span class="title function_">delete</span>(<span class="number">6</span>); </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">has</span>(<span class="number">6</span>))  <span class="comment">// false</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s,s.<span class="property">size</span>)  <span class="comment">//Set(2) &#123;&quot;努力&quot;, &quot;学习的汪&quot;&#125; 2</span></span><br></pre></td></tr></table></figure><p>下面是一个对比, 看看在判断是否包括一个键上面, <code>Object</code>结构和<code>Set</code>结构的写法不同. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 对象的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> properties = &#123;</span><br><span class="line"> <span class="string">&#x27;width&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;height&#x27;</span>: <span class="number">1</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">if</span> (properties[someName]) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;对象的写法&quot;</span>)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Set的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;properties.<span class="title function_">add</span>(<span class="string">&#x27;width&#x27;</span>);</span><br><span class="line">&gt;properties.<span class="title function_">add</span>(<span class="string">&#x27;height&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">if</span> (properties.<span class="title function_">has</span>(someName))<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Set的写法&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>Array.from</code>方法可以将 Set 结构转为数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;<span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-遍历操作"><a href="#Ⅳ-遍历操作" class="headerlink" title="Ⅳ - 遍历操作"></a>Ⅳ - 遍历操作</h3><blockquote><p>Set 结构的实例有四个遍历方法, 可以用于遍历成员. </p><ul><li><code>Set.prototype.keys()</code>: 返回键名的遍历器</li><li><code>Set.prototype.values()</code>: 返回键值的遍历器</li><li><code>Set.prototype.entries()</code>: 返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>: 使用回调函数遍历每个成员</li></ul><p>需要特别指出的是, <code>Set</code>的遍历顺序就是插入顺序. 这个特性有时非常有用, 比如使用 Set 保存一个回调函数列表, 调用时就能保证按照添加顺序调用</p></blockquote><h4 id="①-keys-values-entries"><a href="#①-keys-values-entries" class="headerlink" title="① keys(), values(), entries()"></a>① <code>keys()</code>, <code>values()</code>, <code>entries()</code></h4><blockquote><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》）. 由于 Set 结构没有键名, 只有键值（或者说键名和键值是同一个值）, 所以<code>keys</code>方法和<code>values</code>方法的行为完全一致. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------  set.keys()  -------------&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------  set.values()  -------------&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------  set.entries()  -------------&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(item) &#125;</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830180145744.png" alt="image-20210830180145744"> 上面代码中, <code>entries</code>方法返回的遍历器, 同时包括键名和键值, 所以每次输出一个数组, 它的两个成员完全相等. </p><p>Set 结构的实例默认可遍历, 它的默认遍历器生成函数就是它的<code>values</code>方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">values</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着, 可以省略<code>values</code>方法, 直接用<code>for...of</code>循环遍历 Set. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>]);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) &#125;</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830180417020.png" alt="image-20210830180417020">  </p></blockquote><h4 id="②-forEach"><a href="#②-forEach" class="headerlink" title="② forEach()"></a>② forEach()</h4><blockquote><p>Set 结构的实例与数组一样, 也拥有<code>forEach</code>方法, 用于对每个成员执行某种操作, 没有返回值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>,<span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的大帅哥&#x27;</span>]);</span><br><span class="line">&gt;set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830180645571.png" alt="image-20210830180645571"> </p><blockquote><ul><li>上面代码说明, <code>forEach</code>方法的参数就是一个处理函数. </li><li>该函数的参数与数组的<code>forEach</code>一致, 依次为键值、键名、集合本身（上例省略了该参数）. </li><li>这里需要注意，Set 结构的键名就是键值（两者是同一个值), 因此第一个参数与第二个参数的值永远都是一样的.</li></ul></blockquote><p>另外, <code>forEach</code>方法还可以有第二个参数, 表示绑定处理函数内部的<code>this</code>对象. </p></blockquote><h4 id="③-遍历的应用"><a href="#③-遍历的应用" class="headerlink" title="③ 遍历的应用"></a>③ 遍历的应用</h4><blockquote><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环, 所以也可以用于 Set 结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>]);</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [...set]; <span class="comment">// [&quot;努力&quot;, &quot;学习&quot;, &quot;的汪&quot;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合, 就可以去除数组的重复成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>,<span class="string">&#x27;努力&#x27;</span>, <span class="string">&#x27;学习&#x27;</span>, <span class="string">&#x27;的汪&#x27;</span>,<span class="string">&#x27;不学习&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">//  [&quot;努力&quot;, &quot;的汪&quot;, &quot;学习&quot;, &quot;不学习&quot;]</span></span><br></pre></td></tr></table></figure><p>而且, 数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line">&gt;<span class="comment">// 返回Set结构: &#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line">&gt;<span class="comment">// 返回Set结构: &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;<span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 并集</span></span><br><span class="line">&gt;<span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line">&gt;<span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 交集</span></span><br><span class="line">&gt;<span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line">&gt;<span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line">&gt;<span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line">&gt;<span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅴ-改变原来的-Set-结构"><a href="#Ⅴ-改变原来的-Set-结构" class="headerlink" title="Ⅴ -  改变原来的 Set 结构"></a>Ⅴ -  改变原来的 Set 结构</h3><blockquote><p>如果想在遍历操作中, 同步改变原来的 Set 结构, 目前没有直接的方法, 但有两种变通方法. 一种是利用原 Set 结构映射出一个新的结构, 然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 方法一</span></span><br><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line">&gt;<span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 方法二</span></span><br><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&gt;set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line">&gt;<span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法, 直接在遍历操作中改变原来的 Set 结构. </p></blockquote><h3 id="Ⅵ-WeakSet"><a href="#Ⅵ-WeakSet" class="headerlink" title="Ⅵ - WeakSet"></a>Ⅵ - WeakSet</h3><blockquote><p>到目前为止本人对于此知识点( WeakSet )实践遇到较少,所以此处笔记主要为知识点摘录,后续若实践遇到,再来补充自己理解</p></blockquote><h4 id="①-含义-1"><a href="#①-含义-1" class="headerlink" title="① 含义"></a>① 含义</h4><blockquote><p>WeakSet 结构与 Set 类似, 也是不重复的值的集合. 但是, 它与 Set 有两个区别. </p><p>首先，WeakSet 的成员只能是对象, 而不能是其他类型的值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">&gt;ws.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">&gt;ws.<span class="title function_">add</span>(<span class="title class_">Symbol</span>())</span><br><span class="line">&gt;<span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值, 结果报错, 因为 WeakSet 只能放置对象. </p><p>其次，WeakSet 中的对象都是弱引用, 即垃圾回收机制不考虑 WeakSet 对该对象的引用, 也就是说, 如果其他对象都不再引用该对象, 那么垃圾回收机制会自动回收该对象所占用的内存, 不考虑该对象还存在于 WeakSet 之中. </p><p>这是因为垃圾回收机制依赖引用计数, 如果一个值的引用次数不为<code>0</code>, 垃圾回收机制就不会释放这块内存. 结束使用该值之后, 有时会忘记取消引用, 导致内存无法释放, 进而可能会引发内存泄漏. WeakSet 里面的引用, 都不计入垃圾回收机制, 所以就不存在这个问题. 因此，WeakSet 适合临时存放一组对象, 以及存放跟对象绑定的信息. 只要这些对象在外部消失, 它在 WeakSet 里面的引用就会自动消失. </p><p>由于上面这个特点，WeakSet 的成员是不适合引用的, 因为它会随时消失. 另外, 由于 WeakSet 内部有多少个成员, 取决于垃圾回收机制有没有运行, 运行前后很可能成员个数是不一样的, 而垃圾回收机制何时运行是不可预测的, 因此 ES6 规定 WeakSet 不可遍历. </p><p>这些特点同样适用于本章后面要介绍的 WeakMap 结构. </p></blockquote><h4 id="②-语法"><a href="#②-语法" class="headerlink" title="② 语法"></a>② 语法</h4><blockquote><p>WeakSet 是一个构造函数, 可以使用<code>new</code>命令, 创建 WeakSet 数据结构. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数. （实际上, 任何具有 Iterable 接口的对象, 都可以作为 WeakSet 的参数. ）该数组的所有成员, 都会自动成为 WeakSet 实例对象的成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line">&gt;<span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>a</code>是一个数组, 它有两个成员, 也都是数组. 将<code>a</code>作为 WeakSet 构造函数的参数, <code>a</code>的成员会自动成为 WeakSet 的成员. </p><p>注意, 是<code>a</code>数组的成员成为 WeakSet 的成员, 而不是<code>a</code>数组本身. 这意味着, 数组的成员只能是对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(b);</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure><p>上面代码中, 数组<code>b</code>的成员不是对象, 加入 WeakSet 就会报错. </p><p>WeakSet 结构有以下三个方法. </p><ul><li><strong>WeakSet.prototype.add(value)</strong>: 向 WeakSet 实例添加一个新成员. </li><li><strong>WeakSet.prototype.delete(value)</strong>: 清除 WeakSet 实例的指定成员. </li><li><strong>WeakSet.prototype.has(value)</strong>: 返回一个布尔值, 表示某个值是否在 WeakSet 实例之中.</li></ul><p>下面是一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">add</span>(<span class="variable language_">window</span>);</span><br><span class="line">&gt;ws.<span class="title function_">add</span>(obj);</span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">has</span>(<span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">&gt;ws.<span class="title function_">has</span>(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">delete</span>(<span class="variable language_">window</span>);</span><br><span class="line">&gt;ws.<span class="title function_">has</span>(<span class="variable language_">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>WeakSet 没有<code>size</code>属性, 没有办法遍历它的成员. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;ws.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">&gt;ws.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">&gt;ws.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性, 结果都不能成功. </p><p>WeakSet 不能遍历, 是因为成员都是弱引用, 随时可能消失, 遍历机制无法保证成员的存在, 很可能刚刚遍历结束, 成员就取不到了. WeakSet 的一个用处, 是储存 DOM 节点, 而不用担心这些节点从文档移除时, 会引发内存泄漏. </p><p>下面是 WeakSet 的另一个例子. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   foos.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> method () &#123;</span><br><span class="line">   <span class="keyword">if</span> (!foos.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在Foo的实例上调用！&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了<code>Foo</code>的实例方法, 只能在<code>Foo</code>的实例上调用. 这里使用 WeakSet 的好处是, <code>foos</code>对实例的引用, 不会被计入内存回收机制, 所以删除实例的时候, 不用考虑<code>foos</code>, 也不会出现内存泄漏. </p></blockquote><h3 id="Ⅶ-做个题目吧"><a href="#Ⅶ-做个题目吧" class="headerlink" title="Ⅶ - 做个题目吧"></a>Ⅶ - 做个题目吧</h3><blockquote><p>光说不练假把式,试着回答几个问题检测下是否理解Set 数据结构</p></blockquote><h3 id="①-代码阅读题1"><a href="#①-代码阅读题1" class="headerlink" title="① 代码阅读题1:"></a>① 代码阅读题1:</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">s.<span class="title function_">add</span>([<span class="number">1</span>]);</span><br><span class="line">s.<span class="title function_">add</span>([<span class="number">1</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">size</span>);</span><br></pre></td></tr></table></figure><p><strong>问: 打印出来的size的值是多少？</strong></p><p>答: 2，两个[1]定义的是两个不同的数组, 在内存中的存储地址不同, 所以是不同的值</p></blockquote><h3 id="②-代码阅读题2"><a href="#②-代码阅读题2" class="headerlink" title="② 代码阅读题2:"></a>② 代码阅读题2:</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> str=<span class="string">&#x27;abstract&#x27;</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...str]).<span class="property">size</span>);<span class="comment">//6  重复的无法加入</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="12、Map-数据结构"><a href="#12、Map-数据结构" class="headerlink" title="12、Map 数据结构"></a>12、Map 数据结构</h2><h3 id="Ⅰ-概括与总结-4"><a href="#Ⅰ-概括与总结-4" class="headerlink" title="Ⅰ - 概括与总结"></a>Ⅰ - 概括与总结</h3><h4 id="①-Map"><a href="#①-Map" class="headerlink" title="①  Map"></a>①  Map</h4><blockquote><ul><li>定义: 类似于对象的数据结构, 成员键是任何类型的值</li><li>声明: <code>const set = new Map(arr)</code></li><li>入参: 具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数, 返回Map</li><li><strong>size</strong>: 返回实例成员总数</li><li>方法</li><li><strong>get()</strong>: 返回键值对</li><li><strong>set()</strong>: 添加键值对, 返回实例</li><li><strong>delete()</strong>: 删除键值对, 返回布尔</li><li><strong>has()</strong>: 检查键值对, 返回布尔</li><li><strong>clear()</strong>: 清除所有成员</li><li><strong>keys()</strong>: 返回以键为遍历器的对象</li><li><strong>values()</strong>: 返回以值为遍历器的对象</li><li><strong>entries()</strong>: 返回以键和值为遍历器的对象</li><li><strong>forEach()</strong>: 使用回调函数遍历每个成员</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>遍历顺序: 插入顺序</li><li>对同一个键多次赋值, 后面的值将覆盖前面的值</li><li>对同一个对象的引用, 被视为一个键</li><li>对同样值的两个实例, 被视为两个键</li><li>键跟内存地址绑定, 只要内存地址不一样就视为两个键</li><li>添加多个以<code>NaN</code>作为键时, 只会存在一个以<code>NaN</code>作为键的值</li><li><code>Object结构</code>提供<code>字符串—值</code>的对应, <code>Map结构</code>提供<code>值—值</code>的对应</li></ul></blockquote><h4 id="②-WeakMap"><a href="#②-WeakMap" class="headerlink" title="② WeakMap"></a>② WeakMap</h4><blockquote><ul><li>定义: 和Map结构类似, 成员键只能是对象</li><li>声明: <code>const set = new WeakMap(arr)</code></li><li>入参: 具有<code>Iterator接口</code>且每个成员都是一个双元素数组的数据结构</li><li>属性</li><li><strong>constructor</strong>: 构造函数, 返回WeakMap</li><li>方法</li><li><strong>get()</strong>: 返回键值对</li><li><strong>set()</strong>: 添加键值对, 返回实例</li><li><strong>delete()</strong>: 删除键值对, 返回布尔</li><li><strong>has()</strong>: 检查键值对, 返回布尔</li></ul><blockquote><p>应用场景</p></blockquote><ul><li>储存DOM节点: DOM节点被移除时自动释放此成员键, 不用担心这些节点从文档移除时会引发内存泄漏</li><li>部署私有属性: 内部属性是实例的弱引用, 删除实例时它们也随之消失, 不会造成内存泄漏</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>成员键都是<code>弱引用</code>, 垃圾回收机制不考虑<code>WeakMap结构</code>对此成员键的引用</li><li>成员键不适合引用, 它会随时消失, 因此ES6规定<code>WeakMap结构不可遍历</code></li><li>其他对象不再引用成员键时, 垃圾回收机制会自动回收此成员所占用的内存, 不考虑此成员是否还存在于<code>WeakMap结构</code>中</li><li>一旦不再需要, 成员会自动消失, 不用手动删除引用</li><li>弱引用的<code>只是键而不是值</code>, 值依然是正常引用</li><li>即使在外部消除了成员键的引用, 内部的成员值依然存在</li></ul></blockquote><h3 id="Ⅱ-含义和基本用法"><a href="#Ⅱ-含义和基本用法" class="headerlink" title="Ⅱ - 含义和基本用法"></a>Ⅱ - 含义和基本用法</h3><h4 id="①-map-出现的意义"><a href="#①-map-出现的意义" class="headerlink" title="① map()出现的意义"></a>① map()出现的意义</h4><blockquote><p>JavaScript 的对象（Object）, 本质上是键值对的集合（Hash 结构）, 但是传统上只能用字符串当作键. 这给它的使用带来了很大的限制. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">//取得的 HTMLDivElement 元素对象</span></span><br><span class="line"></span><br><span class="line">&gt;data[element] = <span class="string">&#x27;努力学习的汪&#x27;</span>; <span class="comment">//尝试将其当作key 并赋值</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(element) <span class="comment">// &quot;&lt;div&gt;...&lt;/div&gt;&quot;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="string">&#x27;[object HTMLDivElement]&#x27;</span>]) <span class="comment">// &quot;努力学习的汪&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830183644910.png" alt="image-20210830183644910"> 上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键, 但是由于对象只接受字符串作为键名, 所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>. </p><p>为了解决这个问题，ES6 提供了 Map 数据结构. 它类似于对象, 也是键值对的集合, 但是“键”的范围不限于字符串, 各种类型的值（包括对象）都可以当作键. 也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应, 是一种更完善的 Hash 结构实现. 如果你需要“键值对”的数据结构，Map 比 Object 更合适. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> o = &#123; <span class="attr">name</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m) <span class="comment">//Map(0) &#123;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------  写入O属性 ----------&#x27;</span>)</span><br><span class="line">&gt;m.<span class="title function_">set</span>(o, <span class="string">&#x27;努力学习的汪&#x27;</span>) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">keys</span>())  <span class="comment">//MapIterator &#123;&#123;…&#125;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(o))  <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m) <span class="comment">//Map(1) &#123;&#123;…&#125; =&gt; &quot;努力学习的汪&quot;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------  删除O属性 ----------&#x27;</span>)</span><br><span class="line">&gt;m.<span class="title function_">delete</span>(o) </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m)  <span class="comment">//Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210830184513952.png" alt="image-20210830184513952"> </p><p>上面代码使用 Map 结构的<code>set</code>方法, 将对象<code>o</code>当作<code>m</code>的一个键, 然后又使用<code>get</code>方法读取这个键, 接着使用<code>delete</code>方法删除了这个键. </p></blockquote><h4 id="②-接受数组作为参数"><a href="#②-接受数组作为参数" class="headerlink" title="② 接受数组作为参数"></a>② 接受数组作为参数</h4><blockquote><p>上面的例子展示了如何向 Map 添加成员. 作为构造函数，Map 也可以接受一个数组作为参数. 该数组的成员是一个个表示键值对的数组. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">&gt;[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line">&gt;[<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">&gt;]);</span><br><span class="line">&gt;map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">&gt;map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;努力学习的汪&quot;</span></span><br><span class="line">&gt;map.<span class="title function_">has</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时, 就指定了两个键<code>name</code>和<code>title</code>. </p><p><code>Map</code>构造函数接受数组作为参数, 实际上执行的是下面的算法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> items = [</span><br><span class="line">&gt;[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line">&gt;[<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;items.<span class="title function_">forEach</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.<span class="title function_">set</span>(key, value)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>事实上, 不仅仅是数组, 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数. 这就是说, <code>Set</code>和<code>Map</code>都可以用来生成新的 Map. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([</span><br><span class="line">&gt;[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line">&gt;[<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">&gt;]);</span><br><span class="line">&gt;<span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>(set);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m1)              <span class="comment">//Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;bar&quot; =&gt; 2&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m1.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>))  <span class="comment">//努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m2)<span class="comment">//Map(1) &#123;&quot;baz&quot; =&gt; 3&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>(m2);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m3) <span class="comment">//Map(1) &#123;&quot;baz&quot; =&gt; 3&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831095025529.png" alt="image-20210831095025529"> </p><p>上面代码中, 我们分别使用 Set 对象和 Map 对象, 当作<code>Map</code>构造函数的参数, 结果都生成了新的 Map 对象. </p></blockquote><h4 id="③-对同一个键多次赋值-后面的值将覆盖前面的值"><a href="#③-对同一个键多次赋值-后面的值将覆盖前面的值" class="headerlink" title="③ 对同一个键多次赋值, 后面的值将覆盖前面的值"></a>③ 对同一个键多次赋值, 后面的值将覆盖前面的值</h4><blockquote><p>如果对同一个键多次赋值, 后面的值将覆盖前面的值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;hongjilin&#x27;</span>).<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">//Map(1) &#123;1 =&gt; &quot;努力学习的汪&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831094538046.png" alt="image-20210831094538046"> 上面代码对键<code>1</code>连续赋值两次, 后一次的值覆盖前一次的值. </p><p>如果读取一个未知的键, 则返回<code>undefined</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">get</span>(<span class="string">&#x27;随便输入的键值&#x27;</span>)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-只有对同一个对象的引用，Map-结构才将其视为同一个键"><a href="#④-只有对同一个对象的引用，Map-结构才将其视为同一个键" class="headerlink" title="④  只有对同一个对象的引用，Map 结构才将其视为同一个键"></a>④  只有对同一个对象的引用，Map 结构才将其视为同一个键</h4><blockquote><p>注意, 只有对同一个对象的引用，Map 结构才将其视为同一个键. 这一点要非常小心. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="comment">//实际上下方两个 [&#x27;name&#x27;] 是不同实例,相当于只是语法糖 [&#x27;name&#x27;] == 等同 ==&gt; new Array(&#x27;name&#x27;)</span></span><br><span class="line">&gt;map.<span class="title function_">set</span>([<span class="string">&#x27;name&#x27;</span>], <span class="string">&#x27;努力学习的汪&#x27;</span>); </span><br><span class="line">&gt;map.<span class="title function_">get</span>([<span class="string">&#x27;name&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>set</code>和<code>get</code>方法, 表面是针对同一个键, 但实际上这是两个不同的数组实例, 内存地址是不一样的, 因此<code>get</code>方法无法读取该键, 返回<code>undefined</code>. </p><p>同理, 同样的值的两个实例, 在 Map 结构中被视为两个键. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> k1 = [<span class="string">&#x27;name&#x27;</span>];   <span class="comment">//实际上相当于是语法糖 [&#x27;name&#x27;] == 等同 ==&gt; new Array(&#x27;name&#x27;)</span></span><br><span class="line">&gt;<span class="keyword">const</span> k2 = [<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">&gt;map.<span class="title function_">set</span>(k1, <span class="number">111</span>).<span class="title function_">set</span>(k2, <span class="number">222</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map)  <span class="comment">// Map(2) &#123;Array(1) =&gt; 111, Array(1) =&gt; 222&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(k1),map.<span class="title function_">get</span>(k2))  <span class="comment">// 111 222</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831095859490.png" alt="image-20210831095859490"> </p><p>上面代码中, 变量 [ k1 ] 和 [ k2 ] 的值是一样的, 但是它们在 Map 结构中被视为两个键. </p><p>由上可知, <code>Map 的键实际上是跟内存地址绑定的</code>, 只要内存地址不一样, 就视为两个键. 这就解决了同名属性碰撞（clash）的问题, 我们扩展别人的库的时候, 如果使用对象作为键名, 就不用担心自己的属性与原作者的属性同名. </p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值）, 则只要两个值严格相等，Map 将其视为一个键, 比如<code>0</code>和<code>-0</code>就是一个键, 布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键. 另外, <code>undefined</code>和<code>null</code>也是两个不同的键. 虽然<code>NaN</code>不严格相等于自身, 但 Map 将其视为同一个键. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">&gt;map.<span class="title function_">get</span>(<span class="title class_">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-实例的属性和操作方法"><a href="#Ⅲ-实例的属性和操作方法" class="headerlink" title="Ⅲ -  实例的属性和操作方法"></a>Ⅲ -  实例的属性和操作方法</h3><blockquote><p>Map 结构的实例有以下属性和操作方法.  </p></blockquote><h4 id="①-size-属性"><a href="#①-size-属性" class="headerlink" title="① size 属性"></a>① size 属性</h4><blockquote><p><code>size</code>属性返回 Map 结构的成员总数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Map-prototype-set-key-value"><a href="#②-Map-prototype-set-key-value" class="headerlink" title="② Map.prototype.set(key, value)"></a>② Map.prototype.set(key, value)</h4><blockquote><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>, 然后返回整个 Map 结构. 如果<code>key</code>已经有值, 则键值会被更新, 否则就新生成该键. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="number">666</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;xxxx&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m)  <span class="comment">//Map(3) &#123;&quot;age&quot; =&gt; 18, 666 =&gt; &quot;努力学习的汪&quot;, undefined =&gt; &quot;xxxx&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象, 因此可以采用链式写法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;努力&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;学习&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map)    <span class="comment">//Map(3) &#123;1 =&gt; &quot;努力&quot;, 2 =&gt; &quot;学习&quot;, 3 =&gt; &quot;的汪&quot;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831101956692.png" alt="image-20210831101956692"> </p></blockquote><h4 id="③-Map-prototype-get-key"><a href="#③-Map-prototype-get-key" class="headerlink" title="③  Map.prototype.get(key)"></a>③  Map.prototype.get(key)</h4><blockquote><p><code>get</code>方法读取<code>key</code>对应的键值, 如果找不到<code>key</code>, 返回<code>undefined</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Learn ES6&#x27;</span>)&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> name = &#123;name : <span class="string">&quot;hongjilin&quot;</span>&#125;</span><br><span class="line">&gt;m.<span class="title function_">set</span>(hello, <span class="string">&#x27;你好 ES6&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(name, <span class="string">&#x27;努力学习的汪&#x27;</span>) <span class="comment">// 键是对象</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;字符串名字&#x27;</span>) <span class="comment">// 键是字符串</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;键是函数:&quot;</span>,m.<span class="title function_">get</span>(hello),<span class="string">&quot;;键是对象:&quot;</span>,m.<span class="title function_">get</span>(name),<span class="string">&quot;;键是字符串:&quot;</span>,m.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;找不到的键&#x27;</span>,m.<span class="title function_">get</span>(<span class="string">&#x27;找不到的键&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831102632292.png" alt="image-20210831102632292"> </p></blockquote><h4 id="④-Map-prototype-has-key"><a href="#④-Map-prototype-has-key" class="headerlink" title="④ Map.prototype.has(key)"></a>④ Map.prototype.has(key)</h4><blockquote><p><code>has</code>方法返回一个布尔值, 表示某个键是否在当前 Map 对象之中. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="number">666</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;xxxx&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;age&#x27;</span>))   <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="number">666</span>))  <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="literal">undefined</span>))    <span class="comment">// true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">has</span>(<span class="string">&#x27;不存在的键&#x27;</span>))  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Map-prototype-delete-key"><a href="#⑤-Map-prototype-delete-key" class="headerlink" title="⑤ Map.prototype.delete(key)"></a>⑤ Map.prototype.delete(key)</h4><blockquote><p><code>delete</code>方法删除某个键, 返回<code>true</code>. 如果删除失败, 返回<code>false</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;undefined!&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m,m.<span class="title function_">has</span>(<span class="literal">undefined</span>)) <span class="comment">// Map(1) &#123;undefined =&gt; &quot;undefined!&quot;&#125; true</span></span><br><span class="line"></span><br><span class="line">&gt;m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(m,m.<span class="title function_">has</span>(<span class="literal">undefined</span>)) <span class="comment">// Map(0) &#123;&#125; false</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-Map-prototype-clear"><a href="#⑥-Map-prototype-clear" class="headerlink" title="⑥ Map.prototype.clear()"></a>⑥ Map.prototype.clear()</h4><blockquote><p><code>clear</code>方法清除所有成员, 没有返回值. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br><span class="line">&gt;map.<span class="title function_">clear</span>()</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map) <span class="comment">// Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅳ-遍历方法"><a href="#Ⅳ-遍历方法" class="headerlink" title="Ⅳ -  遍历方法"></a>Ⅳ -  遍历方法</h3><blockquote><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法. </p><ul><li><code>Map.prototype.keys()</code>: 返回键名的遍历器. </li><li><code>Map.prototype.values()</code>: 返回键值的遍历器. </li><li><code>Map.prototype.entries()</code>: 返回所有成员的遍历器. </li><li><code>Map.prototype.forEach()</code>: 遍历 Map 的所有成员.</li></ul></blockquote><h4 id="①-Map-的遍历顺序就是插入顺序"><a href="#①-Map-的遍历顺序就是插入顺序" class="headerlink" title="① Map 的遍历顺序就是插入顺序"></a>① Map 的遍历顺序就是插入顺序</h4><blockquote><p>需要特别注意的是，Map 的遍历顺序就是插入顺序. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line"> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>],</span><br><span class="line"> [<span class="string">&#x27;handsome&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">&gt;]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------- keys() ---------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------- values() ---------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;------------- entries() ---------------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]) &#125;</span><br><span class="line">&gt;<span class="comment">// 或者</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value) &#125;</span><br><span class="line">&gt;<span class="comment">// 等同于使用map.entries()</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value) &#125;</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831104307237.png" alt="image-20210831104307237">  上面代码最后的那个例子, 表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性), 就是<code>entries</code>方法. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === map.<span class="property">entries</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Map-结构转为数组结构"><a href="#②-Map-结构转为数组结构" class="headerlink" title="② Map 结构转为数组结构"></a>② Map 结构转为数组结构</h4><blockquote><p>Map 结构转为数组结构, 比较快速的方法是使用扩展运算符（<code>...</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([ [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],[<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],[<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>] ]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">keys</span>()])<span class="comment">// [1, 2, 3]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">values</span>()])<span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">entries</span>()])<span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...map])<span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法, 可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>( [...map].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>) );</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map1) <span class="comment">// Map(2) &#123;1 =&gt; &quot;a&quot;, 2 =&gt; &quot;b&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>( [...map].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;*&#x27;</span> + v]) );</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(map2) <span class="comment">//Map(3) &#123;2 =&gt; &quot;*a&quot;, 4 =&gt; &quot;*b&quot;, 6 =&gt; &quot;*c&quot;&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Map-的-forEach-方法"><a href="#③-Map-的-forEach-方法" class="headerlink" title="③ Map 的  forEach()  方法"></a>③ Map 的  <code>forEach()</code>  方法</h4><blockquote><p>Map 还有一个<code>forEach</code>方法, 与数组的<code>forEach</code>方法类似, 也可以实现遍历. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p><code>forEach</code>方法还可以接受第二个参数, 用来绑定<code>this</code>. 下面举个栗子说明:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;不读书&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> reporter = &#123;</span><br><span class="line"> <span class="attr">report</span>: <span class="keyword">function</span>(<span class="params">key, value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//第二个参数绑定后,可以通过this取得其内部属性方法</span></span><br><span class="line">&gt;map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;<span class="variable language_">this</span>.<span class="title function_">report</span>(key, value); &#125;, reporter);</span><br><span class="line">&gt;<span class="comment">//不绑定示例  报错!!</span></span><br><span class="line">&gt;map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;<span class="variable language_">this</span>.<span class="title function_">report</span>(key, value); &#125;);</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831105438551.png" alt="image-20210831105438551"> 上面代码中, <code>forEach</code>方法的回调函数的<code>this</code>, 就指向<code>reporter</code>. </p></blockquote><h3 id="Ⅴ-与其他数据结构的互相转换"><a href="#Ⅴ-与其他数据结构的互相转换" class="headerlink" title="Ⅴ - 与其他数据结构的互相转换"></a>Ⅴ - 与其他数据结构的互相转换</h3><h4 id="①-Map-转为数组"><a href="#①-Map-转为数组" class="headerlink" title="① Map 转为数组"></a>① Map 转为数组</h4><blockquote><p>前面已经提过，Map 转为数组最方便的方法, 就是使用扩展运算符（<code>...</code>）. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>).<span class="title function_">set</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;对象&#x27;</span>&#125;, [<span class="string">&#x27;这是数组&#x27;</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...myMap])</span><br><span class="line">&gt;<span class="comment">//[ [true, 1] , [&#123;name: &quot;对象&quot;&#125;,[&quot;这是数组&quot;]]  ]  ==&gt;数组内部两个二维数组</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831110044997.png" alt="image-20210831110044997">  </p></blockquote><h4 id="②-数组-转为-Map"><a href="#②-数组-转为-Map" class="headerlink" title="② 数组 转为 Map"></a>② 数组 转为 Map</h4><blockquote><p>将数组传入 Map 构造函数, 就可以转为 Map. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>).<span class="title function_">set</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;对象&#x27;</span>&#125;, [<span class="string">&#x27;这是数组&#x27;</span>]);</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831110236279.png" alt="image-20210831110236279"> </p></blockquote><h4 id="③-Map-转为对象"><a href="#③-Map-转为对象" class="headerlink" title="③ Map 转为对象"></a>③ Map 转为对象</h4><blockquote><p>如果所有 Map 的键都是字符串, 它可以无损地转为对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">//创建一个空对象</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;  obj[k] = v &#125; <span class="comment">//循环遍历并给空对象赋值</span></span><br><span class="line"> <span class="keyword">return</span> obj;  <span class="comment">//最后将加工好的对象返回出去</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//字符串的键转对象</span></span><br><span class="line">&gt;<span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">strMapToObj</span>(myMap))</span><br><span class="line">&gt;<span class="comment">//其他转对象</span></span><br><span class="line">&gt;<span class="keyword">const</span> testMap =<span class="title function_">strMapToObj</span>( <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">&gt;.<span class="title function_">set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>), <span class="string">&#x27;文档对象&#x27;</span>).<span class="title function_">set</span>(<span class="literal">true</span>, <span class="string">&#x27;布尔值&#x27;</span>).<span class="title function_">set</span>(<span class="number">123</span>,<span class="string">&quot;数值&quot;</span>) )<span class="comment">//转为对象时都转为了字符串形式</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(testMap)</span><br></pre></td></tr></table></figure><p>如果有非字符串的键名, 那么这个键名会被转成字符串, 再作为对象的键名. </p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831111717060.png" alt="image-20210831111717060"></p><p>当然,如果你像是布尔值或者数值 如输入时直接 testMap[true] 也能获得结果,因为有<code>隐式转换</code>,这就涉及JS基础了</p></blockquote><h4 id="④-对象转为-Map"><a href="#④-对象转为-Map" class="headerlink" title="④ 对象转为 Map"></a>④ 对象转为 Map</h4><blockquote><p>对象转为 Map 可以通过<code>Object.entries()</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;handsome&#x27;</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">&gt;<span class="comment">//其实就是通过[Object.entries()]将对象转化为数组,再通过Map()构造函数转化为Map</span></span><br><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)); <span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br></pre></td></tr></table></figure><p>此外, 也可以自己实现一个转换函数. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 定义一个空的Map</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;  strMap.<span class="title function_">set</span>(k, obj[k]) &#125; <span class="comment">//通过循环将对象内容取出并加入Map中</span></span><br><span class="line"> <span class="keyword">return</span> strMap;   <span class="comment">//最后返回</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="title function_">objToStrMap</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;handsome&#x27;</span>:<span class="literal">true</span>&#125;)<span class="comment">// Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Map-转为-JSON"><a href="#⑤-Map-转为-JSON" class="headerlink" title="⑤ Map 转为 JSON"></a>⑤ Map 转为 JSON</h4><h5 id="a-Map-的键名都是字符串"><a href="#a-Map-的键名都是字符串" class="headerlink" title="a) Map 的键名都是字符串"></a>a) Map 的键名都是字符串</h5><blockquote><p>Map 转为 JSON 要区分两种情况. 一种情况是，Map 的键名都是字符串, 这时可以选择转为对象 JSON. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map转对象 函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">strMapToObj</span>=(<span class="params">strMap</span>)=&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;obj[k] = v;&#125;</span><br><span class="line"> <span class="keyword">return</span> obj;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//对象转JSON 函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">strMapToJson</span>=(<span class="params">strMap</span>)=&gt;  <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&gt;<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;handsome&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">strMapToObj</span>(myMap))  <span class="comment">//调用map转对象,查看效果</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">strMapToJson</span>(myMap))  <span class="comment">//调用map转对象 对象转JSON 方法</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831114712158.png" alt="image-20210831114712158"> </p></blockquote><h5 id="b-Map-的键名有非字符串"><a href="#b-Map-的键名有非字符串" class="headerlink" title="b)  Map 的键名有非字符串"></a>b)  Map 的键名有非字符串</h5><blockquote><p>另一种情况是，Map 的键名有非字符串, 这时可以选择转为数组 JSON. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//Map转JSON函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">mapToArrayJson</span>=(<span class="params">map</span>)=&gt; <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]) </span><br><span class="line">&gt;<span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>).<span class="title function_">set</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;对象&#x27;</span>&#125;, [<span class="string">&#x27;这是数组&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>([...myMap]) <span class="comment">//查看点运算符解构转换后结果</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mapToArrayJson</span>(myMap)) <span class="comment">//调用转换函数</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831115125771.png" alt="image-20210831115125771"> </p></blockquote><h4 id="⑥-JSON-转为-Map"><a href="#⑥-JSON-转为-Map" class="headerlink" title="⑥ JSON 转为 Map"></a>⑥ JSON 转为 Map</h4><blockquote><p>JSON 转为 Map，正常情况下, 所有键名都是字符串. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// 定义一个空的Map</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;  strMap.<span class="title function_">set</span>(k, obj[k]) &#125; <span class="comment">//通过循环将对象内容取出并加入Map中</span></span><br><span class="line"> <span class="keyword">return</span> strMap;   <span class="comment">//最后返回</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">jsonToStrMap</span>=(<span class="params">jsonStr</span>) =&gt; <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;努力学习的汪&quot;,&quot;handsome&quot;:true&#125;&#x27;</span>))</span><br><span class="line">&gt;<span class="comment">//log: Map(2) &#123;&quot;name&quot; =&gt; &quot;努力学习的汪&quot;, &quot;handsome&quot; =&gt; true&#125;</span></span><br></pre></td></tr></table></figure><p>但是, 有一种特殊情况, 整个 JSON 就是一个数组, 且每个数组成员本身, 又是一个有两个成员的数组. 这时, 它可以一一对应地转为 Map. 这往往是 Map 转为数组 JSON 的逆操作. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span>  <span class="title function_">jsonToMap</span> = (<span class="params">jsonStr</span>) =&gt;  <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&gt;<span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,1],[&#123;&quot;name&quot;:&quot;对象&quot;&#125;,[&quot;这是数组&quot;]]]&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831115700778.png" alt="image-20210831115700778"> </p></blockquote><h4 id="⑦-WeakMap"><a href="#⑦-WeakMap" class="headerlink" title="⑦ WeakMap"></a>⑦ WeakMap</h4><blockquote><p>此处知识点本人较少用到,就暂不整理,留后续补充</p></blockquote><h3 id="Ⅵ-map-方法"><a href="#Ⅵ-map-方法" class="headerlink" title="Ⅵ - map()方法:"></a>Ⅵ - map()方法:</h3><blockquote><p><strong>map(): 映射, 即原数组映射成一个新的数组</strong>–&gt; <code>非常常用</code></p><p>map方法接受一个新参数, 这个参数就是将原数组变成新数组的映射关系. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">fun1</span>=(<span class="params">arr</span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">let</span> array = [];</span><br><span class="line"> arr.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span>  array.<span class="title function_">push</span>(item*item) );</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">fun2</span>=(<span class="params">arr</span>)=&gt;&#123;</span><br><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"> arr.<span class="title function_">map</span>( <span class="keyword">function</span>(<span class="params">item</span>)&#123; array.<span class="title function_">push</span>(item*item) &#125;);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> arr1 = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">&gt;<span class="title function_">fun1</span>(arr1);    <span class="comment">//[25, 4, 1, 9, 16]</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">&gt;<span class="title function_">fun1</span>(arr2);   <span class="comment">// [1, 4, 9, 16, 25]</span></span><br><span class="line">&gt;<span class="keyword">var</span> arr3 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>];</span><br><span class="line">&gt;<span class="title function_">fun2</span>(arr3);   <span class="comment">//[9, 16, 25, 1, 4, 36] </span></span><br></pre></td></tr></table></figure><p>在实际的应用中, 我们可以通过map方法得到某一个对象数组中特定属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = [</span><br><span class="line"> &#123;<span class="attr">name</span>:<span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">name</span>:<span class="string">&#x27;hongjilin&#x27;</span>,<span class="attr">age</span>:<span class="number">88</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="attr">name</span>:<span class="string">&#x27;帅小伙&#x27;</span>,<span class="attr">age</span>:<span class="number">66</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">&gt;]</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">getter</span>=(<span class="params">obj</span>)=&gt;&#123; obj.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">name</span>) &#125;)&#125;</span><br><span class="line">&gt;<span class="title function_">getter</span>(obj);</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831181721474.png" alt="image-20210831181721474">  </p><p>map方法的作用不难理解, 即“映射”, 也就是原数组被“映射”成对应新数组. 下面这个例子是数值项求平方: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>)=&gt;</span> item * item);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arrayOfSquares); <span class="comment">// 1, 4, 9, 16</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//callback需要有return值, 如果没有, 就像下面这样: </span></span><br><span class="line">&gt;<span class="keyword">var</span> data1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&gt;<span class="keyword">var</span> arrayOfSquares1 = data.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arrayOfSquares1)<span class="comment">//数组所有项都被映射成了undefined: </span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210831181951620.png" alt="image-20210831181951620"> </p></blockquote><h3 id="Ⅶ-做个题目吧-1"><a href="#Ⅶ-做个题目吧-1" class="headerlink" title="Ⅶ - 做个题目吧"></a>Ⅶ - 做个题目吧</h3><blockquote><p>光说不练假把式,试着回答几个问题检测下是否理解 Mep 数据结构</p></blockquote><h3 id="①-代码阅读题"><a href="#①-代码阅读题" class="headerlink" title="① 代码阅读题"></a>① 代码阅读题</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;map.<span class="title function_">set</span>([<span class="number">1</span>],<span class="string">&quot;ES6系列&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> con = map.<span class="title function_">get</span>([<span class="number">1</span>]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(con);</span><br></pre></td></tr></table></figure><p><strong>问: 打印出来的变量con的值是多少, 为什么？</strong></p><blockquote><p>答: undefined. 因为set的时候用的数组[1]和get的时候用的数组[1]是分别两个不同的数组, 只不过它们元素都是1. 它们是分别定义的两个数组, 并不是同一个值. </p></blockquote><p>**如果想达到预期的效果, 你要保证get的时候和set的时候用同一个数组. 比如: **</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="number">1</span>];</span><br><span class="line">&gt;map.<span class="title function_">set</span>(arr,<span class="string">&quot;ES6系列&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> con = map.<span class="title function_">get</span>(arr);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(con); <span class="comment">//ES6系列</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="13、Proxy"><a href="#13、Proxy" class="headerlink" title="13、Proxy"></a>13、Proxy</h2><blockquote><p>很重要的知识点,也许你初入前端的时候会用的比较少,但是在后面进阶开发中此知识点是绕不过的,这知识点常与下方 <strong>Reflect</strong> 搭配使用</p><p>嗯,如果你是Vue前端工程师,那这个就更要掌握了,毕竟Vue3.x双向绑定就是用这个知识点实现的</p><p>下面我也会用Proxy自己模拟实现一个数据双向绑定</p></blockquote><h3 id="Ⅰ-概括与总结-5"><a href="#Ⅰ-概括与总结-5" class="headerlink" title="Ⅰ - 概括与总结"></a>Ⅰ - 概括与总结</h3><blockquote><ol><li>定义: Proxy 用于修改某些操作的默认行为, 等同于在语言层面做出修改, 所以属于一种“元编程”（meta programming）, 即对编程语言进行编程. </li><li>声明: <code>const proxy = new Proxy(target, handler)</code></li><li>入参:<ul><li><strong>target</strong>: 拦截的目标对象</li><li><strong>handler</strong>: 定制拦截行为</li></ul></li><li>方法:<ul><li><strong>Proxy.revocable()</strong>: 返回可取消的Proxy实例(返回<code>&#123; proxy, revoke &#125;</code>, 通过revoke()取消代理)</li></ul></li></ol><blockquote><p>下面是 Proxy 支持的拦截操作一览, 一共 13 种. </p></blockquote><ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取, 比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>. </li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置, 比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>, 返回一个布尔值. </li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作, 返回一个布尔值. </li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作, 返回一个布尔值. </li><li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环, 返回一个数组. 该方法返回目标对象所有自身的属性的属性名, 而 [Object.keys()] 的返回结果仅包括目标对象自身的可遍历属性. </li><li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>, 返回属性的描述对象. </li><li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>, 返回一个布尔值. </li><li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>, 返回一个布尔值. </li><li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>, 返回一个对象. </li><li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>, 返回一个布尔值. </li><li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>, 返回一个布尔值. 如果目标对象是函数, 那么还有两种额外操作可以拦截. </li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作, 比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>. </li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作, 比如<code>new proxy(...args)</code>.</li></ul><blockquote><p>应用场景</p></blockquote><ul><li><code>Proxy.revocable()</code>: 不允许直接访问对象, 必须通过代理访问, 一旦访问结束就收回代理权不允许再次访问</li><li><code>get()</code>: 读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li><li><code>set()</code>: 数据绑定(Vue数据双向绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li><li><code>has()</code>: 隐藏内部属性不被发现、排除不符合属性条件的对象</li><li><code>deleteProperty()</code>: 保护内部属性不被删除</li><li><code>defineProperty()</code>: 阻止属性被外部定义</li><li>[ownKeys()] : 保护内部属性不被遍历</li></ul><blockquote><p>重点难点</p></blockquote><ul><li>要使 [ Proxy ] 起作用, 必须针对<code>实例</code>进行操作, 而不是针对<code>目标对象</code>进行操作</li><li>没有设置任何拦截时, 等同于<code>直接通向原对象</code></li><li>属性被定义为<code>不可读写/扩展/配置/枚举</code>时, 使用拦截方法会报错</li><li>代理下的目标对象, 内部<code>this</code>指向<code>Proxy代理</code></li></ul></blockquote><h3 id="Ⅱ-概念结合实例解析"><a href="#Ⅱ-概念结合实例解析" class="headerlink" title="Ⅱ - 概念结合实例解析"></a>Ⅱ - 概念结合实例解析</h3><blockquote><p>通过分析简单常用的例子,来帮助我们理解Proxy</p></blockquote><h4 id="①-概述"><a href="#①-概述" class="headerlink" title="①  概述"></a>①  概述</h4><blockquote><p>Proxy 用于修改某些操作的默认行为, 等同于在语言层面做出修改, 所以属于一种“元编程”（meta programming）, 即对编程语言进行编程. </p><p>Proxy 可以理解成, 在目标对象之前架设一层“拦截”, 外界对该对象的访问, 都必须先通过这层拦截, 因此提供了一种机制, 可以对外界的访问进行过滤和改写. Proxy 这个词的原意是代理, 用在这里表示由它来“代理”某些操作, 可以译为“代理器”. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="comment">//拦截的对象,传入的对象属性,整个proxy对象</span></span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="comment">// [ Reflect.get ] 方法查找并返回`target`对象的`name`属性, 如果没有该属性, 则返回`undefined`. </span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);  <span class="comment">//详见下方Reflect一章,但此处不深究</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="comment">//`Reflect.set`方法设置`target`对象的`name`属性等于`value`. </span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截, 重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为. 这里暂时先不解释具体的语法(详见下一章节 &lt; Reflect &gt;), 只看运行结果. 对设置了拦截行为的对象<code>obj</code>, 去读写它的属性, 就会得到下面的结果. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;obj.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line">&gt;<span class="comment">//  setting count!</span></span><br><span class="line">&gt;++obj.<span class="property">count</span></span><br><span class="line">&gt;<span class="comment">//  getting count!</span></span><br><span class="line">&gt;<span class="comment">//  setting count!</span></span><br><span class="line">&gt;<span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901150537854.png" alt="image-20210901150537854"> 上面代码说明，Proxy 实际上重载（overload)了点运算符, 即用自己的定义覆盖了语言的原始定义. </p><p>ES6 原生提供 Proxy 构造函数, 用来生成 Proxy 实例. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>Proxy 对象的所有用法, 都是上面这种形式, 不同的只是<code>handler</code>参数的写法. 其中, <code>new Proxy()</code>表示生成一个 [ Proxy ] 实例, <code>target</code>参数表示所要拦截的目标对象, <code>handler</code>参数也是一个对象, 用来定制拦截行为. </p></blockquote><h4 id="②-举个拦截读取属性行为的栗子"><a href="#②-举个拦截读取属性行为的栗子" class="headerlink" title="② 举个拦截读取属性行为的栗子"></a>② 举个拦截读取属性行为的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, propKey</span>)=&gt;</span> <span class="string">&#x27;努力学习的汪&#x27;</span> <span class="comment">//温习下:ES6箭头函数写法,如果你对这个写法陌生一定要回头去巩固</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>) <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">title</span>) <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;proxy.<span class="property">a</span> = <span class="number">1</span> <span class="comment">//写入操作,修改[a]属性</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">a</span>) <span class="comment">//由于[读] 操作已经被拦截,所有 [读] 操作都返回的是 &#x27;努力学习的汪&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901151222628.png" alt="image-20210901151222628"> 上面代码中, 作为构造函数,  [ Proxy ] 接受两个参数 : </p><ul><li><p>第一个参数是所要代理的目标对象（上例是一个空对象), 即如果没有 [ Proxy ] 的介入, 操作原来要访问的就是这个对象；</p></li><li><p>第二个参数是一个配置对象, 对于每一个被代理的操作, 需要提供一个对应的处理函数, 该函数将拦截对应的操作:</p></li></ul><blockquote><p>比如, 上面代码中, 配置对象有一个<code>get</code>方法, 用来拦截对目标对象属性的访问请求. </p><p><code>get</code>方法的两个参数分别是目标对象和所要访问的属性. </p><p>可以看到, 由于拦截函数总是返回[<code>努力学习的汪</code>], 所以即使我给其设置了值,访问任何属性都得到[<code>努力学习的汪</code>]. </p></blockquote></blockquote><h4 id="③-没有设置任何拦截-等同-直接通向原对象"><a href="#③-没有设置任何拦截-等同-直接通向原对象" class="headerlink" title="③ 没有设置任何拦截 等同 直接通向原对象."></a>③ 没有设置任何拦截 等同 直接通向原对象.</h4><blockquote><p>注意, 要使得 [ Proxy ] 起作用, 必须针对 [ Proxy ] 实例（上例是<code>proxy</code>对象）进行操作, 而不是针对目标对象（上例是空对象）进行操作. </p><p>如果<code>handler</code>没有设置任何拦截, 那就等同于直接通向原对象. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">a</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;target.<span class="property">a</span> <span class="comment">// &quot;努力学习的汪&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>handler</code>是一个空对象, 没有任何拦截效果, 访问<code>proxy</code>就等同于访问<code>target</code>. </p><p>一个技巧是将 Proxy 对象, 设置到<code>object.proxy</code>属性, 从而可以在<code>object</code>对象上调用. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="④-Proxy-实例作为其他对象的原型对象"><a href="#④-Proxy-实例作为其他对象的原型对象" class="headerlink" title="④ Proxy 实例作为其他对象的原型对象"></a>④ Proxy 实例作为其他对象的原型对象</h4><blockquote><p>Proxy 实例也可以作为其他对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, propKey</span>)=&gt;</span><span class="string">&#x27;不努力学习的单身汪&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">&gt;obj.<span class="property">name</span>=<span class="string">&#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">xxx</span>)  <span class="comment">// 不努力学习的单身汪</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901152237811.png" alt="image-20210901152237811"> 上面代码中, <code>proxy</code>对象是<code>obj</code>对象的原型</p><blockquote><ul><li><code>obj</code>对象本身并有 [ name ] 属性,当访问 [ name ] 属性时,因为对象本身有,就不会去其原型上找,所以不会触发拦截</li><li><code>obj</code>对象本身并没有 [ xxx ] 属性, 所以根据原型链, 会在<code>proxy</code>对象上读取该属性, 导致被拦截。</li></ul></blockquote></blockquote><h4 id="⑤-同一个拦截器函数-设置拦截多个操作"><a href="#⑤-同一个拦截器函数-设置拦截多个操作" class="headerlink" title="⑤ 同一个拦截器函数, 设置拦截多个操作"></a>⑤ 同一个拦截器函数, 设置拦截多个操作</h4><blockquote><p>同一个拦截器函数, 可以设置拦截多个操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//当读取拦截对象的 [ prototype ],返回的是 Object的 [ prototype ]</span></span><br><span class="line">   <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>)  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">     <span class="comment">//如果读取非[ prototype ]属性,返回加工后的属性名</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;进行了非[prototype]属性的读取: &#x27;</span> + name;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">//温习巩固一下:箭头函数、标签语法</span></span><br><span class="line"> <span class="attr">apply</span>: <span class="function">(<span class="params">target, thisBinding, args</span>) =&gt;</span> <span class="string">`拦截进入apply:<span class="subst">$&#123;args[<span class="number">0</span>]&#125;</span>`</span>,</span><br><span class="line"><span class="comment">//构造函数 温习一下:构造函数不能使用箭头函数,如果不知道为什么的需要回头去巩固下-&gt;箭头函数没有自己的 this</span></span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;  <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="string">`拦截进入构造函数:<span class="subst">$&#123;args[<span class="number">1</span>]&#125;</span>`</span>&#125;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//new 一个 Proxy 实例</span></span><br><span class="line">&gt;<span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> x + y;</span><br><span class="line">&gt;&#125;, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">// 拦截进入apply:1</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">//&#123;value: &quot;拦截进入构造函数:2&quot;&#125;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(fproxy.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//对比读取fproxy与Object的 [prototype]属性是否一致 ==true</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(fproxy.<span class="property">xxx</span>)  <span class="comment">//进行了非[prototype]属性的读取: xxx</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901154515337.png" alt="image-20210901154515337"> 对于可以设置、但没有设置拦截的操作, 则直接落在目标对象上, 按照原先的方式产生结果。</p></blockquote><h3 id="Ⅲ-Proxy-实例的方法"><a href="#Ⅲ-Proxy-实例的方法" class="headerlink" title="Ⅲ - Proxy 实例的方法"></a>Ⅲ - Proxy 实例的方法</h3><blockquote><p>主要就是对于拦截方法的详细介绍</p></blockquote><h4 id="①-get"><a href="#①-get" class="headerlink" title="① get()"></a>① get()</h4><blockquote><p>**get(target, propKey, receiver)**：拦截对象属性的读取, 比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>. </p><p><code>get</code>方法用于拦截某个属性的读取操作, 可以接受三个参数, 依次为目标对象、属性名和 proxy 实例本身（严格地说, 是操作行为所针对的对象）, 其中最后一个参数可选。</p></blockquote><h5 id="a-举个栗子"><a href="#a-举个栗子" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;努力学习的汪&quot;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="comment">//如果  [propKey(属性名)] 属于 target 对象,则正常返回,否则直接抛出异常</span></span><br><span class="line">   <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) <span class="keyword">return</span>  target[propKey];</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;属性名 \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; 不存在.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>) <span class="comment">//努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">age</span>)  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901165834077.png" alt="image-20210901165834077"> </p><p>上面代码表示, 如果访问目标对象不存在的属性, 会抛出一个错误。如果没有这个拦截函数, 访问不存在的属性, 只会返回<code>undefined</code>。</p></blockquote><h5 id="b-get-方法可以继承"><a href="#b-get-方法可以继承" class="headerlink" title="b) get() 方法可以继承"></a>b) get() 方法可以继承</h5><blockquote><p><code>get</code>方法可以继承。此处用上方用过的一个例子来说明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="function">(<span class="params">target, propKey</span>)=&gt;</span><span class="string">&#x27;不努力学习的单身汪&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">&gt;obj.<span class="property">name</span>=<span class="string">&#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">xxx</span>)  <span class="comment">// 不努力学习的单身汪</span></span><br></pre></td></tr></table></figure><p>上面代码中, 拦截操作定义在<code>Prototype</code>对象上面, 所以如果读取<code>obj</code>对象继承的属性时, 拦截会生效。</p><blockquote><ul><li><code>obj</code>对象本身并有 [ name ] 属性,当访问 [ name ] 属性时,因为对象本身有,就不会去其原型上找,所以不会触发拦截</li><li><code>obj</code>对象本身并没有 [ xxx ] 属性, 所以根据原型链, 会在<code>proxy</code>对象上读取该属性, 导致被拦截。</li></ul></blockquote></blockquote><h5 id="c-实现数组读取负数的索引"><a href="#c-实现数组读取负数的索引" class="headerlink" title="c) 实现数组读取负数的索引"></a>c) 实现数组读取负数的索引</h5><blockquote><p>下面的例子使用<code>get</code>拦截, 实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> handler = &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">      <span class="comment">//如果小于0,则修改传入的属性名[propKey],做到负数索引能正确读取  </span></span><br><span class="line">     <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">     <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> target = [];</span><br><span class="line"> target.<span class="title function_">push</span>(...elements); <span class="comment">//将传入参数解构 push 进 target数组中</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> arr = <span class="title function_">createArray</span>(<span class="string">&#x27;倒数第三&#x27;</span>, <span class="string">&#x27;倒数第二&#x27;</span>, <span class="string">&#x27;倒数第一&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr[-<span class="number">2</span>],arr[-<span class="number">1</span>]) <span class="comment">//倒数第二 倒数第一</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- 正常数组读取做对比----------&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">let</span> arr1 =[<span class="string">&#x27;倒数第三&#x27;</span>, <span class="string">&#x27;倒数第二&#x27;</span>, <span class="string">&#x27;倒数第一&#x27;</span>]</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(arr1[-<span class="number">2</span>],arr1[-<span class="number">1</span>])  <span class="comment">//undefined undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 数组的位置参数是<code>-1</code>, 就会输出数组的倒数第一个成员。</p></blockquote><h5 id="d-实现属性的链式操作"><a href="#d-实现属性的链式操作" class="headerlink" title="d)  实现属性的链式操作"></a>d)  实现属性的链式操作</h5><blockquote><p>利用 Proxy，可以将读取属性的操作（<code>get</code>）, 转变为执行某个函数, 从而实现属性的链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//使用var定义函数: 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">double</span> = n =&gt; n * <span class="number">2</span>;</span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">pow</span>    = n =&gt; n * n;</span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title function_">reverseInt</span> = n =&gt; n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line">&gt;<span class="comment">//定义链式调用函数</span></span><br><span class="line">&gt;<span class="keyword">const</span> pipe = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> funcStack = [];</span><br><span class="line"> <span class="keyword">const</span> oproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">   get : <span class="keyword">function</span> (<span class="params">target, propKey</span>) &#123;</span><br><span class="line">      <span class="comment">//如果传入的属性名是 [get] ,就会从函数栈[funcStack]中循环取出,然后逐层调用</span></span><br><span class="line">     <span class="keyword">if</span> (propKey === <span class="string">&#x27;get&#x27;</span>) </span><br><span class="line">      <span class="comment">//[window]是必须的,因为定义时用的是 [var] ,这几个函数都是挂载在[window]上 </span></span><br><span class="line">      <span class="keyword">return</span> funcStack.<span class="title function_">reduce</span>( <span class="function">(<span class="params">val, fn</span>) =&gt;</span> <span class="variable language_">window</span>[fn](val),value);</span><br><span class="line">     funcStack.<span class="title function_">push</span>(propKey);<span class="comment">//传入的不是 [get] 所以将传入的当前属性名 压入数组中存储</span></span><br><span class="line">     <span class="keyword">return</span> oproxy;<span class="comment">//当不是[get]时,返回proxy给下一层调用</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">return</span> oproxy;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//打印调用</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">get</span>) <span class="comment">//3</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">get</span>) <span class="comment">//6</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">get</span>) <span class="comment">//36</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">reverseInt</span>.<span class="property">get</span>)<span class="comment">//63</span></span><br></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后, 达到了将函数名链式使用的效果。注意点:</p><blockquote><ul><li>使用var定义函数: 所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法</li><li>[window]是必须的,因为定义时用的是 [var] ,这几个函数都是挂载在[window]上</li></ul></blockquote><p>对于某些刚入坑的同学来说可能会比较绕,所以我尽量多的给出了注释,如果还不能理解也多看几遍,以后在学习数据结构与算法的时候就会觉得这里很简单了</p></blockquote><h5 id="e-实现生成各种-DOM-节点的通用函数"><a href="#e-实现生成各种-DOM-节点的通用函数" class="headerlink" title="e) 实现生成各种 DOM 节点的通用函数"></a>e) 实现生成各种 DOM 节点的通用函数</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">   <span class="comment">//声明一个函数,第一个参数为默认为空的对象  第二个参数为其余所有入参</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(propKey); <span class="comment">//根据传入的 [属性名] 创建对应初始 DOM 节点</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(attrs)) &#123;<span class="comment">//取出传入第一个参数对象的属性名</span></span><br><span class="line">       el.<span class="title function_">setAttribute</span>(prop, attrs[prop]); <span class="comment">//如果有属性名,就将其写入标签的属性中</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123; <span class="comment">//循环取出所有入参(除第一个入参外)</span></span><br><span class="line">       <span class="comment">//如果入参类型为字符串,则将其转换为文本节点 </span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;string&#x27;</span>)  child = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">       el.<span class="title function_">appendChild</span>(child); <span class="comment">//将子节点插入el中</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> el;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> els = dom.<span class="title function_">div</span>(&#123;&#125;, <span class="comment">//生成外层的div节点</span></span><br><span class="line"> <span class="string">&#x27;你好!我的名字叫做: &#x27;</span>, <span class="comment">//生成文本节点</span></span><br><span class="line"> dom.<span class="title function_">a</span>(&#123;<span class="attr">href</span>: <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>&#125;, <span class="string">&#x27;努力学习的汪&#x27;</span>),<span class="comment">//生成一个a节点</span></span><br><span class="line"> <span class="string">&#x27;. 我喜欢:&#x27;</span>,</span><br><span class="line"> dom.<span class="title function_">ul</span>(&#123;&#125;,<span class="comment">//生成一个ul节点</span></span><br><span class="line">   dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;划水&#x27;</span>), <span class="comment">//生成li节点</span></span><br><span class="line">   dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;吃瓜&#x27;</span>),</span><br><span class="line">   dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;…其他&#x27;</span>)</span><br><span class="line"> )</span><br><span class="line">&gt;);</span><br><span class="line">&gt;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">insertBefore</span>(els); </span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210901184714299.png" alt="image-20210901184714299"> </p></blockquote><h5 id="f-get-的第三个参数"><a href="#f-get-的第三个参数" class="headerlink" title="f) get() 的第三个参数"></a>f) get() 的第三个参数</h5><blockquote><p>下面是一个<code>get</code>方法的第三个参数的例子, 它总是指向原始的读操作所在的那个对象, 一般情况下就是 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">&gt;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> receiver;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;proxy.<span class="property">getReceiver</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的, 所以  [ receiver ] 指向<code>proxy</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">&gt;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> receiver;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> d = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">&gt;d.<span class="property">a</span> === d <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>d</code>对象本身没有<code>a</code>属性, 所以读取<code>d.a</code>的时候, 会去<code>d</code>的原型<code>proxy</code>对象找。这时,   [ receiver ] 就指向<code>d</code>, 代表原始的读操作所在的那个对象。</p><p>如果一个属性不可配置（configurable）且不可写（writable）, 则 Proxy 不能修改该属性, 否则通过 Proxy 对象访问该属性会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line"><span class="attr">obj</span>: &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"><span class="attr">handsome</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//configurable:默认为 false 只有设为 true 该属性可能的类型可以被改变, 该属性可以从中删除。</span></span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">false</span>  </span><br><span class="line">&#125;,</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line">&gt;<span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="string">&#x27;不想学习&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">obj</span></span><br><span class="line">&gt;<span class="comment">//TypeError: &#x27;get&#x27; on proxy: property &#x27;obj&#x27; is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected &#x27;undefined&#x27; but got &#x27;不想学习&#x27;)</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-set"><a href="#②-set" class="headerlink" title="② set()"></a>② set()</h4><blockquote><p><code>set</code>方法用来拦截某个属性的赋值操作, 可以接受四个参数, 依次为目标对象、属性名、属性值和 Proxy 实例本身, 其中最后一个参数可选。</p></blockquote><h5 id="a-举个栗子-1"><a href="#a-举个栗子-1" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p>假定<code>Person</code>对象有一个<code>age</code>属性, 该属性应该是一个不大于 200 的整数, 那么可以使用 [ Proxy ] 拦截进而保证<code>age</code>的属性值符合要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> validator = &#123;</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123; <span class="comment">//对于设置 [age] 的操作进行拦截</span></span><br><span class="line">     <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value))  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;年龄不是一个整数&#x27;</span>);</span><br><span class="line">     <span class="keyword">if</span> (value &gt; <span class="number">200</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;你在修仙吗?&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对于满足条件的 age 属性以及其他属性, 直接保存</span></span><br><span class="line">   obj[prop] = value;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="number">99</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入年龄99岁:&#x27;</span>,person)</span><br><span class="line">&gt;person.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>  </span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入名字:&#x27;</span>,person)</span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="string">&#x27;寿元无限&#x27;</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902152109632.png" alt="image-20210902152109632"> 上面代码中, 由于设置了存值函数<code>set</code>, 任何不符合要求的<code>age</code>属性赋值, 都会抛出一个错误, 这是数据验证的一种实现方法。利用<code>set</code>方法, 还可以数据绑定, 即每当对象发生变化时, 会自动更新 DOM。</p></blockquote><h5 id="b-做到防止内部属性被外部读写"><a href="#b-做到防止内部属性被外部读写" class="headerlink" title="b) 做到防止内部属性被外部读写"></a>b) 做到防止内部属性被外部读写</h5><blockquote><p>有时, 我们会在对象上面设置内部属性, 属性名的第一个字符使用下划线开头, 表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法, 就可以做到防止这些内部属性被外部读写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> get (target, key) &#123;</span><br><span class="line">   <span class="title function_">invariant</span>(key, <span class="string">&#x27;get&#x27;</span>); <span class="comment">//将传入的属性名当作参数传给函数</span></span><br><span class="line">   <span class="keyword">return</span> target[key];</span><br><span class="line"> &#125;,</span><br><span class="line"> set (target, key, value) &#123;</span><br><span class="line">   <span class="title function_">invariant</span>(key, <span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">   target[key] = value;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">   <span class="comment">//当传入的 [属性名] 第一位字符是 &#x27;_&#x27; 时抛出错误</span></span><br><span class="line"> <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`对私有属性 [<span class="subst">$&#123;key&#125;</span>] 进行 [<span class="subst">$&#123;action&#125;</span>] 操作是无效的 `</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">_prop</span>  <span class="comment">//报错: 对私有属性 [_prop] 进行 [get] 操作是无效的 </span></span><br><span class="line">&gt;proxy.<span class="property">_prop</span> = <span class="string">&#x27;c&#x27;</span> <span class="comment">//报错 : 对私有属性 [_prop] 进行 [set] 操作是无效的 </span></span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span><span class="comment">//正常的</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>)  <span class="comment">//正常的</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902153407195.png" alt="image-20210902153407195"></p><p>上面代码中, 只要读写的属性名的第一个字符是下划线, 一律抛出错误, 从而达到禁止读写内部属性的目的。</p></blockquote><h5 id="c-举个关于第四个参数的栗子"><a href="#c-举个关于第四个参数的栗子" class="headerlink" title="c) 举个关于第四个参数的栗子"></a>c) 举个关于第四个参数的栗子</h5><blockquote><p>下面是<code>set</code>方法第四个参数的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;<span class="comment">//拦截写入方法 将本身实例挂载在传入的属性名</span></span><br><span class="line">   obj[prop] = receiver; <span class="comment">//效果:不论写入什么,赋值上去的都是本身实例.主要就是给你做例子用,这种写法开发中不会用到</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy)</span><br><span class="line">&gt;proxy.<span class="property">name</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902154217329.png" alt="image-20210902154217329"> </p><p>上面代码中, <code>set</code>方法的第四个参数  [ receiver ] , 指的是原始的操作行为所在的那个对象, 一般情况下是<code>proxy</code>实例本身, 请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">   obj[prop] = receiver; <span class="comment">//当触发属性写入操作时,将本身proxy实例写入属性中</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&gt;<span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> testObj = &#123;&#125;</span><br><span class="line">&gt;<span class="comment">//Object.setPrototypeOf() 方法一个指定的对象的原型（即设置, 内部[[Prototype]]属性）到另一个对象或  null。</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, proxy); <span class="comment">//将proxy指定为 myObj 的原型对象</span></span><br><span class="line"></span><br><span class="line">&gt;myObj.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;testObj.<span class="property">name</span> = <span class="string">&#x27;对比:努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;绑定原型的:&#x27;</span>,myObj, <span class="string">&#x27; ;没有绑定proxy原型的:&#x27;</span>,testObj)</span><br><span class="line">&gt;myObj.<span class="property">name</span> === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210902155654217.png" alt="image-20210902155654217"> 分析一下上面代码:</p><blockquote><ul><li>设置<code>myObj.name</code>属性的值时, <code>myObj</code>并没有 [ name ] 属性, 因此引擎会到<code>myObj</code>的原型链去找 [ name ] 属性。</li><li><code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例, 设置它的 [ name ] 属性会触发<code>set</code>方法。</li><li>这时, 第四个参数  [ receiver ] 就指向原始赋值行为所在的对象<code>myObj</code>。</li></ul></blockquote></blockquote><h4 id="③-apply"><a href="#③-apply" class="headerlink" title="③ apply()"></a>③ apply()</h4><blockquote><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p><p><code>apply</code>方法可以接受三个参数, 分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> apply (target, ctx, args) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);  <span class="comment">//对于此方法不懂的可以看下方章节 [Reflect]</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h5 id="a-举个栗子-2"><a href="#a-举个栗子-2" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;我是 target&#x27;</span>; &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">apply</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;我是 proxy&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="title function_">p</span>()</span><br><span class="line">&gt;<span class="comment">// &quot;我是 proxy&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>p</code>是 Proxy 的实例, 当它作为函数调用时[<code>p()</code>], 就会被<code>apply</code>方法拦截, 返回一个字符串。</p></blockquote><h5 id="b-举两个栗子"><a href="#b-举两个栗子" class="headerlink" title="b) 举两个栗子"></a>b) 举两个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> twice = &#123;</span><br><span class="line"> apply (target, ctx, args) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line"> <span class="keyword">return</span> left + right;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice);</span><br><span class="line">&gt;<span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">&gt;proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">&gt;proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>上面代码中, 每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用）, 就会被<code>apply</code>方法拦截。</p><p>另外, 直接调用<code>Reflect.apply</code>方法, 也会被拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">apply</span>(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-has"><a href="#④-has" class="headerlink" title="④ has()"></a>④ has()</h4><blockquote><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作, 即判断对象是否具有某个属性时, 这个方法会生效。典型的操作就是<code>in</code>运算符。</p><p><code>has()</code>方法可以接受两个参数, 分别是目标对象、需查询的属性名。</p></blockquote><h5 id="a-举个栗子-3"><a href="#a-举个栗子-3" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p>下面的例子使用<code>has()</code>方法隐藏某些属性, 不被<code>in</code>运算符发现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> has (target, key) &#123;</span><br><span class="line">   <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;隐藏属性&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;正常属性&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中, 如果原对象的属性名的第一个字符是下划线, <code>proxy.has()</code>就会返回<code>false</code>, 从而不会被<code>in</code>运算符发现。</p></blockquote><h5 id="b-当原对象不可配置或者禁止扩展时-has-会报错"><a href="#b-当原对象不可配置或者禁止扩展时-has-会报错" class="headerlink" title="b) 当原对象不可配置或者禁止扩展时, has() 会报错"></a>b) 当原对象不可配置或者禁止扩展时, <code>has()</code> 会报错</h5><blockquote><p>如果原对象不可配置或者禁止扩展, 这时<code>has()</code>拦截会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj); <span class="comment">//设置为不可配置</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>  &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>obj</code>对象禁止扩展, 结果使用<code>has</code>拦截就会报错。也就是说, 如果某个属性不可配置（或者目标对象不可扩展）, 则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p><p>值得注意的是, <code>has()</code>方法拦截的是<code>HasProperty</code>操作, 而不是<code>HasOwnProperty</code>操作, 即<code>has()</code>方法不判断一个属性是对象自身的属性, 还是继承的属性。</p></blockquote><h5 id="c-has-拦截对-for-in-循环不生效"><a href="#c-has-拦截对-for-in-循环不生效" class="headerlink" title="c) has() 拦截对 for...in 循环不生效"></a>c) <code>has()</code> 拦截对 <code>for...in</code> 循环不生效</h5><blockquote><p>另外, 虽然<code>for...in</code>循环也用到了<code>in</code>运算符, 但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>, <span class="attr">score</span>: <span class="number">89</span>&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">score</span>: <span class="number">149</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (prop === <span class="string">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class="number">90</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu1, handler);</span><br><span class="line">&gt;<span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy1</span><br><span class="line">&gt;<span class="comment">//hongjilin 不及格</span></span><br><span class="line">&gt;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy2   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy1[a]); <span class="comment">//hongjilin   // 89</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy2[b]); <span class="comment">//努力学习的汪 // 149</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>has()</code>拦截只对<code>in</code>运算符生效, 对<code>for...in</code>循环不生效, 导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p></blockquote><h4 id="⑤-construct"><a href="#⑤-construct" class="headerlink" title="⑤ construct()"></a>⑤ construct()</h4><blockquote><p><code>construct()</code>方法用于拦截<code>new</code>命令, 下面是拦截对象的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> construct (target, args, newTarget) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h5 id="a-construct-的三个参数"><a href="#a-construct-的三个参数" class="headerlink" title="a) construct() 的三个参数"></a>a) construct() 的三个参数</h5><blockquote><p><code>construct()</code>方法可以接受三个参数。</p><ul><li><code>target</code>：目标对象。</li><li><code>args</code>：构造函数的参数数组。</li><li><code>newTarget</code>：创造实例对象时, <code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;构造函数的参数数组: &#x27;</span>+args,<span class="string">&#x27;构造函数的参数转字符串: &#x27;</span>+args.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>)); <span class="comment">//打印其传入参数</span></span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">2</span> &#125;;  <span class="comment">//将传入参数的第一个参数乘2 返回</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">9</span>,<span class="number">66</span>)</span><br><span class="line">&gt;<span class="comment">//构造函数的参数数组: 9,66 构造函数的参数转字符串: 9, 66</span></span><br><span class="line">&gt;<span class="comment">//&#123;value: 18&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923165830708.png" alt="image-20210923165830708"> </p></blockquote><h5 id="b-construct-方法返回的必须是一个对象-否则会报错"><a href="#b-construct-方法返回的必须是一个对象-否则会报错" class="headerlink" title="b) construct() 方法返回的必须是一个对象, 否则会报错"></a>b) construct() 方法返回的必须是一个对象, 否则会报错</h5><blockquote><p><code>construct()</code>方法返回的必须是一个对象, 否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923170059451.png" alt="image-20210923170059451"> </p></blockquote><h5 id="c-construct-的目标对象必须是函数"><a href="#c-construct-的目标对象必须是函数" class="headerlink" title="c) construct() 的目标对象必须是函数"></a>c) construct() 的目标对象必须是函数</h5><blockquote><p>由于<code>construct()</code>拦截的是构造函数, 所以它的目标对象必须是函数, 否则就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123; <span class="comment">//此处第一个参数设置为对象</span></span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;  <span class="keyword">return</span> &#123;&#125; &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面例子中, 拦截的目标对象不是一个函数, 而是一个对象（<code>new Proxy()</code>的第一个参数）, 导致报错。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923171049824.png" alt="image-20210923171049824"> </p></blockquote><h5 id="d-方法中的this指向的是handler-而不是实例对象"><a href="#d-方法中的this指向的是handler-而不是实例对象" class="headerlink" title="d) 方法中的this指向的是handler, 而不是实例对象"></a>d) 方法中的<code>this</code>指向的是<code>handler</code>, 而不是实例对象</h5><blockquote><p>注意, <code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>, 而不是实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this指向: &#x27;</span>,<span class="variable language_">this</span> ); <span class="comment">// this指向:  &#123;construct: ƒ&#125;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;this是否指向handler: &quot;</span>,<span class="variable language_">this</span> === handler ); <span class="comment">//this是否指向handler:  true</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, handler);</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title function_">p</span>() </span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923171637969.png" alt="image-20210923171637969"> </p></blockquote><h4 id="⑥-deleteProperty"><a href="#⑥-deleteProperty" class="headerlink" title="⑥ deleteProperty()"></a>⑥ deleteProperty()</h4><blockquote><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作, 如果这个方法抛出错误或者返回<code>false</code>, 当前属性就无法被<code>delete</code>命令删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> deleteProperty (target, key) &#123;</span><br><span class="line">   <span class="title function_">deleteHandler</span>(key, <span class="string">&#x27;delete&#x27;</span>); <span class="comment">//调用自定义抛出异常方法</span></span><br><span class="line">   <span class="keyword">delete</span> target[key]; <span class="comment">//如果上面方法中没有抛出异常才可走到此处,这里进行删除</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//拦截 [ delete ] 时调用的方法,当为私有属性时,抛出异常</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">deleteHandler</span> (key, action) &#123;</span><br><span class="line"> <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无效的动作尝试: <span class="subst">$&#123;action&#125;</span> , 私有属性 &quot;<span class="subst">$&#123;key&#125;</span>&quot; 是不可删除的 `</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> target = &#123; <span class="attr">_name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;<span class="comment">//声明一个对象,有私有属性 [ _name ]</span></span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="keyword">delete</span> proxy.<span class="property">_name</span>  <span class="comment">//进行删除私有属性操作</span></span><br><span class="line">&gt;<span class="comment">//Uncaught Error: 无效的动作尝试: delete , 私有属性 &quot;_name&quot; 是不可删除的 </span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>deleteProperty</code>方法拦截了<code>delete</code>操作符, 删除第一个字符为下划线的属性会报错。</p><p>注意, 目标对象自身的不可配置（configurable）的属性, 不能被<code>deleteProperty</code>方法删除, 否则报错 </p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923172813525.png" alt="image-20210923172813525"> </p></blockquote><h4 id="⑦-defineProperty"><a href="#⑦-defineProperty" class="headerlink" title="⑦ defineProperty()"></a>⑦ defineProperty()</h4><blockquote><p><code>defineProperty()</code>方法拦截了  [ Object.defineProperty() ] 操作。</p><p><strong>Object.defineProperty() 方法</strong>: 会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回此对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> defineProperty (target, key, descriptor) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span> ;</span><br><span class="line">&gt;proxy.<span class="property">age</span> = <span class="number">99</span> ;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy)</span><br></pre></td></tr></table></figure><p>实际上,你只要使用了  <strong>defineProperty</strong> 方法拦截了,就会导致添加新属性失败,(返回的 布尔值 其实只是用来提示的,与是否能添加新属性无关)</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923174252622.png" alt="image-20210923174252622"> </p><p>注意, 如果目标对象不可扩展（non-extensible）, 则<code>defineProperty()</code>不能增加目标对象上不存在的属性, 否则会报错。另外, 如果目标对象的某个属性不可写（writable）或不可配置（configurable）, 则<code>defineProperty()</code>方法不得改变这两个设置。</p></blockquote><h4 id="⑧-getOwnPropertyDescriptor"><a href="#⑧-getOwnPropertyDescriptor" class="headerlink" title="⑧ getOwnPropertyDescriptor()"></a>⑧ getOwnPropertyDescriptor()</h4><blockquote><p><code>getOwnPropertyDescriptor()</code>方法拦截  [ Object.getOwnPropertyDescriptor() ] , 返回一个属性描述对象或者<code>undefined</code>。</p><p><strong>Object.getOwnPropertyDescriptor() 方法</strong>: 返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性, 不需要从原型链上进行查找的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">   <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>)  <span class="keyword">return</span>; <span class="comment">//如果为私有属性,则返回undefined</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key); <span class="comment">//不是私有属性就正常返回</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> target = &#123; <span class="attr">_name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;sex&#x27;</span>)) <span class="comment">//对象本身就没这个属性,所以返回 undefined</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;_name&#x27;</span>))<span class="comment">//私有属性,被拦截,所以得到    undefined</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;age&#x27;</span>))  <span class="comment">//对象本身有此属性且不是私有属性,正常返回  &#123;value: 18, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923174907011.png" alt="image-20210923174907011"> </p></blockquote><h4 id="⑨-getPrototypeOf"><a href="#⑨-getPrototypeOf" class="headerlink" title="⑨ getPrototypeOf()"></a>⑨ getPrototypeOf()</h4><blockquote><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说, 拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul></blockquote><h5 id="a-举个栗子-4"><a href="#a-举个栗子-4" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> proto; &#125; <span class="comment">//拦截:不论如何都返回空对象</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>, 返回<code>proto</code>对象。</p><p>注意, <code>getPrototypeOf()</code>方法的返回值必须是 <strong>对象或者null</strong>, 否则报错。另外, 如果目标对象不可扩展（non-extensible）,  <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象</p></blockquote><h4 id="⑩-isExtensible"><a href="#⑩-isExtensible" class="headerlink" title="⑩ isExtensible()"></a>⑩ isExtensible()</h4><blockquote><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p><p><strong>Object.isExtensible() 方法:</strong> 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拦截:全部变为可拓展&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line">&gt;<span class="comment">//拦截:全部变为可拓展</span></span><br><span class="line">&gt;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了<code>isExtensible()</code>方法, 在调用<code>Object.isExtensible</code> 时会打印字符串 [拦截:全部变为可拓展]。</p><p>注意, 该方法只能返回布尔值, 否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制, 它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致, 否则就会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy) === <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(target)</span><br></pre></td></tr></table></figure></blockquote><h5 id="a-举个栗子-5"><a href="#a-举个栗子-5" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210923180130237.png" alt="image-20210923180130237"> </p><p>这边就是本身可拓展,却设置为false, 所以报错.具体使用场景比较特殊,就不列举了</p></blockquote><h4 id="⑩①-ownKeys"><a href="#⑩①-ownKeys" class="headerlink" title="⑩① ownKeys()"></a>⑩① ownKeys()</h4><blockquote><p>[ownKeys()] 方法用来拦截对象自身属性的读取操作。具体来说, 拦截以下操作。</p><ul><li>[Object.getOwnPropertyNames()] </li><li><code>Object.getOwnPropertySymbols()</code></li><li>[Object.keys()] </li><li><code>for...in</code>循环</li></ul></blockquote><h5 id="a-举个-拦截-Object-keys-的栗子"><a href="#a-举个-拦截-Object-keys-的栗子" class="headerlink" title="a) 举个 拦截 [Object.keys()]  的栗子"></a>a) 举个 拦截 [Object.keys()]  的栗子</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> target = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">cm</span>: <span class="number">180</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>] &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) <span class="comment">//name</span></span><br></pre></td></tr></table></figure><p>上面代码拦截了对于<code>target</code>对象的 [Object.keys()] 操作, 只返回 [ name ] 、[ age ]、[ cm ] 三个属性之中的 [ age ] 属性。</p></blockquote><h5 id="b-举个-拦截-Object-keys-中第一个字符为下划线的属性名-的栗子"><a href="#b-举个-拦截-Object-keys-中第一个字符为下划线的属性名-的栗子" class="headerlink" title="b) 举个 拦截 [Object.keys()] 中第一个字符为下划线的属性名 的栗子"></a>b) 举个 拦截 [Object.keys()] 中第一个字符为下划线的属性名 的栗子</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> target = &#123;</span><br><span class="line"> <span class="attr">_name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">_age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> ownKeys (target) &#123;</span><br><span class="line">    <span class="comment">//筛选不是以下划线开头的属性名(私有属性)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(target[key]);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 只输出 18</span></span><br></pre></td></tr></table></figure><p>[Object.keys()] 本来应是都能输出,但是经过拦截后,开头为下划线的属性被过滤不进行输出,就纸打印了 18</p></blockquote><h5 id="c-使用-Object-keys-方法时-有三类属性会被-ownKeys-方法自动过滤"><a href="#c-使用-Object-keys-方法时-有三类属性会被-ownKeys-方法自动过滤" class="headerlink" title="c) 使用 [Object.keys()] 方法时, 有三类属性会被 [ownKeys()] 方法自动过滤"></a>c) 使用 [Object.keys()] 方法时, 有三类属性会被 [ownKeys()] 方法自动过滤</h5><blockquote><p>注意, 使用 [Object.keys()] 方法时, 有三类属性会被 [ownKeys()] 方法自动过滤, 不会返回。</p><ul><li>目标对象上不存在的属性</li><li>属性名为 Symbol 值</li><li>不可遍历（<code>enumerable</code>）的属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//1. 定义原对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> target = &#123; </span><br><span class="line"> <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//2. 定义 不可遍历（`enumerable`）的属性 对照组数据</span></span><br><span class="line">&gt;<span class="comment">//Object.defineProperty() 方法会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回此对象。</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">//当且仅当该属性的 enumerable 键值为 true 时, 该属性才会出现在对象的枚举属性中。</span></span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;这是测试不可遍历属性&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;test&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">true</span>, </span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;出现在枚举中&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//3. 定义拦截</span></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;name&#x27;</span>), <span class="string">&#x27;key&#x27;</span> , <span class="string">&#x27;test&#x27;</span>]; &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy) <span class="comment">//[&#x27;a&#x27;, &#x27;test&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中,  [ownKeys()] 方法之中, 显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>）, 结果都被自动过滤掉。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924155428555.png" alt="image-20210924155428555"> </p></blockquote><h5 id="d-ownKeys-方法还可以拦截-Object-getOwnPropertyNames"><a href="#d-ownKeys-方法还可以拦截-Object-getOwnPropertyNames" class="headerlink" title="d)  [ownKeys()] 方法还可以拦截 [Object.getOwnPropertyNames()]"></a>d)  [ownKeys()] 方法还可以拦截 [Object.getOwnPropertyNames()]</h5><blockquote><p><strong>Object.getOwnPropertyNames():</strong> 方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line">&gt;<span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="e-for-in循环也受到-ownKeys-方法的拦截。"><a href="#e-for-in循环也受到-ownKeys-方法的拦截。" class="headerlink" title="e) for...in循环也受到 [ownKeys()] 方法的拦截。"></a>e) <code>for...in</code>循环也受到 [ownKeys()] 方法的拦截。</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 没有任何输出</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,  [ownKeys()] 指定只返回<code>a</code>和<code>b</code>属性, 由于<code>obj</code>没有这两个属性, 因此<code>for...in</code>循环不会有任何输出。</p></blockquote><h5 id="f-ownKeys-方法返回的数组成员-只能是字符串或-Symbol-值"><a href="#f-ownKeys-方法返回的数组成员-只能是字符串或-Symbol-值" class="headerlink" title="f)  [ownKeys()] 方法返回的数组成员, 只能是字符串或 Symbol 值"></a>f)  [ownKeys()] 方法返回的数组成员, 只能是字符串或 Symbol 值</h5><blockquote><p>[ownKeys()] 方法返回的数组成员, 只能是字符串或 Symbol 值。如果有其他类型的值, 或者返回的根本不是数组, 就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 报错</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,  [ownKeys()] 方法虽然返回一个数组, 但是每一个数组成员都不是字符串或 Symbol 值, 因此就报错了。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924160251672.png" alt="image-20210924160251672"> </p></blockquote><h5 id="g-如果目标对象自身包含不可配置的属性-则该属性必须被-ownKeys-方法返回-否则报错"><a href="#g-如果目标对象自身包含不可配置的属性-则该属性必须被-ownKeys-方法返回-否则报错" class="headerlink" title="g) 如果目标对象自身包含不可配置的属性, 则该属性必须被 [ownKeys()] 方法返回, 否则报错"></a>g) 如果目标对象自身包含不可配置的属性, 则该属性必须被 [ownKeys()] 方法返回, 否则报错</h5><blockquote><p>如果目标对象自身包含不可配置的属性, 则该属性必须被 [ownKeys()] 方法返回, 否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">configurable</span>: <span class="literal">false</span>, <span class="comment">//当且仅当该属性的 configurable 键值为 true 时, 该属性的描述符才能够被改变, 同时该属性也能从对应的对象上被删除。</span></span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="attr">value</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;</span><br><span class="line">&gt;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> getName = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>]  &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> getB = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> [<span class="string">&#x27;b&#x27;</span>]  &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//前面说过,也能拦截此方法</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(getName)) <span class="comment">// [&#x27;name&#x27;]</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(getB))    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>obj</code>对象的<code>name</code>属性是不可配置的, 这时 [ownKeys()] 方法返回的数组之中, 必须包含<code>name</code>, 否则会报错</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924160738101.png" alt="image-20210924160738101"> </p></blockquote><h5 id="h-如果目标对象是不可扩展的（non-extensible）-这时-ownKeys-方法返回的数组之中-必须包含原对象的所有属性-且不能包含多余的属性-否则报错"><a href="#h-如果目标对象是不可扩展的（non-extensible）-这时-ownKeys-方法返回的数组之中-必须包含原对象的所有属性-且不能包含多余的属性-否则报错" class="headerlink" title="h) 如果目标对象是不可扩展的（non-extensible）, 这时 [ownKeys()] 方法返回的数组之中, 必须包含原对象的所有属性, 且不能包含多余的属性, 否则报错"></a>h) 如果目标对象是不可扩展的（non-extensible）, 这时 [ownKeys()] 方法返回的数组之中, 必须包含原对象的所有属性, 且不能包含多余的属性, 否则报错</h5><blockquote><p>另外, 如果目标对象是不可扩展的（non-extensible）, 这时 [ownKeys()] 方法返回的数组之中, 必须包含原对象的所有属性, 且不能包含多余的属性, 否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">name</span>:<span class="string">&quot;努力学习的汪&quot;</span> &#125;;</span><br><span class="line">&gt;<span class="comment">//Object.preventExtensions()方法让一个对象变的不可扩展, 也就是永远不能再添加新的属性。</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj); <span class="comment">//不可拓展</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123; <span class="keyword">return</span> [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>] &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line">&gt;<span class="comment">//报错 Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap returned extra keys but proxy target is non-extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>obj</code>对象是不可扩展的, 这时 [ownKeys()] 方法返回的数组之中, 包含了<code>obj</code>对象的多余属性<code>b</code>, 所以导致了报错。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924161052315.png" alt="image-20210924161052315"> </p></blockquote><h4 id="⑩②-preventExtensions"><a href="#⑩②-preventExtensions" class="headerlink" title="⑩② preventExtensions()"></a>⑩② preventExtensions()</h4><blockquote><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值, 否则会被自动转为布尔值。</p><p><strong>Object.preventExtensions()方法:</strong> 让一个对象变的不可扩展, 也就是永远不能再添加新的属性。</p></blockquote><h5 id="a-限制"><a href="#a-限制" class="headerlink" title="a) 限制"></a>a) 限制</h5><blockquote><p>这个方法有一个限制, 只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>）, <code>proxy.preventExtensions</code>才能返回<code>true</code>, 否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;  <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line">&gt;<span class="comment">//VM2320:4 Uncaught TypeError: &#x27;preventExtensions&#x27; on proxy: trap returned truish but the proxy target is extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>proxy.preventExtensions()</code>方法返回<code>true</code>, 但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>, 因此报错。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924161839936.png" alt="image-20210924161839936"> </p></blockquote><h5 id="b-解决"><a href="#b-解决" class="headerlink" title="b) 解决"></a>b) 解决</h5><blockquote><p>为了防止出现这个问题, 通常要在<code>proxy.preventExtensions()</code>方法里面, 调用一次<code>Object.preventExtensions()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;回调&#x27;</span>);</span><br><span class="line">   <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line">&gt;<span class="comment">// &quot;called&quot;</span></span><br><span class="line">&gt;<span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924161941463.png" alt="image-20210924161941463"> </p></blockquote><h4 id="⑩③-setPrototypeOf"><a href="#⑩③-setPrototypeOf" class="headerlink" title="⑩③ setPrototypeOf()"></a>⑩③ setPrototypeOf()</h4><blockquote><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p><p><strong>Object.setPrototypeOf()</strong> 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> handler = &#123;</span><br><span class="line"> setPrototypeOf (target, proto) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;禁止更改原型&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, proto);</span><br><span class="line">&gt;<span class="comment">// Error: 禁止更改原型</span></span><br></pre></td></tr></table></figure><p>上面代码中, 只要修改<code>target</code>的原型对象, 就会报错。</p><p>注意, 该方法只能返回布尔值, 否则会被自动转为布尔值。另外, 如果目标对象不可扩展（non-extensible）, <code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p></blockquote><h3 id="Ⅳ-Proxy-revocable-可取消的Proxy实例"><a href="#Ⅳ-Proxy-revocable-可取消的Proxy实例" class="headerlink" title="Ⅳ  - Proxy.revocable() 可取消的Proxy实例"></a>Ⅳ  - Proxy.revocable() 可取消的Proxy实例</h3><blockquote><p>Proxy.revocable()&#96;方法返回一个可取消的 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;proxy.<span class="property">name</span> <span class="comment">// 努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">revoke</span>();</span><br><span class="line">&gt;proxy.<span class="property">name</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable()</code>方法返回一个对象, 该对象的<code>proxy</code>属性是 [ Proxy ] 实例, <code>revoke</code>属性是一个函数, 可以取消 [ Proxy ] 实例。上面代码中, 当执行<code>revoke</code>函数之后, 再访问 [ Proxy ] 实例, 就会抛出一个错误。</p><p><code>Proxy.revocable()</code>的一个使用场景是, 目标对象不允许直接访问, 必须通过代理访问, 一旦访问结束, 就收回代理权, 不允许再次访问。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924174228432.png" alt="image-20210924174228432"> </p></blockquote><h3 id="Ⅴ-this-问题"><a href="#Ⅴ-this-问题" class="headerlink" title="Ⅴ - this 问题"></a>Ⅴ - this 问题</h3><blockquote><p>虽然 Proxy 可以代理针对目标对象的访问, 但它不是目标对象的透明代理, 即不做任何拦截的情况下, 也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下, 目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = &#123;</span><br><span class="line"> <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy); <span class="comment">//打印this执行是否指向 proxy</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;target.<span class="title function_">m</span>() <span class="comment">// false</span></span><br><span class="line">&gt;proxy.<span class="title function_">m</span>()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, 一旦<code>proxy</code>代理<code>target</code>, <code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>, 而不是<code>target</code>。</p></blockquote><h4 id="①-举个栗子-1"><a href="#①-举个栗子-1" class="headerlink" title="① 举个栗子"></a>① 举个栗子</h4><blockquote><p>下面是一个例子, 由于<code>this</code>指向的变化, 导致 Proxy 无法代理目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">name</span>) &#123; _name.<span class="title function_">set</span>(<span class="variable language_">this</span>, name) &#125;</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">name</span>() &#123; <span class="keyword">return</span> _name.<span class="title function_">get</span>(<span class="variable language_">this</span>) &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> hong = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(hong.<span class="property">name</span> ) <span class="comment">//努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(hong, &#123;&#125;);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span> ) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 目标对象<code>hong</code>的<code>name</code>属性, 实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面, 通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时, <code>this</code>指向<code>proxy</code>, 导致无法取到值, 所以返回<code>undefined</code>。</p></blockquote><h4 id="②-无法某些原生对象的内部属性"><a href="#②-无法某些原生对象的内部属性" class="headerlink" title="② 无法某些原生对象的内部属性"></a>② 无法某些原生对象的内部属性</h4><blockquote><p>有些原生对象的内部属性, 只有通过正确的<code>this</code>才能拿到, 所以 Proxy 也无法代理这些原生对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="title function_">getDate</span>();</span><br><span class="line">&gt;<span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到, 如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时, <code>this</code>绑定原始对象, 就可以解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2021-11-11&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (prop === <span class="string">&#x27;getDate&#x27;</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> target.<span class="property">getDate</span>.<span class="title function_">bind</span>(target);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="title function_">getDate</span>() <span class="comment">//11</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Proxy-拦截函数内部的this-指向的是handler对象。"><a href="#③-Proxy-拦截函数内部的this-指向的是handler对象。" class="headerlink" title="③ Proxy 拦截函数内部的this, 指向的是handler对象。"></a>③ Proxy 拦截函数内部的<code>this</code>, 指向的是<code>handler</code>对象。</h4><blockquote><p>Proxy 拦截函数内部的<code>this</code>, 指向的是<code>handler</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;此时this === handler:&quot;</span>,<span class="variable language_">this</span> === handler);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">`拦截get: [<span class="subst">$&#123;key&#125;</span>] 属性`</span> ;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;此时this === handler:&quot;</span>,<span class="variable language_">this</span> === handler);</span><br><span class="line">   target[key] = value;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">`拦截set: [<span class="subst">$&#123;key&#125;</span>] 属性`</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">&gt;proxy.<span class="property">name</span></span><br><span class="line">&gt;proxy.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span></span><br></pre></td></tr></table></figure><p>上面例子中, <code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>, 指向的都是<code>handler</code>对象。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924180414812.png" alt="image-20210924180414812"> </p></blockquote><h3 id="Ⅵ-应用-Web-服务的客户端"><a href="#Ⅵ-应用-Web-服务的客户端" class="headerlink" title="Ⅵ - 应用: Web 服务的客户端"></a>Ⅵ - 应用: Web 服务的客户端</h3><blockquote><p>Proxy 对象可以拦截目标对象的任意属性, 这使得它很合适用来写 Web 服务的客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> service = <span class="title function_">createWebService</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>);</span><br><span class="line">&gt;service.<span class="title function_">employees</span>().<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">......</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码新建了一个 Web 服务的接口, 这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性, 所以不用为每一种数据写一个适配方法, 只要写一个 Proxy 拦截就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseUrl</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">   <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">&#x27;/&#x27;</span> + propKey);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p></blockquote><h3 id="Ⅶ-Proxy模拟实现VUE数据双向绑定"><a href="#Ⅶ-Proxy模拟实现VUE数据双向绑定" class="headerlink" title="Ⅶ - Proxy模拟实现VUE数据双向绑定"></a>Ⅶ - Proxy模拟实现VUE数据双向绑定</h3><blockquote><p> [ Proxy ] 就像一个代理器,当有人对目标对象进行处理(set、has、get 等等操作)的时候它会首先经过它, 这时我们可以使用代码进行处理, 此时 [ Proxy ] 相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。</p></blockquote><h4 id="①-Object-defineProperty"><a href="#①-Object-defineProperty" class="headerlink" title="①  [ Object.defineProperty ]"></a>①  [ Object.defineProperty ]</h4><blockquote><p>众所周知, <code>vue</code>使用了 [ Object.defineProperty ] 来做数据劫持, 它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">&gt;<span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get val&#x27;</span>)</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;<span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set val:&#x27;</span> + newVal)</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-与-Object-defineProperty-相比-Proxy-的优势"><a href="#②-与-Object-defineProperty-相比-Proxy-的优势" class="headerlink" title="② 与 [ Object.defineProperty ] 相比,  [ Proxy ] 的优势"></a>② 与 [ Object.defineProperty ] 相比,  [ Proxy ] 的优势</h4><blockquote><ol><li><p>数组作为特殊的对象, 但Object.defineProperty无法监听数组变化。</p></li><li><p>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历, 如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p></li><li><p>Proxy 有多达 13 种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。</p></li><li><p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</p></li><li><p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化</p></li></ol></blockquote><h4 id="③-手写双向绑定代码"><a href="#③-手写双向绑定代码" class="headerlink" title="③ 手写双向绑定代码"></a>③ 手写双向绑定代码</h4><blockquote><ol><li>简单实现双向绑定</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input_el&quot;</span> <span class="attr">oninput</span>=<span class="string">&quot;inputHandle(this)&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show_el&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  proxy_bind = <span class="function">(<span class="params">traget</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(traget, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">get</span>(<span class="params">obj, name</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果传入的key并没有,则赋初始值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (!obj[name]) obj[name] = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//根据传入的key进行相应属性返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//拦截的对象,拦截对象的值,传入要修改的值,(第四个参数通常不用,返回整个Proxy对象)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">set</span>(<span class="params">obj, name, val</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        obj[name] = val</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//将输入狂内容即修改的proxy对象属性渲染到页面节点上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  inputHandle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//将输入框的值赋值给proxy对象的value属性上, 此处触发proxy的`set（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj_bind.<span class="property">value</span> = e.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>: <span class="string">&quot;2&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">b</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">value</span>: <span class="string">&quot;默认值&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj_bind = <span class="title function_">proxy_bind</span>(obj)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//自闭合, 如果前面没有加分号 会导致压缩式合并到前面去就会报错, 以防万一加分号, 此处触发proxy的`get（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#input_el&quot;</span>).<span class="property">value</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>模拟vue实现完整双向绑定实现</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml">class Watcher &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(vm, key, callback) &#123;</span></span><br><span class="line"><span class="language-xml">    this.vm = vm</span></span><br><span class="line"><span class="language-xml">    this.callback = callback</span></span><br><span class="line"><span class="language-xml">    this.key = key // 被订阅的数据</span></span><br><span class="line"><span class="language-xml">    this.val = this.get() // 维护更新之前的数据</span></span><br><span class="line"><span class="language-xml">    vm.$data = this.createProxy(vm.$data)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  update(newVal) &#123;</span></span><br><span class="line"><span class="language-xml">    this.callback(newVal)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  get() &#123;</span></span><br><span class="line"><span class="language-xml">    const val = this.vm.$data[this.key]</span></span><br><span class="line"><span class="language-xml">    return val</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  createProxy(data) &#123;</span></span><br><span class="line"><span class="language-xml">    let _this = this</span></span><br><span class="line"><span class="language-xml">    let handler = &#123;</span></span><br><span class="line"><span class="language-xml">      get(target, property) &#123;</span></span><br><span class="line"><span class="language-xml">        return Reflect.get(target, property)</span></span><br><span class="line"><span class="language-xml">      &#125;,</span></span><br><span class="line"><span class="language-xml">      set(target, property, value) &#123;</span></span><br><span class="line"><span class="language-xml">        let res = null</span></span><br><span class="line"><span class="language-xml">        if (target[property] != value) &#123;</span></span><br><span class="line"><span class="language-xml">          const isOk = Reflect.set(target, property, value)</span></span><br><span class="line"><span class="language-xml">          if (_this.key === property) &#123;</span></span><br><span class="line"><span class="language-xml">            // 同一层级</span></span><br><span class="line"><span class="language-xml">            res = value</span></span><br><span class="line"><span class="language-xml">          &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">            res = _this.get()</span></span><br><span class="line"><span class="language-xml">            console.log(res)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          _this.callback(res)</span></span><br><span class="line"><span class="language-xml">          return isOk</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    return toDeepProxy(data, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    function toDeepProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">      if (!isPureObject(object)) addSubProxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      return new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function addSubProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">        for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">          if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">            if (!isPureObject(object[prop])) addSubProxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">            object[prop] = new Proxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        object = new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function isPureObject(object) &#123;</span></span><br><span class="line"><span class="language-xml">        if (typeof object !== &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">          return false</span></span><br><span class="line"><span class="language-xml">        &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">          for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">            if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">              return false</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        return true</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">class Vue &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(data) &#123;</span></span><br><span class="line"><span class="language-xml">    // 将所有data最外层属性代理到实例上</span></span><br><span class="line"><span class="language-xml">    this.$data = data</span></span><br><span class="line"><span class="language-xml">    Object.keys(data).forEach(key =&gt; this.$proxy(key))</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $watch(key, cb) &#123;</span></span><br><span class="line"><span class="language-xml">    new Watcher(this, key, cb)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $proxy(key) &#123;</span></span><br><span class="line"><span class="language-xml">    Reflect.defineProperty(this, key, &#123; //此处API不懂的可以看下方下个知识点</span></span><br><span class="line"><span class="language-xml">      configurable: true,</span></span><br><span class="line"><span class="language-xml">      enumerable: true,</span></span><br><span class="line"><span class="language-xml">      get: () =&gt; this.$data[key],</span></span><br><span class="line"><span class="language-xml">      set: val =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        this._data[key] = val</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const p = document.getElementById(&#x27;p&#x27;)</span></span><br><span class="line"><span class="language-xml">const input = document.getElementById(&#x27;input&#x27;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const data = new Vue(&#123; text: &#123; a: &#x27;&#x27; &#125; &#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">input.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span></span><br><span class="line"><span class="language-xml">  data.text.a = e.target.value</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">data.$watch(&#x27;text&#x27;, content =&gt; p.innerHTML = content.a)</span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="14、Reflect"><a href="#14、Reflect" class="headerlink" title="14、Reflect"></a>14、Reflect</h2><blockquote><p>在前方我们在描述 [ Proxy ] 知识点时,我们有用到 <strong>Reflect</strong> 这个API</p><p>实际上你可以认为 <strong>Reflect</strong> 就是将 <strong>Object</strong> 上的部分内部方法移到上面,让我们的JS编码更规范、清晰明了</p></blockquote><h3 id="Ⅰ-概述与总结-1"><a href="#Ⅰ-概述与总结-1" class="headerlink" title="Ⅰ - 概述与总结"></a>Ⅰ - 概述与总结</h3><blockquote><p> <strong>Reflect</strong>  对象与 [ Proxy ] 对象一样, 也是 ES6 为了操作对象而提供的新 API。  <strong>Reflect</strong>  对象的设计目的有这样几个。</p><ol><li><p>将<code>Object</code>对象的一些明显属于语言内部的方法（比如 [ Object.defineProperty ] ）, 放到  <strong>Reflect</strong>  对象上。现阶段, 某些方法同时在<code>Object</code>和  <strong>Reflect</strong>  对象上部署, 未来的新方法将只部署在  <strong>Reflect</strong>  对象上。也就是说, 从  <strong>Reflect</strong>  对象上可以拿到语言内部的方法</p></li><li><p>修改某些<code>Object</code>方法的返回结果, 让其变得更合理。比如,  [Object.defineProperty(obj, name, desc)] 在无法定义属性时, 会抛出一个错误, 而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p></li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="comment">// 老写法: 因为会抛出异常错误,所以必须用 try..catch() 去承接错误</span></span><br><span class="line"> &gt;<span class="keyword">try</span> &#123;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"> &gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="comment">// 这里承接抛出的错误</span></span><br><span class="line"> &gt;&#125;</span><br><span class="line"></span><br><span class="line"> &gt;<span class="comment">// 新写法</span></span><br><span class="line"> &gt;<span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"> &gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// failure</span></span><br><span class="line"> &gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式, 比如<code>name in obj</code>和<code>delete obj[name]</code>, 而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 老写法</span></span><br><span class="line">&gt;<span class="string">&#x27;assign&#x27;</span> <span class="keyword">in</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><ol start="4"><li><strong>Reflect</strong> 对象的方法与 [Proxy] 对象的方法一一对应, 只要是 [Proxy] 对象的方法, 就能在 <strong>Reflect</strong> 对象上找到对应的方法。这就让 [Proxy] 对象可以方便地调用对应的 <strong>Reflect</strong> 方法, 完成默认行为, 作为修改行为的基础。也就是说, 不管 [Proxy] 怎么修改默认行为, 你总可以在 <strong>Reflect</strong> 上获取默认行为。</li></ol><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">&gt;<span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, name, value, receiver);</span><br><span class="line">&gt;<span class="keyword">if</span> (success)  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在属性:&#x27;</span> + name + <span class="string">&#x27; 上 &#x27;</span> + target + <span class="string">&#x27; 写入 &#x27;</span> + value);</span><br><span class="line">&gt;<span class="keyword">return</span> success;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, 每一个 [Proxy] 对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>）, 内部都调用对应的 <strong>Reflect</strong> 方法, 保证原生行为能够正常执行。添加的工作, 就是将每一个操作输出一行日志。</p></blockquote><p> 有了 <strong>Reflect</strong> 对象以后, 很多操作会更易读。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="①-设计目的"><a href="#①-设计目的" class="headerlink" title="① 设计目的"></a>① 设计目的</h4><blockquote><ul><li>将<code>Object</code>属于<code>语言内部的方法</code>放到  <strong>Reflect</strong>  上</li><li>将某些Object方法报错情况改成返回<code>false</code></li><li>让<code>Object操作</code>变成<code>函数行为</code></li><li>[ Proxy ] 与  <strong>Reflect</strong>  相辅相成</li></ul></blockquote><h4 id="②废弃方法"><a href="#②废弃方法" class="headerlink" title="②废弃方法"></a>②废弃方法</h4><blockquote><ul><li>[ Object.defineProperty() ]  &#x3D;&gt;   [ Reflect.defineProperty() ] </li><li>[ Object.getOwnPropertyDescriptor() ]  &#x3D;&gt;   [ Reflect.getOwnPropertyDescriptor() ]</li></ul></blockquote><h4 id="③-重点难点"><a href="#③-重点难点" class="headerlink" title="③ 重点难点"></a>③ 重点难点</h4><blockquote><ul><li><code>Proxy方法</code>和<code>Reflect方法</code>一一对应</li><li>[ Proxy ] 和  <strong>Reflect</strong>  联合使用, 前者负责<code>拦截赋值操作</code>, 后者负责<code>完成赋值操作</code></li></ul></blockquote><h4 id="④-方法"><a href="#④-方法" class="headerlink" title="④ 方法"></a>④ 方法</h4><blockquote><p>下面这些方法的作用, 大部分与<code>Object</code>对象的同名方法的作用都是相同的, 而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p><ul><li>**get()**：返回对象属性</li><li>**set()**：设置对象属性, 返回布尔</li><li>**has()**：检查对象属性, 返回布尔</li><li>**deleteProperty()**：删除对象属性, 返回布尔</li><li>**defineProperty()**：定义对象属性, 返回布尔</li><li>**ownKeys()**：遍历对象属性, 返回数组(<code>Object.getOwnPropertyNames()</code>+<code>Object.getOwnPropertySymbols()</code>)</li><li>**getOwnPropertyDescriptor()**：返回对象属性描述, 返回对象</li><li>**getPrototypeOf()**：返回对象原型, 返回对象</li><li>**setPrototypeOf()**：设置对象原型, 返回布尔</li><li>**isExtensible()**：返回对象是否可扩展, 返回布尔</li><li>**preventExtensions()**：设置对象不可扩展, 返回布尔</li><li>**apply()**：绑定this后执行指定函数</li><li>**construct()**：调用构造函数创建实例</li></ul><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926095039091.png" alt="image-20210926095039091"> </p></blockquote><h4 id="⑤-数据绑定：观察者模式"><a href="#⑤-数据绑定：观察者模式" class="headerlink" title="⑤ 数据绑定：观察者模式"></a>⑤ 数据绑定：观察者模式</h4><blockquote><p>[ Proxy ] 和  <strong>Reflect</strong>  联合使用, 前者负责<code>拦截赋值操作</code>, 后者负责<code>完成赋值操作</code>, 相辅相成,下面举个栗子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> observerQueue = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; observerQueue.<span class="title function_">add</span>(fn);</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">tgt, key, val, receiver</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(tgt, key, val, receiver);</span><br><span class="line">       observerQueue.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">v</span>());</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123; <span class="attr">age</span>: <span class="number">66</span>, <span class="attr">name</span>: <span class="string">&quot;hongjilin&quot;</span> &#125;);</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">print</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> is <span class="subst">$&#123;person.age&#125;</span> years old`</span>); </span><br><span class="line">&gt;<span class="title function_">observe</span>(print); <span class="comment">//进行监听</span></span><br><span class="line"></span><br><span class="line">&gt;person.<span class="property">name</span> = <span class="string">&quot;努力学习的汪&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210924194108853.png" alt="image-20210924194108853"> </p></blockquote><h3 id="Ⅱ-方法详解"><a href="#Ⅱ-方法详解" class="headerlink" title="Ⅱ - 方法详解"></a>Ⅱ - 方法详解</h3><h4 id="①-Reflect-get-target-name-receiver"><a href="#①-Reflect-get-target-name-receiver" class="headerlink" title="① Reflect.get(target, name, receiver)"></a>① Reflect.get(target, name, receiver)</h4><blockquote><p>[ Reflect.get ] 方法查找并返回<code>target</code>对象的<code>name</code>属性, 如果没有该属性, 则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">msg</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;现在&quot;</span> +<span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;name&#x27;</span>))<span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;age&#x27;</span>) ) <span class="comment">// 99</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;msg&#x27;</span>))  <span class="comment">// 努力学习的汪现在99岁</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-如果name属性部署了读取函数（getter）-则读取函数的-this-绑定-receiver"><a href="#a-如果name属性部署了读取函数（getter）-则读取函数的-this-绑定-receiver" class="headerlink" title="a) 如果name属性部署了读取函数（getter）, 则读取函数的 this 绑定   [ receiver ]"></a>a) 如果<code>name</code>属性部署了读取函数（getter）, 则读取函数的 <code>this</code> 绑定   [ receiver ]</h5><blockquote><p>如果<code>name</code>属性部署了读取函数（getter）, 则读取函数的<code>this</code>绑定  [ receiver ] </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="keyword">get</span> <span class="title function_">msg</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;现在&quot;</span> +<span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&quot;岁&quot;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> myReceiverObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;msg&#x27;</span>, myReceiverObject) <span class="comment">//&#x27;hongjilin现在18岁&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-如果第一个参数不是对象-Reflect-get-方法会报错。"><a href="#b-如果第一个参数不是对象-Reflect-get-方法会报错。" class="headerlink" title="b) 如果第一个参数不是对象,  [ Reflect.get ] 方法会报错。"></a>b) 如果第一个参数不是对象,  [ Reflect.get ] 方法会报错。</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="literal">false</span>, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Reflect-set-target-name-value-receiver"><a href="#②-Reflect-set-target-name-value-receiver" class="headerlink" title="② Reflect.set(target, name, value, receiver)"></a>② Reflect.set(target, name, value, receiver)</h4><h5 id="a-Reflect-set方法设置target对象的name属性等于value"><a href="#a-Reflect-set方法设置target对象的name属性等于value" class="headerlink" title="a) Reflect.set方法设置target对象的name属性等于value"></a>a) <code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code></h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">setName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> = value;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// hongjilin</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// 努力学习的汪</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;setName&#x27;</span>,<span class="string">&#x27;调用setName写入名字&#x27;</span>)</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// 调用setName写入名字</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-如果name属性设置了赋值函数-则赋值函数的this绑定-receiver-。"><a href="#b-如果name属性设置了赋值函数-则赋值函数的this绑定-receiver-。" class="headerlink" title="b) 如果name属性设置了赋值函数, 则赋值函数的this绑定  [ receiver ] 。"></a>b) 如果<code>name</code>属性设置了赋值函数, 则赋值函数的<code>this</code>绑定  [ receiver ] 。</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="keyword">set</span> <span class="title function_">setName</span>(<span class="params">value</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> = value;</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> myReceiverObject = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;这是 myReceiverObject 的 name&#x27;</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, myReceiverObject);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myObject.<span class="property">name</span>) <span class="comment">// hongjilin</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(myReceiverObject.<span class="property">name</span>) <span class="comment">// 努力学习的汪  </span></span><br></pre></td></tr></table></figure><p>可以看到 [ <strong>myReceiverObject</strong> ] 被修改了</p></blockquote><h5 id="c-如果-Proxy对象和-Reflect对象联合使用注意事项"><a href="#c-如果-Proxy对象和-Reflect对象联合使用注意事项" class="headerlink" title="c) 如果 Proxy对象和 Reflect对象联合使用注意事项"></a>c) 如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用注意事项</h5><blockquote><p>注意, 如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用, 前者拦截赋值操作, 后者完成赋值的默认行为, 而且传入了  [ receiver ] , 那么<code>Reflect.set</code>会触发  [ Proxy.defineProperty ] 拦截。</p><blockquote><p>知识点回顾:</p><ul><li><strong>handler.defineProperty()</strong> : 用于拦截对对象的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a> 操作</li><li><strong>Object.defineProperty()</strong> : 会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回此对象。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拦截 set 操作&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 defineProperty&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">&gt;obj.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 拦截 set 操作</span></span><br><span class="line">&gt;<span class="comment">// 触发 defineProperty</span></span><br></pre></td></tr></table></figure><p>上面代码中,  <strong>Proxy.set</strong> 拦截里面使用了<code>Reflect.set</code>, 而且传入了  [ receiver ] , 导致触发  [ Proxy.defineProperty ] 拦截。</p><blockquote><ul><li>这是因为 <strong>Proxy.set</strong> 的  [ receiver ] 参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>）</li><li>而<code>Reflect.set</code>一旦传入  [ receiver ] , 就会将属性赋值到  [ receiver ] 上面(即<code>obj</code>), 导致触发<code>defineProperty</code>拦截</li><li>如果<code>Reflect.set</code>没有传入  [ receiver ] , 那么就不会触发<code>defineProperty</code>拦截。</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> handler = &#123;</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拦截 set 操作&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value) <span class="comment">// 差异:此处没有传入receiver</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发 defineProperty&#x27;</span>);</span><br><span class="line">   <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">&gt;obj.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 拦截 set 操作 --&gt;不会触发 defineProperty</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="d-如果第一个参数不是对象-Reflect-get-方法会报错。"><a href="#d-如果第一个参数不是对象-Reflect-get-方法会报错。" class="headerlink" title="d) 如果第一个参数不是对象,  [ Reflect.get ] 方法会报错。"></a>d) 如果第一个参数不是对象,  [ Reflect.get ] 方法会报错。</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>,&#123;&#125;) <span class="comment">// 报错 </span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="literal">false</span>, <span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;xx&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="comment">//Uncaught TypeError: Reflect.set called on non-object</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-Reflect-has-obj-name"><a href="#③-Reflect-has-obj-name" class="headerlink" title="③ Reflect.has(obj, name)"></a>③ Reflect.has(obj, name)</h4><blockquote><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123; <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> myObject <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">has</span>(myObject, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象, 会报错。</p></blockquote><h4 id="④-Reflect-deleteProperty-obj-name"><a href="#④-Reflect-deleteProperty-obj-name" class="headerlink" title="④ Reflect.deleteProperty(obj, name)"></a>④ Reflect.deleteProperty(obj, name)</h4><blockquote><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>, 用于删除对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObj = &#123; <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="keyword">delete</span> myObj.<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(myObj, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该方法返回一个布尔值。如果删除成功, 或者被删除的属性不存在, 返回<code>true</code>；删除失败, 被删除的属性依然存在, 返回<code>false</code>。</p><p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象, 会报错。</p></blockquote><h4 id="⑤-Reflect-construct-target-args"><a href="#⑤-Reflect-construct-target-args" class="headerlink" title="⑤ Reflect.construct(target, args)"></a>⑤ Reflect.construct(target, args)</h4><blockquote><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>, 这提供了一种不使用<code>new</code>, 来调用构造函数的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// new 的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Greeting</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Reflect.construct 的写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> instance = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Greeting</span>, [<span class="string">&#x27;努力学习的汪&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数, 会报错。</p></blockquote><h4 id="⑥-Reflect-getPrototypeOf-obj"><a href="#⑥-Reflect-getPrototypeOf-obj" class="headerlink" title="⑥ Reflect.getPrototypeOf(obj)"></a>⑥ Reflect.getPrototypeOf(obj)</h4><blockquote><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性, 对应<code>Object.getPrototypeOf(obj)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObj = <span class="keyword">new</span> <span class="title class_">FancyThing</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是, 如果参数不是对象, <code>Object.getPrototypeOf</code>会将这个参数转为对象, 然后再运行, 而<code>Reflect.getPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑦-Reflect-setPrototypeOf-obj-newProto"><a href="#⑦-Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="⑦ Reflect.setPrototypeOf(obj, newProto)"></a>⑦ Reflect.setPrototypeOf(obj, newProto)</h4><blockquote><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype）, 对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值, 表示是否设置成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">&gt;myObj.<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-如果无法设置目标对象的原型时"><a href="#a-如果无法设置目标对象的原型时" class="headerlink" title="a) 如果无法设置目标对象的原型时"></a>a) 如果无法设置目标对象的原型时</h5><blockquote><p>如果无法设置目标对象的原型（比如, 目标对象禁止扩展）, <code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;), <span class="literal">null</span>)</span><br><span class="line">&gt;<span class="comment">// false</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-第一个参数不是对象时"><a href="#b-第一个参数不是对象时" class="headerlink" title="b) 第一个参数不是对象时"></a>b) 第一个参数不是对象时</h5><blockquote><p>如果第一个参数不是对象, <code>Object.setPrototypeOf</code>会返回第一个参数本身, 而<code>Reflect.setPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-如果第一个参数是undefined或null时"><a href="#c-如果第一个参数是undefined或null时" class="headerlink" title="c) 如果第一个参数是undefined或null时"></a>c) 如果第一个参数是<code>undefined</code>或<code>null</code>时</h5><blockquote><p>如果第一个参数是<code>undefined</code>或<code>null</code>, <code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line">&gt;<span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑧-Reflect-apply-func-thisArg-args"><a href="#⑧-Reflect-apply-func-thisArg-args" class="headerlink" title="⑧ Reflect.apply(func, thisArg, args)"></a>⑧ Reflect.apply(func, thisArg, args)</h4><blockquote><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>, 用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说, 如果要绑定一个函数的<code>this</code>对象, 可以这样写<code>fn.apply(obj, args)</code>, 但是如果函数定义了自己的<code>apply</code>方法, 就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>, 采用<code>Reflect</code>对象可以简化这种操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> youngest = <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> oldest = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(youngest);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="keyword">const</span> youngest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">min</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> oldest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">max</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line">&gt;<span class="keyword">const</span> type = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>, youngest, []);</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑨-Reflect-defineProperty-target-propertyKey-attributes"><a href="#⑨-Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="⑨ Reflect.defineProperty(target, propertyKey, attributes)"></a>⑨ Reflect.defineProperty(target, propertyKey, attributes)</h4><blockquote><p> [ Reflect.defineProperty ] 方法基本等同于<code>Object.defineProperty</code>, 用来为对象定义属性。未来, 后者会被逐渐废除, 请从现在开始就使用  [ Reflect.defineProperty ] 代替它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">MyDate</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>如果  [ Reflect.defineProperty ] 的第一个参数不是对象, 就会抛出错误, 比如<code>Reflect.defineProperty(18, &#39;age&#39;)</code></p></blockquote><h5 id="a-可以与-Proxy-defineProperty-配合使用"><a href="#a-可以与-Proxy-defineProperty-配合使用" class="headerlink" title="a) 可以与  [ Proxy.defineProperty ] 配合使用"></a>a) 可以与  [ Proxy.defineProperty ] 配合使用</h5><blockquote><p>这个方法可以与  [ Proxy.defineProperty ] 配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"> <span class="title function_">defineProperty</span>(<span class="params">target, prop, descriptor</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor); <span class="comment">//此处拦截后 进行一次打印</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, prop, descriptor);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;<span class="comment">// &#123;value: &#x27;努力学习的汪&#x27;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line">&gt;p.<span class="property">name</span> <span class="comment">// &#x27;努力学习的汪&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中,   [ Proxy.defineProperty ] 对属性赋值设置了拦截, 然后使用  [ Reflect.defineProperty ] 完成了赋值,这样就能不影响原来赋值效果的同时还能进行拦截处理</p></blockquote><h4 id="⑩-Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#⑩-Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="⑩ Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>⑩ Reflect.getOwnPropertyDescriptor(target, propertyKey)</h4><blockquote><p> [ Reflect.getOwnPropertyDescriptor ] 基本等同于  [ Object.getOwnPropertyDescriptor ] , 用于得到指定属性的描述对象, 将来会替代掉后者。</p><blockquote><p><strong>Object.getOwnPropertyDescriptor()方法</strong>: 返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性, 不需要从原型链上进行查找的属性）</p><p><strong>Object.defineProperty()</strong> 方法会直接在一个对象上定义一个新属性, 或者修改一个对象的现有属性, 并返回此对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myObject, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="literal">true</span>, <span class="comment">//该属性对应的值。可以是任何有效的 JavaScript 值（数值, 对象, 函数等）。</span></span><br><span class="line"> <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="comment">//当且仅当该属性的 enumerable 键值为 true 时, 该属性才会出现在对象的枚举属性中。</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> theDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="keyword">var</span> theDescriptor1 = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p> [ Reflect.getOwnPropertyDescriptor ] 和  [ Object.getOwnPropertyDescriptor ] 的一个区别是, 如果第一个参数不是对象</p><ul><li>[ Object.getOwnPropertyDescriptor(99, ‘age’) ]不报错, 返回<code>undefined</code></li><li>而 [ Reflect.getOwnPropertyDescriptor(99, ‘age’) ] 会抛出错误, 表示参数非法。</li></ul></blockquote><h4 id="⑩①-Reflect-isExtensible-target"><a href="#⑩①-Reflect-isExtensible-target" class="headerlink" title="⑩① Reflect.isExtensible (target)"></a>⑩① Reflect.isExtensible (target)</h4><blockquote><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>, 返回一个布尔值, 表示当前对象是否可扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象, <code>Object.isExtensible</code>会返回<code>false</code>, 因为非对象本来就是不可扩展的, 而<code>Reflect.isExtensible</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑩②-Reflect-preventExtensions-target"><a href="#⑩②-Reflect-preventExtensions-target" class="headerlink" title="⑩② Reflect.preventExtensions(target)"></a>⑩② Reflect.preventExtensions(target)</h4><blockquote><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法, 用于让一个对象变为不可扩展。它返回一个布尔值, 表示是否操作成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象, <code>Object.preventExtensions</code>在 ES5 环境报错, 在 ES6 环境返回传入的参数, 而<code>Reflect.preventExtensions</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5 环境</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6 环境</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑩③-Reflect-ownKeys-target"><a href="#⑩③-Reflect-ownKeys-target" class="headerlink" title="⑩③ Reflect.ownKeys (target"></a>⑩③ Reflect.ownKeys (target</h4><blockquote><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性, 基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> myObject = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;baz&#x27;</span>)]: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bing&#x27;</span>)]: <span class="number">4</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 旧写法</span></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(myObject)</span><br><span class="line">&gt;<span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(myObject)</span><br><span class="line">&gt;<span class="comment">//[Symbol(baz), Symbol(bing)]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新写法</span></span><br><span class="line">&gt;<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(myObject)</span><br><span class="line">&gt;<span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, Symbol(baz), Symbol(bing)]</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象, 会报错。</p></blockquote><h3 id="Ⅲ-应用-配合-Proxy-实现观察者模式"><a href="#Ⅲ-应用-配合-Proxy-实现观察者模式" class="headerlink" title="Ⅲ - 应用: 配合 Proxy 实现观察者模式"></a>Ⅲ - 应用: 配合 Proxy 实现观察者模式</h3><blockquote><p>实际上与上方[ Proxy ] 模拟实现Vue数据双向绑定一样,这里按照 阮一峰ES6 教程中的示例代码  实现</p><p>观察者模式（Observer mode）指的是函数自动观察数据对象, 一旦对象有变化, 函数就会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;hongjilin&#x27;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span> 今年 <span class="subst">$&#123;person.age&#125;</span> 岁了`</span>) &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">observe</span>(print); <span class="comment">//监听  这个方法定义实现放在下方</span></span><br><span class="line">&gt;person.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;person.<span class="property">age</span> = <span class="number">99</span>;</span><br></pre></td></tr></table></figure><p>上面代码中, 数据对象<code>person</code>是观察目标, 函数<code>print</code>是观察者。一旦数据对象发生变化, <code>print</code>就会自动执行。</p><p>下面, 使用 Proxy 写一个观察者模式的最简单实现, 即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理, 拦截赋值操作, 触发充当观察者的各个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line"> queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 先定义了一个<code>Set</code>集合, 所有观察者函数都放进这个集合。然后, <code>observable</code>函数返回原始对象的代理, 拦截赋值操作。拦截函数<code>set</code>之中, 会自动执行所有观察者。</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926165622747.png" alt="image-20210926165622747"> </p></blockquote><h2 id="15、Iterator-和-for…of-循环"><a href="#15、Iterator-和-for…of-循环" class="headerlink" title="15、Iterator 和 for…of 循环"></a>15、Iterator 和 for…of 循环</h2><blockquote><p>这个知识点就属于,貌似你不学也不影响基本编程开发的类型,但当你编程开发了一段时间后这东西似乎又无处不在地存在于我们 JavaScript 的每个部分</p><p>起码在我初学前端时这部分是直接跳过不学的,也是到现在才回头来补充学习,</p></blockquote><h3 id="Ⅰ-概述与总结-2"><a href="#Ⅰ-概述与总结-2" class="headerlink" title="Ⅰ- 概述与总结"></a>Ⅰ- 概述与总结</h3><blockquote><ol><li>定义：为各种不同的数据结构提供统一的访问机制</li><li>原理：创建一个指针指向首个成员, 按照次序使用<code>next()</code>指向下一个成员, 直接到结束位置(数据结构只要部署<code>Iterator接口</code>就可完成遍历操作)</li><li>作用</li></ol><ul><li>为各种数据结构提供一个统一的简便的访问接口</li><li>使得数据结构成员能够按某种次序排列</li><li>ES6创造了新的遍历命令 [ for-of ] , <code>Iterator接口</code>主要供 [ for-of ] 消费</li></ul><ol start="4"><li>形式： [ for-of ] (自动去寻找Iterator接口)</li><li>数据结构</li></ol><ul><li>集合：<code>Array</code>、<code>Object</code>、<code>Set</code>、<code>Map</code></li><li>原生具备接口的数据结构：<code>String</code>、<code>Array</code>、<code>Set</code>、<code>Map</code>、<code>TypedArray</code>、<code>Arguments</code>、<code>NodeList</code></li></ul><ol start="6"><li>部署：默认部署在<code>Symbol.iterator</code>(具备此属性被认为<code>可遍历的iterable</code>)</li><li>遍历器对象</li></ol><ul><li>**next()**：下一步操作, 返回<code>&#123; done, value &#125;</code>(必须部署)</li><li>**return()**： [ for-of ] 提前退出调用, 返回<code>&#123; done: true &#125;</code></li><li>**throw()**：不使用, 配合<code>Generator函数</code>使用</li></ul><blockquote><h6 id="For…Of-循环"><a href="#For…Of-循环" class="headerlink" title="For…Of 循环"></a>For…Of 循环</h6></blockquote><ol><li><p>定义：调用<code>Iterator接口</code>产生遍历器对象( [ for-of ] 内部调用数据结构的<code>Symbol.iterator()</code>)</p></li><li><p>遍历字符串： [ for-in ] 获取<code>索引</code>,  [ for-of ] 获取<code>值</code>(可识别32位UTF-16字符)</p></li><li><p>遍历数组： [ for-in ] 获取<code>索引</code>,  [ for-of ] 获取<code>值</code></p></li><li><p>遍历对象： [ for-in ] 获取<code>键</code>,  [ for-of ] 需自行部署</p></li><li><p>遍历Set： [ for-of ] 获取<code>值</code> &#x3D;&gt; <code>for (const v of set)</code></p></li><li><p>遍历Map： [ for-of ] 获取<code>键值对</code> &#x3D;&gt;  <code>for (const [k, v] of map)</code></p></li><li><p>遍历类数组：<code>包含length的对象</code>、<code>Arguments对象</code>、<code>NodeList对象</code>(无<code>Iterator接口的类数组</code>可用<code>Array.from()</code>转换)</p></li><li><p>计算生成数据结构：<code>Array</code>、<code>Set</code>、<code>Map</code></p></li></ol><blockquote><ul><li>**keys()**：返回遍历器对象, 遍历所有的键</li><li>**values()**：返回遍历器对象, 遍历所有的值</li><li>**entries()**：返回遍历器对象, 遍历所有的键值对</li></ul></blockquote><ol start="9"><li>与 [ for-in ] 区别</li></ol><blockquote><ul><li>有着同 [ for-in ] 一样的简洁语法, 但没有 [ for-in ] 那些缺点、</li><li>不同于<code>forEach()</code>, 它可与<code>break</code>、<code>continue</code>和<code>return</code>配合使用</li><li>提供遍历所有数据结构的统一操作接口</li></ul></blockquote><blockquote><h6 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h6></blockquote><ol><li>改写具有<code>Iterator接口</code>的数据结构的<code>Symbol.iterator</code></li><li>解构赋值：对Set进行解构</li><li>扩展运算符：将部署<code>Iterator接口</code>的数据结构转为数组</li><li>yield*：<code>yield*</code>后跟一个可遍历的数据结构, 会调用其遍历器接口</li><li>接受数组作为参数的函数： [ for-of ] 、<code>Array.from()</code>、<code>new Set()</code>、<code>new WeakSet()</code>、<code>new Map()</code>、<code>new WeakMap()</code>、<code>Promise.all()</code>、<code>Promise.race()</code></li></ol></blockquote><h3 id="Ⅱ-Iterator（遍历器）的概念"><a href="#Ⅱ-Iterator（遍历器）的概念" class="headerlink" title="Ⅱ - Iterator（遍历器）的概念"></a>Ⅱ - Iterator（遍历器）的概念</h3><blockquote><h5 id="提出原因"><a href="#提出原因" class="headerlink" title="提出原因:"></a>提出原因:</h5><ul><li>JavaScript 原有的表示“集合”的数据结构, 主要是数组(<code>Array</code>)和对象(<code>Object</code>)</li><li>ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合, 用户还可以组合使用它们, 定义自己的数据结构, 比如数组的成员是<code>Map</code>, <code>Map</code>的成员是对象。</li><li>这样就需要一种统一的接口机制, 来处理所有不同的数据结构。</li></ul><p>遍历器（Iterator）就是这样一种机制。它是一种接口, 为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口, 就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p></blockquote><h4 id="①-Iterator-的作用有三个"><a href="#①-Iterator-的作用有三个" class="headerlink" title="① Iterator 的作用有三个"></a>① Iterator 的作用有三个</h4><blockquote><ul><li>一是为各种数据结构, 提供一个统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费</li></ul></blockquote><h4 id="②-Iterator-的遍历过程"><a href="#②-Iterator-的遍历过程" class="headerlink" title="② Iterator 的遍历过程"></a>② Iterator 的遍历过程</h4><blockquote><p>（1）创建一个指针对象, 指向当前数据结构的起始位置。也就是说, 遍历器对象本质上, 就是一个指针对象。</p><p>（2）第一次调用指针对象的<code>next</code>方法, 可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的<code>next</code>方法, 指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法, 直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法, 都会返回数据结构的当前成员的信息。具体来说, 就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中, <code>value</code>属性是当前成员的值, <code>done</code>属性是一个布尔值, 表示遍历是否结束。</p></blockquote><h4 id="③-模拟next方法返回值的🌰"><a href="#③-模拟next方法返回值的🌰" class="headerlink" title="③ 模拟next方法返回值的🌰"></a>③ 模拟<code>next</code>方法返回值的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> nextIndex = <span class="number">0</span>; <span class="comment">//定义初始下标为 0</span></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ? </span><br><span class="line">       &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :<span class="comment">//当 当前下标小于数组总长度时,返回当前下标数据</span></span><br><span class="line">       &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;  <span class="comment">//当 当前下标大于等于数组总长度时,返回 undefined</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hongjilin&#x27;</span>]);</span><br><span class="line">&gt;it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;努力学习的汪&quot;, done: false &#125;</span></span><br><span class="line">&gt;it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;hongjilin&quot;, done: false &#125;</span></span><br><span class="line">&gt;it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;  --&gt;可以根据 done 设置是否能继续遍历</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数, 它是一个遍历器生成函数, 作用就是返回一个遍历器对象。对数组<code>[&#39;努力学习的汪&#39;, &#39;hongjilin&#39;]</code>执行这个函数, 就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><ul><li>指针对象的<code>next</code>方法, 用来移动指针。</li><li>开始时, 指针指向数组的开始位置。然后, 每次调用<code>next</code>方法, 指针就会指向数组的下一个成员。第一次调用, 指向<code>&#39;努力学习的汪&#39;</code>；第二次调用, 指向<code>hongjilin</code>。</li><li><code>next</code>方法返回一个对象, 表示当前数据成员的信息。</li><li>这个对象具有<code>value</code>和<code>done</code>两个属性, <code>value</code>属性返回当前位置的成员, <code>done</code>属性是一个布尔值, 表示遍历是否结束, 即是否还有必要再一次调用<code>next</code>方法。</li></ul><blockquote><p>总之, 调用指针对象的<code>next</code>方法, 就可以遍历事先给定的数据结构。</p></blockquote><p>对于遍历器对象来说, <code>done: false</code>和<code>value: undefined</code>属性都是可以省略的, 因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">       &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">       &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>由于 Iterator 只是把接口规格加到数据结构之上, 所以, 遍历器与它所遍历的那个数据结构, 实际上是分开的, 完全可以写出没有对应数据结构的遍历器对象, 或者说用遍历器对象模拟出数据结构。</p></blockquote><h4 id="④-无限运行的遍历器对象的🌰"><a href="#④-无限运行的遍历器对象的🌰" class="headerlink" title="④ 无限运行的遍历器对象的🌰"></a>④ 无限运行的遍历器对象的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">idMaker</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;&#125; <span class="comment">//不论如何都返回 done:false</span></span><br><span class="line">&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> it = <span class="title function_">idMaker</span>();</span><br><span class="line">&gt;<span class="keyword">let</span> values=[]</span><br><span class="line"><span class="comment">//这边给了限制,只循环一百次,一百次都会打印出来</span></span><br><span class="line">&gt;<span class="comment">// 可以预见如果遍历器没法设置条件done为true,使用 for...of 就会无限遍历</span></span><br><span class="line">&gt;<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">values.<span class="title function_">push</span>(it.<span class="title function_">next</span>().<span class="property">value</span> )</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;values  <span class="comment">//[1, 2, 3 ... 98, 99]</span></span><br></pre></td></tr></table></figure><p>上面的例子中, 遍历器生成函数<code>idMaker</code>, 返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构, 或者说是遍历器对象自己描述了一个数据结构出来(无法控制)。</p></blockquote><h4 id="⑤-遍历器接口-Iterable-、指针对象-Iterator-和next方法返回值的规格以TS写法描述"><a href="#⑤-遍历器接口-Iterable-、指针对象-Iterator-和next方法返回值的规格以TS写法描述" class="headerlink" title="⑤ 遍历器接口(Iterable)、指针对象(Iterator)和next方法返回值的规格以TS写法描述"></a>⑤ 遍历器接口(Iterable)、指针对象(Iterator)和<code>next</code>方法返回值的规格以TS写法描述</h4><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">Iterable</span> &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() : <span class="title class_">Iterator</span>,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line"> <span class="title function_">next</span>(value?: <span class="built_in">any</span>) : <span class="title class_">IterationResult</span>,</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">IterationResult</span> &#123;</span><br><span class="line"> <span class="attr">value</span>: <span class="built_in">any</span>,</span><br><span class="line"> <span class="attr">done</span>: <span class="built_in">boolean</span>,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-默认-Iterator-接口"><a href="#Ⅲ-默认-Iterator-接口" class="headerlink" title="Ⅲ - 默认 Iterator 接口"></a>Ⅲ - 默认 Iterator 接口</h3><blockquote><p>Iterator 接口的目的, 就是为所有数据结构, 提供了一种统一的访问机制, 即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时, 该循环会自动去寻找 Iterator 接口。</p><blockquote><h6 id="一种数据结构只要部署了-Iterator-接口-我们就称这种数据结构是“可遍历的”（iterable）"><a href="#一种数据结构只要部署了-Iterator-接口-我们就称这种数据结构是“可遍历的”（iterable）" class="headerlink" title="一种数据结构只要部署了 Iterator 接口, 我们就称这种数据结构是“可遍历的”（iterable）"></a><strong>一种数据结构只要部署了 Iterator 接口, 我们就称这种数据结构是“可遍历的”（iterable）</strong></h6></blockquote><ul><li>ES6 规定, 默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性, 或者说, 一个数据结构只要具有<code>Symbol.iterator</code>属性, 就可以认为是“可遍历的”（iterable）。</li></ul></blockquote><h4 id="①-Symbol-iterator-设置时需要写在中括号中"><a href="#①-Symbol-iterator-设置时需要写在中括号中" class="headerlink" title="① Symbol.iterator 设置时需要写在中括号中"></a>① Symbol.iterator 设置时需要写在中括号中</h4><blockquote><ol><li><code>Symbol.iterator</code>属性本身是一个函数, 就是当前数据结构默认的遍历器生成函数。执行这个函数, 就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>, 它是一个表达式, 返回<code>Symbol</code>对象的<code>iterator</code>属性, 这是一个预定义好的、类型为 Symbol 的特殊值, <strong>所以要放在方括号内</strong>(在前面 <strong>Symbol、Map、Set</strong> 章节中的示例也是如此使用)</li><li><strong>Symbol.iterator</strong>: 指向一个默认遍历器方法, 当实例对象执行 [ for-of ] 时会调用指定的默认遍历器</li><li>我们知道,在给对象设置属性名时,如果属性名是变量,那么我们用 <strong>[ ]</strong> 进行包裹</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123;</span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] : <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// Symbol.iterator 本身是一个表达式,所以需要写在中括号中</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>,  <span class="attr">done</span>: <span class="literal">true</span>&#125;  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, 对象<code>obj</code>是可遍历的（iterable）, 因为具有<code>Symbol.iterator</code>属性。执行这个属性, 会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法, 都会返回一个代表当前成员的信息对象, 具有<code>value</code>和<code>done</code>两个属性。</p></blockquote><h4 id="②-怎样算是部署了遍历器接口"><a href="#②-怎样算是部署了遍历器接口" class="headerlink" title="② 怎样算是部署了遍历器接口 ?"></a>② 怎样算是部署了遍历器接口 ?</h4><blockquote><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组）, 即不用任何处理, 就可以被<code>for...of</code>循环遍历。原因在于, 这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文）, 另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构, 就称为部署了遍历器接口。调用这个接口, 就会返回一个遍历器对象。</p></blockquote><h4 id="③-原生具备-Iterator-接口的数据结构如下"><a href="#③-原生具备-Iterator-接口的数据结构如下" class="headerlink" title="③ 原生具备 Iterator 接口的数据结构如下:"></a>③ 原生具备 Iterator 接口的数据结构如下:</h4><blockquote><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>对于原生部署 Iterator 接口的数据结构, 不用自己写遍历器生成函数, <code>for...of</code>循环会自动遍历它们。除此之外, 其他数据结构（主要是对象）的 Iterator 接口, 都需要自己在<code>Symbol.iterator</code>属性上面部署, 这样才会被<code>for...of</code>循环遍历</p></blockquote><h4 id="④-举个数组的Symbol-iterator属性的🌰"><a href="#④-举个数组的Symbol-iterator属性的🌰" class="headerlink" title="④ 举个数组的Symbol.iterator属性的🌰"></a>④ 举个数组的<code>Symbol.iterator</code>属性的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;不想学习了我头秃了&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;努力学习的汪&#x27;, done: false &#125;</span></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;hongjilin&#x27;, done: false &#125;</span></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;不想学习了我头秃了&#x27;, done: false &#125;</span></span><br><span class="line">&gt;iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>arr</code>是一个数组, 原生就具有遍历器接口, 部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以, 调用这个属性, 就得到遍历器对象。</p></blockquote><h4 id="⑥-对象为何没有默认部署-Iterator-接口"><a href="#⑥-对象为何没有默认部署-Iterator-接口" class="headerlink" title="⑥ 对象为何没有默认部署 Iterator 接口 ?"></a>⑥ 对象为何没有默认部署 Iterator 接口 ?</h4><blockquote><p>对象（Object）之所以没有默认部署 Iterator 接口, 是因为对象的哪个属性先遍历, 哪个属性后遍历是不确定的, 需要开发者手动指定。本质上, 遍历器是一种线性处理, 对于任何非线性的数据结构, 部署遍历器接口, 就等于部署一种线性转换。不过, 严格地说, 对象部署遍历器接口并不是很必要, 因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构, 而 ES6 原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口, 就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = start; <span class="comment">//定义一个初始开始值</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">stop</span> = stop;  <span class="comment">//定义结束点</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//Symbol.iterator 绑定自身实例对象,这样 [next()] 也相当于是函数体内声明的,看不懂的回顾JS进阶基础部分</span></span><br><span class="line">[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125; </span><br><span class="line">  <span class="comment">//定义遍历器方法</span></span><br><span class="line"><span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">value</span>; <span class="comment">//声明一个临时变量储存当前实例的 value</span></span><br><span class="line"><span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123; </span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">value</span>++; <span class="comment">//注意 这里的 [this.value] 是 RangeIterator 实例的 value, 此处给实例的value进行+1</span></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;; <span class="comment">//当 当前 value 小于 stop 时,返回当前 value(未加1时的)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;<span class="comment">//当 当前 value 大等于 stop 时,返回 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//声明一个生成 RangeIterator 实例的方法</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">range</span> = (<span class="params">start, stop</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123; <span class="comment">//如果遍历器没法设置条件 done为true,就会无限循环</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数, 执行后返回当前对象的遍历器对象</p></blockquote><h4 id="⑦-通过遍历器实现指针结构的🌰"><a href="#⑦-通过遍历器实现指针结构的🌰" class="headerlink" title="⑦ 通过遍历器实现指针结构的🌰"></a>⑦ 通过遍历器实现指针结构的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//在 Obj 的原型上加 [Symbol.iterator] 属性</span></span><br><span class="line">&gt;<span class="title class_">Obj</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> iterator = &#123; <span class="attr">next</span>: next &#125;; <span class="comment">//设置迭代器</span></span><br><span class="line"><span class="keyword">let</span> current = <span class="variable language_">this</span>;  <span class="comment">//用 current 储存当前 this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current) &#123;</span><br><span class="line">            <span class="keyword">const</span> value = current.<span class="property">value</span>; <span class="comment">//将当前实例的 value 储存到 新的value变量 中</span></span><br><span class="line">current = current.<span class="property">next</span>;      <span class="comment">//将 current 储存的this 替换为下次迭代next出来的 this</span></span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;; <span class="comment">//返回储存的 value  同时设置为可以继续遍历</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; <span class="comment">//如果 current 储存的 当前this 找不到(undefined),停止遍历</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> iterator;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> one = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;hongjilin&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> two = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> three = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;新生代农民&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;one.<span class="property">next</span> = two; <span class="comment">// 将 two 赋值给 one的next属性</span></span><br><span class="line">&gt;two.<span class="property">next</span> = three; <span class="comment">// 将 three 赋值给 two的next属性</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法, 调用该方法会返回遍历器对象<code>iterator</code>, 调用该对象的<code>next</code>方法, 在返回一个值的同时, 自动将内部指针移到下一个实例。</p><blockquote><ul><li>**for…of **代码运行的第一步时运行 one ,这时候它在本身实例上找不到,就回到自身的Prototype中找,找到了 <strong>next()</strong>,并执行,得到结果 <strong>{ done: false, value: ‘hongjilin’ }</strong></li><li>当调用 <strong>one.next</strong> 时 (<strong>for…of会自动往深处一直调用,直到done为true</strong>) ,相当于调用运行了 two ,然后参照第一步,它找到了 two 的prototype中的 <strong>next</strong>,得到 <strong>{ done: false, value: ‘努力学习的汪’ }</strong></li><li>当调用 <strong>one.next.next</strong> 时(每次循环加一层) ,相当于调用  运行了 <strong>three</strong> ,得到了  <strong>{ done: false, value: ‘新生代农名工’ }</strong></li></ul></blockquote><h6 id="截图示例"><a href="#截图示例" class="headerlink" title="截图示例"></a>截图示例</h6><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210929120021560.png" alt="image-20210929120021560"> </p></blockquote><h4 id="⑧-为对象添加-Iterator-接口的🌰"><a href="#⑧-为对象添加-Iterator-接口的🌰" class="headerlink" title="⑧ 为对象添加 Iterator 接口的🌰"></a>⑧ 为对象添加 Iterator 接口的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> <span class="attr">data</span>: [ <span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span> ],</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">   <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;<span class="comment">//当index 小于 data 的长度时,返回当前下标数据</span></span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">           <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">         &#125;;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="⑨-类似数组的对象部署-Iterator-接口"><a href="#⑨-类似数组的对象部署-Iterator-接口" class="headerlink" title="⑨ 类似数组的对象部署 Iterator 接口"></a>⑨ 类似数组的对象部署 Iterator 接口</h4><blockquote><p>对于类似数组的对象（存在数值键名和<code>length</code>属性）, 部署 Iterator 接口, 有一个简便方法, 就是<code>Symbol.iterator</code>方法直接引用数组的 <strong>Iterator</strong> 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line">&gt;<span class="comment">// 或者</span></span><br><span class="line">&gt;<span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"></span><br><span class="line">&gt;[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure><p>NodeList 对象是类似数组的对象, 本来就具有遍历接口, 可以直接遍历。上面代码中, 我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性, 可以看到没有任何影响。</p></blockquote><h5 id="a-类似数组的对象调用数组的Symbol-iterator方法的🌰"><a href="#a-类似数组的对象调用数组的Symbol-iterator方法的🌰" class="headerlink" title="a) 类似数组的对象调用数组的Symbol.iterator方法的🌰"></a>a) 类似数组的对象调用数组的<code>Symbol.iterator</code>方法的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> iterable = &#123;</span><br><span class="line"> <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"> <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-普通对象部署数组的Symbol-iterator方法-并无效果"><a href="#b-普通对象部署数组的Symbol-iterator方法-并无效果" class="headerlink" title="b) 普通对象部署数组的Symbol.iterator方法, 并无效果"></a>b) 普通对象部署数组的<code>Symbol.iterator</code>方法, 并无效果</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> iterable = &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line"> <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line"> <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line"> <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-如果Symbol-iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数）-解释引擎将会报错"><a href="#c-如果Symbol-iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数）-解释引擎将会报错" class="headerlink" title="c) 如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数）, 解释引擎将会报错"></a>c) 如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象的函数）, 解释引擎将会报错</h5><blockquote><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象）, 解释引擎将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="function">() =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;[...obj] <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中, 变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数, 因此报错。</p></blockquote><h5 id="d-有了遍历器接口-也可以使用while循环遍历"><a href="#d-有了遍历器接口-也可以使用while循环遍历" class="headerlink" title="d) 有了遍历器接口,也可以使用while循环遍历"></a>d) 有了遍历器接口,也可以使用<code>while</code>循环遍历</h5><blockquote><p>有了遍历器接口, 数据结构就可以用<code>for...of</code>循环遍历（详见下文）, 也可以使用<code>while</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> $iterator = <span class="variable constant_">ITERABLE</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line">&gt;<span class="keyword">let</span> $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line">&gt;<span class="keyword">while</span> (!$result.<span class="property">done</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> x = $result.<span class="property">value</span>;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> $result = $iterator.<span class="title function_">next</span>(); <span class="comment">//指向下一个</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>ITERABLE</code>代表某种可遍历的数据结构, <code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法）, 都检查一下返回值的<code>done</code>属性, 如果遍历还没结束, 就移动遍历器对象的指针到下一步（<code>next</code>方法）, 不断循环。</p></blockquote><h3 id="Ⅳ-调用-Iterator-接口的场合"><a href="#Ⅳ-调用-Iterator-接口的场合" class="headerlink" title="Ⅳ - 调用 Iterator 接口的场合"></a>Ⅳ - 调用 Iterator 接口的场合</h3><blockquote><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法）, 除了下文会介绍的<code>for...of</code>循环, 还有几个别的场合。</p></blockquote><h4 id="①-解构赋值"><a href="#①-解构赋值" class="headerlink" title="①  解构赋值"></a>①  解构赋值</h4><blockquote><p>对数组和 Set 结构进行解构赋值时, 会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;hongjilin&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;新生代农民工&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [x,y] = set;</span><br><span class="line">&gt;<span class="comment">// x=&#x27;hongjilin&#x27;; y=&#x27;努力学习的汪&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line">&gt;<span class="comment">// first=&#x27;hongjilin&#x27;; rest=[&#x27;努力学习的汪&#x27;,&#x27;新生代农民工&#x27;];</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="②-扩展运算符"><a href="#②-扩展运算符" class="headerlink" title="② 扩展运算符"></a>② 扩展运算符</h4><blockquote><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 例一</span></span><br><span class="line">&gt;<span class="keyword">const</span> str = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">&gt;[...str] <span class="comment">//  [&#x27;努&#x27;, &#x27;力&#x27;, &#x27;学&#x27;, &#x27;习&#x27;, &#x27;的&#x27;, &#x27;汪&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 例二</span></span><br><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;hongjilin&#x27;</span>];</span><br><span class="line">&gt;[<span class="string">&#x27;我是谁?&#x27;</span>, ...arr, <span class="string">&#x27;新生代农民工&#x27;</span>]</span><br><span class="line">&gt;<span class="comment">// [&#x27;我是谁?&#x27;, &#x27;努力学习的汪&#x27;, &#x27;hongjilin&#x27;, &#x27;新生代农民工&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p><p>实际上, 这提供了一种简便机制, 可以将任何部署了 Iterator 接口的数据结构, 转为数组。也就是说, 只要某个数据结构部署了 Iterator 接口, 就可以对它使用扩展运算符, 将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure></blockquote><h4 id="③-yield"><a href="#③-yield" class="headerlink" title="③ yield*"></a>③ yield*</h4><blockquote><p><code>yield*</code>后面跟的是一个可遍历的结构, 它会调用该结构的遍历器接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> generator = <span class="keyword">function</span>* () &#123; <span class="comment">//注意 此处有个 * 号</span></span><br><span class="line"> <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">yield</span>* [<span class="string">&#x27;努力学习的汪&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">true</span>]; <span class="comment">//注意 此处有个 * 号</span></span><br><span class="line"> <span class="keyword">yield</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">yield</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;hongjilin&#x27;</span>&#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: &#x27;努力学习的汪&#x27;, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: true, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: null, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: &#123;name:&#x27;hongjilin&#x27;&#125;, done: false&#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: true&#125;  --&gt; 到此处done为true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-其他场合"><a href="#④-其他场合" class="headerlink" title="④ 其他场合"></a>④ 其他场合</h4><blockquote><p>由于数组的遍历会调用遍历器接口, 所以任何接受数组作为参数的场合, 其实都调用了遍历器接口。下面是一些🌰</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;hong&#39;,1],[&#39;汪&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul></blockquote><h3 id="Ⅴ-字符串的-Iterator-接口"><a href="#Ⅴ-字符串的-Iterator-接口" class="headerlink" title="Ⅴ - 字符串的 Iterator 接口"></a>Ⅴ - 字符串的 Iterator 接口</h3><blockquote><p>字符串是一个类似数组的对象, 也原生具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someString = <span class="string">&quot;农民工&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">typeof</span> someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]  <span class="comment">// &quot;function&quot;</span></span><br><span class="line">&gt;<span class="keyword">const</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>](); <span class="comment">//将 someString 字符串的遍历器方法赋值给 iterator</span></span><br><span class="line"></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;农&quot;, done: false &#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;民&quot;, done: false &#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;工&quot;, done: false &#125;</span></span><br><span class="line">&gt;iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 调用<code>Symbol.iterator</code>方法返回一个遍历器对象, 在这个遍&#96;历器上可以调用 next 方法, 实现对于字符串的遍历。</p><blockquote><h6 id="可以覆盖原生的Symbol-iterator方法-达到修改遍历器行为的目的。"><a href="#可以覆盖原生的Symbol-iterator方法-达到修改遍历器行为的目的。" class="headerlink" title="可以覆盖原生的Symbol.iterator方法, 达到修改遍历器行为的目的。"></a>可以覆盖原生的<code>Symbol.iterator</code>方法, 达到修改遍历器行为的目的。</h6></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br><span class="line">&gt;[...str] <span class="comment">//  [&#x27;努&#x27;, &#x27;力&#x27;, &#x27;学&#x27;, &#x27;习&#x27;, &#x27;的&#x27;, &#x27;汪&#x27;]</span></span><br><span class="line">&gt;<span class="comment">//修改遍历器行为</span></span><br><span class="line">&gt;str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_first</span>) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">_first</span> = <span class="literal">false</span>; <span class="comment">//进来后直接将 _first 赋值为false ,这样这个代码块只会进来一次</span></span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&quot;新生代农民工&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;; <span class="comment">//当 [_first] 为false 时,直接停止遍历</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">_first</span>: <span class="literal">true</span> <span class="comment">//初次声明,未进入next时,默认值给true,这样确保</span></span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;[...str] <span class="comment">// [&quot;新生代农民工&quot;]  --&gt;可以看到,调用到其遍历器时,行为已经被修改了</span></span><br><span class="line">&gt;str <span class="comment">// String &#123;&#x27;努力学习的汪&#x27;, Symbol(Symbol.iterator): ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中, 字符串 str 的<code>Symbol.iterator</code>方法被修改了, 所以扩展运算符（<code>...</code>）返回的值变成了<code>新生代农民工</code>, 而字符串本身还是<code>努力学习的汪</code>。</p></blockquote><h3 id="Ⅵ-Iterator-接口与-Generator-函数"><a href="#Ⅵ-Iterator-接口与-Generator-函数" class="headerlink" title="Ⅵ - Iterator 接口与 Generator 函数"></a>Ⅵ - Iterator 接口与 Generator 函数</h3><blockquote><p><code>Symbol.iterator()</code>方法的最简单实现, 还是使用下一节要介绍的 Generator 函数,此处先列出来,具体详情可以看下方详解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> myIterable = &#123;</span><br><span class="line"> [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>* () &#123; <span class="comment">//此处有个 * 号</span></span><br><span class="line">   <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> obj = &#123;</span><br><span class="line"> * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line">   <span class="keyword">yield</span> <span class="string">&#x27;新生代农民工&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// &quot;努力学习的汪&quot;</span></span><br><span class="line">&gt;<span class="comment">// &quot;新生代农民工&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Symbol.iterator()</code>方法几乎不用部署任何代码, 只要用 yield 命令给出每一步的返回值即可。</p></blockquote><h3 id="Ⅶ-遍历器对象的-return-，throw"><a href="#Ⅶ-遍历器对象的-return-，throw" class="headerlink" title="Ⅶ - 遍历器对象的 return()，throw()"></a>Ⅶ - 遍历器对象的 return()，throw()</h3><blockquote><p>遍历器对象除了具有<code>next()</code>方法, 还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数, 那么<code>next()</code>方法是必须部署的, <code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p></blockquote><h4 id="①-return-方法的使用场合"><a href="#①-return-方法的使用场合" class="headerlink" title="① return()方法的使用场合"></a>① <code>return()</code>方法的使用场合</h4><blockquote><p><code>return()</code>方法的使用场合是, 如果<code>for...of</code>循环提前退出（通常是因为出错, 或者有<code>break</code>语句）, 就会调用<code>return()</code>方法。如果一个对象在完成遍历前, 需要清理或释放资源, 就可以部署<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">readLinesSync</span>(<span class="params">file</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="keyword">return</span>() &#123; <span class="comment">//清理或释放资源</span></span><br><span class="line">         file.<span class="title function_">close</span>();</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;,</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>readLinesSync</code>接受一个文件对象作为参数, 返回一个遍历器对象, 其中除了<code>next()</code>方法, 还部署了<code>return()</code>方法。</p></blockquote><h4 id="②-会触发执行return-方法的两种情况"><a href="#②-会触发执行return-方法的两种情况" class="headerlink" title="② 会触发执行return()方法的两种情况"></a>② 会触发执行<code>return()</code>方法的两种情况</h4><blockquote><p>下面的两种情况, 都会触发执行<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 情况一</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 情况二</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中:</p><ul><li>情况一输出文件的第一行以后, 就会执行<code>return()</code>方法, 关闭这个文件；</li><li>情况二会在执行<code>return()</code>方法关闭文件之后, 再抛出错误。</li><li>注意, <code>return()</code>方法必须返回一个对象, 这是 Generator 语法决定的。</li></ul><p><code>throw()</code>方法主要是配合 Generator 函数使用, 一般的遍历器对象用不到这个方法。</p></blockquote><h3 id="Ⅷ-for…of-循环"><a href="#Ⅷ-for…of-循环" class="headerlink" title="Ⅷ - for…of 循环"></a>Ⅷ - for…of 循环</h3><blockquote><p>ES6 借鉴 C++、Java、C# 和 Python 语言, 引入了<code>for...of</code>循环, 作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性, 就被视为具有 iterator 接口, 就可以用<code>for...of</code>循环遍历它的成员。也就是说, <code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象, 以及字符串。</p></blockquote><h4 id="①-数组"><a href="#①-数组" class="headerlink" title="① 数组"></a>① 数组</h4><blockquote><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性）, <code>for...of</code>循环本质上就是调用这个接口产生的遍历器, 可以用下面的代码证明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// hongjilin 努力学习的汪 新生代农民工</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">&gt;<span class="comment">//实际上相当于将arr的迭代器行为复制到obj中,迭代的还是之前那个数组</span></span><br><span class="line">&gt;obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>].<span class="title function_">bind</span>(arr); </span><br><span class="line">&gt;<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// hongjilin 努力学习的汪 新生代农民工</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, 空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性, 结果<code>obj</code>的<code>for...of</code>循环, 产生了与<code>arr</code>完全一样的结果。</p></blockquote><h5 id="a-for-of循环可以代替数组实例的forEach方法"><a href="#a-for-of循环可以代替数组实例的forEach方法" class="headerlink" title="a) for...of循环可以代替数组实例的forEach方法"></a>a) <code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法</h5><blockquote><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item, index</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// hongjilin 努力学习的汪 新生代农民工</span></span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(index);   <span class="comment">// 0 1 2</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-与-for-in循环的区别1"><a href="#b-与-for-in循环的区别1" class="headerlink" title="b) 与 for...in循环的区别1:"></a>b) 与 <code>for...in</code>循环的区别1:</h5><blockquote><p>JavaScript 原有的<code>for...in</code>循环, 只能获得对象的键名, 不能直接获取键值。ES6 提供<code>for...of</code>循环, 允许遍历获得键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明, <code>for...in</code>循环读取键名, <code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环, 获取数组的索引, 可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法 (详见前面数组拓展部分)</p></blockquote><h5 id="c-与-for-in循环的区别2"><a href="#c-与-for-in循环的区别2" class="headerlink" title="c) 与 for...in循环的区别2:"></a>c) 与 <code>for...in</code>循环的区别2:</h5><blockquote><p><code>for...of</code>循环调用遍历器接口, 数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;item1&#x27;</span>, <span class="string">&#x27;item2&#x27;</span>, <span class="string">&#x27;item3&#x27;</span>];</span><br><span class="line">&gt;arr.<span class="property">name</span> = <span class="string">&#x27;努力学习的汪&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;name&quot;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>for...of</code>循环不会返回数组<code>arr</code>的<code>name</code>属性。</p></blockquote><h4 id="②-Set-和-Map-结构"><a href="#②-Set-和-Map-结构" class="headerlink" title="② Set 和 Map 结构"></a>② Set 和 Map 结构</h4><blockquote><p>Set 和 Map 结构也原生具有 <strong>Iterator</strong> 接口, 可以直接使用<code>for...of</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;hongjilin&#x27;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>,<span class="string">&#x27;新生代农民工&#x27;</span>]);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// hongjilin</span></span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br><span class="line">&gt;<span class="comment">// 新生代农民工</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> es6 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">&gt;es6.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line">&gt;es6.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="number">99</span>);</span><br><span class="line">&gt;es6.<span class="title function_">set</span>(<span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;新生代农民工&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// name: 努力学习的汪</span></span><br><span class="line">&gt;<span class="comment">// age: 99</span></span><br><span class="line">&gt;<span class="comment">// occupation: 新生代农民工</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个, 首先, 遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时, 返回的是一个值, 而 Map 结构遍历时, 返回的是一个数组, 该数组的两个成员分别为当前 Map 成员的键名和键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&#x27;努力学习的汪&#x27;</span>).<span class="title function_">set</span>(<span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;新生代农民工&quot;</span>)</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [&#x27;name&#x27;, &#x27;努力学习的汪&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// [&#x27;occupation&#x27;, &#x27;新生代农民工&#x27;]</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// name: 努力学习的汪</span></span><br><span class="line">&gt;<span class="comment">// occupation: 新生代农民工</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③-计算生成的数据结构"><a href="#③-计算生成的数据结构" class="headerlink" title="③ 计算生成的数据结构"></a>③ 计算生成的数据结构</h4><blockquote><p>有些数据结构是在现有数据结构的基础上, 计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法, 调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象, 用来遍历<code>[键名, 键值]</code>组成的数组。对于数组, 键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口, 默认就是调用<code>entries</code>方法。</li><li><code>keys()</code> 返回一个遍历器对象, 用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象, 用来遍历所有的键值。</li></ul><p>这三个方法调用后生成的遍历器对象, 所遍历的都是计算生成的数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line">&gt;<span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="④-类似数组的对象"><a href="#④-类似数组的对象" class="headerlink" title="④ 类似数组的对象"></a>④ 类似数组的对象</h4><blockquote><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 字符串</span></span><br><span class="line">&gt;<span class="keyword">let</span> str = <span class="string">&quot;努力学习的汪&quot;</span>;</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">//  &#x27;努&#x27;, &#x27;力&#x27;, &#x27;学&#x27;, &#x27;习&#x27;, &#x27;的&#x27;, &#x27;汪&#x27;</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// DOM NodeList对象</span></span><br><span class="line">&gt;<span class="keyword">let</span> paras = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// arguments对象</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">printArgs</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="string">&#x27;新生代农民工&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// &#x27;努力学习的汪&#x27;</span></span><br><span class="line">&gt;<span class="comment">// &#x27;新生代农民工&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-会正确识别-32-位-UTF-16-字符"><a href="#a-会正确识别-32-位-UTF-16-字符" class="headerlink" title="a) 会正确识别 32 位 UTF-16 字符"></a>a) 会正确识别 32 位 UTF-16 字符</h5><blockquote><p>对于字符串来说, <code>for...of</code>循环还有一个特点, 就是会正确识别 32 位 UTF-16 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;a\uD83D\uDC0A&#x27;</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">&gt;<span class="comment">// &#x27;\uD83D\uDC0A&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="b-使用Array-from方法将其转为数组"><a href="#b-使用Array-from方法将其转为数组" class="headerlink" title="b) 使用Array.from方法将其转为数组"></a>b) 使用<code>Array.from</code>方法将其转为数组</h5><blockquote><p>并不是所有类似数组的对象都具有 Iterator 接口, 一个简便的解决方法, 就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;努力学习的汪&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;新生代农民工&#x27;</span> ,<span class="number">2</span>:<span class="string">&#x27;hongjilin&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 报错</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 正确</span></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// undefined --&gt;找不到下标为0 的,所以打印undefined </span></span><br><span class="line">&gt;<span class="comment">// 新生代农民工</span></span><br><span class="line">&gt;<span class="comment">// hongjilin</span></span><br><span class="line">&gt;<span class="comment">// undefined  --&gt;实际上是根据length确定类似数组的长度,所以找不到下标为3的</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-对象"><a href="#⑤-对象" class="headerlink" title="⑤ 对象"></a>⑤ 对象</h4><blockquote><p>对于普通的对象, <code>for...of</code>结构不能直接使用, 会报错, 必须部署了 Iterator 接口后才能使用。但是, 这样情况下, <code>for...in</code>循环依然可以用来遍历键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> es6 = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;努力学习的汪&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">occupation</span>: <span class="string">&quot;新生代农民工&quot;</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// name</span></span><br><span class="line">&gt;<span class="comment">// age</span></span><br><span class="line">&gt;<span class="comment">// occupation</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// Uncaught TypeError: es6 is not iterable</span></span><br></pre></td></tr></table></figure><p>上面代码表示, 对于普通的对象, <code>for...in</code>循环可以遍历键名, <code>for...of</code>循环会报错</p></blockquote><h5 id="a-解决方案1"><a href="#a-解决方案1" class="headerlink" title="a) 解决方案1"></a>a) 解决方案1</h5><blockquote><p>一种解决方法是, 使用<code>Object.keys</code>方法将对象的键名生成一个数组, 然后遍历这个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(someObject)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-使用-Generator-函数将对象重新包装-进行解决"><a href="#b-使用-Generator-函数将对象重新包装-进行解决" class="headerlink" title="b) 使用 Generator 函数将对象重新包装 进行解决"></a>b) 使用 Generator 函数将对象重新包装 进行解决</h5><blockquote><p>另一个方法是使用 Generator 函数将对象重新包装一下,不懂的可以带着疑惑往下看,可以先知道有这个用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> es6 = &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;努力学习的汪&quot;</span>,</span><br><span class="line"> <span class="attr">age</span>: <span class="number">99</span>,</span><br><span class="line"> <span class="attr">occupation</span>: <span class="string">&quot;新生代农民工&quot;</span></span><br><span class="line">&gt;&#125;; </span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;  <span class="comment">//注意 此处有 * 号</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">   <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(es6)) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;:&#x27;</span>, value);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//name: &quot;努力学习的汪&quot;,</span></span><br><span class="line">&gt;<span class="comment">//age: 99,</span></span><br><span class="line">&gt;<span class="comment">//occupation: &quot;新生代农民工&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑥-与其他遍历语法的比较"><a href="#⑥-与其他遍历语法的比较" class="headerlink" title="⑥ 与其他遍历语法的比较"></a>⑥ 与其他遍历语法的比较</h4><h5 id="a-for-与-forEach-概述"><a href="#a-for-与-forEach-概述" class="headerlink" title="a) for 与 forEach 概述"></a>a) for 与 forEach 概述</h5><blockquote><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦, 因此数组提供内置的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>这种写法的问题在于, 无法中途跳出<code>forEach</code>循环, <code>break</code>命令或<code>return</code>命令都不能奏效。</p></blockquote><h5 id="b-for-in循环-概述"><a href="#b-for-in循环-概述" class="headerlink" title="b) for...in循环 概述"></a>b) <code>for...in</code>循环 概述</h5><blockquote><p><code>for...in</code>循环可以遍历数组的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有几个缺点。</p><ul><li>数组的键名是数字, 但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名, 还会遍历手动添加的其他键, 甚至包括原型链上的键。</li><li>某些情况下, <code>for...in</code>循环会以任意顺序遍历键名。</li></ul><p>总之, <code>for...in</code>循环主要是为遍历对象而设计的, 不适用于遍历数组</p></blockquote><h5 id="c-for-of循环相比上面几种做法的优点"><a href="#c-for-of循环相比上面几种做法的优点" class="headerlink" title="c) for...of循环相比上面几种做法的优点"></a>c) <code>for...of</code>循环相比上面几种做法的优点</h5><blockquote><p><code>for...of</code>循环相比上面几种做法, 有一些显著的优点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>有着同<code>for...in</code>一样的简洁语法, 但是没有<code>for...in</code>那些缺点。具体区别看下方</li><li>不同于<code>forEach</code>方法, 它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><p>下面是一个使用 break 语句, 跳出<code>for...of</code>循环的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line"> <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的例子, 会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p></blockquote><h3 id="Ⅸ-for…of-与-for…in区别"><a href="#Ⅸ-for…of-与-for…in区别" class="headerlink" title="Ⅸ - for…of 与 for…in区别"></a>Ⅸ - for…of 与 for…in区别</h3><blockquote><p>首先最明显的区别:</p><ul><li>for in遍历的是数组的索引（即键名）</li><li>而for of遍历的是数组元素值。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> myArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line">&gt;myArray.<span class="property">name</span>=<span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);    <span class="comment">//0,1,2,&#x27;数组&#x27;, f()&#123;&#125; ,</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray)  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);    <span class="comment">//1,2,4</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="a-for-in的一些缺陷"><a href="#a-for-in的一些缺陷" class="headerlink" title="a)  for in的一些缺陷:"></a>a)  for in的一些<strong>缺陷</strong>:</h5><blockquote><ol><li>索引是字符串型的数字, 因而不能直接进行几何运算</li><li>遍历顺序可能不是实际的内部顺序</li><li>for in会遍历数组所有的可枚举属性, 包括原型。例如的原型方法method和name属性</li></ol><p>故而一般用<strong>for in遍历对象而不用来遍历数组</strong></p><p>这也就是for of存在的意义了,<strong>for of 不遍历method和name,适合用来遍历数组</strong></p></blockquote><h5 id="b-for-of有缺点"><a href="#b-for-of有缺点" class="headerlink" title="b) for of有缺点:"></a>b) for of有缺点:</h5><blockquote><p><strong>for of不支持普通对象</strong>, 想遍历对象的属性, 可以用for in循环, 或内建的Object.keys()方法：</p><p><strong>Object.keys(myObject)获取对象的实例属性组成的数组, 不包括原型方法和属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Object</span>))</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;: &quot;</span> + <span class="title class_">Object</span>[key]);</span><br></pre></td></tr></table></figure><p>但是这样似乎代码优点冗余</p></blockquote><h2 id="16、Promise"><a href="#16、Promise" class="headerlink" title="16、Promise"></a>16、Promise</h2><blockquote><p>此知识点因为 <strong>很重要</strong> ,此处将只列出 ES6 中关于Promise的用法详解,像是 <strong>自定义Promise手撕代码</strong> 、<strong>Promise+ async +await</strong>、<strong>Promise的宏任务与微任务</strong> ….等等都不会在此处记载</p><p>更多完整关于Promise的知识点可以看这里 –&gt; <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Promise学习笔记</a></strong> </p></blockquote><h3 id="一、Promise的理解与使用"><a href="#一、Promise的理解与使用" class="headerlink" title="一、Promise的理解与使用"></a>一、Promise的理解与使用</h3><blockquote><p>1、概念:</p><p>​Promise是<code>异步编程的一种解决方案</code>, 比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器, 里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p><p>通俗讲, <code>Promise是一个许诺、承诺</code>,是对未来事情的承诺, 承诺不一定能完成, 但是无论是否能完成都会有一个结果。</p><ul><li>Pending  正在做。。。</li><li>Resolved 完成这个承诺</li><li>Rejected 这个承诺没有完成, 失败了</li></ul><p>​Promise 用来预定一个不一定能完成的任务, 要么成功, 要么失败</p><p>​在具体的程序中具体的体现, 通常用来封装一个异步任务, 提供承诺结果</p><p>Promise 是异步编程的一种解决方案, <code>主要用来解决回调地狱的问题, 可以有效的减少回调嵌套</code>。真正解决需要<code>配合async/await</code></p><p>2、特点:</p><p>​(1)对象的状态不受外界影响。Promise对象代表一个异步操作, 有三种状态：Pending（进行中）、Resolved（已完成, 又称Fulfilled）和Rejected（已失败）。只有异步操作的结果, 可以决定当前是哪一种状态, 任何其他操作都无法改变这个状态。</p><p>​(2)一旦状态改变, 就不会再变, 任何时候都可以得到这个结果。Promise对象的状态改变, 只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生, 状态就凝固了, 不会再变了, 会一直保持这个结果。就算改变已经发生了, 你再对Promise对象添加回调函数, 也会立即得到这个结果。</p><p>3、缺点:</p><p>​(1)无法取消Promise，一旦新建它就会立即执行, 无法中途取消。和一般的对象不一样, 无需调用。</p><p>​(2)如果不设置回调函数，Promise内部抛出的错误, 不会反应到外部。</p><p>​(3)当处于Pending状态时, 无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</p></blockquote><hr><h3 id="1、Promise是什么"><a href="#1、Promise是什么" class="headerlink" title="1、Promise是什么?"></a>1、Promise是什么?</h3><h5 id="Ⅰ-理解"><a href="#Ⅰ-理解" class="headerlink" title="Ⅰ-理解"></a>Ⅰ-理解</h5><blockquote><ol><li>抽象表达:</li></ol><p>​1) Promise 是一门新的技术(ES6 规范) </p><p>​2)Promise 是 JS 中<code>进行异步编程</code>的新解决方案 备注：旧方案是单纯使用回调函数</p><ol start="2"><li><p>具体表达: </p><ol><li><p>从语法上来说: Promise 是一个<code>构造函数</code></p></li><li><p>从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功&#x2F; 失败的结果值</p></li></ol></li></ol></blockquote><h5 id="Ⅱ-promise-的状态"><a href="#Ⅱ-promise-的状态" class="headerlink" title="Ⅱ-promise 的状态"></a>Ⅱ-promise 的状态</h5><h6 id="a-promise-的状态"><a href="#a-promise-的状态" class="headerlink" title="a) promise 的状态"></a>a) promise 的状态</h6><blockquote><p>实例对象中的一个属性 『PromiseState』</p><ul><li>pending  未决定的</li><li>resolved &#x2F; fullfilled  成功</li><li>rejected  失败</li></ul></blockquote><h6 id="b-promise-的状态改变"><a href="#b-promise-的状态改变" class="headerlink" title="b) promise 的状态改变"></a>b) promise 的状态改变</h6><blockquote><ol><li><p>pending 变为 resolved </p></li><li><p>pending 变为 rejected</p></li></ol><p> 说明: <code>只有这 2 种</code>, 且一个 promise 对象<code>只能改变一次</code> 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason</p></blockquote><h5 id="Ⅲ-promise的基本流程"><a href="#Ⅲ-promise的基本流程" class="headerlink" title="Ⅲ-promise的基本流程"></a>Ⅲ-promise的基本流程</h5><blockquote><p><img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_promise%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Promise系统学习_promise工作流程"></p></blockquote><h5 id="Ⅳ-promise的基本使用"><a href="#Ⅳ-promise的基本使用" class="headerlink" title="Ⅳ-promise的基本使用"></a>Ⅳ-promise的基本使用</h5><h6 id="1-使用-promise-封装基于定时器的异步"><a href="#1-使用-promise-封装基于定时器的异步" class="headerlink" title="1.使用 promise 封装基于定时器的异步"></a>1.使用 promise 封装基于定时器的异步</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doDelay</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 promise 对象(pending 状态), 指定执行器函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 2. 在执行器函数中启动异步任务</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;启动异步任务&#x27;</span>)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;延迟任务开始执行...&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 假设: 时间为奇数代表成功, 为偶数代表失败</span></span><br><span class="line">        <span class="keyword">if</span> (time % <span class="number">2</span> === <span class="number">1</span>) &#123; <span class="comment">// 成功了</span></span><br><span class="line">          <span class="comment">// 3. 1. 如果成功了, 调用 resolve()并传入成功的 value</span></span><br><span class="line">          <span class="title function_">resolve</span>(<span class="string">&#x27;成功的数据 &#x27;</span> + time)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 失败了</span></span><br><span class="line">          <span class="comment">// 3.2. 如果失败了, 调用 reject()并传入失败的 reason</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&#x27;失败的数据 &#x27;</span> + time)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">doDelay</span>(<span class="number">2000</span>)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="comment">// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason</span></span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="comment">// 成功的回调函数 onResolved, 得到成功的 vlaue</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功的 value: &#x27;</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="comment">// 失败的回调函数 onRejected, 得到失败的 reason</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败的 reason: &#x27;</span>, reason)</span><br><span class="line">    &#125;,</span><br><span class="line">  ) &lt;</span><br><span class="line">  /script&gt;</span><br></pre></td></tr></table></figure><h6 id="2-使用-promise-封装-ajax-异步请求"><a href="#2-使用-promise-封装-ajax-异步请求" class="headerlink" title="2.使用 promise 封装 ajax 异步请求"></a>2.使用 promise 封装 ajax 异步请求</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;script &gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  可复用的发 ajax 请求的函数: xhr + promise</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">promiseAjax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          status,</span><br><span class="line">          response</span><br><span class="line">        &#125; = xhr</span><br><span class="line">        <span class="comment">// 请求成功, 调用 resolve(value)</span></span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(response))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 请求失败, 调用 reject(reason)</span></span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败: status: &#x27;</span> + status))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">      xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="title function_">promiseAjax</span>(<span class="string">&#x27;https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=vid</span></span><br><span class="line"><span class="string">    eo &#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(</span><br><span class="line">      <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;显示成功数据&#x27;</span>, data)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ) &lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="3-fs模块使用Promise"><a href="#3-fs模块使用Promise" class="headerlink" title="3.fs模块使用Promise"></a>3.fs模块使用Promise</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数 形式----------------------------------------------------</span></span><br><span class="line"> fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 如果出错 则抛出错误</span></span><br><span class="line">     <span class="keyword">if</span>(err)  <span class="keyword">throw</span> err;</span><br><span class="line">     <span class="comment">//输出文件内容</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise 形式-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装一个函数 mineReadFile 读取文件内容</span></span><br><span class="line"><span class="comment"> * 参数:  path  文件路径</span></span><br><span class="line"><span class="comment"> * 返回:  promise 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mineReadFile</span>(<span class="params">path</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFile</span>(path, <span class="function">(<span class="params">err, data</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span>(err) <span class="title function_">reject</span>(err);</span><br><span class="line">            <span class="comment">//成功</span></span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//输出文件内容</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-异常穿透"><a href="#4-异常穿透" class="headerlink" title="4.异常穿透"></a>4.异常穿透</h6><blockquote><p>可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</p><p>在每个.then()中我可以将数据再次传出给下一个then()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./11.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>())</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(data,<span class="string">&quot;2222222&quot;</span>))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是catch的&quot;</span>))</span><br></pre></td></tr></table></figure><h6 id="5-util-promisify方法"><a href="#5-util-promisify方法" class="headerlink" title="5.util.promisify方法"></a>5.<code>util.promisify方法</code></h6><blockquote><p>可以将函数直接变成promise的封装方式,不用再去手动封装</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入 util 模块</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="comment">//引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//返回一个新的函数</span></span><br><span class="line"><span class="keyword">let</span> mineReadFile = util.<span class="title function_">promisify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">mineReadFile</span>(<span class="string">&#x27;./resource/content.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toString</span>());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="2、为什么要用Promise"><a href="#2、为什么要用Promise" class="headerlink" title="2、为什么要用Promise?"></a>2、为什么要用Promise?</h3><h4 id="Ⅰ-指定回调函数的方式更加灵活"><a href="#Ⅰ-指定回调函数的方式更加灵活" class="headerlink" title="Ⅰ-指定回调函数的方式更加灵活"></a>Ⅰ-指定回调函数的方式更加灵活</h4><blockquote><ol><li>旧的: 必须在启动异步任务前指定 </li><li>promise: 启动异步任务 &#x3D;&gt; 返回promie对象 &#x3D;&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定&#x2F;多个)</li></ol></blockquote><h4 id="Ⅱ-支持链式调用-可以解决回调地狱问题"><a href="#Ⅱ-支持链式调用-可以解决回调地狱问题" class="headerlink" title="Ⅱ-支持链式调用, 可以解决回调地狱问题"></a>Ⅱ-支持链式调用, 可以解决回调地狱问题</h4><h5 id="1、什么是回调地狱"><a href="#1、什么是回调地狱" class="headerlink" title="1、什么是回调地狱"></a>1、什么是回调地狱</h5><blockquote><p>回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="Promise系统学习_回调地狱"></p></blockquote><h5 id="2、回调地狱的缺点"><a href="#2、回调地狱的缺点" class="headerlink" title="2、回调地狱的缺点?"></a>2、回调地狱的缺点?</h5><blockquote><p>不便于阅读 不便于异常处理</p></blockquote><h5 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案?"></a>3、解决方案?</h5><blockquote><p>promise <code>链式调用</code>,</p><p>用来解决回调地狱问题, 但是<code>只是简单的改变格式</code>, 并没有彻底解决上面的问题真正要解决上述问题, 一定要利用promise再加上await和async关键字实现异步传同步</p></blockquote><h5 id="4、终极解决方案"><a href="#4、终极解决方案" class="headerlink" title="4、终极解决方案?"></a>4、终极解决方案?</h5><blockquote><p>promise +async&#x2F;await</p></blockquote><hr><h3 id="3、Promise中的常用-API-概述"><a href="#3、Promise中的常用-API-概述" class="headerlink" title="3、Promise中的常用 API 概述"></a>3、Promise中的常用 API 概述</h3><blockquote><p>此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的  <strong>Promise方法的具体使用</strong> 描述</p></blockquote><h4 id="Ⅰ-Promise-构造函数-Promise-excutor"><a href="#Ⅰ-Promise-构造函数-Promise-excutor" class="headerlink" title="Ⅰ- Promise 构造函数: Promise (excutor) {}"></a>Ⅰ- Promise 构造函数: Promise (excutor) {}</h4><blockquote><p>(1) executor 函数: 执行器 (resolve, reject) &#x3D;&gt; {}</p><p>(2) resolve 函数: 内部定义成功时我们调用的函数 value &#x3D;&gt; {} </p><p>(3) reject 函数: 内部定义失败时我们调用的函数 reason &#x3D;&gt; {} </p><p>说明: executor 会在 Promise 内部立即<code>同步调用</code>,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作</p></blockquote><h4 id="Ⅱ-Promise-prototype-then-方法-onResolved-onRejected"><a href="#Ⅱ-Promise-prototype-then-方法-onResolved-onRejected" class="headerlink" title="Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}"></a>Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) &#x3D;&gt; {}</h4><blockquote><p>(1) onResolved 函数: 成功的回调函数 (value) &#x3D;&gt; {} </p><p>(2) onRejected 函数: 失败的回调函数 (reason) &#x3D;&gt; {} </p><p>说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</p></blockquote><h4 id="Ⅲ-Promise-prototype-catch-方法-onRejected"><a href="#Ⅲ-Promise-prototype-catch-方法-onRejected" class="headerlink" title="Ⅲ-Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}"></a>Ⅲ-Promise.prototype.catch 方法: (onRejected) &#x3D;&gt; {}</h4><blockquote><p>(1) onRejected 函数: 失败的回调函数 (reason) &#x3D;&gt; {}</p><p>说明: then()的语法糖, 相当于: then(undefined, onRejected)</p><p>(2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中</p></blockquote><h4 id="Ⅳ-Promise-resolve-方法-value"><a href="#Ⅳ-Promise-resolve-方法-value" class="headerlink" title="Ⅳ-Promise.resolve 方法: (value) &#x3D;&gt; {}"></a>Ⅳ-Promise.resolve 方法: (value) &#x3D;&gt; {}</h4><blockquote><p>(1) value: 成功的数据或 promise 对象 </p><p>说明: 返回一个成功&#x2F;失败的 promise 对象,直接改变promise状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;));      </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅴ-Promise-reject-方法-reason"><a href="#Ⅴ-Promise-reject-方法-reason" class="headerlink" title="Ⅴ-Promise.reject 方法: (reason) &#x3D;&gt; {}"></a>Ⅴ-Promise.reject 方法: (reason) &#x3D;&gt; {}</h4><blockquote><p>(1) reason: 失败的原因 </p><p>说明: 返回一个失败的 promise 对象,直接改变promise状态,<code>代码示例同上</code></p></blockquote><h4 id="Ⅵ-Promise-all-方法-promises"><a href="#Ⅵ-Promise-all-方法-promises" class="headerlink" title="Ⅵ-Promise.all 方法: (promises) &#x3D;&gt; {}"></a>Ⅵ-Promise.all 方法: (promises) &#x3D;&gt; {}</h4><blockquote><p>promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, 只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);  &#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;错误错误错误&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;也是成功&#x27;</span>)</span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅶ-Promise-race-方法-promises"><a href="#Ⅶ-Promise-race-方法-promises" class="headerlink" title="Ⅶ-Promise.race 方法: (promises) &#x3D;&gt; {}"></a>Ⅶ-Promise.race 方法: (promises) &#x3D;&gt; {}</h4><blockquote><p>(1) promises: 包含 n 个 promise 的数组 </p><p>说明: 返回一个新的 promise, <code>第一个完成</code>的 promise 的结果状态就是最终的结果状态,</p><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="4、Promise的几个关键问题"><a href="#4、Promise的几个关键问题" class="headerlink" title="4、Promise的几个关键问题"></a>4、Promise的几个关键问题</h3><h4 id="Ⅰ-如何改变-promise-的状态"><a href="#Ⅰ-如何改变-promise-的状态" class="headerlink" title="Ⅰ-如何改变 promise 的状态?"></a>Ⅰ-如何改变 promise 的状态?</h4><blockquote><p>(1) resolve(value): 如果当前是 pending 就会变为 resolved </p><p>(2) reject(reason): 如果当前是 pending 就会变为 rejected </p><p>(3) 抛出异常: 如果当前是 pending 就会变为 rejected</p></blockquote><h4 id="Ⅱ-一个-promise-指定多个成功-失败回调函数-都会调用吗"><a href="#Ⅱ-一个-promise-指定多个成功-失败回调函数-都会调用吗" class="headerlink" title="Ⅱ-一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?"></a>Ⅱ-一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?</h4><blockquote><p>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">&gt;<span class="comment">///指定回调 - 1</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;);</span><br><span class="line">&gt;<span class="comment">//指定回调 - 2</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅲ-改变-promise-状态和指定回调函数谁先谁后"><a href="#Ⅲ-改变-promise-状态和指定回调函数谁先谁后" class="headerlink" title="Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?"></a>Ⅲ- 改变 promise 状态和指定回调函数谁先谁后?</h4><blockquote><p>(1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 </p><p>​先指定回调再改变状态(<code>异步</code>):先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数</p><p>​先改状态再指定回调(<code>同步</code>):改变状态 –&gt;指定回调 <code>并马上执行</code>回调</p><p>(2) 如何先改状态再<code>指定</code>回调?   –&gt;注意:指定并不是执行</p><p>​① 在执行器中直接调用 resolve()&#x2F;reject() –&gt;即,不使用定时器等方法,执行器内直接同步操作 </p><p>​② 延迟更长时间才调用 then() –&gt;即,在<code>.then()</code>这个方法外再包一层例如延时器这种方法</p><p>(3) 什么时候才能得到数据? </p><p>​① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 </p><p>​② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;<span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>(4) 个人理解–结合源码</p><p>​源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断,所以当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>,所以只是这样导致只有同步操作才能成功.</p><p>​所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p><p>​具体代码实现看下方自定义promise</p></blockquote><h4 id="Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定"><a href="#Ⅳ-promise-then-返回的新-promise-的结果状态由什么决定" class="headerlink" title="Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?"></a>Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定?</h4><blockquote><p>(1) 简单表达: 由 then()指定的回调函数执行的结果决定 </p><p>(2) 详细表达: </p><p>​① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 </p><p>​② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 </p><p>​③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//执行 then 方法</span></span><br><span class="line">&gt;<span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&gt;<span class="comment">// 1. 抛出错误 ,变为 rejected</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line">&gt;<span class="comment">// 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅴ-promise-如何串连多个操作任务"><a href="#Ⅴ-promise-如何串连多个操作任务" class="headerlink" title="Ⅴ- promise 如何串连多个操作任务?"></a>Ⅴ- promise 如何串连多个操作任务?</h4><blockquote><p>(1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 </p><p>(2) 通过 then 的链式调用串连多个同步&#x2F;异步任务,这样就能用<code>then()</code>将多个同步或异步操作串联成一个同步队列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>); &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&quot;success&quot;</span>); &#125;);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅵ-promise-异常传透"><a href="#Ⅵ-promise-异常传透" class="headerlink" title="Ⅵ-promise 异常传透?"></a>Ⅵ-promise 异常传透?</h4><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h4 id="Ⅶ-中断-promise-链"><a href="#Ⅶ-中断-promise-链" class="headerlink" title="Ⅶ- 中断 promise 链?"></a>Ⅶ- 中断 promise 链?</h4><blockquote><p>在<code>关键问题2</code>中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何?</p><p>(1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 </p><p>(2) 办法: 在回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="5、-Promise的实际应用"><a href="#5、-Promise的实际应用" class="headerlink" title="5、 Promise的实际应用"></a>5、 Promise的实际应用</h3><blockquote><p>举两个栗子</p></blockquote><h4 id="Ⅰ-加载图片"><a href="#Ⅰ-加载图片" class="headerlink" title="Ⅰ - 加载图片"></a>Ⅰ - 加载图片</h4><blockquote><p>我们可以将图片的加载写成一个<code>Promise</code>, 一旦加载完成, <code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">&gt;image.<span class="property">onload</span>  = resolve;</span><br><span class="line">&gt;image.<span class="property">onerror</span> = reject;</span><br><span class="line">&gt;image.<span class="property">src</span> = path;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="Ⅱ-Generator-函数与-Promise-的结合"><a href="#Ⅱ-Generator-函数与-Promise-的结合" class="headerlink" title="Ⅱ - Generator 函数与 Promise 的结合"></a>Ⅱ - Generator 函数与 Promise 的结合</h4><blockquote><p>使用 Generator 函数管理流程, 遇到异步操作的时候, 通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getFoo</span> () &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> foo = <span class="keyword">yield</span> <span class="title function_">getFoo</span>();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">run</span> (generator) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> it = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));</span><br><span class="line">&gt;&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">go</span>(it.<span class="title function_">next</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中, 有一个异步操作<code>getFoo</code>, 它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象, 并调用下一个<code>next</code>方法。</p></blockquote><hr><h3 id="二、Promise-API-用法详解"><a href="#二、Promise-API-用法详解" class="headerlink" title="二、Promise API 用法详解"></a>二、Promise API 用法详解</h3><blockquote><p>ES6 规定, <code>Promise</code>对象是一个构造函数, 用来生成<code>Promise</code>实例。</p><p>此部分是对于 <strong>Promise API 用法的详解</strong> ,尽量详细地列举其常见用法,所以篇幅较长</p></blockquote><h3 id="Ⅰ-基本用法"><a href="#Ⅰ-基本用法" class="headerlink" title="Ⅰ -  基本用法"></a>Ⅰ -  基本用法</h3><h4 id="①-举个创造-Promise-实例的栗子"><a href="#①-举个创造-Promise-实例的栗子" class="headerlink" title="①  举个创造 Promise 实例的栗子"></a>①  举个创造 Promise 实例的栗子</h4><blockquote><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)  <span class="title function_">resolve</span>(value); <span class="comment">//将该 Promise 修改为成功且返回</span></span><br><span class="line"><span class="keyword">else</span>  <span class="title function_">reject</span>(error); <span class="comment">//将该 Promise 修改为失败且返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数, 该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数, 由 JavaScript 引擎提供, 不用自己部署。</p><p><code>resolve</code>函数的作用是, 将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved）, 在异步操作成功时调用, 并将异步操作的结果, 作为参数传递出去；<code>reject</code>函数的作用是, 将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected）, 在异步操作失败时调用, 并将异步操作报出的错误, 作为参数传递出去。</p></blockquote><h4 id="②-使用-then-方法分别指定-成功-失败-的回调"><a href="#②-使用-then-方法分别指定-成功-失败-的回调" class="headerlink" title="② 使用 [ then ] 方法分别指定 成功&#x2F;失败 的回调"></a>② 使用 [ then ] 方法分别指定 成功&#x2F;失败 的回调</h4><blockquote><p><code>Promise</code>实例生成以后, 可以用 [ then() ] 方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为resolve 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 当promise状态返回为rejected 时会执行的回调函数</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>[ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用, 第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中, <strong>第二个函数是可选的, 不一定要提供</strong>。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p></blockquote><h4 id="③-举个-Promise-对象的简单栗子"><a href="#③-举个-Promise-对象的简单栗子" class="headerlink" title="③ 举个 Promise 对象的简单栗子"></a>③ 举个 Promise 对象的简单栗子</h4><blockquote><p>下面是一个<code>Promise</code>对象的简单例子。</p><blockquote><p>setTimeout的第三个参数是给第一个函数的参数, 而且是先于第一个参数(即回调函数)执行的 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123; <span class="comment">//声明一个方法, 传入的 参数ms 为延时器时间</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">//这行代码实际效果: 当 [ms] 毫秒后 执行 resolve(&#x27;努力学习的汪&#x27;)</span></span><br><span class="line"> <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;努力学习的汪&#x27;</span>); </span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">timeout</span>(<span class="number">1000</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line">&gt;<span class="comment">//打印结果 : 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>timeout</code>方法返回一个<code>Promise</code>实例, 表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后, <code>Promise</code>实例的状态变为<code>resolved</code>, 就会触发<code>then</code>方法绑定的回调函数。</p></blockquote><h4 id="④-Promise-新建后就会立即执行"><a href="#④-Promise-新建后就会立即执行" class="headerlink" title="④ Promise 新建后就会立即执行"></a>④ Promise 新建后就会立即执行</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">&gt;<span class="title function_">resolve</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise</span></span><br><span class="line">&gt;<span class="comment">// Hi!</span></span><br><span class="line">&gt;<span class="comment">// resolved //可以发现,明明then是在 Hi 前面,却最后打印</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行, 所以首先输出的是<code>Promise</code>。然后, <code>then</code>方法指定的回调函数, 将在当前脚本所有同步任务执行完才会执行, 所以<code>resolved</code>最后输出。</p><p>实际上,这个运行结果相关知识点是 [ <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#%E5%9B%9B%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务与微任务</a> ] ,单独梳理在下方.这里可以先初步理解为: </p><ol><li><p>JS是单线程的,至上往下运行,在声明 <strong>Promise</strong> 时实际上已经执行到了内部方法</p></li><li><p>为何 resolve() 运行后没有立即打印?</p></li></ol><ul><li><p>JS中用来存储待执行回调函数的队列包含2个不同特定的列队</p><blockquote><p><code>宏队列</code>:用来保存待执行的宏任务(回调),比如:<code>定时器</code>回调&#x2F;ajax回调&#x2F;dom事件回调</p><p><code>微队列</code>:用来保存待执行的微任务(回调),比如:<code>Promise</code>的回调&#x2F;muntation回调</p></blockquote></li><li><p>JS执行时会区别这2个队列:</p><blockquote><p>JS执行引擎首先必须执行所有的<code>初始化同步任务</code>代码</p><p>每次准备取出第一个<code>宏任务执行前</code>,都要将所有的<code>微任务</code>一个一个取出来执行</p></blockquote></li></ul></blockquote><h4 id="⑤-举个异步加载图片的栗子"><a href="#⑤-举个异步加载图片的栗子" class="headerlink" title="⑤ 举个异步加载图片的栗子"></a>⑤ 举个异步加载图片的栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">&gt;image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片加载成功&#x27;</span>)</span><br><span class="line">&gt;<span class="title function_">resolve</span>(image);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法从 <span class="subst">$&#123;url&#125;</span> 中加载图片`</span> ));</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;image.<span class="property">src</span> = url;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">loadImageAsync</span>(<span class="string">&#x27;正确的url&#x27;</span>) <span class="comment">//打印图片加载成功</span></span><br><span class="line">&gt;<span class="title function_">loadImageAsync</span>(<span class="string">&#x27;错误的url&#x27;</span>) <span class="comment">//抛出异常</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码中, 使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功, 就调用<code>resolve</code>方法, 否则就调用<code>reject</code>方法。</p><p><img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926180306961.png" alt="image-20210926180306961"> </p></blockquote><h4 id="⑥-举个用Promise对象实现的-Ajax-操作的栗子"><a href="#⑥-举个用Promise对象实现的-Ajax-操作的栗子" class="headerlink" title="⑥ 举个用Promise对象实现的 Ajax 操作的栗子"></a>⑥ 举个用<code>Promise</code>对象实现的 Ajax 操作的栗子</h4><blockquote><p>Ajax知识点不懂的同学要去补一下: 这里可以看本人梳理的ajax笔记 –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">点我跳转</a> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>)  <span class="keyword">return</span>; <span class="comment">//当readyState 为4 时直接返回,不修改 promise 状态</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>); <span class="comment">//返回状态为 200 时将状态修改为成功,且将响应内容返回</span></span><br><span class="line">&gt;<span class="keyword">else</span>  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>)); <span class="comment">//失败时抛出异常</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">//实例化xml实例</span></span><br><span class="line">&gt;client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url); <span class="comment">//下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点</span></span><br><span class="line">&gt;client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">&gt;client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">&gt;client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">&gt;client.<span class="title function_">send</span>();</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="keyword">return</span> promise;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> , json);</span><br><span class="line">&gt;&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, <code>getJSON</code>是对 XMLHttpRequest 对象的封装, 用于发出一个针对 JSON 数据的 HTTP 请求, 并且返回一个<code>Promise</code>对象。需要注意的是, 在<code>getJSON</code>内部, <code>resolve</code>函数和<code>reject</code>函数调用时, 都带有参数。</p><p><img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926182129672.png" alt="image-20210926182129672"></p><blockquote><p>小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们</p></blockquote><blockquote><p><img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210926182506259.png" alt="image-20210926182506259"> </p></blockquote></blockquote><h4 id="⑦-resolve-的参数可以是另一个-Promise-实例"><a href="#⑦-resolve-的参数可以是另一个-Promise-实例" class="headerlink" title="⑦  resolve()  的参数可以是另一个 Promise 实例"></a>⑦  resolve()  的参数可以是另一个 Promise 实例</h4><blockquote><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数, 那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例, 表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外, 还可能是另一个 Promise 实例, 比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123; <span class="title function_">resolve</span>(p1) &#125;)</span><br></pre></td></tr></table></figure><p>上面代码中, <code>p1</code>和<code>p2</code>都是 Promise 的实例, 但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数, 即一个异步操作的结果是返回另一个异步操作。</p><p>注意, 这时<code>p1</code>的状态就会传递给<code>p2</code>, 也就是说, <code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>, 那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>, 那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;p1的状态改为错误&#x27;</span>)), <span class="number">0</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">3000</span>) <span class="comment">//将p1 传给p2</span></span><br><span class="line">&gt;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;p2.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result),<span class="function"><span class="params">result</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败&#x27;</span>))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch异常捕获:&#x27;</span>+error))</span><br><span class="line">&gt;<span class="comment">//首先报错</span></span><br><span class="line">&gt;<span class="comment">//运行三秒后打印: 失败</span></span><br></pre></td></tr></table></figure><h5 id="上面代码运行后执行效果"><a href="#上面代码运行后执行效果" class="headerlink" title="上面代码运行后执行效果:"></a>上面代码运行后执行效果:</h5><ul><li>首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错)</li><li>然后等3秒后再打印:  ‘失败’</li><li>注意: 如果 <strong>p2.then()</strong> 中没有写 <strong>reject</strong> 回调函数(第二个参数),则会被 <strong>catch</strong> 捕获,变为<code>catch异常捕获:Error: p1的状态改为错误</code></li></ul><h5 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h5><blockquote><ul><li>首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 <strong>p1 的reject()</strong>,所以直接控制台报错了</li><li><code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了, 由<code>p1</code>的状态决定<code>p2</code>的状态</li><li>总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态</li></ul></blockquote></blockquote><h4 id="⑧-调用resolve或reject并不会终结-Promise-的参数函数的执行"><a href="#⑧-调用resolve或reject并不会终结-Promise-的参数函数的执行" class="headerlink" title="⑧ 调用resolve或reject并不会终结 Promise 的参数函数的执行"></a>⑧ 调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行</h4><blockquote><p>调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 2</span></span><br><span class="line">&gt;<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中, 调用<code>resolve(1)</code>以后, 后面的<code>console.log(2)</code>还是会执行, 并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行, 总是晚于本轮循环的同步任务。</p></blockquote><h4 id="⑨-建议在修改状态函数前加return"><a href="#⑨-建议在修改状态函数前加return" class="headerlink" title="⑨ 建议在修改状态函数前加return"></a>⑨ 建议在修改状态函数前加return</h4><blockquote><p>一般来说, 调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了, 后继操作应该放到<code>then</code>方法里面, 而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以, 最好在它们前面加上<code>return</code>语句, 这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&gt;<span class="comment">// 后面的语句不会执行</span></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure><p>有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 <code>resolve/reject</code>前后好像都不影响啊! 这里我给举个实际场景</p></blockquote><h5 id="a-不加-return-导致的错误场景举🌰"><a href="#a-不加-return-导致的错误场景举🌰" class="headerlink" title="a) 不加 return 导致的错误场景举🌰"></a>a) 不加 return 导致的错误场景举🌰</h5><blockquote><p>一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 [②Promise.prototype.catch()](#② Promise.prototype.catch())</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//如果你加了 return , 函数执行到此步就停止了</span></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误错误!!!!!&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line">&gt;<span class="comment">// ok</span></span><br><span class="line">&gt;<span class="comment">// Uncaught Error: 错误错误!!!!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了, 所以这个错误是在 Promise 函数体外抛出的, 会冒泡到最外层, 成了未捕获的错误。</p></blockquote><h3 id="Ⅱ-API-用法详解"><a href="#Ⅱ-API-用法详解" class="headerlink" title="Ⅱ -  API 用法详解"></a>Ⅱ -  API 用法详解</h3><blockquote><p>此处将对于所有API进行详细剖析,参照资料为 <a href="">阮一峰的ES6日志</a></p></blockquote><h4 id="①-Promise-prototype-then"><a href="#①-Promise-prototype-then" class="headerlink" title="① Promise.prototype.then()"></a>① Promise.prototype.then()</h4><blockquote><p>Promise 实例具有<code>then</code>方法, 也就是说, <code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过, <code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数, 第二个参数（可选）是<code>rejected</code>状态的回调函数。</p></blockquote><h5 id="a-then方法返回的是一个新的Promise实例"><a href="#a-then方法返回的是一个新的Promise实例" class="headerlink" title="a) then方法返回的是一个新的Promise实例"></a>a) <code>then</code>方法返回的是一个新的<code>Promise</code>实例</h5><blockquote><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意, 不是原来那个<code>Promise</code>实例）。因此可以采用链式写法, 即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> json.<span class="property">name</span>;</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>`</span> )</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法, 依次指定了两个回调函数。第一个回调函数完成以后, 会将返回结果作为参数, 传入第二个回调函数。</p></blockquote><h5 id="b-采用链式的then-会等待前一个Promise状态发生改变才会被调用"><a href="#b-采用链式的then-会等待前一个Promise状态发生改变才会被调用" class="headerlink" title="b) 采用链式的then, 会等待前一个Promise状态发生改变才会被调用"></a>b) 采用链式的<code>then</code>, 会等待前一个Promise状态发生改变才会被调用</h5><blockquote><p>采用链式的<code>then</code>, 可以指定一组按照次序调用的回调函数。这时, 前一个回调函数, 有可能返回的还是一个<code>Promise</code>对象（即有异步操作）, 这时后一个回调函数, 就会等待该<code>Promise</code>对象的状态发生变化, 才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;  <span class="keyword">return</span> <span class="title function_">getJSON</span>(json.<span class="property">name</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="keyword">function</span> (<span class="params">name</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: My name is &quot;</span>, name)&#125;, </span><br><span class="line">&gt;<span class="keyword">function</span> (<span class="params">err</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中, 第一个<code>then</code>方法指定的回调函数, 返回的是另一个<code>Promise</code>对象。这时, 第二个<code>then</code>方法指定的回调函数, 就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>, 就调用第一个回调函数, 如果状态变为<code>rejected</code>, 就调用第二个回调函数。</p></blockquote><h5 id="c-使用箭头函数简写"><a href="#c-使用箭头函数简写" class="headerlink" title="c) 使用箭头函数简写"></a>c) 使用箭头函数简写</h5><blockquote><p>如果采用箭头函数, 上面的代码可以写得更简洁 (实际代码中基本都是这样写了)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&quot;./hong.json&quot;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="title function_">getJSON</span>(json.<span class="property">name</span>) )</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">name</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: My name is &quot;</span>, name), </span><br><span class="line">&gt;<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h4 id="②-Promise-prototype-catch"><a href="#②-Promise-prototype-catch" class="headerlink" title="② Promise.prototype.catch()"></a>② Promise.prototype.catch()</h4><blockquote><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名, 用于指定发生错误时的回调函数。</p></blockquote><h5 id="a-基本用法-2"><a href="#a-基本用法-2" class="headerlink" title="a) 基本用法"></a>a) 基本用法</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, <code>getJSON()</code>方法返回一个 Promise 对象</p><blockquote><ul><li>如果该对象状态变为<code>resolved</code>, 则会调用<code>then()</code>方法指定的回调函数；</li><li>如果异步操作抛出错误, 状态就会变为<code>rejected</code>, 就会调用<code>catch()</code>方法指定的回调函数, 处理这个错误</li><li>另外, <code>then()</code>方法指定的回调函数, 如果运行中抛出错误, 也会被<code>catch()</code>方法捕获。</li><li>被 catch 方法捕获的前提是前方的 then() 方法中没有对 <code>rejected</code> 进行捕获处理(即没有写reject回调函数)</li></ul></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在catch中进行 rejected 的处理&#x27;</span>, err));</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;指定成功回调:&#x27;</span>, val))</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;等同于另起一个then,只指定 rejected 的处理&quot;</span>, err));</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-reject-方法的作用-等同于抛出错误"><a href="#b-reject-方法的作用-等同于抛出错误" class="headerlink" title="b)  reject()方法的作用, 等同于抛出错误"></a>b)  <code>reject()</code>方法的作用, 等同于抛出错误</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异常捕获: &#x27;</span>,error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//异常捕获:  Error: 直接抛出错误</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>promise</code>抛出一个错误, 就被<code>catch()</code>方法指定的回调函数捕获。注意, 上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/******************  写法一 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;直接抛出错误&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进入catch,然后再用 reject(e)抛出 &#x27;</span>)</span><br><span class="line">&gt;<span class="title function_">reject</span>(e) </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//进入catch,然后再用 reject(e)抛出 </span></span><br><span class="line">&gt;<span class="comment">//Error: 直接抛出错误</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************  写法二 ***************************************/</span></span><br><span class="line">&gt;<span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;使用 reject() 抛出错误&#x27;</span>));</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise1.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//Error: 使用 reject() 抛出错误</span></span><br></pre></td></tr></table></figure><p>比较上面两种写法, 可以发现<code>reject()</code>方法的作用, 等同于抛出错误,所以不必用try..catch()去承接后再去抛出了</p></blockquote><h5 id="c-如果-Promise-状态已经被修改-再抛出错误是无效的"><a href="#c-如果-Promise-状态已经被修改-再抛出错误是无效的" class="headerlink" title="c) 如果 Promise 状态已经被修改, 再抛出错误是无效的"></a>c) 如果 Promise 状态已经被修改, 再抛出错误是无效的</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;成功了&#x27;</span>); <span class="comment">//换成 reject(&#x27;成功了&#x27;) 结果也是一样的</span></span><br><span class="line">&gt;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;成功后扔抛出异常&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line">&gt;<span class="comment">// 成功了</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve/reject</code>语句后面, 再抛出错误, 不会被捕获, 等于没有抛出。因为 Promise 的状态一旦改变, 就永久保持该状态, 不会再变了(前面有说过)</p></blockquote><h5 id="d-Promise-对象的错误具有-“冒泡”-性质"><a href="#d-Promise-对象的错误具有-“冒泡”-性质" class="headerlink" title="d) Promise 对象的错误具有 “冒泡” 性质"></a>d) Promise 对象的错误具有 “冒泡” 性质</h5><blockquote><p>Promise 对象的错误具有“冒泡”性质, 会一直向后传递, 直到被捕获为止。也就是说, 错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>) <span class="comment">//第一个promise</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123; <span class="comment">//第二个promise</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123; <span class="comment">//第三个promise</span></span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, 一共有三个 Promise 对象(<strong>then返回的仍可能是一个Promise对象</strong>)：一个由<code>getJSON()</code>产生, 两个由<code>then()</code>产生。它们之中任何一个抛出的错误, 都会被最后一个<code>catch()</code>捕获。</p><p>也是因为这个特性,有了 <strong>异常穿透问题</strong> </p></blockquote><h5 id="e-异常穿透问题"><a href="#e-异常穿透问题" class="headerlink" title="e) 异常穿透问题"></a>e) 异常穿透问题</h5><blockquote><ul><li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调</li><li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res),<span class="function"><span class="params">e</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被then的错误回调捕获&#x27;</span>,e) )</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果: 被then的错误回调捕获 Error: 抛出异常</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/******************** 利用异常穿透 ****************************************/</span></span><br><span class="line">&gt;<span class="title function_">getJSON</span>(<span class="string">&#x27;./hong.json&#x27;</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;抛出异常&#x27;</span>) &#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res) ) <span class="comment">//此处差异,不指定 reject 回调,利用异常穿透传到最后</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获: &#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line">&gt;<span class="comment">//执行结果:  错误捕获:  Error: 抛出异常</span></span><br></pre></td></tr></table></figure><p>注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用<code>catch</code>去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch<img src="/k705.github.io/../../Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927105504988.png" alt="image-20210927105504988"></p></blockquote><h5 id="f-建议使用-catch-进行异常处理"><a href="#f-建议使用-catch-进行异常处理" class="headerlink" title="f) 建议使用 catch() 进行异常处理"></a>f) 建议使用 catch() 进行异常处理</h5><blockquote><p>一般来说, 不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数）, 总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// bad</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">data</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>,data),</span><br><span class="line">&gt;<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,err)</span><br><span class="line">);</span><br><span class="line">&gt;<span class="comment">/********* 好的写法 ********************/</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>( <span class="function"><span class="params">data</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;成功&#x27;</span>,data)) <span class="comment">//只指定成功回调</span></span><br><span class="line">&gt;.<span class="title function_">catch</span>( <span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败了&#x27;</span>,err));</span><br></pre></td></tr></table></figure><p>上面代码中, 第二种写法要好于第一种写法:</p><ul><li>理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误</li><li>也更接近同步的写法（<code>try/catch</code>）</li><li>因此, 建议总是使用<code>catch()</code>方法, 而不使用<code>then()</code>方法的第二个参数。</li></ul></blockquote><h5 id="g-与传统-try-catch-代码块的差异"><a href="#g-与传统-try-catch-代码块的差异" class="headerlink" title="g) 与传统 try/catch 代码块的差异"></a>g) 与传统 <code>try/catch</code> 代码块的差异</h5><blockquote><p>跟传统的<code>try/catch</code>代码块不同的是, 如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码, 即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错, 因为hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">//Promise 的 then() 处理,但不处理异常</span></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;只指定成功回调,不处理异常错误&#x27;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>someAsyncThing()</code>函数产生的 Promise 对象, 内部有语法错误。</p><blockquote><ul><li>浏览器运行到这一行, 会打印出错误提示<code>Uncaught (in promise) ReferenceError: hong is not defined</code></li><li>但是不会退出进程、终止脚本执行, 2 秒之后还是会输出<code>努力学习的汪</code>。</li><li>这就是说，Promise 内部的错误不会影响到 Promise 外部的代码, 通俗的说法就是“Promise 会吃掉错误”。</li></ul></blockquote></blockquote><h5 id="h-catch-方法后还能跟-then-方法"><a href="#h-catch-方法后还能跟-then-方法" class="headerlink" title="h) catch()方法后还能跟 then() 方法"></a>h) catch()方法后还能跟 then() 方法</h5><blockquote><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法, 这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象, 因此后面还可以接着调用<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错, 因为 hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>()</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捉到错误咯:&#x27;</span>, error)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误捕获后我还要浪&#x27;</span>) &#125;);</span><br><span class="line">&gt;<span class="comment">//捉到错误咯: ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//错误捕获后我还要浪</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch()</code>方法指定的回调函数, 会接着运行后面那个<code>then()</code>方法指定的回调函数。</p><p>如果没有报错, 则会跳过<code>catch()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;硬是成功了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捉错误&#x27;</span>, error) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch后面的then: &#x27;</span>,v) );</span><br><span class="line">&gt;<span class="comment">//catch后面的then:  硬是成功了</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错, 跳过了<code>catch()</code>方法, 直接执行后面的<code>then()</code>方法。此时, 要是<code>then()</code>方法里面报错, 就与前面的<code>catch()</code>无关了。</p></blockquote><h5 id="i-catch-方法之中-还能再抛出错误"><a href="#i-catch-方法之中-还能再抛出错误" class="headerlink" title="i) catch()方法之中, 还能再抛出错误"></a>i) <code>catch()</code>方法之中, 还能再抛出错误</h5><blockquote><p><code>catch()</code>方法之中, 还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错, 因为 hong 没有声明</span></span><br><span class="line">&gt;<span class="title function_">resolve</span>( hong );</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">someAsyncThing</span>()</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function">() =&gt;</span>  <span class="title function_">someOtherAsyncThing</span>()) </span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ctach:&#x27;</span>, error);</span><br><span class="line"> <span class="comment">// 下面一行会报错, 因为 sum 没有声明</span></span><br><span class="line">  sum ++;</span><br><span class="line">&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获后的then()&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ctach: [ReferenceError: hong is not defined]</span></span><br><span class="line">&gt;<span class="comment">// Uncaught (in promise) ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>catch()</code>方法抛出一个错误, 因为后面没有别的<code>catch()</code>方法了, 导致这个错误不会被捕获, 也不会传递到外层。如果改写一下, 结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch: &#x27;</span>, error);</span><br><span class="line">&gt;<span class="comment">// 下面一行会报错, 因为 sum 没有声明</span></span><br><span class="line">&gt;sum ++;</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;catch()后的catch: &#x27;</span>, error);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">//catch:  ReferenceError: hong is not defined</span></span><br><span class="line">&gt;<span class="comment">//catch()后的catch:  ReferenceError: sum is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中, 第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p></blockquote><h4 id="③-Promise-prototype-finally"><a href="#③-Promise-prototype-finally" class="headerlink" title="③ Promise.prototype.finally()"></a>③ Promise.prototype.finally()</h4><blockquote><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何, 都会执行的操作。该方法是 <code>ES2018</code> 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">&gt;.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, 不管<code>promise</code>最后的状态, 在执行完<code>then</code>或<code>catch</code>指定的回调函数以后, 都会执行<code>finally</code>方法指定的回调函数。</p><blockquote><ul><li><code>finally</code>方法的回调函数不接受任何参数, </li><li>这意味着没有办法知道, 前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。</li><li>这表明, <code>finally</code>方法里面的操作, 应该是与状态无关的, 不依赖于 Promise 的执行结果。</li></ul></blockquote></blockquote><h5 id="a-finally本质上是then方法的特例"><a href="#a-finally本质上是then方法的特例" class="headerlink" title="a) finally本质上是then方法的特例"></a>a) <code>finally</code>本质上是<code>then</code>方法的特例</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;promise</span><br><span class="line">&gt;.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">result</span> =&gt;</span>  result ,</span><br><span class="line">&gt;<span class="function"><span class="params">error</span> =&gt;</span>  <span class="keyword">throw</span> error</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure><p>上面代码中, 如果不使用<code>finally</code>方法, 同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法, 则只需要写一次。</p></blockquote><h5 id="b-它的实现"><a href="#b-它的实现" class="headerlink" title="b) 它的实现"></a>b) 它的实现</h5><blockquote><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">&gt;<span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中, 不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>, 都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到, <code>finally</code>方法总是会返回原来的值(传入什么即传出什么)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// resolve 的值是 undefined</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// resolve 的值是 2</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 undefined</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// reject 的值是 3</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210927135255264.png" alt="image-20210927135255264"> </p></blockquote><h4 id="④-Promise-all"><a href="#④-Promise-all" class="headerlink" title="④ Promise.all()"></a>④ Promise.all()</h4><blockquote><p><code>Promise.all()</code>方法用于将多个 Promise 实例, 包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.all()</code>方法接受一个数组作为参数, </li><li><code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例, 如果不是, 就会先调用下面讲到的<code>Promise.resolve</code>方法, 将参数转为 Promise 实例, 再进一步处理。</li><li>另外, <code>Promise.all()</code>方法的参数可以不是数组, 但必须具有 Iterator 接口, 且返回的每个成员都是 Promise 实例。</li></ul></blockquote></blockquote><h5 id="a-返回的状态由什么决定"><a href="#a-返回的状态由什么决定" class="headerlink" title="a) 返回的状态由什么决定?"></a>a) 返回的状态由什么决定?</h5><blockquote><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定, 分成两种情况。</p><blockquote><ol><li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>, <code>p</code>的状态才会变成<code>fulfilled</code>, 此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组, 传递给<code>p</code>的回调函数。</li><li>只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>, <code>p</code>的状态就变成<code>rejected</code>, 此时第一个被<code>reject</code>的实例的返回值, 会传递给<code>p</code>的回调函数。</li></ol></blockquote><h6 id="下面是一个具体的例子。"><a href="#下面是一个具体的例子。" class="headerlink" title="下面是一个具体的例子。"></a>下面是一个具体的例子。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line">&gt;<span class="keyword">const</span> promises = [<span class="string">&#x27;hong&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">map</span>(item &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">getJSON</span>( item+<span class="string">&#x27;.json&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, <code>promises</code>是包含 6 个 Promise 实例的数组, 只有这 6 个实例的状态 <strong>都</strong> 变成<code>fulfilled</code>, 或者<strong>其中有一个变为<code>rejected</code></strong>, 才会调用<code>Promise.all</code>方法后面的回调函数。</p><h6 id="下面是另一个例子"><a href="#下面是另一个例子" class="headerlink" title="下面是另一个例子"></a>下面是另一个例子</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>(); <span class="comment">//假设定义了一个异步方法,此方法能拿到你需要的所有数据</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> booksPromise = databasePromise     <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部书本信息</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> userPromise = databasePromise    <span class="comment">//定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息</span></span><br><span class="line">&gt;.<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">&gt;booksPromise,</span><br><span class="line">&gt;userPromise</span><br><span class="line">&gt;])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中, <code>booksPromise</code>和<code>userPromise</code>是两个异步操作, 只有等到它们的结果都返回了, 才会触发<code>pickTopRecommendations</code>这个回调函数。</p></blockquote><h5 id="b-如果参数中的Promise实例定义了自己的catch方法"><a href="#b-如果参数中的Promise实例定义了自己的catch方法" class="headerlink" title="b) 如果参数中的Promise实例定义了自己的catch方法 ?"></a>b) 如果参数中的Promise实例定义了自己的catch方法 ?</h5><blockquote><p>注意, 如果作为参数的 Promise 实例, 自己定义了<code>catch</code>方法, 那么它一旦被<code>rejected</code>, 并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2自己的catch捕获: &#x27;</span>, e)</span><br><span class="line">&gt;<span class="keyword">return</span> e; <span class="comment">//异常获取后原样返回,不做修改</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//p2自己的catch捕获:  Error: 报错了</span></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的成功回调:  (2) [&#x27;hello&#x27;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中, </p><blockquote><ul><li><code>p1</code>会<code>resolved</code>, <code>p2</code>首先会<code>rejected</code></li><li>但是<code>p2</code>有自己的<code>catch</code>方法, 该方法返回的是一个新的 Promise 实例, <code>p2</code>指向的实际上是这个实例。</li><li>该实例执行完<code>catch</code>方法后, 也会变成<code>resolved</code>, 导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code></li><li>因此会调用<code>then</code>方法指定的回调函数, 而不会调用<code>catch</code>方法指定的回调函数</li></ul></blockquote></blockquote><h5 id="c-如果参数中的Promise实例-没有-定义自己的catch方法"><a href="#c-如果参数中的Promise实例-没有-定义自己的catch方法" class="headerlink" title="c)  如果参数中的Promise实例 没有 定义自己的catch方法 ?"></a>c)  如果参数中的Promise实例 <code>没有</code> 定义自己的catch方法 ?</h5><blockquote><p>如果<code>p2</code>没有自己的<code>catch</code>方法, 就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//定义一个状态将为成功的的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//定义一个将抛出错误的promise</span></span><br><span class="line">&gt;<span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>) &#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用 Promise.all 方法</span></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Promise.all 方法中的成功回调: &#x27;</span>, result))</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; Promise.all 方法中的catch&quot;</span>, e));</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Promise.all 方法中的catch Error: 报错了</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="⑤-Promise-race"><a href="#⑤-Promise-race" class="headerlink" title="⑤ Promise.race()"></a>⑤ Promise.race()</h4><blockquote><p><code>Promise.race()</code>方法同样是将多个 Promise 实例, 包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中, 只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态, <code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值, 就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样, 如果不是 Promise 实例, 就会先调用下面讲到的<code>Promise.resolve()</code>方法, 将参数转为 Promise 实例, 再进一步处理。</p></blockquote><h5 id="a-举个简单的🌰"><a href="#a-举个简单的🌰" class="headerlink" title="a) 举个简单的🌰"></a>a) 举个简单的🌰</h5><blockquote><p>如p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">&gt;&#125;, <span class="number">1000</span>);</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">//调用</span></span><br><span class="line">&gt;<span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-举个应用实🌰"><a href="#b-举个应用实🌰" class="headerlink" title="b) 举个应用实🌰"></a>b) 举个应用实🌰</h5><blockquote><p>下面是一个例子, 如果指定时间内没有获得结果, 就将 Promise 的状态变为<code>reject</code>, 否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求超时!!!!&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;]);</span><br><span class="line"></span><br><span class="line">&gt;p</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中, 如果 5 秒之内<code>fetch</code>方法无法返回结果, 变量<code>p</code>的状态就会变为<code>rejected</code>, 从而触发<code>catch</code>方法指定的回调函数。</p><p>是不是很好用又简单</p></blockquote><h4 id="⑥-Promise-allSettled"><a href="#⑥-Promise-allSettled" class="headerlink" title="⑥ Promise.allSettled()"></a>⑥ Promise.allSettled()</h4><blockquote><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数, 包装成一个新的 Promise 实例。</p><p><strong>只有等到所有这些参数实例都返回结果</strong>, 不管是<code>fulfilled</code>还是<code>rejected</code>, 包装实例才会结束。</p><p>该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p></blockquote><h5 id="a-举个简单的🌰-1"><a href="#a-举个简单的🌰-1" class="headerlink" title="a) 举个简单的🌰"></a>a) 举个简单的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;loading = <span class="literal">true</span>; <span class="comment">//请求前将 loading 改为true ; 页面出现滚动加载图标蒙层</span></span><br><span class="line">&gt;<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line">&gt;loading = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面代码对服务器发出三个请求, 等到三个请求都结束, 不管请求成功还是失败, 加载的滚动图标就会消失。</p></blockquote><h5 id="b-该方法返回的新的-Promise-实例-一旦结束-状态总是fulfilled-不会变成rejected"><a href="#b-该方法返回的新的-Promise-实例-一旦结束-状态总是fulfilled-不会变成rejected" class="headerlink" title="b)  该方法返回的新的 Promise 实例, 一旦结束, 状态总是fulfilled, 不会变成rejected"></a>b)  该方法返回的新的 Promise 实例, 一旦结束, 状态总是<code>fulfilled</code>, 不会变成<code>rejected</code></h5><blockquote><p>该方法返回的新的 Promise 实例, 一旦结束, 状态总是<code>fulfilled</code>, 不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组, 每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;返回成功状态的promise&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;返回失败状态的promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line">&gt;<span class="comment">// Promise.allSettled 得到的新实例状态只会是 `fulfilled`</span></span><br><span class="line">&gt;allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">//注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">/*</span></span><br><span class="line"><span class="comment">&gt;[</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;返回成功状态的promise&quot; &#125;,</span></span><br><span class="line"><span class="comment">&#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;返回失败状态的promise&quot; &#125;</span></span><br><span class="line"><span class="comment">&gt;]</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>, 状态只可能变成<code>fulfilled</code>(注意,是 <strong>allSettledPromise</strong> 的状态,而不是内部的promise实例)</li><li>它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象, 对应的是传入<code>Promise.allSettled()</code>的 Promise 实例。</li><li>每个对象都有<code>status</code>属性, 该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。</li><li><code>fulfilled</code>时, 对象有<code>value</code>属性, <code>rejected</code>时有<code>reason</code>属性, 对应两种状态的返回值。</li></ul></blockquote></blockquote><h5 id="c-举个返回值用法的🌰"><a href="#c-举个返回值用法的🌰" class="headerlink" title="c) 举个返回值用法的🌰"></a>c) 举个返回值用法的🌰</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [ <span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>) ];</span><br><span class="line">&gt;<span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出成功的请求</span></span><br><span class="line">&gt;<span class="keyword">const</span> successfulPromises = results.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 过滤出失败的请求, 并取得它们的失败原因</span></span><br><span class="line">&gt;<span class="keyword">const</span> errors = results</span><br><span class="line">&gt;.<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure><p>有时候, 我们不关心异步操作的结果, 只关心这些操作有没有结束。这时, <code>Promise.allSettled()</code>方法就很有用。如果没有这个方法, 想要确保所有操作都结束, 就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> urls = [ <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span> ,<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>];</span><br><span class="line">&gt;<span class="keyword">const</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">fetch</span>(x));</span><br><span class="line">&gt;<span class="comment">//举例用 Promise.all 尝试实现,很明显,难以实现</span></span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requests);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;至少一个请求失败, 其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的, 写起来很麻烦, 有了<code>Promise.allSettled()</code>, 这就很容易了</p></blockquote><h4 id="⑦-Promise-any"><a href="#⑦-Promise-any" class="headerlink" title="⑦ Promise.any()"></a>⑦ Promise.any()</h4><blockquote><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数, 包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态, 包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态, 包装实例就会变成<code>rejected</code>状态。</p></blockquote><h5 id="a-与-Promise-race-方法的区别"><a href="#a-与-Promise-race-方法的区别" class="headerlink" title="a) 与 Promise.race() 方法的区别"></a>a) 与 <code>Promise.race()</code> 方法的区别</h5><blockquote><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像, 只有一点不同, 就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> promises = [</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;https://github.com/Hongjilin&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">&gt;<span class="title function_">fetch</span>(<span class="string">&#x27;./hong.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">&gt;];</span><br><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>, <code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>, 那么<code>await</code>命令就会抛出错误。</p></blockquote><h5 id="b-Promise-any-抛出的错误"><a href="#b-Promise-any-抛出的错误" class="headerlink" title="b) Promise.any() 抛出的错误"></a>b) Promise.any() 抛出的错误</h5><blockquote><p><code>Promise.any()</code>抛出的错误, 不是一个一般的错误, 而是一个 AggregateError 实例。它相当于一个数组, 每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">AggregateError</span>() <span class="keyword">extends</span> <span class="title class_">Array</span> -&gt; <span class="title class_">AggregateError</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">AggregateError</span>();</span><br><span class="line">&gt;err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">&gt;err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line">&gt;<span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure><p>捕捉错误时, 如果不用<code>try...catch</code>结构和 await 命令, 可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>(promises).<span class="title function_">then</span>(</span><br><span class="line">&gt;<span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="comment">// All of the promises were rejected.</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;);</span><br></pre></td></tr></table></figure></blockquote><h5 id="c-再举个🌰"><a href="#c-再举个🌰" class="headerlink" title="c) 再举个🌰"></a>c) 再举个🌰</h5><blockquote><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;失败了&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> alsoRejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;太失败了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>([resolved, rejected, alsoRejected]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 成功</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">any</span>([rejected, alsoRejected]).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(results);  <span class="comment">//AggregateError: All promises were rejected</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败</p></blockquote><h4 id="⑧-Promise-resolve"><a href="#⑧-Promise-resolve" class="headerlink" title="⑧ Promise.resolve()"></a>⑧ Promise.resolve()</h4><blockquote><p>有时需要将现有对象转为 Promise 对象, <code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象, 转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况</p></blockquote><h5 id="a-参数是一个-Promise-实例"><a href="#a-参数是一个-Promise-实例" class="headerlink" title="a) 参数是一个 Promise 实例"></a>a) 参数是一个 Promise 实例</h5><blockquote><p>如果参数是 Promise 实例, 那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p></blockquote><h5 id="b-参数是一个thenable对象"><a href="#b-参数是一个thenable对象" class="headerlink" title="b) 参数是一个thenable对象"></a><strong>b) 参数是一个<code>thenable</code>对象</strong></h5><blockquote><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象, 比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象, 然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> thenable = &#123;</span><br><span class="line"><span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;成功&#x27;</span>) &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">&gt;p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// &#x27;成功&#x27;</span></span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中, <code>thenable</code>对象的<code>then()</code>方法执行后, 对象<code>p1</code>的状态就变为<code>resolved</code>, 从而立即执行最后那个<code>then()</code>方法指定的回调函数, 输出 **’成功’**。 </p></blockquote><h5 id="c-参数不是具有then-方法的对象-或根本就不是对象"><a href="#c-参数不是具有then-方法的对象-或根本就不是对象" class="headerlink" title="c) 参数不是具有then()方法的对象, 或根本就不是对象"></a>c) 参数不是具有<code>then()</code>方法的对象, 或根本就不是对象</h5><blockquote><p>如果参数是一个原始值, 或者是一个不具有<code>then()</code>方法的对象, 则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象, 状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。</p><blockquote><ul><li>由于字符串 <code>努力学习的汪</code> 不属于异步操作（判断方法是字符串对象不具有 then 方法）</li><li>返回 Promise 实例的状态从一生成就是<code>resolved</code>, 所以回调函数会立即执行</li><li><code>Promise.resolve()</code>方法的参数会同时传给回调函数作为其参数</li></ul></blockquote></blockquote><h5 id="d-不带有任何参数"><a href="#d-不带有任何参数" class="headerlink" title="d) 不带有任何参数"></a>d) 不带有任何参数</h5><blockquote><p><code>Promise.resolve()</code>方法允许调用时不带参数, 直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以, 如果希望得到一个 Promise 对象, 比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是, 立即<code>resolve()</code>的 Promise 对象, 是在本轮“事件循环”（event loop）的结束时执行, 而不是在下一轮“事件循环”的开始时 –&gt; 不懂的同学请看 <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0#4%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%9E%8Bevent-loop%E6%9C%BA%E5%88%B6">JavaScript笔记中的#4事件循环模型event-loop机制</a> ,本人在此有进行详细的解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>); <span class="comment">//这里是新的一轮事件循环</span></span><br><span class="line">&gt;&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>); <span class="comment">//本轮同步代码结束后,新一轮事件循环前,就执行</span></span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// one</span></span><br><span class="line">&gt;<span class="comment">// two</span></span><br><span class="line">&gt;<span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行, <code>Promise.resolve()</code>在本轮“事件循环”结束时执行, <code>console.log(&#39;one&#39;)</code>则是立即执行, 因此最先输出。</p></blockquote><h4 id="⑨-Promise-reject"><a href="#⑨-Promise-reject" class="headerlink" title="⑨ Promise.reject()"></a>⑨ Promise.reject()</h4><blockquote><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例, 该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;<span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>, 状态为<code>rejected</code>, 回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数, 会原封不动地作为<code>reject</code>的理由, 变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)</span><br><span class="line">&gt;<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中, <code>Promise.reject()</code>方法的参数是一个字符串, 后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p></blockquote><h4 id="⑩-Promise-try"><a href="#⑩-Promise-try" class="headerlink" title="⑩ Promise.try()"></a>⑩ Promise.try()</h4><blockquote><p>实际开发中, 经常遇到一种情况：不知道或者不想区分, 函数<code>f</code>是同步函数还是异步操作, 但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作, 都用<code>then</code>方法指定下一步流程, 用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点, 就是如果<code>f</code>是同步函数, 那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// next</span></span><br><span class="line">&gt;<span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中, 函数<code>f</code>是同步的, 但是用 Promise 包装了以后, 就变成异步执行了。</p><h6 id="那么有没有一种方法-让同步函数同步执行-异步函数异步执行-并且让它们具有统一的-API-呢？"><a href="#那么有没有一种方法-让同步函数同步执行-异步函数异步执行-并且让它们具有统一的-API-呢？" class="headerlink" title="那么有没有一种方法, 让同步函数同步执行, 异步函数异步执行, 并且让它们具有统一的 API 呢？"></a>那么有没有一种方法, 让同步函数同步执行, 异步函数异步执行, 并且让它们具有统一的 API 呢？</h6></blockquote><h5 id="a-写法一-用async函数来写"><a href="#a-写法一-用async函数来写" class="headerlink" title="a) 写法一 : 用async函数来写"></a>a) 写法一 : 用<code>async</code>函数来写</h5><blockquote><p>该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中, 第二行是一个立即执行的匿名函数, 会立即执行里面的<code>async</code>函数, 因此如果<code>f</code>是同步的, 就会得到同步的结果；如果<code>f</code>是异步的, 就可以用<code>then</code>指定下一步, 就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure><p>需要注意的是, <code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以, 如果想捕获错误, 要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-写法二-使用new-Promise"><a href="#b-写法二-使用new-Promise" class="headerlink" title="b)  写法二 : 使用new Promise()"></a>b)  写法二 : 使用<code>new Promise()</code></h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;(</span><br><span class="line">&gt;<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">&gt;<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">f</span>())</span><br><span class="line">&gt;)</span><br><span class="line">&gt;)();</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数, 执行<code>new Promise()</code>。这种情况下, 同步函数也是同步执行的。</p></blockquote><h5 id="c-Promise-try的引出"><a href="#c-Promise-try的引出" class="headerlink" title="c) Promise.try的引出"></a>c) Promise.try的引出</h5><blockquote><p>鉴于这是一个很常见的需求, 所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>, 提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// now</span></span><br><span class="line">&gt;<span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上, <code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>, 早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制, 所以如果想用<code>then</code>方法管理流程, 最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>, 其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中, <code>database.users.get()</code>返回一个 Promise 对象, 如果抛出异步错误, 可以用<code>catch</code>方法捕获, 就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误, 具体要看实现方法）, 这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line">&gt;database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;<span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了, 这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">try</span>(<span class="function">() =&gt;</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">&gt;.<span class="title function_">then</span>(...)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>事实上, <code>Promise.try</code>就是模拟<code>try</code>代码块, 就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p></blockquote><hr><h3 id="Ⅲ-更多-Promise-知识点"><a href="#Ⅲ-更多-Promise-知识点" class="headerlink" title="Ⅲ - 更多 Promise 知识点"></a>Ⅲ - 更多 Promise 知识点</h3><blockquote><p>此知识点因为 <strong>很重要</strong> ,此处将只列出ES6中关于Promise的用法详解,像是 <strong>自定义Promise手撕代码</strong> 、<strong>Promise+async+await</strong>、<strong>Promise的宏任务与微任务</strong> ….等等都不会在此处记载</p><p>更多完整关于Promise的知识点可以看这里 –&gt; <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Promise学习笔记</a></strong> </p></blockquote><h2 id="17、Generator"><a href="#17、Generator" class="headerlink" title="17、Generator"></a>17、Generator</h2><h3 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ - 概述"></a>Ⅰ - 概述</h3><h4 id="①-定义与声明"><a href="#①-定义与声明" class="headerlink" title="① 定义与声明"></a>① 定义与声明</h4><blockquote><ol><li><p>定义：Generator 函数是 ES6 提供的一种异步编程解决方案, 语法行为与传统函数完全不同</p></li><li><p>形式：调用<code>Generator函数</code>(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p></li><li><p>声明：<code>function* Func() &#123;&#125;</code></p></li><li><p>理解 :</p></li></ol><blockquote><h6 id="Generator-函数有多种理解角度"><a href="#Generator-函数有多种理解角度" class="headerlink" title="Generator 函数有多种理解角度"></a>Generator 函数有多种理解角度</h6><p>语法上:</p><ul><li>首先可以把它理解成: Generator 函数是一个状态机, 封装了多个内部状态</li><li>执行 Generator 函数会返回一个遍历器对象, 也就是说 : Generator 函数除了状态机, 还是一个遍历器对象生成函数。返回的遍历器对象, 可以依次遍历 Generator 函数内部的每一个状态。</li></ul><p>形式上Generator 函数是一个普通函数,但它有两个特征</p><ul><li><strong>关键字与函数名之间有一个星号</strong></li><li>函数体内部使用<code>yield</code>表达式, 定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）</li></ul></blockquote><ol start="5"><li>方法</li></ol><ul><li>**next()**：使指针移向下一个状态, 返回<code>&#123; done, value &#125;</code>(入参会被当作上一个<code>yield命令表达式</code>的返回值)</li><li>**return()**：返回指定值且终结遍历<code>Generator函数</code>, 返回<code>&#123; done: true, value: 入参 &#125;</code></li><li>**throw()**：在<code>Generator函数</code>体外抛出错误, 在<code>Generator函数</code>体内捕获错误, 返回自定义的<code>new Errow()</code></li></ul></blockquote><h4 id="②-yield命令"><a href="#②-yield命令" class="headerlink" title="② yield命令"></a>② yield命令</h4><blockquote><p>yield命令：由于 Generator 函数返回的遍历器对象, 只有调用<code>next</code>方法才会遍历下一个内部状态, 所以其实提供了一种可以暂停执行的函数 : <code>yield</code>表达式就是暂停标志。</p><ul><li>遇到<code>yield命令</code>就暂停执行后面的操作, 并将其后表达式的值作为返回对象的<code>value</code></li><li>下次调用<code>next()</code>时, 再继续往下执行直到遇到下一个<code>yield命令</code></li><li>没有再遇到<code>yield命令</code>就一直运行到<code>Generator函数</code>结束, 直到遇到<code>return语句</code>为止并将其后表达式的值作为返回对象的<code>value</code></li><li><code>Generator函数</code>没有<code>return语句</code>则返回对象的<code>value</code>为<code>undefined</code></li></ul><p>yield*命令：在一个<code>Generator函数</code>里执行另一个<code>Generator函数</code>(后随具有<code>Iterator接口</code>的数据结构)</p></blockquote><h4 id="③-遍历与其上下文"><a href="#③-遍历与其上下文" class="headerlink" title="③ 遍历与其上下文"></a>③ 遍历与其上下文</h4><blockquote><p>遍历：通过<code>for-of</code>自动调用<code>next()</code></p><p>作为对象属性</p><ul><li>全写：<code>const obj = &#123; method: function*() &#123;&#125; &#125;</code></li><li>简写：<code>const obj = &#123; * method() &#123;&#125; &#125;</code></li></ul><p>上下文：执行产生的<code>上下文环境</code>一旦遇到<code>yield命令</code>就会暂时退出堆栈(但并不消失), 所有变量和对象会冻结在<code>当前状态</code>, 等到对它执行<code>next()</code>时, 这个<code>上下文环境</code>又会重新加入调用栈, 冻结的变量和对象恢复执行</p></blockquote><h4 id="④-方法异同"><a href="#④-方法异同" class="headerlink" title="④ 方法异同"></a>④ 方法异同</h4><blockquote><p>相同点：<code>next()</code>、<code>throw()</code>、<code>return()</code>本质上是同一件事, 作用都是让函数恢复执行且使用不同的语句替换<code>yield命令</code></p><p>不同点</p><ul><li>**next()**：将<code>yield命令</code>替换成一个<code>值</code></li><li>**return()**：将<code>yield命令</code>替换成一个<code>return语句</code></li><li>**throw()**：将<code>yield命令</code>替换成一个<code>throw语句</code></li></ul></blockquote><h4 id="⑤-应用场景"><a href="#⑤-应用场景" class="headerlink" title="⑤ 应用场景"></a>⑤ 应用场景</h4><blockquote><ol><li>异步操作同步化表达</li><li>控制流管理</li><li>为对象部署Iterator接口：把<code>Generator函数</code>赋值给对象的<code>Symbol.iterator</code>, 从而使该对象具有<code>Iterator接口</code></li><li>作为具有Iterator接口的数据结构</li></ol></blockquote><h4 id="⑥-重点难点"><a href="#⑥-重点难点" class="headerlink" title="⑥ 重点难点"></a>⑥ 重点难点</h4><blockquote><ol><li>每次调用<code>next()</code>, 指针就从<code>函数头部</code>或<code>上次停下的位置</code>开始执行, 直到遇到下一个<code>yield命令</code>或<code>return语句</code>为止</li><li>函数内部可不用<code>yield命令</code>, 但会变成单纯的<code>暂缓执行函数</code>(还是需要<code>next()</code>触发)</li></ol><ul><li><code>yield命令</code>是暂停执行的标记, <code>next()</code>是恢复执行的操作</li><li><code>yield命令</code>用在另一个表达式中必须放在<code>圆括号</code>里</li><li><code>yield命令</code>用作函数参数或放在赋值表达式的右边, 可不加<code>圆括号</code></li><li><code>yield命令</code>本身没有返回值, 可认为是返回<code>undefined</code></li><li><code>yield命令表达式</code>为惰性求值, 等<code>next()</code>执行到此才求值</li></ul><ol start="3"><li>函数调用后生成遍历器对象, 此对象的<code>Symbol.iterator</code>是此对象本身</li><li>在函数运行的不同阶段, 通过<code>next()</code>从外部向内部注入不同的值, 从而调整函数行为</li></ol><ul><li>首个<code>next()</code>用来启动遍历器对象, 后续才可传递参数</li><li>想首次调用<code>next()</code>时就能输入值, 可在函数外面再包一层</li><li>一旦<code>next()</code>返回对象的<code>done</code>为<code>true</code>, <code>for-of</code>遍历会中止且不包含该返回对象</li></ul><ol start="5"><li>函数内部部署<code>try-finally</code>且正在执行<code>try</code>, 那么<code>return()</code>会导致立刻进入<code>finally</code>, 执行完<code>finally</code>以后整个函数才会结束</li></ol><ul><li>函数内部没有部署<code>try-catch</code>, <code>throw()</code>抛错将被外部<code>try-catch</code>捕获</li><li><code>throw()</code>抛错要被内部捕获, 前提是必须&#96;至少执行过一次next()</li><li><code>throw()</code>被捕获以后, 会附带执行下一条yield命令</li></ul><p>函数还未开始执行, 这时<code>throw()</code>抛错只可能抛出在函数外部</p></blockquote><h4 id="⑦-首次next-可传值"><a href="#⑦-首次next-可传值" class="headerlink" title="⑦ 首次next()可传值"></a>⑦ 首次next()可传值</h4><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Wrapper</span>(<span class="params">func</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> generator = <span class="title function_">func</span>(...args);</span><br><span class="line">       generator.<span class="title function_">next</span>();</span><br><span class="line">       <span class="keyword">return</span> generator;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> print = <span class="title class_">Wrapper</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第一次next可传值: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;说点啥&quot;</span>;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">print</span>().<span class="title function_">next</span>(<span class="string">&quot;努力学习的汪&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20211021142129505.png" alt="image-20211021142129505"> </p></blockquote><h3 id="Ⅱ-next方法的参数"><a href="#Ⅱ-next方法的参数" class="headerlink" title="Ⅱ - next方法的参数"></a>Ⅱ - next方法的参数</h3><blockquote><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">   <span class="keyword">if</span>(reset) &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">&gt;g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">&gt;g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">&gt;g.<span class="title function_">next</span>(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p></blockquote><h4 id="①-举个栗子-2"><a href="#①-举个栗子-2" class="headerlink" title="①  举个栗子"></a>①  举个栗子</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line"> <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line"> <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">&gt;a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">&gt;a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">&gt;a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">&gt;b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">&gt;b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">&gt;b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>上面代码中</strong>:</p><ul><li>第二次运行<code>next</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。</li><li>第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</li></ul><h6 id="如果向next方法提供参数，返回结果就完全不一样了"><a href="#如果向next方法提供参数，返回结果就完全不一样了" class="headerlink" title="如果向next方法提供参数，返回结果就完全不一样了"></a>如果向<code>next</code>方法提供参数，返回结果就完全不一样了</h6><ul><li>上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；</li><li>第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；</li><li>第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</li></ul><p><strong>注意</strong>:</p><blockquote><ul><li>由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的</li><li>V8 引擎直接忽略第一次使用<code>next</code>方法时的参数</li><li>只有从第二次使用<code>next</code>方法开始，参数才是有效的。</li><li><strong>从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</strong></li></ul></blockquote></blockquote><h4 id="②-再举一个通过next方法的参数，向-Generator-函数内部输入值的🌰"><a href="#②-再举一个通过next方法的参数，向-Generator-函数内部输入值的🌰" class="headerlink" title="② 再举一个通过next方法的参数，向 Generator 函数内部输入值的🌰"></a>② 再举一个通过<code>next</code>方法的参数，向 Generator 函数内部输入值的🌰</h4><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">dataConsumer</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是首次运行&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第一次传入的值:  <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第二次传入的值: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;最后结果&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> genObj = <span class="title function_">dataConsumer</span>();</span><br><span class="line">&gt;genObj.<span class="title function_">next</span>();</span><br><span class="line">&gt;<span class="comment">//这是首次运行</span></span><br><span class="line">&gt;genObj.<span class="title function_">next</span>(<span class="string">&#x27;hongjilin&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 第一次传入的值: hongjilin</span></span><br><span class="line">&gt;genObj.<span class="title function_">next</span>(<span class="string">&#x27;努力学习的汪&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 第二次传入的值: 努力学习的汪</span></span><br></pre></td></tr></table></figure><p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向 Generator 函数输入值，然后打印出来</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20211021145837119.png" alt="image-20211021145837119"> </p></blockquote><h4 id="③-想要第一次调用-next-时就能输入值怎么做"><a href="#③-想要第一次调用-next-时就能输入值怎么做" class="headerlink" title="③ 想要第一次调用 next() 时就能输入值怎么做?"></a>③ 想要第一次调用 next() 时就能输入值怎么做?</h4><blockquote><p>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">generatorFunction</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> generatorObject = <span class="title function_">generatorFunction</span>(...args);</span><br><span class="line">   generatorObject.<span class="title function_">next</span>();</span><br><span class="line">   <span class="keyword">return</span> generatorObject;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> wrapped = <span class="title function_">wrapper</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`首次输入: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;结束&#x27;</span>;</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">wrapped</span>().<span class="title function_">next</span>(<span class="string">&#x27;努力学习的汪!&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，Generator 函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法就输入参数的。</p><p>实际上原理就是: 调用时已经将其运行了一次,你传入参数扔是第二次调用才传入的,代码上看像是第一次调用</p></blockquote><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20211021150237896.png" alt="image-20211021150237896"> </p></blockquote><h3 id="Ⅲ-for…of循环"><a href="#Ⅲ-for…of循环" class="headerlink" title="Ⅲ - for…of循环"></a>Ⅲ - for…of循环</h3><blockquote><p><code>for...of</code>循环可以自动遍历 <strong>Generator</strong> 函数运行时生成的 <code>Iterator</code></p><p>此部分暂停,后续更新</p></blockquote><h2 id="18、异步操作和Async函数"><a href="#18、异步操作和Async函数" class="headerlink" title="18、异步操作和Async函数"></a>18、异步操作和Async函数</h2><blockquote><p>异步编程对JS语言十分重要,因为语言本身的执行环境是 <strong>单线程</strong> 的,如果没有异步编程,很容易出现卡死、堵塞的鲜血</p><p>ES6诞生以前,异步编程的方法大概分为下面四种:</p><ul><li>回调函数</li><li>事件监听</li><li>发布&#x2F;订阅</li><li>Promise对象</li></ul><p>ES6将JS异步编程带入了一个全新的阶段,ES7的<code>Async</code>函数更是提出了异步编程的一个极好的解决方案</p></blockquote><h3 id="Ⅰ-概述与总结-3"><a href="#Ⅰ-概述与总结-3" class="headerlink" title="Ⅰ - 概述与总结"></a>Ⅰ - 概述与总结</h3><blockquote><h4 id="一、Async的定义与概念"><a href="#一、Async的定义与概念" class="headerlink" title="一、Async的定义与概念"></a>一、Async的定义与概念</h4><ol><li>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)<blockquote><ol start="2"><li>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</li></ol></blockquote></li><li>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code><blockquote><ol start="4"><li>声明:</li></ol></blockquote></li></ol><blockquote><ul><li>具名函数：<code>async function Func() &#123;&#125;</code></li></ul></blockquote><ul><li>函数表达式：<code>const func = async function() &#123;&#125;</code><blockquote><ul><li>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></li></ul></blockquote></li><li>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></li><li>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></li></ul><ol start="5"><li>await命令：等待当前Promise对象状态变更完毕</li></ol><blockquote><ul><li>正常情况：后面是Promise对象则返回其结果，否则返回对应的值</li></ul></blockquote><ul><li>后随<code>Thenable对象</code>：将其等同于Promise对象返回其结果<blockquote></blockquote></li></ul><ol start="6"><li>错误处理：将<code>await命令Promise对象</code>放到<code>try-catch</code>中(可放多个)</li></ol><blockquote><h6 id="二、Async对Generator改进"><a href="#二、Async对Generator改进" class="headerlink" title="二、Async对Generator改进"></a>二、Async对Generator改进</h6></blockquote><ul><li>内置执行器</li><li>更好的语义</li><li>更广的适用性</li><li>返回值是Promise对象</li></ul><h6 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h6><blockquote><p>按顺序(同步)完成异步操作</p></blockquote><h6 id="四、重点难点"><a href="#四、重点难点" class="headerlink" title="四、重点难点"></a>四、重点难点</h6><ol><li><code>Async函数</code>返回<code>Promise对象</code>，可使用<code>then()</code>添加回调函数</li><li>内部<code>return返回值</code>会成为后续<code>then()</code>的出参</li><li>内部抛出错误会导致返回的Promise对象变为<code>rejected状态</code>，被<code>catch()</code>接收到</li><li>返回的Promise对象必须等到内部所有<code>await命令Promise对象</code>执行完才会发生状态改变，除非遇到<code>return语句</code>或<code>抛出错误</code></li><li>任何一个<code>await命令Promise对象</code>变为<code>rejected状态</code>，整个<code>Async函数</code>都会中断执行</li><li>希望即使前一个异步操作失败也不要中断后面的异步操作</li></ol><ul><li>将<code>await命令Promise对象</code>放到<code>try-catch</code>中</li><li><code>await命令Promise对象</code>跟一个<code>catch()</code></li></ul><ol start="7"><li><code>await命令Promise对象</code>可能变为<code>rejected状态</code>，最好把其放到<code>try-catch</code>中</li><li>多个<code>await命令Promise对象</code>若不存在继发关系，最好让它们同时触发(异步机制的存在本身就是为了提高效率)</li><li><code>await命令</code>只能用在<code>Async函数</code>之中，否则会报错</li><li>数组使用<code>forEach()</code>执行<code>async/await</code>会失效，可使用<code>for-of</code>和<code>Promise.all()</code>代替</li><li>可保留运行堆栈，函数上下文随着<code>Async函数</code>的执行而存在，执行完成就消失</li></ol></blockquote><h3 id="Ⅱ-基本概念"><a href="#Ⅱ-基本概念" class="headerlink" title="Ⅱ -  基本概念"></a>Ⅱ -  基本概念</h3><blockquote><p>回顾一些基本概念</p></blockquote><h4 id="①-异步"><a href="#①-异步" class="headerlink" title="① 异步"></a>① 异步</h4><blockquote><p>所谓异步,简单说就是一个任务分成两段,先执行第一段,然后转而去执行更重要的其他任务,等做好了准备或者有空闲了,再来执行第二段</p><blockquote><p>栗子:有一个任务是读取文件进行处理</p><ul><li>任务的第一段是向操作系统发出请求,要求读取文件,然后程序执行其他任务</li><li>然后程序执行其他任务,等到操作系统返回了文件,我才接着执行任务的第二段(处理文件)</li><li>这种不连续的执行就叫做异步</li></ul></blockquote><p>相对应的,连续的执行就叫做同步,由于是连续执行,不能插入其他任务,如果 <strong>读取文件操作</strong> 转成同步操作的话,操作系统从硬盘读取文件的这段时间,就只能等待,造成’堵塞’</p></blockquote><h4 id="②-回调函数"><a href="#②-回调函数" class="headerlink" title="② 回调函数"></a>② 回调函数</h4><blockquote><p>JS语言对异步编程的实现就是 <strong>回调函数(callback)</strong>. 所谓回调函数:就是把任务的第二段单独写在一个函数里面,等到重新执行这个任务的时候就直接调用这个函数</p></blockquote><h5 id="a-举个栗子-6"><a href="#a-举个栗子-6" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><p>这时Node中常见的读取文件操作函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//读取文件操作</span></span><br><span class="line">&gt;fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fs&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><h6 id="上面代码中-readFile函数的第二个参数就是回调函数-也就是任务的第二段-等到操作系统返回-etc-fs-后-回调函数才会执行"><a href="#上面代码中-readFile函数的第二个参数就是回调函数-也就是任务的第二段-等到操作系统返回-etc-fs-后-回调函数才会执行" class="headerlink" title="上面代码中:readFile函数的第二个参数就是回调函数,也就是任务的第二段.等到操作系统返回 /etc/fs 后,回调函数才会执行"></a>上面代码中:<code>readFile</code>函数的第二个参数就是回调函数,也就是任务的第二段.等到操作系统返回 <code>/etc/fs</code> 后,回调函数才会执行</h6><p>引申的问题:为什么Nodejs约定回调函数的第一个参数,必须是错误对象err(如果没有错,该参数就是null)?</p><blockquote><p>原因是执行分成两段,这两段之间抛出的错误,程序无法捕捉,只能当作参数传入第二段中</p></blockquote></blockquote><h4 id="③-Promise"><a href="#③-Promise" class="headerlink" title="③ Promise"></a>③ Promise</h4><blockquote><p>回调函数本身没有问题,但是他的问题出现在多个回调函数嵌套时,俗称 <code>回调地狱</code>,如同下面这样:</p><p><img src="/k705.github.io/ES%E5%85%A8%E7%B3%BB%E5%88%97%E8%AF%A6%E7%BB%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Promise%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0_%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.jpg" alt="Promise系统学习_回调地狱"></p><p>而Promise的出现就是为了解决回调地狱的问题,但<strong>只是简单的改变格式</strong>, 并没有彻底解决上面的问题(还是会有一堆的then).真正要解决上述问题, 一定要利用promise再加上await和async关键字实现异步传同步</p><p>具体内容更可以看本人 <strong><a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Promise学习笔记</a></strong> </p></blockquote><h3 id="Ⅲ-Generator函数"><a href="#Ⅲ-Generator函数" class="headerlink" title="Ⅲ -  Generator函数"></a>Ⅲ -  Generator函数</h3><blockquote><p>更详细的内容看上面笔记,这里做个大致回顾</p></blockquote><h4 id="①-协程"><a href="#①-协程" class="headerlink" title="① 协程"></a>① 协程</h4><blockquote><p>传统的编程语言,早有异步编程的解决方案(其实是多任务的解决方案).其中一种叫做’协程(coroutine)’:意思是多个线程互相协作,完成异步任务</p><p>协程有点像函数却又有点像线程,它的运行流程大致如下:</p><ul><li>第一步:协程A开始执行</li><li>第二步:协程A执行到一半进入暂停,执行权转移到协程B</li><li>第三步:(一段时间后)协程B交还执行权</li><li>第四步:协程A恢复执行</li></ul><p>上面流程的协程A就是异步任务,因为它分成两段或者多段执行</p></blockquote><h5 id="a-举个栗子-7"><a href="#a-举个栗子-7" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> *<span class="title function_">asyncJob</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// ...其他代码</span></span><br><span class="line"> <span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line"> <span class="comment">// ...其他代码</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程,它的奥妙就在其中的<code>yield</code>命令,它表示执行到此处执行权将交给其他协程,也就是说<code>yield</code>命令是异步两个阶段的分界线</p><p>协程遇到<code>yield</code>命令就暂停,等到执行权返回,再从暂停的地方继续往后执行.它的最大优点就是代码的写法非常像同步操作</p></blockquote><h4 id="②-Generator函数的ming的概念"><a href="#②-Generator函数的ming的概念" class="headerlink" title="② Generator函数的ming的概念"></a>② Generator函数的ming的概念</h4><blockquote><p>Generator函数是协程在ES6的实现,最大的特点就是可以交出函数的执行权(即暂停执行)</p><p>整个Generator函数就是一个封装的异步任务或者说是异步任务的容器,异步操作需要暂停的地方都用<code>yield</code>语句注明,Generator函数的执行方法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">&gt;g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">&gt;g.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中调用Generator函数,会返回一个内部指针(即遍历器):这是Generator函数不同于普通函数的另一个地方,即执行它不会返回结果,返回的是指针对象.调用指针g的next方法,会移动内部指针(即执行异步函数的第一段)指向第一个遇到yield语句,上例是执行到<code>x+1</code>为止</p><p>换言之:next方法的作用是分阶段执行Generator函数,每次调用next方法,会返回一个对象表示当前阶段的信息(value属性和done属性)</p><ul><li>value属性:yield语句后面表达式的值,表示当前阶段的值</li><li>done属性:布尔值–&gt;表示Generator函数是否执行完毕(即是否还有下一个阶段)</li></ul></blockquote><h4 id="③-Generator函数的数据交换和错误处理"><a href="#③-Generator函数的数据交换和错误处理" class="headerlink" title="③ Generator函数的数据交换和错误处理"></a>③ Generator函数的数据交换和错误处理</h4><blockquote><p>Generator函数可以在暂停执行和恢复执行,这是它能封装异步任务的根本原因</p><p>除此之外它还有两个特性使它可以作为异步编程的完美解决方案:<strong>函数体内外的数据交换和错误处理机制</strong></p><ul><li>next方法返回值的value属性是Generator函数向外输出数据</li><li>next方法还可以接受参数,这是向Generator函数体内输入数据</li></ul></blockquote><h5 id="a-举个栗子-8"><a href="#a-举个栗子-8" class="headerlink" title="a) 举个栗子"></a>a) 举个栗子</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">yield</span> x + <span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">&gt;g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">&gt;g.<span class="title function_">next</span>(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中:</p><ul><li>第一个next方法的value属性,返回表达式<code>x+1</code>的值</li><li>第二个next方法带有参数 <code>2</code>,这个参数可以传入Generator函数作为上一个阶段异步任务的返回结果,所以这一步的value属性返回的就是2,且done为true</li></ul></blockquote><h5 id="b-再举个栗子"><a href="#b-再举个栗子" class="headerlink" title="b) 再举个栗子"></a>b) 再举个栗子</h5><blockquote><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> y;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">&gt;g.<span class="title function_">next</span>();</span><br><span class="line">&gt;g.<span class="keyword">throw</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p></blockquote><h4 id="④-异步任务的封装"><a href="#④-异步任务的封装" class="headerlink" title="④ 异步任务的封装"></a>④ 异步任务的封装</h4><blockquote><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> url = <span class="string">&#x27;https://gitee.com/hongjilin&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">bio</span>);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p></blockquote><h5 id="a-执行代码的方法如下"><a href="#a-执行代码的方法如下" class="headerlink" title="a) 执行代码的方法如下"></a>a) 执行代码的方法如下</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">&gt;<span class="keyword">var</span> result = g.<span class="title function_">next</span>();</span><br><span class="line">&gt;<span class="comment">//这里的value实际上相当于 fetch(url);</span></span><br><span class="line">&gt;result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> data.<span class="title function_">json</span>();</span><br><span class="line">&gt;&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line"> g.<span class="title function_">next</span>(data);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中:</p><ul><li>先执行Generator函数,获取遍历器对象,然后使用next方法(第二行),执行异步任务第一阶段</li><li>由于Fetch模块返回的是一个Promise对象,因此要用then方法调用下一个next方法</li><li>可以看到虽然Generator函数将异步操作表示的很简洁,但是流程管理却不方便(即何时执行第一阶段、何时执行第二阶段)</li></ul></blockquote><h3 id="Ⅳ-Thunk函数"><a href="#Ⅳ-Thunk函数" class="headerlink" title="Ⅳ - Thunk函数"></a>Ⅳ - Thunk函数</h3><blockquote><p>JavaScript 语言是 <strong><code>传值调用</code></strong> </p></blockquote><h4 id="①-参数的求值策略"><a href="#①-参数的求值策略" class="headerlink" title="① 参数的求值策略"></a>① 参数的求值策略</h4><blockquote><p>Thunk函数早在上个世纪60年代就诞生了,那时候编程语言才刚刚起步,计算机学家还在研究编译器怎么写比较好,一个争论的焦点时’<strong>求值策略</strong>‘:即函数的参数到底应该何时求值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">f</span>(x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面代码先定义函数f,然后向它传入表达式<code>x+1</code>,请问这个表达式应该何时求值?</p></blockquote><h5 id="a-传值调用-call-by-value"><a href="#a-传值调用-call-by-value" class="headerlink" title="a) 传值调用(call  by value)"></a>a) 传值调用(call  by value)</h5><blockquote><p>即在进入函数体之前,就计算<code>x+1</code>的值(等于2),再将这个值传入函数f,C语言就是采用这种策略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">f</span>(x+<span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">//传值调用时,两者等同</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></blockquote><h5 id="b-传名调用-call-by-name"><a href="#b-传名调用-call-by-name" class="headerlink" title="b) 传名调用(call by name)"></a>b) 传名调用(call by name)</h5><blockquote><p>即直接将表达式<code>x+1</code>传入函数体,只在用到它的时候求值,Haskell语言采用这种策略</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">f</span>(x+<span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">//传名调用时,等同下面的</span></span><br><span class="line">&gt;(x+<span class="number">1</span>)*<span class="number">2</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="c-传值和传名调用那种好"><a href="#c-传值和传名调用那种好" class="headerlink" title="c) 传值和传名调用那种好?"></a>c) 传值和传名调用那种好?</h5><blockquote><h6 id="答案是各有利弊-传值调用比较简单-但是对参数求值的时候-实际上还没用到这个参数-有可能造成性能损失"><a href="#答案是各有利弊-传值调用比较简单-但是对参数求值的时候-实际上还没用到这个参数-有可能造成性能损失" class="headerlink" title="答案是各有利弊:传值调用比较简单,但是对参数求值的时候,实际上还没用到这个参数,有可能造成性能损失"></a>答案是各有利弊:传值调用比较简单,但是对参数求值的时候,实际上还没用到这个参数,有可能造成性能损失</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> b;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//这里传入的第一个参数,在实际调用中并没有使用</span></span><br><span class="line">&gt;<span class="title function_">f</span>(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br></pre></td></tr></table></figure><p>上面代码中,函数f的第一个参数是一个复杂的表达式,但是函数体内根本没用到,对于这个参数求值实际上是不必要的,因此有一些计算机学家倾向于’<strong>传名求值</strong>‘–&gt;只在执行时求值</p></blockquote><h4 id="②-Thunk函数的含义"><a href="#②-Thunk函数的含义" class="headerlink" title="② Thunk函数的含义"></a>② Thunk函数的含义</h4><blockquote><h6 id="编译器-‘传名调用‘-实现往往是将参数放到一个临时函数之中-再将这个临时函数传入函数体-这个临时函数就叫做Thunk函数"><a href="#编译器-‘传名调用‘-实现往往是将参数放到一个临时函数之中-再将这个临时函数传入函数体-这个临时函数就叫做Thunk函数" class="headerlink" title="编译器 ‘传名调用‘ 实现往往是将参数放到一个临时函数之中,再将这个临时函数传入函数体,这个临时函数就叫做Thunk函数"></a>编译器 ‘<strong><code>传名调用</code></strong>‘ 实现往往是将参数放到一个临时函数之中,再将这个临时函数传入函数体,这个临时函数就叫做Thunk函数</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> m * <span class="number">2</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="title function_">f</span>(x + <span class="number">1</span>)</span><br><span class="line">&gt;<span class="comment">//等同于下面</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Thunk</span>() * <span class="number">2</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中函数f的参数<code>x + 1</code>被一个自定义的<code>Thunk</code>函数替换了.凡是用到原参数的地方对<code>Thunk</code>函数求值即可,这就是Thunk函数的定义,他是’传名调用’的一种实现策略,用来替换某个表达式</p></blockquote><h4 id="③-JavaScript语言的Thunk函数"><a href="#③-JavaScript语言的Thunk函数" class="headerlink" title="③ JavaScript语言的Thunk函数"></a>③ JavaScript语言的Thunk函数</h4><blockquote><h6 id="JavaScript-语言是-传值调用-它的Thunk函数含义有所不同"><a href="#JavaScript-语言是-传值调用-它的Thunk函数含义有所不同" class="headerlink" title="JavaScript 语言是 传值调用 ,它的Thunk函数含义有所不同:"></a>JavaScript 语言是 <strong><code>传值调用</code></strong> ,它的Thunk函数含义有所不同:</h6><blockquote><p>在JavaScript语言中,Thunk函数替换的不是表达式,而是多参函数,将其转换成单参数的版本,且只接受回调函数作为参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">&gt;fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line">&gt;<span class="keyword">const</span> readFileThunk = <span class="title class_">Thunk</span>(fileName);</span><br><span class="line">&gt;<span class="title function_">readFileThunk</span>(callback);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fileName</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中:</p><ul><li>fs模块的readFie方法是一个多参数函数,两个参数分别是文件名和回调函数</li><li>经过转换器处理,他变成了一个单参数的函数,只接受回调函数作为参数,这个单参数版本就叫做Thunk函数</li></ul></blockquote><h5 id="a-任何函数只要参数有回调函数就能写成Thunk形式"><a href="#a-任何函数只要参数有回调函数就能写成Thunk形式" class="headerlink" title="a) 任何函数只要参数有回调函数就能写成Thunk形式"></a>a) 任何函数只要参数有回调函数就能写成Thunk形式</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// ES5版本</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>)&#123;</span><br><span class="line">     args.<span class="title function_">push</span>(callback);</span><br><span class="line">     <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ES6版本</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//调用栗子1</span></span><br><span class="line">&gt;<span class="keyword">var</span> readFileThunk = <span class="title class_">Thunk</span>(fs.<span class="property">readFile</span>);</span><br><span class="line">&gt;<span class="title function_">readFileThunk</span>(fileA)(callback);</span><br><span class="line">&gt;<span class="comment">//栗子2</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, cb</span>) &#123;</span><br><span class="line"> <span class="title function_">cb</span>(a);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">let</span> ft = <span class="title class_">Thunk</span>(f);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> log = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line">&gt;<span class="title function_">ft</span>(<span class="number">1</span>)(log) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>实际上这个写法非常像<code>闭包</code></p></blockquote><h4 id="④-Generator-函数的流程管理"><a href="#④-Generator-函数的流程管理" class="headerlink" title="④ Generator 函数的流程管理"></a>④ Generator 函数的流程管理</h4><blockquote><p>你可能会问,Thunk函数有什么用?</p><blockquote><p>回答就是以前确实没什么用,但是ES6有了Generator函数,Thunk函数现在可以用于Generator函数</p></blockquote></blockquote><h5 id="a-Generator可以自动执行"><a href="#a-Generator可以自动执行" class="headerlink" title="a) Generator可以自动执行"></a>a) Generator可以自动执行</h5><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">&gt;<span class="keyword">var</span> res = g.<span class="title function_">next</span>();</span><br><span class="line">&gt;<span class="comment">//只要 done 不为true:即流程没有结束时,一直循环</span></span><br><span class="line">&gt;<span class="keyword">while</span>(!res.<span class="property">done</span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line"> res = g.<span class="title function_">next</span>();</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中,Generator函数<code>gen</code>会自动执行完所有步骤,<strong>但是这并不适合异步操作!!!!</strong></p></blockquote><h5 id="b-异步操作解决方案"><a href="#b-异步操作解决方案" class="headerlink" title="b) 异步操作解决方案"></a>b) 异步操作解决方案</h5><blockquote><p>如果必须保证前一步执行完才能执行后一步,上面的自动执行就不可行,这时Thunk函数就能派上用场:以读取文件为例下面的Generator函数封装了两个异步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">var</span> readFile = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line"> <span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line"> <span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h6 id="上面代码中-yield命令用于将程序的执行权移出Generator函数-那么就需要一种方法将执行权再交还给Generator函数"><a href="#上面代码中-yield命令用于将程序的执行权移出Generator函数-那么就需要一种方法将执行权再交还给Generator函数" class="headerlink" title="上面代码中 yield命令用于将程序的执行权移出Generator函数,那么就需要一种方法将执行权再交还给Generator函数"></a>上面代码中 <code>yield</code>命令用于将程序的执行权移出Generator函数,那么就需要一种方法将执行权再交还给Generator函数</h6><p>这种方法就是Thunk函数:因为它可以在回调函数里将执行权交还给Generator函数,为了便于理解我们先看如何手动执行上面这个Generator函数</p></blockquote><h6 id="1-手动执行上面的Generator函数"><a href="#1-手动执行上面的Generator函数" class="headerlink" title="(1)  手动执行上面的Generator函数"></a>(1)  手动执行上面的Generator函数</h6><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">&gt;r1.<span class="title function_">value</span>(<span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line"> <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line"> <span class="keyword">var</span> r2 = g.<span class="title function_">next</span>(data);</span><br><span class="line">   <span class="comment">//需要调用几次,就重复几次这样的代码</span></span><br><span class="line"> r2.<span class="title function_">value</span>(<span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">   g.<span class="title function_">next</span>(data);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p><p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程,那如何实现自动递归调用呢?看下面的内容</p></blockquote><h4 id="⑤-Thunk函数的自动流程管理"><a href="#⑤-Thunk函数的自动流程管理" class="headerlink" title="⑤ Thunk函数的自动流程管理"></a>⑤ Thunk函数的自动流程管理</h4><blockquote><p>hunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> gen = <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">   <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">//将下一级的函数取出,随后传入 next回调函数(上面说过,单参数传入回调)</span></span><br><span class="line">   result.<span class="title function_">value</span>(next);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">next</span>();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个Generator函数的自动执行器</p><ul><li>内部的<code>next</code>函数就是Thunk的回调函数。</li><li><code>next</code>函数先将指针移到Generator函数的下一步（<code>gen.next</code>方法），然后判断Generator函数是否结束（<code>result.done</code>属性）</li><li>如果没结束，就将<code>next</code>函数再传入Thunk函数（<code>result.value</code>属性），否则就直接退出。</li></ul><p>有了这个执行器,执行Generator函数方便多了,不管内部又多少个异步操作,直接把Generator函数传入这个<code>run</code>函数即可,当然前提是:</p><p><strong>每一个异步操作都要是Thunk函数,也就是说yield命令后面必须是Thunk函数</strong></p></blockquote><h5 id="a-实例"><a href="#a-实例" class="headerlink" title="a) 实例"></a>a) 实例</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> g = <span class="keyword">function</span>* ()&#123;</span><br><span class="line"> <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;fileA&#x27;</span>);</span><br><span class="line"> <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;fileB&#x27;</span>);</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">var</span> fn = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;fileN&#x27;</span>);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p></blockquote><h3 id="Ⅴ-co模块"><a href="#Ⅴ-co模块" class="headerlink" title="Ⅴ - co模块"></a>Ⅴ - co模块</h3><h4 id="①-基本用法-3"><a href="#①-基本用法-3" class="headerlink" title="① 基本用法"></a>① 基本用法</h4><blockquote><p>co模块是一个用于Generator函数的自动执行的小工具</p><p>比如，有一个Generator函数，用于依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line"> <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line"> <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>co模块可以让你不用编写Generator函数的执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line">&gt;<span class="title function_">co</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，Generator函数只要传入co函数，就会自动执行。</p><p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator 函数执行完成&#x27;</span>);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p></blockquote><h4 id="②-co模块的原理"><a href="#②-co模块的原理" class="headerlink" title="② co模块的原理"></a>② co模块的原理</h4><blockquote><h6 id="为什么co可以自动执行Generator函数"><a href="#为什么co可以自动执行Generator函数" class="headerlink" title="为什么co可以自动执行Generator函数?"></a>为什么co可以自动执行Generator函数?</h6><blockquote><p>前面说过Generator就是一个异步操作的容器,它的自动执行需要一种机制,当异步操作有了结果能够自动交回执行权</p></blockquote><p>两种方法可以做到这一点</p><ol><li>回调函数: 将异步操作包装成Thunk函数,在回调函数里面交回执行权</li><li>Promise对象:将异步操作包装成Promise对象,用then方法交回执行权</li></ol><p>co模块其实就是将两种自动执行器(Thunk函数和Promise对象)包装成一个模块.使用co的前提条件是:Generator函数的yield命令后面，只能是Thunk函数或Promise对象</p></blockquote><h5 id="a-基于Promise对象的自动执行"><a href="#a-基于Promise对象的自动执行" class="headerlink" title="a)基于Promise对象的自动执行"></a>a)基于Promise对象的自动执行</h5><blockquote><p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">   fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>)&#123;</span><br><span class="line">     <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">     <span class="title function_">resolve</span>(data);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line"> <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line"> <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的Generator函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">&gt;g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line"> g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">   g.<span class="title function_">next</span>(data);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;);</span><br></pre></td></tr></table></figure><p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">   <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">   <span class="comment">//将回调传入,实现自动执行  </span></span><br><span class="line">   result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">     <span class="title function_">next</span>(data);</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">next</span>();</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">run</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p></blockquote><h5 id="b-co模块的源码"><a href="#b-co模块的源码" class="headerlink" title="b) co模块的源码"></a>b) co模块的源码</h5><blockquote><p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">   <span class="comment">//如果下一步已经流程结束或者 非Generator函数,则返回成功状态  </span></span><br><span class="line">   <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">   <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line"></span><br><span class="line">   <span class="title function_">onFulfilled</span>();</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> ret;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="title function_">next</span>(ret);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的next函数，它会反复调用自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line"> <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line"> <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">onRejected</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">   + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="title class_">String</span>(ret.<span class="property">value</span>) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，next 函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，是 Promise 对象。</p><p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p><p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p></blockquote><h4 id="③-处理并发的异步操作"><a href="#③-处理并发的异步操作" class="headerlink" title="③ 处理并发的异步操作"></a>③ 处理并发的异步操作</h4><blockquote><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 数组的写法</span></span><br><span class="line">&gt;<span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line"> <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">   <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">   <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line"> ];</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(onerror);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 对象的写法</span></span><br><span class="line">&gt;<span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line"> <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">   <span class="number">1</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">   <span class="number">2</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&gt;&#125;).<span class="title function_">catch</span>(onerror);</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line"> <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line"> <span class="keyword">yield</span> values.<span class="title function_">map</span>(somethingAsync);</span><br><span class="line">&gt;&#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span>* <span class="title function_">somethingAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line"> <span class="comment">// do something async</span></span><br><span class="line"> <span class="keyword">return</span> y</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p></blockquote><h3 id="Ⅵ-Async函数"><a href="#Ⅵ-Async函数" class="headerlink" title="Ⅵ - Async函数"></a>Ⅵ - Async函数</h3><h4 id="①Async是Generator-函数的语法糖"><a href="#①Async是Generator-函数的语法糖" class="headerlink" title="①Async是Generator 函数的语法糖"></a>①Async是Generator 函数的语法糖</h4><h5 id="a-两者间区别"><a href="#a-两者间区别" class="headerlink" title="a)  两者间区别"></a>a)  两者间区别</h5><blockquote><p>比如我们要实现一个依次读取两个文件的效果</p><ol><li>Generator 函数实现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/test1&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/test2&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>async实现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/test1&#x27;</span>);</span><br><span class="line">&gt;<span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/test2&#x27;</span>);</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h6 id="一比较我们就能发现-他们存在大量相似的地方"><a href="#一比较我们就能发现-他们存在大量相似的地方" class="headerlink" title="一比较我们就能发现,他们存在大量相似的地方:"></a>一比较我们就能发现,他们存在大量相似的地方:</h6><ul><li><code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code></li><li>将<code>yield</code>替换成<code>await</code>,仅此而已</li></ul></blockquote><h5 id="b-Async函数对-Generator-函数的改进"><a href="#b-Async函数对-Generator-函数的改进" class="headerlink" title="b)  Async函数对 Generator 函数的改进"></a>b)  Async函数对 Generator 函数的改进</h5><h6 id="1-内置执行器"><a href="#1-内置执行器" class="headerlink" title="(1)  内置执行器"></a>(1)  内置执行器</h6><blockquote><p>Generator函数的执行必须靠执行器,所以才有了<code>co</code>模块,而<code>async</code>函数自带执行器.</p><ul><li>它不用像Generator函数需要调用<code>next</code>方法,或者用<code>co</code>模块才能真正执行得到结果</li><li>也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</li></ul></blockquote><h6 id="2-更好的语义"><a href="#2-更好的语义" class="headerlink" title="(2) 更好的语义"></a>(2) 更好的语义</h6><blockquote><p><code>async</code>和<code>await</code>,比起<code>*</code>和<code>yield</code>而言语义更清楚了:</p><p><strong><code>async</code>表示函数里有异步操作,<code>await</code>表示紧跟在后面的表达式需要等待结果</strong></p></blockquote><h6 id="3-更广的适用性"><a href="#3-更广的适用性" class="headerlink" title="(3) 更广的适用性"></a>(3) 更广的适用性</h6><blockquote><ul><li><code>co</code>模块约定:<code>yield</code>命令后面只能是Thunk函数或Promise对象</li><li><code>async</code>与<code>await</code>: 命令后面可以是Promise对象和原始类型的值(数值、字符串和布尔值,但这时会自动转成立即<code>resolved</code>的Promise对象)</li></ul></blockquote><h6 id="4-返回值是Promise"><a href="#4-返回值是Promise" class="headerlink" title="(4)返回值是Promise"></a>(4)返回值是Promise</h6><blockquote><p><code>async</code>函数的返回值是Promise对象,这比Generator函数的返回值是Iterator对象方便多了</p><ul><li>你可以用<code>then</code>方法执行下一步操作</li><li>进一步说:<code>async</code>函数完全可以看作多个异步操作,包装成的一个Promise对象</li><li><code>await</code>命令就是内部<code>then</code>命令的语法糖</li></ul></blockquote><h4 id="②-语法-1"><a href="#②-语法-1" class="headerlink" title="② 语法"></a>② 语法</h4><blockquote><p><code>Async</code>函数的语法规则总体上比较简单,难点是错误处理机制</p></blockquote><h5 id="a-Async函数返回一个Promise对象"><a href="#a-Async函数返回一个Promise对象" class="headerlink" title="a) Async函数返回一个Promise对象"></a>a) Async函数返回一个Promise对象</h5><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本笔记是本人&lt;code&gt;ES全系统详细学习笔记&lt;/code&gt;,将ES系列全部梳理一遍,包括新特性等,后续ES系</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="https://k705.github.io/2024/04/08/Es6-15%E3%80%81Es6_Promise%E5%AF%B9%E8%B1%A1_day11-30/"/>
    <id>https://k705.github.io/2024/04/08/Es6-15%E3%80%81Es6_Promise%E5%AF%B9%E8%B1%A1_day11-30/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:33.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p><p>本人有专门系统学习该知识点的笔记，与<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><code>Promise学习笔记</code></a>文件夹中</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指状态，不包含<code>rejected</code>状态。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">    client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">post</span> =&gt;</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fulfilled:&#x27;</span>, val))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fulfilled:&#x27;</span>, val))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected:&quot;</span>, err));</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p><p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post/1.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, p</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p><p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p><p><code>catch()</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>下面是一个具体的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&#x27;/post/&#x27;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p><p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p><p>下面是返回值用法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ <span class="title function_">fetch</span>(<span class="string">&#x27;index.html&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;https://does-not-exist/&#x27;</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* ... */</span> ];</span><br><span class="line"><span class="keyword">const</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">fetch</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requests);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-a&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-b&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-c&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AggregateError</span>() <span class="keyword">extends</span> <span class="title class_">Array</span> -&gt; <span class="title class_">AggregateError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">AggregateError</span>();</span><br><span class="line">err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line"><span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>(promises).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// All of the promises were rejected.</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> alsoRejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Infinity</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([resolved, rejected, alsoRejected]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([rejected, alsoRejected]).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// [-1, Infinity]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;/whatever.json&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p><p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span>  = resolve;</span><br><span class="line">    image.<span class="property">onerror</span> = reject;</span><br><span class="line">    image.<span class="property">src</span> = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFoo</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> <span class="title function_">getFoo</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (generator) &#123;</span><br><span class="line">  <span class="keyword">const</span> it = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));</span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">go</span>(it.<span class="title function_">next</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>第二种写法是使用<code>new Promise()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">f</span>())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(<span class="function">() =&gt;</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本人有专门系统学习该知识点的笔记，与&lt;a href=&quot;https://gitee.com/hongjilin</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Iterator 和 for...of 循环</title>
    <link href="https://k705.github.io/2024/04/08/Es6-16%E3%80%81Es6_Iterator%20%E5%92%8C%20for...of%20%E5%BE%AA%E7%8E%AF_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-16%E3%80%81Es6_Iterator%20%E5%92%8C%20for...of%20%E5%BE%AA%E7%8E%AF_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:15.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><h2 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p><p>Iterator 的遍历过程是这样的。</p><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">idMaker</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 0</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 1</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">idMaker</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Iterable</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() : <span class="title class_">Iterator</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="title function_">next</span>(value?: any) : <span class="title class_">IterationResult</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IterationResult</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: any,</span><br><span class="line">  <span class="attr">done</span>: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现指针结构的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Obj</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> iterator = &#123; <span class="attr">next</span>: next &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.<span class="property">value</span>;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.<span class="property">next</span> = two;</span><br><span class="line">two.<span class="property">next</span> = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是另一个为对象添加 Iterator 接口的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">data</span>: [ <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span> ],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure><p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p><p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="function">() =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[...obj] <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iterator = <span class="variable constant_">ITERABLE</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">while</span> (!$result.<span class="property">done</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $result.<span class="property">value</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p><h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p><p><strong>（1）解构赋值</strong></p><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y] = set;</span><br><span class="line"><span class="comment">// x=&#x27;a&#x27;; y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line"><span class="comment">// first=&#x27;a&#x27;; rest=[&#x27;b&#x27;,&#x27;c&#x27;];</span></span><br></pre></td></tr></table></figure><p><strong>（2）扩展运算符</strong></p><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">[...str] <span class="comment">//  [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, ...arr, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><p><strong>（3）yield*</strong></p><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（4）其他场合</strong></p><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h2 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h2><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;h&quot;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;i&quot;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// [&quot;h&quot;, &quot;i&quot;]</span></span><br><span class="line"></span><br><span class="line">str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_first</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_first</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&quot;bye&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">_first</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// [&quot;bye&quot;]</span></span><br><span class="line">str <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p><h2 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h2><p><code>Symbol.iterator()</code>方法的最简单实现，还是使用下一章要介绍的 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p><h2 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h2><p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p><p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readLinesSync</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">          file.<span class="title function_">close</span>();</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。下面的两种情况，都会触发执行<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</p><p>注意，<code>return()</code>方法必须返回一个对象，这是 Generator 语法决定的。</p><p><code>throw()</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>].<span class="title function_">bind</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// red green blue</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);   <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p><p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p><h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;Gecko&quot;</span>, <span class="string">&quot;Trident&quot;</span>, <span class="string">&quot;Webkit&quot;</span>, <span class="string">&quot;Webkit&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>);</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;committee&quot;</span>, <span class="string">&quot;TC39&quot;</span>);</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;ECMA-262&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure><h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;a\uD83D\uDC0A&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;\uD83D\uDC0A&#x27;</span></span><br></pre></td></tr></table></figure><p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">committee</span>: <span class="string">&quot;TC39&quot;</span>,</span><br><span class="line">  <span class="attr">standard</span>: <span class="string">&quot;ECMA-262&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(someObject)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法是使用 Generator 函数将对象重新包装一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p><p><code>for...in</code>循环可以遍历数组的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有几个缺点。</p><ul><li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li><li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p><h2 id="for…of-与-for…in区别"><a href="#for…of-与-for…in区别" class="headerlink" title="for…of 与 for…in区别"></a>for…of 与 for…in区别</h2><h3 id="for-in遍历的是数组的索引（即键名），"><a href="#for-in遍历的是数组的索引（即键名），" class="headerlink" title="for in遍历的是数组的索引（即键名），"></a>for in遍历的是数组的索引（即键名），</h3><h3 id="而for-of遍历的是数组元素值。"><a href="#而for-of遍历的是数组元素值。" class="headerlink" title="而for of遍历的是数组元素值。"></a>而for of遍历的是数组元素值。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myArray.<span class="property">name</span>=<span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);    <span class="comment">//0,1,2,method,name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);    <span class="comment">//1,2,4</span></span><br></pre></td></tr></table></figure><p>除此之外还有一些细节:</p><p>for in的一些<strong>缺陷</strong>:</p><ol><li>索引是字符串型的数字，因而不能直接进行几何运算</li><li>遍历顺序可能不是实际的内部顺序</li><li>for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性</li></ol><p>故而一般用<strong>for in遍历对象而不用来遍历数组</strong></p><p> 这也就是for of存在的意义了,<strong>for of 不遍历method和name,适合用来遍历数组</strong></p><p> 那for of有缺点吗? 当然有了:</p><p><strong>for of不支持普通对象</strong>，想遍历对象的属性，可以用for in循环, 或内建的Object.keys()方法：</p><p><strong>Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Object</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;: &quot;</span> + <span class="title class_">Object</span>[key]);</span><br></pre></td></tr></table></figure><p>但是感觉这样有些多此一举,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Generator 函数的异步应用</title>
    <link href="https://k705.github.io/2024/04/08/Es6-18%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8_day11-30(%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5)/"/>
    <id>https://k705.github.io/2024/04/08/Es6-18%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8_day11-30(%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5)/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:28:54.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h1><p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布&#x2F;订阅</li><li>Promise 对象</li></ul><p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p><p>读取文件进行处理，是这样写的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p><p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。</p><p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">&#x27;fs-readfile-promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(fileA)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p><p>那么，有没有更好的写法呢？</p><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><ul><li>第一步，协程<code>A</code>开始执行。</li><li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li><li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li><li>第四步，协程<code>A</code>恢复执行。</li></ul><p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p><p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p><h3 id="协程的-Generator-函数实现"><a href="#协程的-Generator-函数实现" class="headerlink" title="协程的 Generator 函数实现"></a>协程的 Generator 函数实现</h3><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator 函数的执行方法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p><h3 id="Generator-函数的数据交换和错误处理"><a href="#Generator-函数的数据交换和错误处理" class="headerlink" title="Generator 函数的数据交换和错误处理"></a>Generator 函数的数据交换和错误处理</h3><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p><code>next</code>返回值的 value 属性，是 Generator 函数向外输出数据；<code>next</code>方法还可以接受参数，向 Generator 函数体内输入数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator 函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">bio</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p><p>执行这段代码的方法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> result = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">json</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个 Promise 对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h2 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h2><p>Thunk 函数是自动执行 Generator 函数的一种方法。</p><h3 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h3><p>Thunk 函数早在上个世纪 60 年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p><p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于 6），再将这个值传入函数<code>f</code>。C 语言就采用这种策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line">(x + <span class="number">5</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？</p><p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p><h3 id="Thunk-函数的含义"><a href="#Thunk-函数的含义" class="headerlink" title="Thunk 函数的含义"></a>Thunk 函数的含义</h3><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p><p>这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p><h3 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h3><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title class_">Thunk</span>(fileName);</span><br><span class="line"><span class="title function_">readFileThunk</span>(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5版本</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>)&#123;</span><br><span class="line">      args.<span class="title function_">push</span>(callback);</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用上面的转换器，生成<code>fs.readFile</code>的 Thunk 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title class_">Thunk</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">readFileThunk</span>(fileA)(callback);</span><br></pre></td></tr></table></figure><p>下面是另一个完整的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, cb</span>) &#123;</span><br><span class="line">  <span class="title function_">cb</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ft = <span class="title class_">Thunk</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h3><p>生产环境的转换器，建议使用 Thunkify 模块。</p><p>首先是安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install thunkify</span><br></pre></td></tr></table></figure><p>使用方式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;package.json&#x27;</span>)(<span class="keyword">function</span>(<span class="params">err, str</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Thunkify 的源码与上一节那个简单的转换器非常像。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thunkify</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">      args.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = a + b;</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft = <span class="title function_">thunkify</span>(f);</span><br><span class="line"><span class="keyword">var</span> print = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p><h3 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h3><p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p><p>Generator 函数可以自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.<span class="property">done</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">  res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>gen</code>会自动执行完所有步骤。</p><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p><p>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> r2 = g.<span class="title function_">next</span>(data);</span><br><span class="line">  r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是 Generator 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p><p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p><h3 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h3><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> gen = <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span>;</span><br><span class="line">    result.<span class="title function_">value</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个 Generator 函数的自动执行器。内部的<code>next</code>函数就是 Thunk 的回调函数。<code>next</code>函数先将指针移到 Generator 函数的下一步（<code>gen.next</code>方法），然后判断 Generator 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 Thunk 函数（<code>result.value</code>属性），否则就直接退出。</p><p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在<code>yield</code>命令后面的必须是 Thunk 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileA&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileB&#x27;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileN&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p><h2 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><a href="https://github.com/tj/co">co 模块</a>是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p><p>下面是一个 Generator 函数，用于依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>co 模块可以让你不用编写 Generator 函数的执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="title function_">co</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator 函数执行完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p><h3 id="co-模块的原理"><a href="#co-模块的原理" class="headerlink" title="co 模块的原理"></a>co 模块的原理</h3><p>为什么 co 可以自动执行 Generator 函数？</p><p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p><p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p><p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p><p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p><h3 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h3><p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">      <span class="title function_">next</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 Generator 函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p><h3 id="co-模块的源码"><a href="#co-模块的源码" class="headerlink" title="co 模块的源码"></a>co 模块的源码</h3><p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的 Promise 对象里面，co 先检查参数<code>gen</code>是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，co 将 Generator 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">onRejected</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">      <span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">      + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span></span><br><span class="line">      + <span class="title class_">String</span>(ret.<span class="property">value</span>)</span><br><span class="line">      + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，是 Promise 对象。</p><p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p><p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为<code>rejected</code>，从而终止执行。</p><h3 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h3><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line">  <span class="keyword">yield</span> values.<span class="title function_">map</span>(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">somethingAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// do something async</span></span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p><h3 id="实例：处理-Stream"><a href="#实例：处理-Stream" class="headerlink" title="实例：处理 Stream"></a>实例：处理 Stream</h3><p>Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。</p><ul><li><code>data</code>事件：下一块数据块已经准备好了。</li><li><code>end</code>事件：整个“数据流”处理完了。</li><li><code>error</code>事件：发生错误。</li></ul><p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./les_miserables.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> valjeanCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.<span class="title function_">once</span>(<span class="string">&#x27;data&#x27;</span>, resolve)),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.<span class="title function_">once</span>(<span class="string">&#x27;end&#x27;</span>, resolve)),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> stream.<span class="title function_">once</span>(<span class="string">&#x27;error&#x27;</span>, reject))</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stream.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    stream.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">    stream.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    valjeanCount += (res.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/valjean/ig</span>) || []).<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count:&#x27;</span>, valjeanCount); <span class="comment">// count: 1120</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Generator 函数的语法</title>
    <link href="https://k705.github.io/2024/04/08/Es6-17%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-17%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:03.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br><span class="line"><span class="keyword">function</span>*<span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p><p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p><p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p><p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p><p>需要注意的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>  <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。</p><p>Generator 函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  generator.<span class="title function_">next</span>()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个 Generator 函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p><p>另外需要注意，<code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure><p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="keyword">function</span>* (a) &#123;</span><br><span class="line">  a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* <span class="title function_">flat</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> <span class="title function_">flat</span>(arr))&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。一种修改方法是改用<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="keyword">function</span>* (a) &#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* <span class="title function_">flat</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> <span class="title function_">flat</span>(arr)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><p>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>上一章说过，任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p><p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>gen</code>是一个 Generator 函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回它自己。</p><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>再看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p><p>再看一个通过<code>next</code>方法的参数，向 Generator 函数内部输入值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">dataConsumer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Started&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = <span class="title function_">dataConsumer</span>();</span><br><span class="line">genObj.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.<span class="title function_">next</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.<span class="title function_">next</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure><p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向 Generator 函数输入值，然后打印出来。</p><p>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">generatorFunction</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> generatorObject = <span class="title function_">generatorFunction</span>(...args);</span><br><span class="line">    generatorObject.<span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">return</span> generatorObject;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="title function_">wrapper</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`First input: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;DONE&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">wrapped</span>().<span class="title function_">next</span>(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="comment">// First input: hello!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法，就输入参数的。</p><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>上面代码使用<code>for...of</code>循环，依次显示 5 个<code>yield</code>表达式的值。这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</p><p>下面是一个利用 Generator 函数和<code>for...of</code>循环，实现斐波那契数列的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibonacci</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> <span class="title function_">fibonacci</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可见，使用<code>for...of</code>语句时不需要使用<code>next</code>方法。</p><p>利用<code>for...of</code>循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用<code>for...of</code>循环，通过 Generator 函数为它加上这个接口，就可以用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>jane</code>原生不具备 Iterator 接口，无法用<code>for...of</code>遍历。这时，我们通过 Generator 函数<code>objectEntries</code>为它加上遍历器接口，就可以用<code>for...of</code>遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="variable language_">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">jane[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = objectEntries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* numbers () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="title function_">numbers</span>()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = <span class="title function_">numbers</span>();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> <span class="title function_">numbers</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p><p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line">i.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>));</span><br><span class="line"><span class="comment">// Error: 出错了！(…)</span></span><br></pre></td></tr></table></figure><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">&#x27;a&#x27;</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><p>如果 Generator 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p><p>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>();</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// Uncaught undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>抛出错误以后，没有任何<code>try...catch</code>代码块可以捕获这个错误，导致程序报错，中断执行。</p><p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Uncaught 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部。</p><p><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// a</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// b</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</p><p>另外，<code>throw</code>命令与<code>g.throw</code>方法是无关的，两者互不影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>命令抛出的错误不会影响到遍历器的状态，所以两次执行<code>next</code>方法，都进行了正确的操作。</p><p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次<code>catch</code>语句就可以了。</p><p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 42，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 TypeError 错误，被函数体外的<code>catch</code>捕获。</p><p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;throwing an exception&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;generator broke!&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">generator</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> v;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;starting generator&#x27;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.<span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.<span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.<span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caller done&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="title function_">g</span>());</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure><p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象，还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，Generator 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code>。</p><p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* numbers () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">numbers</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><p><code>next()</code>是将<code>yield</code>表达式替换成一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* (x, y) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">g</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.<span class="title function_">next</span>(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.<span class="keyword">return</span>(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="comment">// 手动遍历 foo()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">bar</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// y</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>和<code>bar</code>都是 Generator 函数，在<code>bar</code>里面调用<code>foo</code>，就需要手动遍历<code>foo</code>。如果有多个 Generator 函数嵌套，写起来就非常麻烦。</p><p>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">bar</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;x&quot;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="comment">// &quot;y&quot;</span></span><br></pre></td></tr></table></figure><p>再来看一个对比的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outer1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">inner</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">outer1</span>()</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;close&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outer2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">inner</span>()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">outer2</span>()</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;hello!&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;close&quot;</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>outer2</code>使用了<code>yield*</code>，<code>outer1</code>没使用。结果就是，<code>outer1</code>返回一个遍历器对象，<code>outer2</code>返回该遍历器对象的内部值。</p><p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Bye!&#x27;</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Greetings!&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Ok, bye.&#x27;</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;Greetings!</span></span><br><span class="line"><span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Bye!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Ok, bye.&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p><p><code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p><p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">gen</span>().<span class="title function_">next</span>() <span class="comment">// &#123; value:&quot;a&quot;, done:false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p><p>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">read.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p><p>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;v: &quot;</span> + v);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">bar</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &quot;v: foo&quot;</span></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码在第四次调用<code>next</code>方法的时候，屏幕上会有输出，这是因为函数<code>foo</code>的<code>return</code>语句，向函数<code>bar</code>提供了返回值。</p><p>再看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genFuncWithReturn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">logReturned</span>(<span class="params">genObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">logReturned</span>(<span class="title function_">genFuncWithReturn</span>())]</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象，第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以，最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。但是，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量，因此会有终端输出。</p><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">iterTree</span>(<span class="params">tree</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; tree.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* <span class="title function_">iterTree</span>(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [ <span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">iterTree</span>(tree)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>由于扩展运算符<code>...</code>默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="title function_">iterTree</span>(tree)] <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，</span></span><br><span class="line"><span class="comment">// 三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Tree</span>(<span class="params">left, label, right</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">label</span> = label;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数。</span></span><br><span class="line"><span class="comment">// 由于返回的是一个遍历器，所以要用generator函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">inorder</span>(<span class="params">t</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">inorder</span>(t.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">yield</span> t.<span class="property">label</span>;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">inorder</span>(t.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (array.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tree</span>(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tree</span>(<span class="title function_">make</span>(array[<span class="number">0</span>]), array[<span class="number">1</span>], <span class="title function_">make</span>(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = <span class="title function_">make</span>([[[<span class="string">&#x27;a&#x27;</span>], <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>]], <span class="string">&#x27;d&#x27;</span>, [[<span class="string">&#x27;e&#x27;</span>], <span class="string">&#x27;f&#x27;</span>, [<span class="string">&#x27;g&#x27;</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> <span class="title function_">inorder</span>(tree)) &#123;</span><br><span class="line">  result.<span class="title function_">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h2><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个 Generator 函数。</p><p>它的完整形式如下，与上面的写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myGeneratorMethod</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h2><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">g.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hi!&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">g</span>();</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// &#x27;hi!&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator 函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">g</span>();</span><br><span class="line">obj.<span class="title function_">next</span>();</span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p><p>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line"><span class="comment">// TypeError: F is not a constructor</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new</code>命令跟构造函数<code>F</code>一起使用，结果报错，因为<code>F</code>不是构造函数。</p><p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</p><p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">obj.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">obj.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p><p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p><p>一个办法就是将<code>obj</code>换成<code>F.prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(F.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>再将<code>F</code>改成构造函数，就可以对它执行<code>new</code>命令了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gen.<span class="title function_">call</span>(gen.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><h3 id="Generator-与状态机"><a href="#Generator-与状态机" class="headerlink" title="Generator 与状态机"></a>Generator 与状态机</h3><p>Generator 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>clock</code>函数一共有两种状态（<code>Tick</code>和<code>Tock</code>），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p><h3 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h3><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><p><strong>（1）协程与子例程的差异</strong></p><p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p><p><strong>（2）协程与普通线程的差异</strong></p><p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用<code>yield</code>表达式交换控制权。</p><h3 id="Generator-与上下文"><a href="#Generator-与上下文" class="headerlink" title="Generator 与上下文"></a>Generator 与上下文</h3><p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p><p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p><p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  g.<span class="title function_">next</span>().<span class="property">value</span>,</span><br><span class="line">  g.<span class="title function_">next</span>().<span class="property">value</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p><h3 id="（1）异步操作的同步化表达"><a href="#（1）异步操作的同步化表达" class="headerlink" title="（1）异步操作的同步化表达"></a>（1）异步操作的同步化表达</h3><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">loadUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">showLoadingScreen</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">loadUIDataAsynchronously</span>();</span><br><span class="line">  <span class="title function_">hideLoadingScreen</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = <span class="title function_">loadUI</span>();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&quot;http://some.url&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="title function_">makeAjaxCall</span>(url, <span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">    it.<span class="title function_">next</span>(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">main</span>();</span><br><span class="line">it.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。</p><p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;numbers.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.<span class="property">eof</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.<span class="title function_">readLine</span>(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    file.<span class="title function_">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p><h3 id="（2）控制流管理"><a href="#（2）控制流管理" class="headerlink" title="（2）控制流管理"></a>（2）控制流管理</h3><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span>(<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span>(<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span>(<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用 Promise 改写上面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(step1)</span><br><span class="line">  .<span class="title function_">then</span>(step2)</span><br><span class="line">  .<span class="title function_">then</span>(step3)</span><br><span class="line">  .<span class="title function_">then</span>(step4)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">longRunningTask</span>(<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="keyword">yield</span> <span class="title function_">step1</span>(value1);</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="keyword">yield</span> <span class="title function_">step2</span>(value2);</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="keyword">yield</span> <span class="title function_">step3</span>(value3);</span><br><span class="line">    <span class="keyword">var</span> value5 = <span class="keyword">yield</span> <span class="title function_">step4</span>(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，使用一个函数，按次序自动执行所有步骤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scheduler</span>(<span class="title function_">longRunningTask</span>(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> taskObj = task.<span class="title function_">next</span>(task.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.<span class="property">done</span>) &#123;</span><br><span class="line">    task.<span class="property">value</span> = taskObj.<span class="property">value</span></span><br><span class="line">    <span class="title function_">scheduler</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p><p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateSteps</span>(<span class="params">steps</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; steps.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">step</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator 函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p><p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateJobs</span>(<span class="params">jobs</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; jobs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">iterateSteps</span>(job.<span class="property">steps</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator 函数<code>iterateJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p><p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> step <span class="keyword">of</span> <span class="title function_">iterateJobs</span>(jobs))&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p><p><code>for...of</code>的本质是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">iterateJobs</span>(jobs);</span><br><span class="line"><span class="keyword">var</span> res = it.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.<span class="property">done</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = res.<span class="property">value</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）部署-Iterator-接口"><a href="#（3）部署-Iterator-接口" class="headerlink" title="（3）部署 Iterator 接口"></a>（3）部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">iterEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">iterEntries</span>(myObj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p><p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">makeSimpleGenerator</span>(<span class="params">array</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; array.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">makeSimpleGenerator</span>([<span class="string">&#x27;yo&#x27;</span>, <span class="string">&#x27;ya&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &#x27;yo&#x27;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &#x27;ya&#x27;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">done</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="（4）作为数据结构"><a href="#（4）作为数据结构" class="headerlink" title="（4）作为数据结构"></a>（4）作为数据结构</h3><p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;hello.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;world.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;and-such.txt&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (task <span class="keyword">of</span> <span class="title function_">doStuff</span>()) &#123;</span><br><span class="line">  <span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;hello.txt&#x27;</span>),</span><br><span class="line">    fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;world.txt&#x27;</span>),</span><br><span class="line">    fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;and-such.txt&#x27;</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>async 函数</title>
    <link href="https://k705.github.io/2024/04/08/Es6-19%E3%80%81Es6_async%20%E5%87%BD%E6%95%B0_day11-30/"/>
    <id>https://k705.github.io/2024/04/08/Es6-19%E3%80%81Es6_async%20%E5%87%BD%E6%95%B0_day11-30/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:28:43.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p><p>本人有对此知识更为详细的学习笔记，于<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><code>Promise学习笔记</code></a>中</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数，依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncReadFile</span>();</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStockPriceByName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> <span class="title function_">getStockSymbol</span>(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> <span class="title function_">getStockPrice</span>(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getStockPriceByName</span>(<span class="string">&#x27;goog&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">timeout</span>(ms);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">timeout</span>(ms);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>async 函数有多种使用形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>, v),</span><br><span class="line">  <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>, e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//reject Error: 出错了</span></span><br></pre></td></tr></table></figure><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTitle</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">  <span class="keyword">return</span> html.<span class="title function_">match</span>(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getTitle</span>(<span class="string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">timeout</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timeout</span> = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime),</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timeout</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sleepTime = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sleepTime);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p><p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">interval</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, interval);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">one2FiveInAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">one2FiveInAsync</span>();</span><br></pre></td></tr></table></figure><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">await</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> <span class="title function_">firstStep</span>();</span><br><span class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> <span class="title function_">secondStep</span>(val1);</span><br><span class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> <span class="title function_">thirdStep</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Final: &#x27;</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NUM_RETRIES</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="variable constant_">NUM_RETRIES</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> superagent.<span class="title function_">get</span>(<span class="string">&#x27;http://google.com/this-throws-an-error&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是使用数组的<code>reduce()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (_, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> _;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;, <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p><p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p><p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四点，async 函数可以保留运行堆栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">b</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">c</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">genF</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = <span class="title function_">genF</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextF</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = <span class="title function_">nextF</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="title function_">next</span>(v); &#125;);</span><br><span class="line">      &#125;, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空的Promise</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用then方法，添加所有动画</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class="line">  <span class="keyword">return</span> p.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p><p>最后是 async 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 远程读取所有URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  textPromises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> textPromise)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">text</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p><p>目前，有一个<a href="https://github.com/tc39/proposal-top-level-await">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p><p>上面的代码也可以写成立即执行函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>下面是加载这个模块的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p><p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p><p>下面是加载这个模块的新的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p><p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p><p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">const</span> dynamic = <span class="keyword">import</span>(someMission);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> output = <span class="title function_">someProcess</span>((<span class="keyword">await</span> dynamic).<span class="property">default</span>, <span class="keyword">await</span> data);</span><br></pre></td></tr></table></figure><p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p><p>加载这个模块的写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p><p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p><p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p><p>下面是顶层<code>await</code>的一些使用场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import() 方法加载</span></span><br><span class="line"><span class="keyword">const</span> strings = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`/i18n/<span class="subst">$&#123;navigator.language&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">await</span> <span class="title function_">dbConnector</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖回滚</span></span><br><span class="line"><span class="keyword">let</span> jQuery;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  jQuery = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn-a.com/jQuery&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  jQuery = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn-b.com/jQuery&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(r, <span class="number">1000</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;X2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// z.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./x.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./y.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Z&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p><p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本人有对此知识更为详细的学习笔记，于&lt;a href=&quot;https://gitee.com/hongjilin</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
</feed>
