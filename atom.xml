<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KK</title>
  
  <subtitle>KK Blog</subtitle>
  <link href="https://k705.github.io/atom.xml" rel="self"/>
  
  <link href="https://k705.github.io/"/>
  <updated>2024-04-25T09:18:31.539Z</updated>
  <id>https://k705.github.io/</id>
  
  <author>
    <name>KK</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码规范</title>
    <link href="https://k705.github.io/2024/04/25/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://k705.github.io/2024/04/25/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2024-04-25T09:08:57.000Z</published>
    <updated>2024-04-25T09:18:31.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、命名规范"><a href="#一、命名规范" class="headerlink" title="一、命名规范"></a>一、命名规范</h2><p>市面上常用的命名规范：</p><ul><li><code>camelCase</code>（小驼峰式命名法 —— 首字母小写）</li><li><code>PascalCase</code>（大驼峰式命名法 —— 首字母大写）</li><li><code>kebab-case</code>（短横线连接式）</li><li><code>Snake</code>（下划线连接式）</li></ul><h3 id="1-1-项目文件命名"><a href="#1-1-项目文件命名" class="headerlink" title="1.1 项目文件命名"></a>1.1 项目文件命名</h3><h4 id="1-1-1-项目名"><a href="#1-1-1-项目名" class="headerlink" title="1.1.1 项目名"></a>1.1.1 项目名</h4><p>全部采用小写方式， 以<strong>短横线</strong>分隔。 例：<code>my-project-name</code>。</p><h4 id="1-1-2-目录名"><a href="#1-1-2-目录名" class="headerlink" title="1.1.2 目录名"></a>1.1.2 目录名</h4><p><strong>参照项目命名规则，有复数结构时，要采用复数命名法</strong>。例：docs、assets、components、directives、mixins、utils、views。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">my-project-name/</span><br><span class="line">|- <span class="title class_">BuildScript</span>    <span class="comment">// 流水线部署文件目录</span></span><br><span class="line">|- docs           <span class="comment">// 项目的细化文档目录（可选）</span></span><br><span class="line">|- nginx          <span class="comment">// 部署在容器上前端项目 nginx 代理文件目录</span></span><br><span class="line">|- node_modules   <span class="comment">// 下载的依赖包</span></span><br><span class="line">|- public         <span class="comment">// 静态页面目录</span></span><br><span class="line">    |- index.<span class="property">html</span> <span class="comment">// 项目入口</span></span><br><span class="line">|- src            <span class="comment">// 源码目录</span></span><br><span class="line">    |- api        <span class="comment">// http 请求目录</span></span><br><span class="line">    |- assets     <span class="comment">// 静态资源目录，这里的资源会被wabpack构建</span></span><br><span class="line">        |- icon   <span class="comment">// icon 存放目录</span></span><br><span class="line">        |- img    <span class="comment">// 图片存放目录</span></span><br><span class="line">        |- js     <span class="comment">// 公共 js 文件目录</span></span><br><span class="line">        |- scss   <span class="comment">// 公共样式 scss 存放目录</span></span><br><span class="line">            |- frame.<span class="property">scss</span>   <span class="comment">// 入口文件</span></span><br><span class="line">            |- <span class="variable language_">global</span>.<span class="property">scss</span>  <span class="comment">// 公共样式</span></span><br><span class="line">            |- reset.<span class="property">scss</span>   <span class="comment">// 重置样式</span></span><br><span class="line">    |- components     <span class="comment">// 组件</span></span><br><span class="line">    |- plugins        <span class="comment">// 插件</span></span><br><span class="line">    |- router         <span class="comment">// 路由</span></span><br><span class="line">    |- routes         <span class="comment">// 详细的路由拆分目录（可选）</span></span><br><span class="line">        |- index.<span class="property">js</span></span><br><span class="line">    |- store          <span class="comment">// 全局状态管理</span></span><br><span class="line">    |- utils          <span class="comment">// 工具存放目录</span></span><br><span class="line">        |- request.<span class="property">js</span> <span class="comment">// 公共请求工具</span></span><br><span class="line">    |- views          <span class="comment">// 页面存放目录</span></span><br><span class="line">    |- <span class="title class_">App</span>.<span class="property">vue</span>        <span class="comment">// 根组件</span></span><br><span class="line">    |- main.<span class="property">js</span>        <span class="comment">// 入口文件</span></span><br><span class="line">    |- tests          <span class="comment">// 测试用例</span></span><br><span class="line">    |- .<span class="property">browserslistrc</span><span class="comment">// 浏览器兼容配置文件</span></span><br><span class="line">    |- .<span class="property">editorconfig</span>  <span class="comment">// 编辑器配置文件</span></span><br><span class="line">    |- .<span class="property">eslintignore</span>  <span class="comment">// eslint 忽略规则</span></span><br><span class="line">    |- .<span class="property">eslintrc</span>.<span class="property">js</span>   <span class="comment">// eslint 规则</span></span><br><span class="line">    |- .<span class="property">gitignore</span>     <span class="comment">// git 忽略规则</span></span><br><span class="line">    |- babel.<span class="property">config</span>.<span class="property">js</span> <span class="comment">// babel 规则</span></span><br><span class="line">    |- <span class="title class_">Dockerfile</span> <span class="comment">// Docker 部署文件</span></span><br><span class="line">    |- jest.<span class="property">config</span>.<span class="property">js</span></span><br><span class="line">    |- package-lock.<span class="property">json</span></span><br><span class="line">    |- package.<span class="property">json</span> <span class="comment">// 依赖</span></span><br><span class="line">    |- <span class="variable constant_">README</span>.<span class="property">md</span> <span class="comment">// 项目 README</span></span><br><span class="line">    |- vue.<span class="property">config</span>.<span class="property">js</span> <span class="comment">// webpack 配置</span></span><br></pre></td></tr></table></figure><h4 id="1-1-3-图像文件名"><a href="#1-1-3-图像文件名" class="headerlink" title="1.1.3 图像文件名"></a>1.1.3 图像文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">banner_sina.gif</span><br><span class="line">menu_aboutus.gif</span><br><span class="line">menutitle_news.gif</span><br><span class="line">logo_police.gif</span><br><span class="line">logo_national.gif</span><br><span class="line">pic_people.jpg</span><br><span class="line">pic_TV.jpg</span><br></pre></td></tr></table></figure><h4 id="1-1-4-HTML-文件名"><a href="#1-1-4-HTML-文件名" class="headerlink" title="1.1.4 HTML 文件名"></a>1.1.4 HTML 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>下划线</strong>分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|- error_report.html</span><br><span class="line">|- success_report.html</span><br></pre></td></tr></table></figure><h4 id="1-1-5-CSS-文件名"><a href="#1-1-5-CSS-文件名" class="headerlink" title="1.1.5 CSS 文件名"></a>1.1.5 CSS 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|- normalize.less</span><br><span class="line">|- base.less</span><br><span class="line">|- <span class="built_in">date</span>-picker.scss</span><br><span class="line">|- <span class="built_in">input</span>-number.scss</span><br></pre></td></tr></table></figure><h4 id="1-1-6-JavaScript-文件名"><a href="#1-1-6-JavaScript-文件名" class="headerlink" title="1.1.6 JavaScript 文件名"></a>1.1.6 JavaScript 文件名</h4><p>全部采用小写方式， 优先选择单个单词命名，多个单词命名以<strong>短横线</strong>分隔。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|- index<span class="selector-class">.js</span></span><br><span class="line">|- plugin<span class="selector-class">.js</span></span><br><span class="line">|- util<span class="selector-class">.js</span></span><br><span class="line">|- date-util<span class="selector-class">.js</span></span><br><span class="line">|- account-model<span class="selector-class">.js</span></span><br><span class="line">|- collapse-<span class="attribute">transition</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><blockquote><p>上述规则可以快速记忆为“<strong>静态文件下划线，编译文件短横线</strong>”。</p></blockquote><h3 id="1-2-Vue-组件命名"><a href="#1-2-Vue-组件命名" class="headerlink" title="1.2 Vue 组件命名"></a>1.2 Vue 组件命名</h3><h4 id="1-2-1-单文件组件名"><a href="#1-2-1-单文件组件名" class="headerlink" title="1.2.1 单文件组件名"></a>1.2.1 单文件组件名</h4><p>文件扩展名为 <code>.vue</code> 的 <code>single-file components</code> (单文件组件)。单文件组件名应该始终是<strong>单词大写开头</strong> (PascalCase)。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- MyComponent.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-2-单例组件名"><a href="#1-2-2-单例组件名" class="headerlink" title="1.2.2 单例组件名"></a>1.2.2 单例组件名</h4><p><strong>只拥有单个活跃实例的组件应该以 <code>The</code> 前缀命名，以示其唯一性。</strong></p><p>这不意味着组件只可用于一个单页面，而是<em>每个页面</em>只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，<em>只是目前</em>在每个页面里只使用一次。</p><p>比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TheHeading.vue</span><br><span class="line">|- TheSidebar.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-3-基础组件名"><a href="#1-2-3-基础组件名" class="headerlink" title="1.2.3 基础组件名"></a>1.2.3 基础组件名</h4><blockquote><p>基础组件：不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。</p></blockquote><p>应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。<strong>基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- BaseButton.vue</span><br><span class="line">|- BaseTable.vue</span><br><span class="line">|- BaseIcon.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-4-业务组件"><a href="#1-2-4-业务组件" class="headerlink" title="1.2.4 业务组件"></a>1.2.4 业务组件</h4><blockquote><p>业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p></blockquote><p><strong>掺杂了复杂业务的组件（拥有自身 <code>data</code>、<code>prop</code> 的相关处理）即业务组件</strong>应该以 <code>Custom</code> 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- CustomCard.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-5-紧密耦合的组件名"><a href="#1-2-5-紧密耦合的组件名" class="headerlink" title="1.2.5 紧密耦合的组件名"></a>1.2.5 紧密耦合的组件名</h4><p><strong>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</strong> 因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- TodoList.vue</span><br><span class="line">|- TodoListItem.vue</span><br><span class="line">|- TodoListItemButton.vue</span><br></pre></td></tr></table></figure><h4 id="1-2-6-组件名中单词顺序"><a href="#1-2-6-组件名中单词顺序" class="headerlink" title="1.2.6 组件名中单词顺序"></a>1.2.6 组件名中单词顺序</h4><p><strong>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</strong> 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。如下组件主要是用于搜索和设置功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- SearchButtonClear.vue</span><br><span class="line">|- SearchButtonRun.vue</span><br><span class="line">|- SearchInputQuery.vue</span><br><span class="line">|- SearchInputExcludeGlob.vue</span><br><span class="line">|- SettingsCheckboxTerms.vue</span><br><span class="line">|- SettingsCheckboxLaunchOnStartup.vue</span><br></pre></td></tr></table></figure><p>还有另一种多级目录的方式，把所有的搜索组件放到“search”目录，把所有的设置组件放到“settings”目录。我们只推荐在非常大型 (如有 100+ 个组件) 的应用下才考虑这么做，因为在多级目录间找来找去，要比在单个 components 目录下滚动查找要花费更多的精力。</p><h4 id="1-2-7-完整单词的组件名"><a href="#1-2-7-完整单词的组件名" class="headerlink" title="1.2.7 完整单词的组件名"></a>1.2.7 完整单词的组件名</h4><p><strong>组件名应该倾向于而不是缩写。</strong> 编辑器中的自动补全已经让书写长命名的代价非常之低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">components/</span><br><span class="line">|- StudentDashboardSettings.vue</span><br><span class="line">|- UserProfileOptions.vue</span><br></pre></td></tr></table></figure><h3 id="1-3-代码参数命名"><a href="#1-3-代码参数命名" class="headerlink" title="1.3 代码参数命名"></a>1.3 代码参数命名</h3><h4 id="1-3-1-name"><a href="#1-3-1-name" class="headerlink" title="1.3.1 name"></a>1.3.1 name</h4><p><strong>组件名应该始终是多个单词，应该始终是 PascalCase 的。</strong> 根组件 App 以及 <code>&lt;transition&gt;</code>、<code>&lt;component&gt;</code> 之类的 Vue 内置组件除外。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ToDoList&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-prop"><a href="#1-3-2-prop" class="headerlink" title="1.3.2 prop"></a>1.3.2 prop</h4><p><strong>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case</strong>。我们单纯的遵循每个语言的约定，在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">WelcomeMessage</span> <span class="attr">greeting-text</span>=<span class="string">&quot;hi&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">greetingText</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;syncing&#x27;</span>, <span class="string">&#x27;synced&#x27;</span>,].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-router"><a href="#1-3-3-router" class="headerlink" title="1.3.3 router"></a>1.3.3 router</h4><p><strong>Vue Router Path 命名采用 kebab-case 格式。</strong> 用 Snake（如：<code>/user_info</code>）或 camelCase（如：<code>/userInfo</code>)的单词会被当成一个单词，搜索引擎无法区分语义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user_info&#x27;</span>, <span class="comment">// user_info 当成一个单词</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">UserInfo</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27; - 用户&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user-info&#x27;</span>, <span class="comment">// 能解析成 user info</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;UserInfo&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">UserInfo</span>,</span><br><span class="line">  <span class="attr">meta</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27; - 用户&#x27;</span>,</span><br><span class="line">    <span class="attr">desc</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="1-3-4-模板中组件"><a href="#1-3-4-模板中组件" class="headerlink" title="1.3.4 模板中组件"></a>1.3.4 模板中组件</h4><p><strong>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的，但是在 DOM 模板中总是 kebab-case 的。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 DOM 模板中 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-5-自闭合组件"><a href="#1-3-5-自闭合组件" class="headerlink" title="1.3.5 自闭合组件"></a>1.3.5 自闭合组件</h4><p><strong>在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在单文件组件和字符串模板中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在所有地方 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-6-变量"><a href="#1-3-6-变量" class="headerlink" title="1.3.6 变量"></a>1.3.6 变量</h4><ul><li>命名方法：camelCase</li><li>命名规范：类型 + 对象描述或属性的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> getTitle = <span class="string">&quot;LoginTable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> tableTitle = <span class="string">&quot;LoginTable&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySchool = <span class="string">&quot;我的学校&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-7-常量"><a href="#1-3-7-常量" class="headerlink" title="1.3.7 常量"></a>1.3.7 常量</h4><ul><li>命名方法：全部大写下划线分割</li><li>命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_COUNT</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">URL</span> = <span class="string">&#x27;http://test.host.com&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-8-方法"><a href="#1-3-8-方法" class="headerlink" title="1.3.8 方法"></a>1.3.8 方法</h4><ul><li>命名方法：camelCase</li><li>命名规范：统一使用动词或者动词 + 名词形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、普通情况下，使用动词 + 名词形式</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">go、nextPage、show、open、login</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">jumpPage、openCarInfoDialog</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、请求数据方法，以 data 结尾</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">takeData、confirmData、getList、postForm</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">getListData、postFormData</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、单个动词的情况</span></span><br><span class="line">init、refresh</span><br></pre></td></tr></table></figure><table><thead><tr><th>动词</th><th>含义</th><th>返回值</th></tr></thead><tbody><tr><td>can</td><td>判断是否可执行某个动作 (权 )</td><td>函数返回一个布尔值。true：可执行；false：不可执行；</td></tr><tr><td>has</td><td>判断是否含有某个值</td><td>函数返回一个布尔值。true：含有此值；false：不含有此值；</td></tr><tr><td>is</td><td>判断是否为某个值</td><td>函数返回一个布尔值。true：为某个值；false：不为某个值；</td></tr><tr><td>get</td><td>获取某个值</td><td>函数返回一个非布尔值</td></tr><tr><td>set</td><td>设置某个值</td><td>无返回值、返回是否设置成功或者返回链式对象</td></tr></tbody></table><h4 id="1-3-9-自定义事件"><a href="#1-3-9-自定义事件" class="headerlink" title="1.3.9 自定义事件"></a>1.3.9 自定义事件</h4><p><strong>自定义事件应始终使用 kebab-case 的事件名。</strong></p><p>不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;my-event&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyComponent</span> @my-event=<span class="string">&quot;handleDoSomething&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events" title="https://developer.mozilla.org/zh-CN/docs/Web/Events">原生事件参考列表</a></li></ul><p>由原生事件可以发现其使用方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">&quot;toggleHeaderFocus&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;toggleHeaderFocus&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">&quot;toggleMenu&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.esc</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.enter</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.up.prevent</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.down.prevent</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.tab</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">keydown.delete</span>=<span class="string">&quot;handleKeydown&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseenter</span>=<span class="string">&quot;hasMouseHoverHead = true&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">mouseleave</span>=<span class="string">&quot;hasMouseHoverHead = false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而为了区分<em>原生事件</em>和<em>自定义事件</em>在 Vue 中的使用，建议除了多单词事件名使用 kebab-case 的情况下，命名还需遵守为 <strong><code>on</code> + 动词</strong> 的形式，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-search</span>=<span class="string">&quot;handleSearch&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-clear</span>=<span class="string">&quot;handleClear&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">on-clickoutside</span>=<span class="string">&quot;handleClickOutside&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    handleTriggerItem () &#123;</span><br><span class="line">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;on-clear&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-10-事件方法"><a href="#1-3-10-事件方法" class="headerlink" title="1.3.10 事件方法"></a>1.3.10 事件方法</h4><ul><li>命名方法：camelCase</li><li>命名规范：handle + 名称（可选）+ 动词</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">click.native.stop</span>=<span class="string">&quot;handleItemClick()&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    @<span class="attr">mouseenter.native.stop</span>=<span class="string">&quot;handleItemHover()&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    handleItemClick () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    handleItemHover () &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//...</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="二、代码规范"><a href="#二、代码规范" class="headerlink" title="二、代码规范"></a>二、代码规范</h2><h3 id="2-1-Vue"><a href="#2-1-Vue" class="headerlink" title="2.1 Vue"></a>2.1 Vue</h3><h4 id="2-1-1-代码结构"><a href="#2-1-1-代码结构" class="headerlink" title="2.1.1 代码结构"></a>2.1.1 代码结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;my-component&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DemoComponent</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">DemoComponent</span> <span class="keyword">from</span> <span class="string">&#x27;../components/DemoComponent&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;MyComponent&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">DemoComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">mixins</span>: [],</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  data () &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">watch</span>: &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  created () &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  mounted () &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  destroyed () &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line">#my-component &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-data"><a href="#2-1-2-data" class="headerlink" title="2.1.2 data"></a>2.1.2 data</h4><p><strong>组件的 <code>data</code> 必须是一个函数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In a .vue file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-prop"><a href="#2-1-3-prop" class="headerlink" title="2.1.3 prop"></a>2.1.3 prop</h4><p><strong>Prop 定义应该尽量详细。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">status</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">validator</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">          <span class="string">&#x27;syncing&#x27;</span>, </span><br><span class="line">          <span class="string">&#x27;synced&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;version-conflict&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        ].<span class="title function_">indexOf</span>(value) !== -<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-4-computed"><a href="#2-1-4-computed" class="headerlink" title="2.1.4 computed"></a>2.1.4 computed</h4><p><strong>应该把复杂计算属性分割为尽可能多的更简单的属性。</strong> 小的、专注的计算属性减少了信息使用时的假设性限制，所以需求变更时也用不着那么多重构了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="attr">computed</span>: &#123; </span><br><span class="line">  <span class="attr">price</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> basePrice = <span class="variable language_">this</span>.<span class="property">manufactureCost</span> / (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">profitMargin</span>) </span><br><span class="line">    <span class="keyword">return</span> ( </span><br><span class="line">      basePrice - </span><br><span class="line">      basePrice * (<span class="variable language_">this</span>.<span class="property">discountPercent</span> || <span class="number">0</span>) </span><br><span class="line">    ) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">basePrice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">manufactureCost</span> / (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">profitMargin</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">discount</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">basePrice</span> * (<span class="variable language_">this</span>.<span class="property">discountPercent</span> || <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">finalPrice</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">basePrice</span> - <span class="variable language_">this</span>.<span class="property">discount</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-5-为-v-for-设置键值"><a href="#2-1-5-为-v-for-设置键值" class="headerlink" title="2.1.5 为 v-for 设置键值"></a>2.1.5 为 <code>v-for</code> 设置键值</h4><p>**在组件上必须用 <code>key</code> 搭配 <code>v-for</code>**，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的<a href="https://bost.ocks.org/mike/constancy/" title="https://bost.ocks.org/mike/constancy/">对象固化 (object constancy)</a>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-6-v-if-和-v-for-互斥"><a href="#2-1-6-v-if-和-v-for-互斥" class="headerlink" title="2.1.6 v-if 和 v-for 互斥"></a>2.1.6 <code>v-if</code> 和 <code>v-for</code> 互斥</h4><p><strong>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad：控制台报错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般我们在两种常见的情况下会倾向于这样做：</p><ul><li>为了过滤一个列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。在这种情形下，请将 <code>users</code> 替换为一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">activeUsers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">users</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> user.<span class="property">isActive</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in activeUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。这种情形下，请将 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>, <code>ol</code>)。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowUsers&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;user in users&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-7-多个-attribute-的元素"><a href="#2-1-7-多个-attribute-的元素" class="headerlink" title="2.1.7 多个 attribute 的元素"></a>2.1.7 多个 attribute 的元素</h4><p><strong>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://vuejs.org/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Vue Logo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">foo</span>=<span class="string">&quot;a&quot;</span> <span class="attr">bar</span>=<span class="string">&quot;b&quot;</span> <span class="attr">baz</span>=<span class="string">&quot;c&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://vuejs.org/images/logo.png&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;Vue Logo&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span></span></span><br><span class="line"><span class="tag">  <span class="attr">foo</span>=<span class="string">&quot;a&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">bar</span>=<span class="string">&quot;b&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">baz</span>=<span class="string">&quot;c&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-8-模板中简单的表达式"><a href="#2-1-8-模板中简单的表达式" class="headerlink" title="2.1.8 模板中简单的表达式"></a>2.1.8 模板中简单的表达式</h4><p><strong>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</strong></p><p>复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的<strong>是什么</strong>，而非<strong>如何</strong>计算那个值。而且计算属性和方法使得代码可以重用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">&#123;&#123;</span><br><span class="line">  fullName.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">word</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>更好的做法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在模板中 --&gt;</span></span><br><span class="line">&#123;&#123; normalizedFullName &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复杂表达式已经移入一个计算属性</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">normalizedFullName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">fullName</span>.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> word[<span class="number">0</span>].<span class="title function_">toUpperCase</span>() + word.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;).<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-9-带引号的-attribute-值"><a href="#2-1-9-带引号的-attribute-值" class="headerlink" title="2.1.9 带引号的 attribute 值"></a>2.1.9 带引号的 attribute 值</h4><p><strong>非空 HTML 特性值应该始终带双引号。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppSidebar</span> <span class="attr">:style</span>=<span class="string">&#123;width:sidebarWidth+</span>&#x27;<span class="attr">px</span>&#x27;&#125;&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppSidebar</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: sidebarWidth + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-10-指令缩写"><a href="#2-1-10-指令缩写" class="headerlink" title="2.1.10 指令缩写"></a>2.1.10 指令缩写</h4><ul><li><strong>用 <code>:</code> 表示 <code>v-bind:</code></strong></li><li><strong>用 <code>@</code> 表示 <code>v-on:</code></strong></li><li><strong>用 <code>#</code> 表示 <code>v-slot:</code></strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:value</span>=<span class="string">&quot;newTodoText&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:placeholder</span>=<span class="string">&quot;newTodoInstructions&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">input</span>=<span class="string">&quot;onInput&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-HTML"><a href="#2-2-HTML" class="headerlink" title="2.2 HTML"></a>2.2 HTML</h3><h4 id="2-2-1-文件模板"><a href="#2-2-1-文件模板" class="headerlink" title="2.2.1 文件模板"></a>2.2.1 文件模板</h4><p>HTML5 文件模板：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5标准模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>移动端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>移动端HTML模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S DNS预解析 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E DNS预解析 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #include virtual=&quot;&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 线上样式页面片 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /本地调试方式 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://srcPath/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /开发机调试方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 本地调试 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PC 端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your keywords&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your description&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;author,email address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge,chrome=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie-stand&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>PC端HTML模版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S DNS预解析 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E DNS预解析 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 线上样式页面片，开发请直接取消注释引用 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #include virtual=&quot;&quot; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 线上样式页面片 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- S 本地调试，根据开发模式选择调试方式，请开发删除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /本地调试方式 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://srcPath/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /开发机调试方式 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- E 本地调试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-元素及标签闭合"><a href="#2-2-2-元素及标签闭合" class="headerlink" title="2.2.2 元素及标签闭合"></a>2.2.2 元素及标签闭合</h4><p>HTML 元素共有以下5种：</p><ul><li>空元素：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr</li><li>原始文本元素：script、style</li><li>RCDATA 元素：textarea、title</li><li>外来元素：来自 MathML 命名空间和 SVG 命名空间的元素</li><li>常规元素：其他 HTML 允许的元素都称为常规元素</li></ul><p>为了能让浏览器更好的解析代码以及能让代码具有更好的可读性，有如下约定：</p><ul><li>所有具有开始标签和结束标签的元素都要写上起止标签，某些允许省略开始标签或和束标签的元素亦都要写上。</li><li>空元素标签都不加 “&#x2F;” 字符。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字，我有始有终，浏览器能正确解析<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> <span class="attr">data-tomark-pass</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段文字，我有始无终，浏览器亦能正确解析</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-代码嵌套"><a href="#2-2-3-代码嵌套" class="headerlink" title="2.2.3 代码嵌套"></a>2.2.3 代码嵌套</h4><p>元素嵌套规范，每个块状元素独立一行，内联元素可选。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>段落元素与标题元素只能嵌套内联元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-CSS"><a href="#2-3-CSS" class="headerlink" title="2.3 CSS"></a>2.3 CSS</h3><h4 id="2-3-1-样式文件"><a href="#2-3-1-样式文件" class="headerlink" title="2.3.1 样式文件"></a>2.3.1 样式文件</h4><p>样式文件必须写上 <code>@charset</code> 规则，并且一定要在样式文件的第一行首个字符位置开始写，编码名用 <code>“UTF-8”</code>。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @charset规则不在文件首行首个字符开始 */</span></span><br><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @charset规则没有用小写 */</span></span><br><span class="line"><span class="keyword">@CHARSET</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无@charset规则 */</span></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-代码格式化"><a href="#2-3-2-代码格式化" class="headerlink" title="2.3.2 代码格式化"></a>2.3.2 代码格式化</h4><p>样式书写一般有两种：一种是紧凑格式 （Compact），一种是展开格式（Expanded）。</p><ul><li>推荐：展开格式（Expanded）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：紧凑格式 （Compact）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123; <span class="attribute">display</span>: block; <span class="attribute">width</span>: <span class="number">50px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-代码大小写"><a href="#2-3-3-代码大小写" class="headerlink" title="2.3.3 代码大小写"></a>2.3.3 代码大小写</h4><p>样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.JDC</span> &#123;</span><br><span class="line">  <span class="attribute">DISPLAY</span>: BLOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-4-代码易读性"><a href="#2-3-4-代码易读性" class="headerlink" title="2.3.4 代码易读性"></a>2.3.4 代码易读性</h4><ol><li>左括号与类名之间一个空格，冒号与属性值之间一个空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>逗号分隔的取值，逗号之后一个空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#333</span>, <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="number">#333</span>,<span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>为单个 CSS 选择器或新声明开启新行。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>, <span class="selector-class">.jdc_logo</span>, <span class="selector-class">.jdc_hd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span>, <span class="selector-class">.jdc_logo</span>, <span class="selector-class">.jdc_hd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;<span class="selector-class">.nav</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>颜色值 <code>rgb()</code> <code>rgba()</code> <code>hsl()</code> <code>hsla()</code> <code>rect()</code> 中不需有空格，且取值不要带有不必要的 0。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">rgba</span>( <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>属性值十六进制数值能用简写的尽量用简写。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>不要为 <code>0</code> 指明单位。</li></ol><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-5-属性值引号"><a href="#2-3-5-属性值引号" class="headerlink" title="2.3.5 属性值引号"></a>2.3.5 属性值引号</h4><p>CSS 属性值需要用到引号时，统一使用单引号。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Hiragino Sans GB&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Hiragino Sans GB&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-6-属性书写建议"><a href="#2-3-6-属性书写建议" class="headerlink" title="2.3.6 属性书写建议"></a>2.3.6 属性书写建议</h4><p>建议遵循以下顺序：</p><ol><li><p>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</p></li><li><p>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</p></li><li><p>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</p></li><li><p>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background: linear-gradient …</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial, <span class="string">&#x27;Helvetica Neue&#x27;</span>, Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">5</span>);</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-7-CSS3-浏览器私有前缀"><a href="#3-3-7-CSS3-浏览器私有前缀" class="headerlink" title="3.3.7 CSS3 浏览器私有前缀"></a>3.3.7 CSS3 浏览器私有前缀</h4><p>CSS3 浏览器私有前缀在前，标准前缀在后。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-JavaScript"><a href="#2-4-JavaScript" class="headerlink" title="2.4 JavaScript"></a>2.4 JavaScript</h3><h4 id="2-4-1-单行代码块"><a href="#2-4-1-单行代码块" class="headerlink" title="2.4.1 单行代码块"></a>2.4.1 单行代码块</h4><p>在单行代码块中使用空格。</p><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;bar = <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> () &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123; bar = <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-大括号风格"><a href="#2-4-2-大括号风格" class="headerlink" title="2.4.2 大括号风格"></a>2.4.2 大括号风格</h4><p>在编程过程中，大括号风格与缩进风格紧密联系，用来描述大括号相对代码块位置的方法有很多。在 JavaScript 中，主要有三种风格，如下：</p><ul><li><strong>【推荐】One True Brace Style</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Stroustrup</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Allman</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="title function_">baz</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-代码中的空格"><a href="#2-4-3-代码中的空格" class="headerlink" title="2.4.3 代码中的空格"></a>2.4.3 代码中的空格</h4><ol><li>逗号前后的空格可以提高代码的可读性，团队约定在逗号后面使用空格，逗号前面不加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>, bar = <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>,bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> , bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span> ,bar = <span class="number">2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>对象字面量的键和值之间不能存在空格，且要求对象字面量的冒号和值之间存在一个空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;haha&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span> : <span class="string">&#x27;haha&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>代码块前要添加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> () &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a)&#123;</span><br><span class="line">  <span class="title function_">b</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span> ()&#123;&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>函数声明括号前要加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span> (x) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在函数调用时，禁止使用空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn ()</span><br><span class="line"></span><br><span class="line">fn</span><br><span class="line">()</span><br></pre></td></tr></table></figure><ol start="6"><li>在操作符前后都需要添加空格。</li></ol><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="三、注释规范"><a href="#三、注释规范" class="headerlink" title="三、注释规范"></a>三、注释规范</h2><p><strong>注释的目的：</strong></p><ul><li><strong>提高代码的可读性，从而提高代码的可维护性</strong></li></ul><p><strong>注释的原则：</strong></p><ul><li><p><strong>如无必要，勿增注释 ( As short as possible )</strong></p></li><li><p><strong>如有必要，尽量详尽 ( As long as necessary )</strong></p></li></ul><h3 id="3-1-HTML-文件注释"><a href="#3-1-HTML-文件注释" class="headerlink" title="3.1 HTML 文件注释"></a>3.1 HTML 文件注释</h3><h4 id="3-1-1-单行注释"><a href="#3-1-1-单行注释" class="headerlink" title="3.1.1 单行注释"></a>3.1.1 单行注释</h4><p><strong>一般用于简单的描述，如某些状态描述、属性描述等。</strong></p><p>注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行。</p><ul><li>推荐：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>不推荐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- Comment Text --&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-模块注释"><a href="#3-1-2-模块注释" class="headerlink" title="3.1.2 模块注释"></a>3.1.2 模块注释</h4><p><strong>一般用于描述模块的名称以及模块开始与结束的位置。</strong></p><p>注释内容前后各一个空格字符， <code>&lt;!-- S Comment Text --&gt;</code>表示模块开始， <code>&lt;!-- E Comment Text --&gt;</code>表示模块结束，模块与模块之间相隔一行。</p><ul><li>推荐：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- S Comment Text B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text B --&gt;</span></span><br></pre></td></tr></table></figure><ul><li>不推荐</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- S Comment Text B --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text B --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-嵌套模块注释"><a href="#3-1-3-嵌套模块注释" class="headerlink" title="3.1.3 嵌套模块注释"></a>3.1.3 嵌套模块注释</h4><p>当模块注释内再出现模块注释的时候，为了突出主要模块，嵌套模块不再使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text --&gt;</span></span><br></pre></td></tr></table></figure><p>而改用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /Comment Text --&gt;</span></span><br></pre></td></tr></table></figure><p>注释写在模块结尾标签底部，单独一行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- S Comment Text A --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_a&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_b&quot;</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /mod_b --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mod_c&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- /mod_c --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- E Comment Text A --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-CSS-文件注释"><a href="#3-2-CSS-文件注释" class="headerlink" title="3.2 CSS 文件注释"></a>3.2 CSS 文件注释</h3><h4 id="3-2-1-单行注释"><a href="#3-2-1-单行注释" class="headerlink" title="3.2.1 单行注释"></a>3.2.1 单行注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，单独占一行，行与行之间相隔一行。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Comment Text */</span> </span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Comment Text */</span> </span><br><span class="line"><span class="selector-class">.jdc</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Comment Text*/</span></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.jdc</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;<span class="comment">/*Comment Text*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-模块注释"><a href="#3-2-2-模块注释" class="headerlink" title="3.2.2 模块注释"></a>3.2.2 模块注释</h4><p>注释内容第一个字符和最后一个字符都是一个空格字符，<code>/*</code> 与 模块信息描述占一行，多个横线分隔符 <code>-</code> 与 <code>*/</code> 占一行，行与行之间相隔两行。</p><ul><li>推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Module A</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_a</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Module B</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_b</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Module A ---------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_a</span> &#123;&#125;</span><br><span class="line"><span class="comment">/* Module B ---------------------------------------------------- */</span></span><br><span class="line"><span class="selector-class">.mod_b</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-文件注释"><a href="#3-2-3-文件注释" class="headerlink" title="3.2.3 文件注释"></a>3.2.3 文件注释</h4><p>在样式文件编码声明 <code>@charset</code> 语句下面注明页面名称、作者、创建日期等信息。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc File Info</span></span><br><span class="line"><span class="comment"> * @author Author Name</span></span><br><span class="line"><span class="comment"> * @date 2015-10-10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="3-3-JavaScript-文件注释"><a href="#3-3-JavaScript-文件注释" class="headerlink" title="3.3 JavaScript 文件注释"></a>3.3 JavaScript 文件注释</h3><h4 id="3-3-1-单行注释"><a href="#3-3-1-单行注释" class="headerlink" title="3.3.1 单行注释"></a>3.3.1 单行注释</h4><p>单行注释使用 <code>//</code>，注释应单独一行写在被注释对象的上方，不要追加在某条语句的后面。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span> <span class="comment">// is current tab</span></span><br></pre></td></tr></table></figure><p>注释行的上方需要有一个空行（<strong>除非注释行上方是一个块的顶部</strong>），以增加可读性。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> () &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetching type...&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释行上面是一个块的顶部时不需要空行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> () &#123;  </span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span> () &#123;  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fetching type...&#x27;</span>)</span><br><span class="line">  <span class="comment">// set the default type to &#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> type = <span class="variable language_">this</span>.<span class="property">type</span> || <span class="string">&#x27;no type&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-多行注释"><a href="#3-3-2-多行注释" class="headerlink" title="3.3.2 多行注释"></a>3.3.2 多行注释</h4><p>多行注释使用 <code>/** ... */</code>，而不是多行的 <code>//</code>。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span> (tag) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make() returns a new element</span></span><br><span class="line"><span class="comment">// based on the passed in tag name</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span> (tag) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-注释空格"><a href="#3-3-3-注释空格" class="headerlink" title="3.3.3 注释空格"></a>3.3.3 注释空格</h4><p>注释内容和注释符之间需要有一个空格，以增加可读性。eslint: <code>spaced-comment</code>。</p><ul><li>推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * make() returns a new element</span></span><br><span class="line"><span class="comment"> * based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">tag</span>) &#123;  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不推荐：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//is current tab</span></span><br><span class="line"><span class="keyword">const</span> active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *make() returns a new element</span></span><br><span class="line"><span class="comment"> *based on the passed-in tag name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">tag</span>) &#123;  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-特殊标记"><a href="#3-3-4-特殊标记" class="headerlink" title="3.3.4 特殊标记"></a>3.3.4 特殊标记</h4><p>有时我们发现某个可能的 bug，但因为一些原因还没法修复；或者某个地方还有一些待完成的功能，这时我们需要使用相应的特殊标记注释来告知未来的自己或合作者。常用的特殊标记有两种：</p><ul><li><p><code>// FIXME</code> : 说明问题是什么</p></li><li><p><code>// TODO</code> : 说明还要做什么或者问题的解决方案</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Abacus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">super</span> ()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">FIXME:</span> shouldn’t use a global here</span></span><br><span class="line">      total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> total should be configurable by an options param</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">total</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-文档类注释"><a href="#3-3-5-文档类注释" class="headerlink" title="3.3.5 文档类注释"></a>3.3.5 文档类注释</h4><p>文档类注释，如函数、类、文件、事件等；都使用 jsdoc 规范。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Book类，代表一个书本.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">title</span> - 书本的标题.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">author</span> - 书本的作者.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Book</span> (title, author) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = title</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">author</span> = author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Book</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取书本的标题</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> &#123;<span class="type">string|*</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">getTitle</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">title</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置书本的页数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> pageNum &#123;number&#125; 页数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">setPageNum</span>: <span class="keyword">function</span> (<span class="params">pageNum</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pageNum</span>=pageNum</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-6-注释工具"><a href="#3-3-6-注释工具" class="headerlink" title="3.3.6 注释工具"></a>3.3.6 注释工具</h4><p><code>ESLint</code> 是当下最流行的 JS 代码检查工具，<code>ESLint</code> 中有一些注释相关的规则，用户可选择开启：</p><ul><li><p><code>valid-jsdoc</code></p></li><li><p><code>require-jsdoc</code></p></li><li><p><code>no-warning-comments</code></p></li><li><p><code>capitalized-comments</code></p></li><li><p><code>line-comment-position</code></p></li><li><p><code>lines-around-comment</code></p></li><li><p><code>multiline-comment-style</code></p></li><li><p><code>no-inline-comments</code></p></li><li><p><code>spaced-comment</code></p></li></ul><h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><ul><li>缩进换行请使用两个空格。</li><li>大型团队多人协作项目推荐 JavaScript 代码末尾加分号。</li><li>小型个人创新练手项目可尝试使用 JavaScript 代码末尾不加分号的风格，更加清爽简练。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、命名规范&quot;&gt;&lt;a href=&quot;#一、命名规范&quot; class=&quot;headerlink&quot; title=&quot;一、命名规范&quot;&gt;&lt;/a&gt;一、命名规范&lt;/h2&gt;&lt;p&gt;市面上常用的命名规范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;camelCase&lt;/code&gt;（小驼峰式命名</summary>
      
    
    
    
    
    <category term="代码规范" scheme="https://k705.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>vscode 功能与技巧</title>
    <link href="https://k705.github.io/2024/04/25/%E5%B7%A5%E5%85%B7-vscode%20%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <id>https://k705.github.io/2024/04/25/%E5%B7%A5%E5%85%B7-vscode%20%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E5%B7%A7/</id>
    <published>2024-04-25T03:22:46.000Z</published>
    <updated>2024-04-25T03:30:55.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vscode-功能与技巧"><a href="#vscode-功能与技巧" class="headerlink" title="vscode 功能与技巧"></a>vscode 功能与技巧</h1><ul><li>一键执行 npm scripts</li><li>一键 diff、预览</li><li>在新页面搜索</li><li>禅模式</li><li>git 视图显示目录树</li><li>在新编辑器打开文件</li><li>编辑时快速删除、复制、移动行</li><li>全局搜索文件、跳转到某行</li><li>快速切换大小写</li></ul><h2 id="一键执行-npm-scripts"><a href="#一键执行-npm-scripts" class="headerlink" title="一键执行 npm scripts"></a>一键执行 npm scripts</h2><p>vscode 会扫描所有的 npm scripts，然后列出来，直接点击 run 就会打开 terminal 来跑，而且高版本 vscode 还可以直接 debug 来跑。</p><p>根本不需要自己输入 npm run xxx。</p><h2 id="在侧栏打开文件"><a href="#在侧栏打开文件" class="headerlink" title="在侧栏打开文件"></a>在侧栏打开文件</h2><p>当打开文件的时候，默认会在当前编辑器打开，如果想新开一个编辑器打开呢？这时候可以按住 option 再点击文件，就会新开一个编辑器打开文件了。</p><h2 id="更强大的搜索"><a href="#更强大的搜索" class="headerlink" title="更强大的搜索"></a>更强大的搜索</h2><p>搜索这个面板有个按钮可能很多同学都没注意到过，点击之后会打开搜索页面来搜索，可以预览的搜索结果更丰富，行数更多。</p><h2 id="文件-diff-显示目录信息"><a href="#文件-diff-显示目录信息" class="headerlink" title="文件 diff 显示目录信息"></a>文件 diff 显示目录信息</h2><p>当我们改了多个文件的时候，会列在 source control 面板的列表里，有多个同名文件的时候特别不直观。</p><p>这时候其实可以切换成 tree view 的，显示目录树。</p><p>当有多个同名文件的时候，这样会清晰的多：</p><h2 id="编辑器一键预览-markdown"><a href="#编辑器一键预览-markdown" class="headerlink" title="编辑器一键预览 markdown"></a>编辑器一键预览 markdown</h2><p>markdown 需要安装插件么？不需要，vscode 本身就内置了这个功能。</p><p>右上角有个预览按钮，点击就会打开 markdown 预览界面，按住 option 再点击，则是同个窗口打开预览。</p><p>预览之后再点击 show source 按钮就会回去</p><h2 id="编辑区一键-diff"><a href="#编辑区一键-diff" class="headerlink" title="编辑区一键 diff"></a>编辑区一键 diff</h2><h3 id="快速切换-diff-和文件编辑视图"><a href="#快速切换-diff-和文件编辑视图" class="headerlink" title="快速切换 diff 和文件编辑视图"></a>快速切换 diff 和文件编辑视图</h3><p>当改了文件内容的时候，可以点击编辑区右上角的按钮，直接打开 diff，可能很多同学都没注意到这些按钮，但其实是很有用的。</p><p>再次点击就可以回到文件编辑状态</p><p>看功能描述 open changes、open files，很明显就是用于 diff 视图和文件编辑视图的切换。</p><h3 id="diff-视图快速在-diff-之间跳转"><a href="#diff-视图快速在-diff-之间跳转" class="headerlink" title="diff 视图快速在 diff 之间跳转"></a>diff 视图快速在 diff 之间跳转</h3><p>当文件内容特别多，比如好几千行的时候，要找 diff 还是比较麻烦的。其实根本不用自己去找，还容易漏，vscode 编辑器提供了上下按钮，可以直接跳到上一个 diff、下一个 diff</p><p>一键预览、一键 diff，这些都是能提高效率的功能。</p><h2 id="快速搜索功能入口"><a href="#快速搜索功能入口" class="headerlink" title="快速搜索功能入口"></a>快速搜索功能入口</h2><p>知道 vscode 有某个功能但是不知道入口在哪？ 直接用 help 下面的搜索框，搜索结果会直接标出来在哪个菜单下有什么按钮。</p><h2 id="禅模式"><a href="#禅模式" class="headerlink" title="禅模式"></a>禅模式</h2><p>vscode 提供了禅模式（zen mode），可以让你专注于写代码。</p><p>先按 command + k 再按 z 就可以进入禅模式，再按一次退出禅模式。</p><p>禅模式下只显示编辑区的信息，并且会全屏，看不到其他的东西，写代码能更专注。</p><h2 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h2><p>编辑器最主要的功能还是编辑，但其实有很多 vscode 的请打编辑功能大家可能没有过，我来罗列一下。</p><h3 id="行上下移动-复制"><a href="#行上下移动-复制" class="headerlink" title="行上下移动&#x2F;复制"></a>行上下移动&#x2F;复制</h3><p>如果把一行内容上移下移怎么做？</p><p>手动剪切粘贴的效率太低了，不如试下 option + 上&#x2F;下 的快捷键，快速把一行内容上下移动。</p><p>移动的时候想复制呢？再按住 shift 就行了。</p><h3 id="快速删除行"><a href="#快速删除行" class="headerlink" title="快速删除行"></a>快速删除行</h3><p>我们知道了如何快速复制行，那快速删除行呢？</p><p>按 command + shift + k 就好了。</p><p>如果删除多行，那么先选中，再按 command + shift + k。</p><h3 id="多光标同时编辑"><a href="#多光标同时编辑" class="headerlink" title="多光标同时编辑"></a>多光标同时编辑</h3><p>同时修改多个地方的内容？按住 option 点击要修改的地方就可以了。</p><p>如果是上下行的同一位置呢？那就 <strong>option + command + 上&#x2F;下</strong>，这样就是添加多行的同一位置的光标。</p><h2 id="comand-shift-p-相关"><a href="#comand-shift-p-相关" class="headerlink" title="comand + shift + p 相关"></a>comand + shift + p 相关</h2><p>这可能是大家都知道的一个快捷键，输入框中会有一个 &gt; 代表后面是命令，但还有一些大家可能不知道。</p><p>比如直接 command + p，不按 shift，这时候就是搜索文件。</p><p>比如直接按 ctrl + g，或者在输入框输入冒号就代表后面是跳转的行号，可以快速跳到某一行</p><p>当然搜索文件的时候也可以加冒号和行号，快速跳到该文件的那一行。</p><h3 id="快速切换大小写"><a href="#快速切换大小写" class="headerlink" title="快速切换大小写"></a>快速切换大小写</h3><p>还有一个小功能，有个内置的 upppercase、lowercase 的切换功能，可以快速切换选中内容的大小写。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 vscode 中那些可以提效的一些功能，大家可能没有注意到过。</p><ul><li>一键 diff、预览</li><li>在新页面搜索</li><li>git 视图显示目录树</li><li>一键执行 npm scripts</li><li>在新编辑器打开文件</li><li>编辑时快速删除、复制、移动行</li><li>全局搜索文件、跳转到某行</li><li>快速切换大小写</li><li>禅模式</li></ul><p>熟悉了这些功能的使用，相信会给我们日常开发提升一些效率，学习下每天写代码的工具的使用技巧还是挺有意义的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vscode-功能与技巧&quot;&gt;&lt;a href=&quot;#vscode-功能与技巧&quot; class=&quot;headerlink&quot; title=&quot;vscode 功能与技巧&quot;&gt;&lt;/a&gt;vscode 功能与技巧&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一键执行 npm scripts&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="工具" scheme="https://k705.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Vue3-pure-admin</title>
    <link href="https://k705.github.io/2024/04/22/Vue3-pure-admin/"/>
    <id>https://k705.github.io/2024/04/22/Vue3-pure-admin/</id>
    <published>2024-04-22T01:58:28.000Z</published>
    <updated>2024-04-22T02:01:47.144Z</updated>
    
    
    
    
    
    <category term="Vue3" scheme="https://k705.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Ajax笔记</title>
    <link href="https://k705.github.io/2024/04/08/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:44:52.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>本笔记为<code>尚硅谷Web前端Ajax教程初学者零基础入门到精通全套完整版</code>的学习笔记</p><p>该课程主要讲述原生AJAX的写法 以及 市场上常用的对于原生ajax封装的插件简单使用</p><p>此部分知识为学习axios预备知识,预备知识链:ajax –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">promise</a> –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">axios</a> –&gt; <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0">react</a>&#x2F;<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88">vue</a></p><p>仅供本人<code>洪</code>学习使用</p><p>本人笔记地址分享:<a href="https://gitee.com/hongjilin/hongs-study-notes"><code>全部笔记</code></a>、<a href="https://gitee.com/hongjilin/hongs-study-notes/blob/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md"><code>ajax笔记</code></a></p><p>​记录时间: 2021-3-10当日学习完成</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、Ajax简介"><a href="#一、Ajax简介" class="headerlink" title="一、Ajax简介"></a>一、Ajax简介</h1><blockquote><p>AJAX 简介 AJAX 全称为 Asynchronous JavaScript And XML，就是异步的 JS 和 XML。</p><p>通过 AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：<code>无刷新获取数据</code>。</p><p>AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式。</p></blockquote><h2 id="1、XML简介"><a href="#1、XML简介" class="headerlink" title="1、XML简介"></a>1、XML简介</h2><blockquote><ol><li><p>XML 可扩展标记语言。</p></li><li><p>XML 被设计用来传输和存储数据。 </p></li><li><p>XML 和 HTML 类似，不同的是 HTML 中都是预定义标签，而 XML 中没有预定义标签， 全都是自定义标签，用来表示一些数据。</p></li></ol></blockquote><blockquote><p>比如说我有一个学生数据：<br>name &#x3D; “孙悟空” ; age &#x3D; 18 ; gender &#x3D; “男” ;</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用 XML 表示：</span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>孙悟空<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>现在已经被 JSON 取代了。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;孙悟空&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span><span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span><span class="string">&quot;男&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2、Ajax的特点"><a href="#2、Ajax的特点" class="headerlink" title="2、Ajax的特点"></a>2、Ajax的特点</h2><h3 id="Ⅰ-AJAX-的优点"><a href="#Ⅰ-AJAX-的优点" class="headerlink" title="Ⅰ-AJAX 的优点"></a>Ⅰ-AJAX 的优点</h3><blockquote><ol><li><p>可以无需刷新页面而与服务器端进行通信。 </p></li><li><p>允许你根据用户事件来更新部分页面内容。</p></li></ol></blockquote><h3 id="Ⅱ-Ajax的缺点"><a href="#Ⅱ-Ajax的缺点" class="headerlink" title="Ⅱ-Ajax的缺点"></a>Ⅱ-Ajax的缺点</h3><blockquote><ol><li><p>没有浏览历史，不能回退</p></li><li><p>存在跨域问题(同源)</p></li><li><p>SEO 不友好</p></li></ol></blockquote><h2 id="3、HTTP简介"><a href="#3、HTTP简介" class="headerlink" title="3、HTTP简介"></a>3、HTTP简介</h2><blockquote><p>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则、约定,、规则</p></blockquote><h3 id="Ⅰ-请求报文"><a href="#Ⅰ-请求报文" class="headerlink" title="Ⅰ-请求报文"></a>Ⅰ-请求报文</h3><blockquote><p><code>重点是格式与参数</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;行   <span class="variable constant_">POST</span> /s?ie=utf-<span class="number">8</span> <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> </span><br><span class="line"></span><br><span class="line">&gt;头   <span class="title class_">Host</span>: atguigu.<span class="property">com</span></span><br><span class="line">&gt;​    <span class="title class_">Cookie</span>: name=guigu</span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">type</span>: application/x-www-form-urlencoded</span><br><span class="line">&gt;​    <span class="title class_">User</span>-<span class="title class_">Agent</span>: chrome <span class="number">83</span></span><br><span class="line">&gt;空行</span><br><span class="line">&gt;体   username=admin&amp;password=admin</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅱ-响应报文"><a href="#Ⅱ-响应报文" class="headerlink" title="Ⅱ-响应报文"></a>Ⅱ-响应报文</h3><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;行   <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"></span><br><span class="line">&gt;头   <span class="title class_">Content</span>-<span class="title class_">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">length</span>: <span class="number">2048</span></span><br><span class="line">&gt;​    <span class="title class_">Content</span>-<span class="attr">encoding</span>: gzip</span><br><span class="line">&gt;空行  </span><br><span class="line">&gt;体   &lt;html&gt;</span><br><span class="line">&gt;​      &lt;head&gt;</span><br><span class="line">&gt;​      &lt;/head&gt;</span><br><span class="line">&gt;​      &lt;body&gt;</span><br><span class="line">&gt;​        &lt;h1&gt;尚硅谷&lt;/h1&gt;</span><br><span class="line">&gt;​      &lt;/body&gt;</span><br><span class="line">&gt;​    &lt;/html&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-Chrome网络控制台查看通信报文"><a href="#Ⅲ-Chrome网络控制台查看通信报文" class="headerlink" title="Ⅲ-Chrome网络控制台查看通信报文"></a>Ⅲ-Chrome网络控制台查看通信报文</h3><blockquote><p>1、Network  –&gt; Hearders  请求头</p><p>2、Network  –&gt; Response 响应体:通常返回的是html</p></blockquote><h1 id="二、原生Ajax"><a href="#二、原生Ajax" class="headerlink" title="二、原生Ajax"></a>二、原生Ajax</h1><blockquote><p>1、XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的。</p><p>2、当你前端想设置自定义的请求头时,需要如此后端设置响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示接收任意类型的请求</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123; <span class="comment">//响应头 允许跨域     运行自定义响应头</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>); response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);&#125;</span><br></pre></td></tr></table></figure><p>3、<code>ajax请求状态</code>:xhr.readyState<br>    0：请求未初始化，还没有调用 open()。</p><p>​1：请求已经建立，但是还没有发送，还没有调用 send()。</p><p>​2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</p><p>​3：请求在处理中；通常响应中已有部分数据可用了，没有全部完成。</p><p>​4：响应已完成；您可以获取并使用服务器的响应了</p></blockquote><h3 id="〇-Ajax的使用"><a href="#〇-Ajax的使用" class="headerlink" title="〇-Ajax的使用"></a>〇-Ajax的使用</h3><blockquote><p>使用步骤:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="number">1</span>) 创建 <span class="title class_">XMLHttpRequest</span> 对象</span><br><span class="line">&gt;<span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">&gt;<span class="number">2</span>) 设置请求信息</span><br><span class="line">&gt;xhr.<span class="title function_">open</span>(method, url);</span><br><span class="line">&gt;<span class="comment">//可以设置请求头，一般不设置</span></span><br><span class="line">&gt;xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">&gt;<span class="number">3</span>) 发送请求</span><br><span class="line">&gt;xhr.<span class="title function_">send</span>(body) <span class="comment">//get 请求不传 body 参数，只有 post 请求使用</span></span><br><span class="line">&gt;<span class="number">4</span>) 接收响应</span><br><span class="line">&gt;<span class="comment">//xhr.responseXML 接收 xml 格式的响应数据</span></span><br><span class="line">&gt;<span class="comment">//xhr.responseText 接收文本格式的响应数据</span></span><br><span class="line">&gt;xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">var</span> text = xhr.<span class="property">responseText</span>;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&gt;&#125;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅰ-Get方式"><a href="#Ⅰ-Get方式" class="headerlink" title="Ⅰ-Get方式"></a>Ⅰ-Get方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//1. 创建对象</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="comment">//2. 初始化 设置请求方法和 url</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">  <span class="comment">//3. 发送</span></span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  <span class="comment">//4. 事件绑定 处理服务端返回的结果</span></span><br><span class="line">  <span class="comment">// on  when 当....时候</span></span><br><span class="line">  <span class="comment">// readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4</span></span><br><span class="line">  <span class="comment">// change  改变</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//判断 (服务端返回了所有的结果)</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="comment">//判断响应状态码 200  404  403 401 500</span></span><br><span class="line">      <span class="comment">// 2xx 成功</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="comment">//处理结果  行 头 空行 体</span></span><br><span class="line">        <span class="comment">//响应 </span></span><br><span class="line">        <span class="comment">// console.log(xhr.status);//状态码</span></span><br><span class="line">        <span class="comment">// console.log(xhr.statusText);//状态字符串</span></span><br><span class="line">        <span class="comment">// console.log(xhr.getAllResponseHeaders());//所有响应头</span></span><br><span class="line">        <span class="comment">// console.log(xhr.response);//响应体</span></span><br><span class="line">        <span class="comment">//设置 result 的文本</span></span><br><span class="line">        result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-Post方式"><a href="#Ⅱ-Post方式" class="headerlink" title="Ⅱ-Post方式"></a>Ⅱ-Post方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">   result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseover&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="comment">//1. 创建对象</span></span><br><span class="line">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">       <span class="comment">//2. 初始化 设置类型与 URL</span></span><br><span class="line">       xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line">       <span class="comment">//设置请求头</span></span><br><span class="line">       xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">       xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;atguigu&#x27;</span>);</span><br><span class="line">       <span class="comment">//3. 发送</span></span><br><span class="line">       xhr.<span class="title function_">send</span>(<span class="string">&#x27;a=100&amp;b=200&amp;c=300&#x27;</span>);</span><br><span class="line">       <span class="comment">// xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;);</span></span><br><span class="line">       <span class="comment">// xhr.send(&#x27;1233211234567&#x27;);</span></span><br><span class="line">       <span class="comment">//4. 事件绑定</span></span><br><span class="line">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="comment">//判断</span></span><br><span class="line">           <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>)&#123;</span><br><span class="line">                   <span class="comment">//处理服务端返回的结果</span></span><br><span class="line">                   result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-解决ie缓存问题"><a href="#Ⅲ-解决ie缓存问题" class="headerlink" title="Ⅲ-解决ie缓存问题"></a>Ⅲ-解决ie缓存问题</h3><blockquote><p>问题：在一些浏览器中(IE),由于<code>缓存机制</code>的存在，ajax 只会发送的第一次请求，剩余多次请求不会再发送给浏览器而是直接加载缓存中的数据。</p><p>解决方式：浏览器的缓存是根据 url地址来记录的，所以我们只需要修改 url 地址 即可避免缓存问题 <code>xhr.open(&quot;get&quot;,&quot;/testAJAX?t=&quot;+Date.now());</code></p></blockquote><h3 id="Ⅳ-请求超时与网络异常"><a href="#Ⅳ-请求超时与网络异常" class="headerlink" title="Ⅳ-请求超时与网络异常"></a>Ⅳ-请求超时与网络异常</h3><blockquote><p>当你的请求时间过长,或者无网络时,进行的相应处理</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">         <span class="comment">//超时设置 2s 设置</span></span><br><span class="line">         xhr.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">         <span class="comment">//超时回调</span></span><br><span class="line">         xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;网络异常, 请稍后重试!!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//网络异常回调</span></span><br><span class="line">         xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="title function_">alert</span>(<span class="string">&quot;你的网络似乎出了一些问题!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         xhr.<span class="title function_">send</span>();</span><br><span class="line">         xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span>&lt; <span class="number">300</span>)&#123;</span><br><span class="line">                     result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure><h3 id="Ⅴ-取消请求"><a href="#Ⅴ-取消请求" class="headerlink" title="Ⅴ-取消请求"></a>Ⅴ-取消请求</h3><blockquote><p>在请求发出去后<code>但是未响应完成</code>时可以进行取消请求操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> x = <span class="literal">null</span>;</span><br><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">    x.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abort</span></span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    x.<span class="title function_">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅵ-重复请求问题"><a href="#Ⅵ-重复请求问题" class="headerlink" title="Ⅵ-重复请求问题"></a>Ⅵ-重复请求问题</h3><blockquote><p>利用之前Ⅴ中取消请求知识点,当我点击时判断之前请求是否在发送中,如果是,则停止请求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="comment">//判断标识变量</span></span><br><span class="line">         <span class="keyword">if</span>(isSending) x.<span class="title function_">abort</span>();<span class="comment">// 如果正在发送, 则取消该请求, 创建一个新的请求</span></span><br><span class="line">         x = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">         <span class="comment">//修改 标识变量的值</span></span><br><span class="line">         isSending = <span class="literal">true</span>;</span><br><span class="line">         x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&#x27;http://127.0.0.1:8000/delay&#x27;</span>);</span><br><span class="line">         x.<span class="title function_">send</span>();</span><br><span class="line">         x.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="keyword">if</span>(x.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                 <span class="comment">//修改标识变量</span></span><br><span class="line">                 isSending = <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h1 id="三、常见三种Ajax请求方式"><a href="#三、常见三种Ajax请求方式" class="headerlink" title="三、常见三种Ajax请求方式"></a>三、常见三种Ajax请求方式</h1><h2 id="1、jQuery发送AJAX请求"><a href="#1、jQuery发送AJAX请求" class="headerlink" title="1、jQuery发送AJAX请求"></a>1、jQuery发送AJAX请求</h2><blockquote><p>jQuery有三种发送请求方法:</p><p>当你只是简单的请求数据,可以直接使用前两种方式请求,当你需要设置的东西较多的时候,可以使用<code>$.ajax()</code>方法</p></blockquote><h3 id="Ⅰ-get"><a href="#Ⅰ-get" class="headerlink" title="Ⅰ-$.get()"></a>Ⅰ-$.get()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          $.<span class="title function_">get</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">          &#125;,<span class="string">&#x27;json&#x27;</span>);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-post"><a href="#Ⅱ-post" class="headerlink" title="Ⅱ-$.post()"></a>Ⅱ-$.post()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">1</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          $.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>, &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-ajax"><a href="#Ⅲ-ajax" class="headerlink" title="Ⅲ-$.ajax"></a>Ⅲ-$.ajax</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">2</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">             <span class="comment">//url</span></span><br><span class="line">             <span class="attr">url</span>: <span class="string">&#x27;http://127.0.0.1:8000/jquery-server&#x27;</span>,</span><br><span class="line">             <span class="comment">//参数</span></span><br><span class="line">             <span class="attr">data</span>: &#123;<span class="attr">a</span>:<span class="number">100</span>, <span class="attr">b</span>:<span class="number">200</span>&#125;,</span><br><span class="line">             <span class="comment">//请求类型</span></span><br><span class="line">             <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">             <span class="comment">//响应体结果</span></span><br><span class="line">             <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">             <span class="comment">//成功的回调</span></span><br><span class="line">             <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">                 <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//超时时间</span></span><br><span class="line">             <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">             <span class="comment">//失败的回调</span></span><br><span class="line">             <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                 <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出错啦!!&#x27;</span>);</span><br><span class="line">             &#125;,</span><br><span class="line">             <span class="comment">//头信息</span></span><br><span class="line">             <span class="attr">headers</span>: &#123;</span><br><span class="line">                 <span class="attr">c</span>:<span class="number">300</span>,</span><br><span class="line">                 <span class="attr">d</span>:<span class="number">400</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><h2 id="2、Axios发送AJAX请求"><a href="#2、Axios发送AJAX请求" class="headerlink" title="2、Axios发送AJAX请求"></a>2、Axios发送AJAX请求</h2><h3 id="Ⅰ-axios-get"><a href="#Ⅰ-axios-get" class="headerlink" title="Ⅰ-axios.get()"></a>Ⅰ-axios.get()</h3><blockquote><p>axios.get(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置 baseURL</span></span><br><span class="line">  axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//GET 请求</span></span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//url 参数</span></span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">vip</span>: <span class="number">7</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求头信息</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-axios-get"><a href="#Ⅱ-axios-get" class="headerlink" title="Ⅱ-axios.get()"></a>Ⅱ-axios.get()</h3><blockquote><p>axios.post(url,data,params)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;  </span><br><span class="line">btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     axios.<span class="title function_">post</span>(<span class="string">&#x27;/axios-server&#x27;</span>, &#123;</span><br><span class="line">       <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">       <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">     &#125;, &#123;</span><br><span class="line">       <span class="comment">//url </span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">id</span>: <span class="number">200</span>,</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">9</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求头参数</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">         <span class="attr">weight</span>: <span class="number">180</span>,</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-axios-常用"><a href="#Ⅲ-axios-常用" class="headerlink" title="Ⅲ-axios() 常用"></a>Ⅲ-axios() <code>常用</code></h3><blockquote><p>axios({})</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//配置 baseURL</span></span><br><span class="line">   axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://127.0.0.1:8000&#x27;</span>;</span><br><span class="line">btns[<span class="number">2</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="title function_">axios</span>(&#123;</span><br><span class="line">       <span class="comment">//请求方法</span></span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">       <span class="comment">//url</span></span><br><span class="line">       <span class="attr">url</span>: <span class="string">&#x27;/axios-server&#x27;</span>,</span><br><span class="line">       <span class="comment">//url参数</span></span><br><span class="line">       <span class="attr">params</span>: &#123;</span><br><span class="line">         <span class="attr">vip</span>: <span class="number">10</span>,</span><br><span class="line">         <span class="attr">level</span>: <span class="number">30</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//头信息,此部分如果使用自定义的头信息,需要服务端进行相应修改,正常不设置</span></span><br><span class="line">       <span class="attr">headers</span>: &#123;</span><br><span class="line">         <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">         <span class="attr">b</span>: <span class="number">200</span></span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="comment">//请求体参数</span></span><br><span class="line">       <span class="attr">data</span>: &#123;</span><br><span class="line">         <span class="attr">username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">         <span class="attr">password</span>: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">//响应状态码</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">       <span class="comment">//响应状态字符串</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">       <span class="comment">//响应头信息</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">       <span class="comment">//响应体</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="3、Fetch发送AJAX请求"><a href="#3、Fetch发送AJAX请求" class="headerlink" title="3、Fetch发送AJAX请求"></a>3、Fetch发送AJAX请求</h2><blockquote><p>代码示例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">//请求方法</span></span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="comment">//请求头</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//请求体</span></span><br><span class="line">      <span class="attr">body</span>: <span class="string">&#x27;username=admin&amp;password=admin&#x27;</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// return response.text();</span></span><br><span class="line">      <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="四、跨域与解决"><a href="#四、跨域与解决" class="headerlink" title="四、跨域与解决"></a>四、跨域与解决</h1><blockquote><h5 id="1、什么是跨越？"><a href="#1、什么是跨越？" class="headerlink" title="1、什么是跨越？"></a>1、什么是跨越？</h5><ul><li>一个网页向另一个不同域名&#x2F;不同协议&#x2F;不同端口的网页请求资源，这就是跨域。</li><li>跨域原因产生：在当前域名请求网站中，默认不允许通过ajax请求发送其他域名。</li></ul><h5 id="2、为什么会产生跨域请求？"><a href="#2、为什么会产生跨域请求？" class="headerlink" title="2、为什么会产生跨域请求？"></a>2、为什么会产生跨域请求？</h5><ul><li>因为浏览器使用了同源策略</li></ul><h5 id="3、什么是同源策略？"><a href="#3、什么是同源策略？" class="headerlink" title="3、什么是同源策略？"></a>3、什么是同源策略？</h5><ul><li>同源策略是Netscape提出的一个著名的安全策略，现在所有支持JavaScript的浏览器都会使用这个策略。同源策略是浏览器最核心也最基本的安全功能，如果缺少同源策略，浏览器的正常功能可能受到影响。可以说web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。</li><li>同源： 协议、域名、端口号 必须完全相同。 <code>违背同源策略就是跨域</code>。</li></ul><h5 id="4、为什么浏览器要使用同源策略？"><a href="#4、为什么浏览器要使用同源策略？" class="headerlink" title="4、为什么浏览器要使用同源策略？"></a>4、为什么浏览器要使用同源策略？</h5><ul><li>是为了保证用户的信息安全，防止恶意网站窃取数据，如果网页之间不满足同源要求，将不能:</li><li><ul><li>1、共享Cookie、LocalStorage、IndexDB</li></ul></li><li><ul><li>2、获取DOM</li></ul></li><li><ul><li>3、AJAX请求不能发送</li></ul></li></ul><h5 id="5、跨域的五个解决方式"><a href="#5、跨域的五个解决方式" class="headerlink" title="5、跨域的五个解决方式:"></a>5、跨域的五个解决方式:</h5><p>​1、前端使用jsonp （不推荐使用）</p><p>​2、后台Http请求转发</p><p>​3、后台配置同源Cors （推荐）</p><p>​4、使用SpringCloud网关</p><p>​5、使用nginx做转发 (推荐)</p><p>本课程提到了其中的两种:</p></blockquote><h2 id="1、jsonP"><a href="#1、jsonP" class="headerlink" title="1、jsonP"></a>1、jsonP</h2><blockquote><p>1)JSONP 是什么?</p><p>​JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明 才智开发出来，只支持 get 请求。</p><p>2)JSONP 怎么工作的？</p><p>​在网页有一些标签天生具有跨域能力，比如：img link iframe script。 JSONP 就是利用 script 标签的跨域能力来发送请求的。</p></blockquote><h3 id="Ⅰ-jsonP的使用"><a href="#Ⅰ-jsonP的使用" class="headerlink" title="Ⅰ-jsonP的使用"></a>Ⅰ-jsonP的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 1. 动态的创建一个 script 标签------------------------------------------------------------</span></span><br><span class="line">   <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"><span class="comment">//2. 设置 script 的 src， 设置回调函数</span></span><br><span class="line">   script.<span class="property">src</span> = <span class="string">&quot;http://localhost:3000/testAJAX?callback=abc&quot;</span>;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">abc</span>(<span class="params">data</span>) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(data.<span class="property">name</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">  <span class="comment">// 3. 将 script 添加到 body 中</span></span><br><span class="line">   <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 服务器中路由的处理------------------------------------------------------</span></span><br><span class="line">   router.<span class="title function_">get</span>(<span class="string">&quot;/testAJAX&quot;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;收到请求&quot;</span>);</span><br><span class="line">     <span class="keyword">var</span> callback = req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">     <span class="keyword">var</span> obj = &#123;</span><br><span class="line">       <span class="attr">ame</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">       <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">     &#125;</span><br><span class="line">     res.<span class="title function_">send</span>(callback + <span class="string">&quot;(&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-jQuery发送jsonP请求"><a href="#Ⅱ-jQuery发送jsonP请求" class="headerlink" title="Ⅱ-jQuery发送jsonP请求"></a>Ⅱ-jQuery发送jsonP请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端代码-----------------------------------------------------------------------------------</span></span><br><span class="line">$(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">eq</span>(<span class="number">0</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  $.<span class="title function_">getJSON</span>(<span class="string">&#x27;http://127.0.0.1:8000/jquery-jsonp-server?callback=?&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#result&#x27;</span>).<span class="title function_">html</span>(<span class="string">`</span></span><br><span class="line"><span class="string">                名称: <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;</span></span><br><span class="line"><span class="string">                校区: <span class="subst">$&#123;data.city&#125;</span></span></span><br><span class="line"><span class="string">            `</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码-----------------------------------------------------------</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅲ-我自己开发封装的jsonP插件"><a href="#Ⅲ-我自己开发封装的jsonP插件" class="headerlink" title="Ⅲ-我自己开发封装的jsonP插件"></a>Ⅲ-我自己开发封装的jsonP插件</h3><blockquote><p>1、代价:需要前后端联动<br>2、精髓:自动的由插件生成方法名,并在当前的页面动态的生成函数,然后再生成的函数里头调用用户预留的回调函数<br>3、插件：自动化的去模拟基于script去实现跨域请求的过程（对用户来说是黑盒子）<br>4、参数拼接：url已经是带参的。和不带参的<br>5、id优化 额可以添加一个容器来管理id</p></blockquote><blockquote><p>1、前端调用测试封装好的jsonP代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试调用函数</span></span><br><span class="line">    <span class="keyword">let</span> test=<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        jsonP.<span class="title function_">req</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>:<span class="string">&quot;http://localhost:3000/jsonpx&quot;</span>,</span><br><span class="line">            <span class="attr">data</span>:&#123;</span><br><span class="line">                <span class="attr">a</span>:<span class="string">&quot;111&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">callback</span>:<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&quot;成功&quot;</span>+result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2、服务端测试代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/jsonpx&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">req, resp, next</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> callback=req.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line">    <span class="keyword">let</span> data=req.<span class="property">query</span>.<span class="property">a</span>;</span><br><span class="line">    <span class="keyword">if</span> (!data)&#123;</span><br><span class="line">        resp.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码&#x27;)`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(&#x27;洪jl:我是服务端代码`</span>+data+<span class="string">`&#x27;)`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>3、封装原生代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">/**author:<span class="doctag">@hongjilin</span></span></span><br><span class="line"><span class="comment">     * 1.声明一个jsonP插件对象</span></span><br><span class="line"><span class="comment">     * 作用：隔开作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> jsonP = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *2.在插件对象中创建两个名字备用符数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">char</span> = &#123;</span><br><span class="line">        <span class="title class_">Number</span>: <span class="string">&#x27;0123456789&#x27;</span>,</span><br><span class="line">        <span class="title class_">Letter</span>: <span class="string">&#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过随机数抽取备用字符数组库拼凑函数id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">charLen</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">numLen</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">newFunId</span> = <span class="keyword">function</span> (<span class="params">charLen, numLen</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> id = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; charLen; i++) &#123;</span><br><span class="line">            id += <span class="variable language_">this</span>.<span class="property">char</span>.<span class="property">Letter</span>.<span class="title function_">charAt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numLen; j++) &#123;</span><br><span class="line">            id += <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拼接路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">url</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">key</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">value</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">jointUrl</span> = <span class="keyword">function</span> (<span class="params">url, key, value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (url &amp;&amp; key &amp;&amp; value) &#123;</span><br><span class="line">            <span class="keyword">let</span> sign = <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">            <span class="comment">//如果是第一次</span></span><br><span class="line">            <span class="keyword">if</span> (url.<span class="title function_">indexOf</span>(<span class="string">&#x27;?&#x27;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                sign = <span class="string">&#x27;?&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            url += sign + key + <span class="string">&quot;=&quot;</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     封装err属性方便</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">err</span> = <span class="keyword">function</span> (<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> <span class="variable">options</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jsonP.<span class="property">req</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> jsonId=&#123;&#125;;</span><br><span class="line">        <span class="comment">//1.生成方法名</span></span><br><span class="line">        jsonId.<span class="property">funId</span> = <span class="variable language_">this</span>.<span class="title function_">newFunId</span>(<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Userurl</span> = options.<span class="property">url</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Userdata</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">err</span>(<span class="string">&quot;输入不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">Userurl</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">err</span>(<span class="string">&quot;url不能空&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title class_">Userdata</span>) &#123;</span><br><span class="line">            <span class="comment">//如果没有data,初始化</span></span><br><span class="line">            <span class="title class_">Userdata</span> = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将函数名赋值给userdata的回调函数属性中</span></span><br><span class="line">        <span class="title class_">Userdata</span>.<span class="property">callback</span> = jsonId.<span class="property">funId</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> <span class="title class_">Userdata</span>) &#123;</span><br><span class="line">            <span class="title class_">Userurl</span> = <span class="variable language_">this</span>.<span class="title function_">jointUrl</span>(<span class="title class_">Userurl</span>, key, <span class="title class_">Userdata</span>[key])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        script.<span class="title function_">setAttribute</span>(<span class="string">&quot;id&quot;</span> , jsonId.<span class="property">funId</span>);</span><br><span class="line">        script.<span class="title function_">setAttribute</span>(<span class="string">&quot;src&quot;</span> , <span class="title class_">Userurl</span>);</span><br><span class="line">        <span class="comment">//动态生成函数</span></span><br><span class="line">        <span class="keyword">let</span> callback=<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;xxxxxxx&quot;</span>)</span><br><span class="line">            <span class="comment">//业务逻辑回调</span></span><br><span class="line">            <span class="keyword">if</span> (options.<span class="property">callback</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    options.<span class="title function_">callback</span>(result)</span><br><span class="line">                &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="title function_">err</span>(e.<span class="property">message</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//善后</span></span><br><span class="line">            <span class="keyword">let</span> tmp=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(jsonId.<span class="property">funId</span>)</span><br><span class="line">            tmp.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(tmp);</span><br><span class="line">            <span class="built_in">eval</span>(jsonId.<span class="property">funId</span>+<span class="string">&#x27;=null&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">eval</span>(<span class="string">&quot;window.&quot;</span>+jsonId.<span class="property">funId</span>+<span class="string">&quot;=function(result)&#123; callback(result) &#125;&quot;</span>)</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2、CORS"><a href="#2、CORS" class="headerlink" title="2、CORS"></a>2、CORS</h2><blockquote><p>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS文档链接</a></p><p>2、CORS是什么?</p><p>​CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方 案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些 源站通过浏览器有权限访问哪些资源</p><p>3、CORS是怎么工作的?</p><p>​CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应 以后就会对响应放行。</p></blockquote><h3 id="Ⅰ-代码示例"><a href="#Ⅰ-代码示例" class="headerlink" title="Ⅰ-代码示例"></a>Ⅰ-代码示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">    <span class="comment">//响应首部中可以携带一个 Access-Control-Allow-Origin 字段</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">//Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Ⅱ-HTTP-响应首部字段"><a href="#Ⅱ-HTTP-响应首部字段" class="headerlink" title="Ⅱ-HTTP 响应首部字段"></a>Ⅱ-<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#http_%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 响应首部字段</a></h3><blockquote><p>本节列出了规范所定义的响应首部字段。上一小节中，我们已经看到了这些首部字段在实际场景中是如何工作的。</p></blockquote><h4 id="1、Access-Control-Allow-Origin"><a href="#1、Access-Control-Allow-Origin" class="headerlink" title="1、Access-Control-Allow-Origin"></a>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-origin">Access-Control-Allow-Origin</a></h4><blockquote><p>响应首部中可以携带一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"><code>Access-Control-Allow-Origin</code></a> 字段，其语法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: &lt;origin&gt; | *</span><br></pre></td></tr></table></figure><p>其中，origin 参数的值指定了允许访问该资源的外域 URI。对于不需要携带身份凭证的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。</p><p>例如，下面的字段值将允许来自 <a href="http://mozilla.com/">http://mozilla.com</a> 的请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//mozilla.com</span></span><br></pre></td></tr></table></figure><p>如果服务端指定了具体的域名而非“*”，那么响应首部中的 Vary 字段的值必须包含 Origin。这将告诉客户端：服务器对不同的源站返回不同的内容。</p></blockquote><h4 id="2、Access-Control-Expose-Headers"><a href="#2、Access-Control-Expose-Headers" class="headerlink" title="2、Access-Control-Expose-Headers"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-expose-headers">Access-Control-Expose-Headers</a></h4><blockquote><p>译者注：在跨源访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"><code>Access-Control-Expose-Headers</code></a> 头让服务器把允许浏览器访问的头放入白名单，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: X-<span class="title class_">My</span>-<span class="title class_">Custom</span>-<span class="title class_">Header</span>, X-<span class="title class_">Another</span>-<span class="title class_">Custom</span>-<span class="title class_">Header</span></span><br></pre></td></tr></table></figure><p>这样浏览器就能够通过getResponseHeader访问<code>X-My-Custom-Header</code>和 <code>X-Another-Custom-Header</code> 响应头了。</p></blockquote><h4 id="3、Access-Control-Max-Age"><a href="#3、Access-Control-Max-Age" class="headerlink" title="3、Access-Control-Max-Age"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-max-age">Access-Control-Max-Age</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age"><code>Access-Control-Max-Age</code></a> 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Max</span>-<span class="title class_">Age</span>: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure><p><code>delta-seconds</code> 参数表示preflight请求的结果在多少秒内有效。</p></blockquote><h4 id="4、Access-Control-Allow-Credentials"><a href="#4、Access-Control-Allow-Credentials" class="headerlink" title="4、Access-Control-Allow-Credentials"></a>4、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-credentials">Access-Control-Allow-Credentials</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"><code>Access-Control-Allow-Credentials</code></a> 头指定了当浏览器的<code>credentials</code>设置为true时是否允许浏览器读取response的内容。当用在对preflight预检测请求的响应中时，它指定了实际的请求是否可以使用<code>credentials</code>。请注意：简单 GET 请求不会被预检；如果对此类请求的响应中不包含该字段，这个响应将被忽略掉，并且浏览器也不会将相应内容返回给网页。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="5、Access-Control-Allow-Methods"><a href="#5、Access-Control-Allow-Methods" class="headerlink" title="5、Access-Control-Allow-Methods"></a>5、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-methods">Access-Control-Allow-Methods</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"><code>Access-Control-Allow-Methods</code></a> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Methods</span>: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h4 id="6、Access-Control-Allow-Headers"><a href="#6、Access-Control-Allow-Headers" class="headerlink" title="6、Access-Control-Allow-Headers"></a>6、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-allow-headers">Access-Control-Allow-Headers</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"><code>Access-Control-Allow-Headers</code></a> 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Headers</span>: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></blockquote><h3 id="Ⅲ-HTTP-请求首部字段"><a href="#Ⅲ-HTTP-请求首部字段" class="headerlink" title="Ⅲ-HTTP 请求首部字段"></a>Ⅲ-<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#http_%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5">HTTP 请求首部字段</a></h3><blockquote><p>本节列出了可用于发起跨源请求的首部字段。请注意，这些首部字段无须手动设置。 当开发者使用 XMLHttpRequest 对象发起跨源请求时，它们已经被设置就绪。</p></blockquote><h4 id="1、Origin"><a href="#1、Origin" class="headerlink" title="1、Origin"></a>1、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#origin">Origin</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 首部字段表明预检请求或实际请求的源站。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Origin</span>: &lt;origin&gt;</span><br></pre></td></tr></table></figure><p>origin 参数的值为源站 URI。它不包含任何路径信息，只是服务器名称。</p><p><strong>Note:</strong> 有时候将该字段的值设置为空字符串是有用的，例如，当源站是一个 data URL 时。</p><p>注意，在所有访问控制请求（Access control request）中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Origin"><code>Origin</code></a> 首部字段<strong>总是</strong>被发送</p></blockquote><h4 id="2、Access-Control-Request-Method"><a href="#2、Access-Control-Request-Method" class="headerlink" title="2、Access-Control-Request-Method"></a>2、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-request-method">Access-Control-Request-Method</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method"><code>Access-Control-Request-Method</code></a> 首部字段用于预检请求。其作用是，将实际请求所使用的 HTTP 方法告诉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Method</span>: &lt;method&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="3、Access-Control-Request-Headers"><a href="#3、Access-Control-Request-Headers" class="headerlink" title="3、Access-Control-Request-Headers"></a>3、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#access-control-request-headers">Access-Control-Request-Headers</a></h4><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers"><code>Access-Control-Request-Headers</code></a> 首部字段用于预检请求。其作用是，将实际请求所携带的首部字段告诉服务器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Request</span>-<span class="title class_">Headers</span>: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></blockquote><hr><hr><h1 id="五、服务端代码示例"><a href="#五、服务端代码示例" class="headerlink" title="五、服务端代码示例"></a>五、服务端代码示例</h1><blockquote><p>配合以上前端代码的服务端代码</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request 是对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 是对响应报文的封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX - 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以接收任意类型的请求 </span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO AJAX POST&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JSON 响应</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/json-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//响应一个数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//对对象进行字符串转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对 IE 缓存</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ie&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;HELLO IE - 5&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时响应</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/delay&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//设置响应体</span></span><br><span class="line">    response.<span class="title function_">send</span>(<span class="string">&#x27;延时响应&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//axios 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/axios-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetch 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/fetch-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头  设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  response.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonp服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷atguigu&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户名检测是否存在</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/check-username&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">exist</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;用户名已经存在&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/jquery-jsonp-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//将数据转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  <span class="comment">//接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.<span class="property">query</span>.<span class="property">callback</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  response.<span class="title function_">end</span>(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&#x27;/cors-server&#x27;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:5500&quot;);</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&#x27;hello CORS&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 监听端口启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动, 8000 端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本笔记为&lt;code&gt;尚硅谷Web前端Ajax教程初学者零基础入门到精通全套完整版&lt;/code&gt;的学习笔记&lt;/p</summary>
      
    
    
    
    
    <category term="Ajax" scheme="https://k705.github.io/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>AntDesign封装</title>
    <link href="https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-Table%E5%8F%8A%E5%85%B6%E7%AD%9B%E9%80%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"/>
    <id>https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-Table%E5%8F%8A%E5%85%B6%E7%AD%9B%E9%80%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T10:16:20.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>代码中使用到了<code>mobx</code>,其实如果只要部分功能,可以不使用<code>mobx</code>,但主要此处列出可以有借鉴效果</p></blockquote><h1 id="一、调用"><a href="#一、调用" class="headerlink" title="一、调用"></a>一、调用</h1><blockquote><p>基本用法与正常antd的table一摸一样,只是多了几个个性化属性,可以满足个性化需求</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="variable constant_">FC</span>, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">Store</span> <span class="keyword">from</span> <span class="string">&#x27;../store&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">Table</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> columns <span class="keyword">from</span> <span class="string">&#x27;./columns&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;../style.scss&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">MyEmpty</span>,<span class="title class_">MyTable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;~/components&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;interface <span class="title class_">IProps</span> &#123;</span><br><span class="line">&gt;<span class="attr">store</span>: <span class="title class_">Store</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">PageTable</span>: <span class="variable constant_">FC</span>&lt;<span class="title class_">IProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> &#123;</span><br><span class="line">&gt;<span class="attr">source</span>: &#123; tableList, pageConfig, loading &#125;,</span><br><span class="line">&gt;getTableList,</span><br><span class="line">&gt;handleChangeTable,</span><br><span class="line">&gt;&#125; = props.<span class="property">store</span>;</span><br><span class="line">&gt;<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">getTableList</span>();</span><br><span class="line">&gt;&#125;, []);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> (</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.tableContainer&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">MyTable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">scroll</span>=<span class="string">&#123;&#123;</span> <span class="attr">x:</span> <span class="attr">600</span>, <span class="attr">y:</span> &#x27;<span class="attr">calc</span>(<span class="attr">100</span>% <span class="attr">-</span> <span class="attr">72px</span>)&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">rowKey</span>=<span class="string">&quot;hongjilin&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">showId</span>=<span class="string">&#123;false&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">columns</span>=<span class="string">&#123;columns(props.store)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">dataSource</span>=<span class="string">&#123;tableList&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">pagination</span>=<span class="string">&#123;pageConfig&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">onChange</span>=<span class="string">&#123;handleChangeTable&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">locale</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">emptyText:</span> &lt;<span class="attr">MyEmpty</span> /&gt;</span>, //此处调用的是,如果为空组件</span></span><br><span class="line"><span class="language-xml">  &#125;&#125;</span></span><br><span class="line"><span class="language-xml">/&gt;</span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> (<span class="title class_">PageTable</span>);</span><br></pre></td></tr></table></figure></blockquote><h1 id="二、运行效果"><a href="#二、运行效果" class="headerlink" title="二、运行效果"></a>二、运行效果</h1><blockquote><p><img src="/k705/kk.github.io.git/AntDesignOfReact%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210806184129571.png"></p></blockquote><h1 id="三、封装"><a href="#三、封装" class="headerlink" title="三、封装"></a>三、封装</h1><h2 id="Ⅰ-SCSS文件"><a href="#Ⅰ-SCSS文件" class="headerlink" title="Ⅰ-SCSS文件"></a>Ⅰ-SCSS文件</h2><blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//table.scss</span></span><br><span class="line">&gt;<span class="selector-class">.tableWrapper</span> &#123;</span><br><span class="line"> :global &#123;</span><br><span class="line">   <span class="selector-class">.ant-table-row-expand-icon</span> &#123;</span><br><span class="line">     &amp;<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">7px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">right</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">3px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     &amp;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">3px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">bottom</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">7px</span> <span class="meta">!important</span>;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">2px</span> <span class="meta">!important</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.react-resizable</span> &#123;</span><br><span class="line">     <span class="attribute">position</span>: relative;</span><br><span class="line">     <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.react-resizable-handle</span> &#123;</span><br><span class="line">     <span class="attribute">position</span>: absolute;</span><br><span class="line">     <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">     <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">     <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">cursor</span>: col-resize;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="selector-class">.filterBody</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line"> <span class="selector-class">.filterTitle</span> &#123;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">32px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.filterItem</span> &#123;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">   <span class="attribute">align-items</span>: center;</span><br><span class="line">   <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">   <span class="attribute">cursor</span>: pointer;</span><br><span class="line">   <span class="attribute">color</span>: <span class="number">#353535</span>;</span><br><span class="line">   <span class="selector-class">.filterText</span> &#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">     <span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &amp;<span class="selector-class">.cursorItem</span> &#123;</span><br><span class="line">     <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.filterItem</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">   <span class="attribute">background</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">   <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">53</span>, <span class="number">105</span>, <span class="number">253</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.line</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: <span class="number">#e8e8e8</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">16px</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅱ-resizable-title-tsx"><a href="#Ⅱ-resizable-title-tsx" class="headerlink" title="Ⅱ-resizable-title.tsx"></a>Ⅱ-resizable-title.tsx</h2><blockquote><p>此处为可拖拽表格组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; useLayoutEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">Resizable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-resizable&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title function_">ResizableTitle</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; onResize, width, ...restProps &#125; = props;</span><br><span class="line"> <span class="keyword">const</span> thRef = useRef&lt;any&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Resizable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">width</span>=<span class="string">&#123;width</span> || <span class="attr">thRef.current</span>?<span class="attr">.offsetWidth</span> || <span class="attr">100</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">height</span>=<span class="string">&#123;0&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">handle</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       &lt;<span class="attr">span</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">className</span>=<span class="string">&quot;react-resizable-handle&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">           e.stopPropagation();</span></span><br><span class="line"><span class="language-xml">         &#125;&#125;</span></span><br><span class="line"><span class="language-xml">       /&gt;</span></span><br><span class="line"><span class="language-xml">     &#125;</span></span><br><span class="line"><span class="language-xml">     onResize=&#123;onResize&#125;</span></span><br><span class="line"><span class="language-xml">     draggableOpts=&#123;&#123; enableUserSelectHack: false &#125;&#125;</span></span><br><span class="line"><span class="language-xml">   &gt;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">th</span> <span class="attr">ref</span>=<span class="string">&#123;thRef&#125;</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Resizable</span>&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ResizableTitle</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅲ-table-tsx"><a href="#Ⅲ-table-tsx" class="headerlink" title="Ⅲ-table.tsx"></a>Ⅲ-table.tsx</h2><blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123;</span><br><span class="line"> useCallback,</span><br><span class="line"> useEffect,</span><br><span class="line"> useMemo,</span><br><span class="line"> useRef,</span><br><span class="line"> useState,</span><br><span class="line">&gt;&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">Table</span>, <span class="title class_">TableProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">CheckOutlined</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; inject, observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">&#x27;./table.scss&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">ResizableTitle</span> <span class="keyword">from</span> <span class="string">&#x27;./resizable-title&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> &#123; <span class="title class_">ColumnsType</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd/lib/table&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;interface <span class="title class_">SuperTableProps</span>&lt;<span class="title class_">RecordType</span>&gt; <span class="keyword">extends</span> <span class="title class_">TableProps</span>&lt;<span class="title class_">RecordType</span>&gt; &#123;</span><br><span class="line"> showId?: boolean;</span><br><span class="line"> <span class="comment">//是否显示筛选自定义列表图标</span></span><br><span class="line"> showColumnFilter?: boolean;</span><br><span class="line"> menuStore?: any;</span><br><span class="line"> userStore?: any;</span><br><span class="line"> <span class="comment">//首列ID是否浮动定位,传入为字符串类型,不传则为空不浮动</span></span><br><span class="line"> fixedType?: <span class="title class_">String</span> | <span class="literal">undefined</span>;</span><br><span class="line"> <span class="comment">//首列ID列的宽度</span></span><br><span class="line"> idWidth?: <span class="title class_">Number</span> | <span class="literal">undefined</span>;</span><br><span class="line"> <span class="comment">//是否需要默认渲染ID列--&gt;true:隐藏</span></span><br><span class="line"> hidderIDColumns?: boolean;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title class_">MyTable</span>&lt;<span class="title class_">RecordType</span> <span class="keyword">extends</span> object = any&gt;(</span><br><span class="line"> <span class="attr">props</span>: <span class="title class_">SuperTableProps</span>&lt;<span class="title class_">RecordType</span>&gt;</span><br><span class="line">&gt;) &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="variable constant_">TABLE_CONFIG_KEY</span> = <span class="string">`TABLE_COLUMNS_CONFIGS_<span class="subst">$&#123;props.userStore.user.name&#125;</span>`</span>;</span><br><span class="line"> <span class="keyword">const</span> &#123; showColumnFilter = <span class="literal">true</span> &#125; = props;</span><br><span class="line"> <span class="keyword">const</span> [hiddenColumns, setHiddenColumns] = <span class="title function_">useState</span>([]);</span><br><span class="line"> <span class="keyword">const</span> [columns, setColumns] = <span class="title function_">useState</span>([]);</span><br><span class="line"> <span class="keyword">const</span> [sorterColumn, setSorterColumn] = <span class="title function_">useState</span>();</span><br><span class="line"> <span class="keyword">const</span> handleResizeRef = useRef&lt;<span class="title class_">Function</span>&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> [pagiConfig, setPagiConfig] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"> <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初次进入页面时，从 localStorage 中读取数据，初始化 hiddenColumns</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">const</span> oldTableColumnsConfigs = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(</span><br><span class="line">     <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="variable constant_">TABLE_CONFIG_KEY</span>)</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">if</span> (!oldTableColumnsConfigs) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> oldHiddenColumns = oldTableColumnsConfigs[props.<span class="property">menuStore</span>.<span class="property">activeKey</span>];</span><br><span class="line">   <span class="keyword">if</span> (oldHiddenColumns) &#123;</span><br><span class="line">     <span class="title function_">setHiddenColumns</span>(oldHiddenColumns);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;, [props.<span class="property">menuStore</span>.<span class="property">activeKey</span>, setHiddenColumns]);</span><br><span class="line"></span><br><span class="line"> handleResizeRef.<span class="property">current</span> =</span><br><span class="line">   <span class="function">(<span class="params">index</span>) =&gt;</span></span><br><span class="line">     <span class="function">(<span class="params">e, &#123; size &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> nextColumns = [...columns];</span><br><span class="line">       nextColumns[index] = &#123;</span><br><span class="line">         ...nextColumns[index],</span><br><span class="line">         <span class="attr">width</span>: size.<span class="property">width</span>,</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="title function_">setColumns</span>(nextColumns);</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; pagination = &#123;&#125;, filters, sorter, otherParams &#125; = pagiConfig;</span><br><span class="line">   <span class="keyword">if</span> (pagination?.<span class="property">current</span> &gt; <span class="number">1</span> &amp;&amp; props?.<span class="property">dataSource</span>?.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 删除了最后一条数据应该返回上一页</span></span><br><span class="line">     <span class="keyword">let</span> newPagi = &#123;</span><br><span class="line">       ...pagination,</span><br><span class="line">       <span class="attr">current</span>: pagination.<span class="property">current</span> - <span class="number">1</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="title function_">handleTableChange</span>(newPagi, filters, sorter, ...otherParams);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;, [props?.<span class="property">dataSource</span>?.<span class="property">length</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; showId = <span class="literal">true</span> &#125; = props;</span><br><span class="line">   <span class="keyword">let</span> newColumns =</span><br><span class="line">     props.<span class="property">columns</span> ||</span><br><span class="line">     <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(props.<span class="property">children</span>, <span class="function">(<span class="params">child: any</span>) =&gt;</span> child?.<span class="property">props</span>);</span><br><span class="line">   <span class="keyword">const</span> hasIdField = newColumns.<span class="title function_">some</span>(</span><br><span class="line">     <span class="function">(<span class="params">col</span>) =&gt;</span> col.<span class="property">dataIndex</span>?.<span class="title function_">toLowerCase</span>() === <span class="string">&#x27;id&#x27;</span></span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!hasIdField &amp;&amp; showId) &#123;</span><br><span class="line">     <span class="comment">//不传或者传入为false时,为不隐藏ID列</span></span><br><span class="line">     <span class="keyword">if</span> (!props?.<span class="property">hidderIDColumns</span>)</span><br><span class="line">       newColumns.<span class="title function_">unshift</span>(&#123;</span><br><span class="line">         <span class="attr">title</span>: <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">         <span class="attr">dataIndex</span>: <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">         <span class="comment">//首列id宽度,如果不传入则默认150</span></span><br><span class="line">         <span class="attr">width</span>: props?.<span class="property">idWidth</span> || <span class="number">150</span>,</span><br><span class="line">         <span class="comment">//首列ID是否浮动定位,传入为字符串类型,不传则为空</span></span><br><span class="line">         <span class="attr">fixed</span>: props?.<span class="property">fixedType</span>,</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   newColumns = newColumns.<span class="title function_">map</span>(<span class="function">(<span class="params">col, index</span>) =&gt;</span> (&#123;</span><br><span class="line">     ...col,</span><br><span class="line">     <span class="attr">onHeaderCell</span>: <span class="function">(<span class="params">column</span>) =&gt;</span> (&#123;</span><br><span class="line">       <span class="attr">width</span>: column.<span class="property">width</span>,</span><br><span class="line">       <span class="attr">onResize</span>: handleResizeRef.<span class="title function_">current</span>(index),</span><br><span class="line">     &#125;),</span><br><span class="line">   &#125;));</span><br><span class="line">   <span class="title function_">setColumns</span>(newColumns);</span><br><span class="line"> &#125;, [props.<span class="property">columns</span>, props.<span class="property">children</span>, handleResizeRef]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> filteredColumns = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">//此处根据传入数组</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">applySorterToColumns</span>(<span class="params">columns: ColumnsType</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> columns.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&#x27;sorter&#x27;</span> <span class="keyword">in</span> item) &#123;</span><br><span class="line">         <span class="keyword">return</span> &#123;</span><br><span class="line">           ...item,</span><br><span class="line">           <span class="attr">key</span>: item.<span class="property">key</span> || item.<span class="property">dataIndex</span>,</span><br><span class="line">           <span class="attr">sortOrder</span>:</span><br><span class="line">             sorterColumn?.<span class="property">field</span> == item.<span class="property">dataIndex</span> &amp;&amp; sorterColumn?.<span class="property">order</span>,</span><br><span class="line">         &#125;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">         ...item,</span><br><span class="line">         <span class="attr">key</span>: item.<span class="property">key</span> || item.<span class="property">dataIndex</span>,</span><br><span class="line">         <span class="attr">isCustomSorter</span>: <span class="literal">true</span>,</span><br><span class="line">         <span class="comment">// sorter: (a, b) =&gt; &#123;</span></span><br><span class="line">         <span class="comment">//   return a[item.dataIndex] - b[item.dataIndex];</span></span><br><span class="line">         <span class="comment">// &#125;,</span></span><br><span class="line">         <span class="comment">// sortOrder:</span></span><br><span class="line">         <span class="comment">//   sorterColumn?.field == item.dataIndex &amp;&amp; sorterColumn?.order,</span></span><br><span class="line">       &#125;;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> filterColumns = columns.<span class="title function_">filter</span>(</span><br><span class="line">     <span class="function">(<span class="params">columns</span>) =&gt;</span> !hiddenColumns.<span class="title function_">includes</span>(columns.<span class="property">dataIndex</span>)</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">const</span> lastColumn = filterColumns[filterColumns.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">   filterColumns[filterColumns.<span class="property">length</span> - <span class="number">1</span>] = &#123;</span><br><span class="line">     ...lastColumn,</span><br><span class="line">     <span class="attr">filterDropdown</span>: showColumnFilter</span><br><span class="line">       ? <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (lastColumn.<span class="property">filterDropdown</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> lastColumn.<span class="title function_">filterDropdown</span>(...params);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_">filterDropdown</span>(...params);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       : <span class="literal">undefined</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">//此行控制列表为部筛选图标</span></span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">applySorterToColumns</span>(filterColumns);</span><br><span class="line"> &#125;, [columns, hiddenColumns, sorterColumn]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">setTableField</span>(<span class="params">dataIndex</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> newHiddenColumns = [...hiddenColumns];</span><br><span class="line">   <span class="keyword">if</span> (hiddenColumns.<span class="title function_">includes</span>(dataIndex)) &#123;</span><br><span class="line">     newHiddenColumns = hiddenColumns.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item !== dataIndex);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     newHiddenColumns = [...hiddenColumns, dataIndex];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//判断是否赋值</span></span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">     columns.<span class="title function_">some</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> value.<span class="property">title</span> == <span class="string">&#x27;操作&#x27;</span>) &amp;&amp;</span><br><span class="line">     columns.<span class="property">length</span> - <span class="number">1</span> == newHiddenColumns.<span class="property">length</span></span><br><span class="line">   ) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (columns.<span class="property">length</span> == newHiddenColumns.<span class="property">length</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">setHiddenColumns</span>(newHiddenColumns);</span><br><span class="line">   <span class="keyword">if</span> (!<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="variable constant_">TABLE_CONFIG_KEY</span>)) &#123;</span><br><span class="line">     <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(</span><br><span class="line">       <span class="variable constant_">TABLE_CONFIG_KEY</span>,</span><br><span class="line">       <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">         [props.<span class="property">menuStore</span>.<span class="property">activeKey</span>]: newHiddenColumns,</span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> oldTableColumnsConfigs = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(</span><br><span class="line">       <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="variable constant_">TABLE_CONFIG_KEY</span>)</span><br><span class="line">     );</span><br><span class="line">     <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(</span><br><span class="line">       <span class="variable constant_">TABLE_CONFIG_KEY</span>,</span><br><span class="line">       <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">         ...oldTableColumnsConfigs,</span><br><span class="line">         [props.<span class="property">menuStore</span>.<span class="property">activeKey</span>]: newHiddenColumns,</span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">filterDropdown</span>(<span class="params">...params</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.filterBody&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.filterTitle&#125;</span>&gt;</span>自定义表格字段<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">       &#123;columns?.map((column, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">         //不将`操作`放入自定义下拉框中---&gt;暂时将最后一列隐藏,后续再改</span></span><br><span class="line"><span class="language-xml">         if (columns?.length - 1 != index || column?.title != &#x27;操作&#x27;)</span></span><br><span class="line"><span class="language-xml">           return (</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">className</span>=<span class="string">&#123;style.filterItem&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">               <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setTableField(column.dataIndex)&#125;</span></span><br><span class="line"><span class="language-xml">             &gt;</span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;style.filterText&#125;</span>&gt;</span>&#123;column.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               &#123;!hiddenColumns.includes(column.dataIndex) &amp;&amp; <span class="tag">&lt;<span class="name">CheckOutlined</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           );</span></span><br><span class="line"><span class="language-xml">       &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">handleTableChange</span>(<span class="params">pagination, filters, sorter, ...otherParams</span>) &#123;</span><br><span class="line">   <span class="title function_">setPagiConfig</span>(&#123; pagination, filters, sorter, otherParams &#125;);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(sorter, <span class="string">&#x27;sorter&#x27;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="title function_">setSorterColumn</span>(&#123; <span class="attr">field</span>: sorter?.<span class="property">field</span>, <span class="attr">order</span>: sorter?.<span class="property">order</span> &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 前端排序的字段，在 onChange 时清空 sorter</span></span><br><span class="line"><span class="comment">    * 避免外部捕获 sorter 后传给接口报错</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (sorter?.<span class="property">column</span>?.<span class="property">isCustomSorter</span>) &#123;</span><br><span class="line">     sorter.<span class="property">field</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">     sorter.<span class="property">order</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (props.<span class="property">onChange</span>) &#123;</span><br><span class="line">     props.<span class="title function_">onChange</span>(pagination, filters, sorter, ...otherParams);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// debugger</span></span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">Table</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     &#123;<span class="attr">...props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">className</span>=<span class="string">&#123;style.tableWrapper&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">columns</span>=<span class="string">&#123;filteredColumns&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">onChange</span>=<span class="string">&#123;handleTableChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     <span class="attr">components</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">header:</span> &#123;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">         <span class="attr">cell:</span> <span class="attr">ResizableTitle</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       &#125;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">...</span>(<span class="attr">props.components</span> || &#123;&#125;),</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">   /&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">inject</span>(<span class="string">&#x27;menuStore&#x27;</span>, <span class="string">&#x27;userStore&#x27;</span>)(<span class="title function_">observer</span>(<span class="title class_">MyTable</span>));</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;代码中使用到了&lt;code&gt;mobx&lt;/code&gt;,其实如果只要部分功能,可以不使用&lt;code&gt;mobx&lt;/co</summary>
      
    
    
    
    
    <category term="AntDesign" scheme="https://k705.github.io/tags/AntDesign/"/>
    
  </entry>
  
  <entry>
    <title>antd原生Notification通知提醒框</title>
    <link href="https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-%E5%B0%81%E8%A3%85Notification%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92%E6%A1%86%E7%BB%84%E4%BB%B6/"/>
    <id>https://k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-%E5%B0%81%E8%A3%85Notification%E9%80%9A%E7%9F%A5%E6%8F%90%E9%86%92%E6%A1%86%E7%BB%84%E4%BB%B6/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:33:17.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p><a href="https://ant.design/components/notification-cn/">antd原生Notification通知提醒框地址</a></p><p>此组件为二次封装[<code>antd原生Notification通知提醒框</code>],方便项目使用.也能起到一定的借鉴与记录作用</p></blockquote><h1 id="Ⅰ-封装的组件代码"><a href="#Ⅰ-封装的组件代码" class="headerlink" title="Ⅰ-封装的组件代码"></a>Ⅰ-封装的组件代码</h1><blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> &#123; notification &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">//此处根据自己需求定义,也可以不进行匹配</span></span><br><span class="line">&gt;<span class="keyword">const</span>  <span class="title class_">NotificationType</span>= &#123;</span><br><span class="line">   <span class="title class_">NetError</span>: -<span class="number">1</span>,</span><br><span class="line">   <span class="title class_">ServerError</span>: -<span class="number">2</span>,</span><br><span class="line">   <span class="title class_">OtherError</span>: -<span class="number">3</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">interface</span> <span class="title class_">NotificationConfig</span> &#123;</span><br><span class="line"> msg?;</span><br><span class="line"> duration?: <span class="built_in">number</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">HongNotification</span> = &#123;</span><br><span class="line"> <span class="comment">//配置默认[config],此处可修改</span></span><br><span class="line"> <span class="attr">defaultConfig</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">   <span class="attr">message</span>: <span class="string">&#x27;提示框&#x27;</span>,</span><br><span class="line">   <span class="attr">duration</span>: <span class="number">2</span>, <span class="comment">//默认自动关闭延时，单位秒</span></span><br><span class="line"> &#125;),</span><br><span class="line"> <span class="comment">// 二次确认</span></span><br><span class="line"> <span class="attr">base</span>: <span class="function">(<span class="params"><span class="keyword">type</span>, beforeConfig</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> config = beforeConfig;</span><br><span class="line">   <span class="comment">//当传入的提示内容为空,提示写死的内容</span></span><br><span class="line">   <span class="keyword">if</span> (config.<span class="property">msg</span> === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">     config = &#123;</span><br><span class="line">       <span class="attr">msg</span>: <span class="string">&#x27;请稍候重试&#x27;</span>,</span><br><span class="line">     &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   config.<span class="property">description</span> = config.<span class="property">msg</span>;</span><br><span class="line">   <span class="keyword">delete</span> config.<span class="property">msg</span>;</span><br><span class="line"></span><br><span class="line">   notification[<span class="keyword">type</span>](</span><br><span class="line">     &#123; ...<span class="title class_">HongNotification</span>.<span class="title function_">defaultConfig</span>(), ...config &#125;</span><br><span class="line">   );</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">success</span>: <span class="function">(<span class="params">config: NotificationConfig = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (!config.<span class="property">msg</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;success&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">info</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;info&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">warning</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;warning&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">error</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(config);</span><br><span class="line">   <span class="comment">// 传入的错误信息为-1 固定都是提示网络问题</span></span><br><span class="line">   <span class="keyword">if</span> (config.<span class="property">msg</span> == <span class="title class_">NotificationType</span>.<span class="property">NetError</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;网络异常，请检查网络环境后重试&#x27;</span>;</span><br><span class="line">    <span class="comment">//传入为-2,提示为服务器繁忙，请稍后重试错误 </span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.<span class="property">msg</span> == <span class="title class_">NotificationType</span>.<span class="property">ServerError</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;服务器繁忙，请稍后重试&#x27;</span>;</span><br><span class="line">     <span class="comment">//传入为-3,其他某种错误提示[可以自己定]</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.<span class="property">msg</span> == <span class="title class_">NotificationType</span>.<span class="property">OtherError</span>) &#123;</span><br><span class="line">     config.<span class="property">msg</span> = <span class="string">&#x27;请稍候重试&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用二次确认函数</span></span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;error&#x27;</span>, config);</span><br><span class="line">   <span class="comment">//,如果不需要写死的数据,这样调用即可</span></span><br><span class="line">   <span class="comment">//  HongNotification.base(&#x27;error&#x27;, &#123;&#123;msg:&quot;努力学习的汪!!&quot;&#125;&#125;);</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">open</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="title class_">HongNotification</span>.<span class="title function_">base</span>(<span class="string">&#x27;open&#x27;</span>, config);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">HongNotification</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h1 id="Ⅱ-调用场景"><a href="#Ⅱ-调用场景" class="headerlink" title="Ⅱ-调用场景"></a>Ⅱ-调用场景</h1><blockquote><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;------------------  提示写死的数据方式:具体效果看下方[实现效果]  --------------------------;</span><br><span class="line">&gt;<span class="comment">//此为自己写死的固定提示</span></span><br><span class="line"><span class="title class_">HongNotification</span>.<span class="title function_">warning</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;无数据可导出&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// [res?.message]为服务端传来的,</span></span><br><span class="line">&gt;<span class="comment">//如果其值匹配代码中[NotificationType],则提示相应写死的提示内容 --&gt;如下方的网络异常</span></span><br><span class="line">&gt;<span class="comment">//如果没匹配上,直接显示服务端给的msg</span></span><br><span class="line"><span class="title class_">HongNotification</span>.<span class="title function_">error</span>(&#123; <span class="attr">msg</span>: res?.<span class="property">message</span> &#125;);</span><br><span class="line">                                            </span><br><span class="line">&gt;------------------- 具体场景示例代码  ----------------------------------------------- ;                        </span><br><span class="line"> getData = <span class="keyword">async</span> (params) =&gt; &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//当你进行请求时--&gt;[HTTP]泛指如axios ajax等请求  </span></span><br><span class="line">   <span class="keyword">const</span> res =<span class="keyword">await</span>  <span class="variable constant_">HTTP</span>.<span class="title function_">get</span>(<span class="string">&#x27;/api/请求的接口&#x27;</span>,&#123;params&#125;)</span><br><span class="line">     <span class="keyword">if</span> (res.<span class="property">code</span> == <span class="number">200</span> )  <span class="variable language_">this</span>.<span class="property">datas</span> = res?.<span class="property">data</span>;</span><br><span class="line">     <span class="comment">//如果服务端返回的状态码不是[200]则将其返回的错误信息以提示框显示  </span></span><br><span class="line">     <span class="keyword">else</span>  <span class="title class_">HongNotification</span>.<span class="title function_">error</span>(&#123; <span class="attr">msg</span>: res?.<span class="property">message</span> &#125;);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">     <span class="title class_">HongNotification</span>.<span class="title function_">error</span>(&#123; <span class="attr">msg</span>: error &#125;);<span class="comment">//如果发生异常,将异常信息捕捉并传入提示框</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Ⅲ-实现效果"><a href="#Ⅲ-实现效果" class="headerlink" title="Ⅲ-实现效果"></a>Ⅲ-实现效果</h1><blockquote><p><img src="/k705/kk.github.io.git/AntDesignOfReact%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210723164024197.png" alt="image-20210723164024197"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://ant.design/components/notification-cn/</summary>
      
    
    
    
    
    <category term="antDesign" scheme="https://k705.github.io/tags/antDesign/"/>
    
  </entry>
  
  <entry>
    <title>Axios笔记</title>
    <link href="https://k705.github.io/2024/04/08/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:45:11.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote><p>本笔记为<code>尚硅谷axios入门与源码解析</code>的学习笔记</p><p>该课程主要讲述 axios的API、源码分析、模拟实现重要功能</p><p>课程预备知识点: <code>HTTP</code> <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ajax</a> <a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">promise</a>  </p><p><code>ps</code>:大学时候的课程一定要好好学,不然迟早要还的,留下了不学无术的眼泪:cry:</p><p>仅供本人<code>洪</code>学习使用</p><p>本人笔记地址分享:<a href="https://gitee.com/hongjilin/hongs-study-notes"><code>全部笔记</code></a>、<a href="https://gitee.com/hongjilin/hongs-study-notes/blob/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Ajax%E3%80%81Axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0.md"><code>axios笔记</code></a></p><p>​记录时间: 2021-3-15晚启  2021-3-19结束</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h2 id="预备工具"><a href="#预备工具" class="headerlink" title="预备工具"></a>预备工具</h2><blockquote><ol><li>作为一个前端开发工程师，在后端还没有ready的时候，不可避免的要使用mock的数据。很多时候，我们并不想使用简单的静态数据，而是希望自己起一个本地的mock-server来完全模拟请求以及请求回来的过程。json-server是一个很好的可以替我们完成这一工作的工具。我们只需要提供一个json文件，或者写几行简单的js脚本就可以模拟出RESTful API的接口。</li><li>安装json-server<br><code>npm install -g json-server</code></li><li>创建db.json<br>在一个文件夹下新建一个db.json文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-server&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;some comment&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;profile&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;typicode&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动json-server<br>在当前文件夹下输入如下命令：<code>json-server db.json</code></li><li><a href="https://github.com/typicode/json-server">文档</a></li></ol></blockquote><h1 id="一、Axios的理解与使用"><a href="#一、Axios的理解与使用" class="headerlink" title="一、Axios的理解与使用"></a>一、Axios的理解与使用</h1><h2 id="Ⅰ-axios-是什么"><a href="#Ⅰ-axios-是什么" class="headerlink" title="Ⅰ-axios 是什么?"></a>Ⅰ-axios 是什么?</h2><blockquote><ol><li>前端最流行的 ajax 请求库 </li><li>react&#x2F;vue 官方都推荐使用 axios 发 ajax 请求 </li><li>文档: <a href="https://github.com/axios/axios">https://github.com/axios/axios</a></li></ol></blockquote><h2 id="Ⅱ-axios-特点"><a href="#Ⅱ-axios-特点" class="headerlink" title="Ⅱ-axios 特点"></a>Ⅱ-axios 特点</h2><blockquote><ol><li>基于 xhr + promise 的异步 ajax 请求库 </li><li>浏览器端&#x2F;node 端都可以使用 </li><li>支持请求／响应拦截器 </li><li>支持请求取消 </li><li>请求&#x2F;响应数据转换 </li><li>批量发送多个请求</li></ol></blockquote><h2 id="Ⅲ-axios-常用语法"><a href="#Ⅲ-axios-常用语法" class="headerlink" title="Ⅲ-axios 常用语法"></a>Ⅲ-axios 常用语法</h2><blockquote><ol><li>axios(config): <code>通用/最本质</code>的发任意类型请求的方式 </li><li>axios(url[, config]): 可以只指定 url 发 get 请求 </li><li>axios.request(config): 等同于 axios(config) </li><li>axios.get(url[, config]): 发 get 请求 </li><li>axios.delete(url[, config]): 发 delete 请求 </li><li>axios.post(url[, data, config]): 发 post 请求</li><li>axios.put(url[, data, config]): 发 put 请求 </li><li>axios.defaults.xxx: 请求的默认全局配置 </li><li>axios.interceptors.request.use(): 添加请求拦截器 </li><li>axios.interceptors.response.use(): 添加响应拦截器 </li><li>axios.create([config]): 创建一个新的 axios(它没有下面的功能) </li><li>axios.Cancel(): 用于创建取消请求的错误对象 </li><li>axios.CancelToken(): 用于创建取消请求的 token 对象 </li><li>axios.isCancel(): 是否是一个取消请求的错误 </li><li>axios.all(promises): 用于批量执行多个异步请求 </li><li>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</li></ol></blockquote><h2 id="Ⅳ-原理图"><a href="#Ⅳ-原理图" class="headerlink" title="Ⅳ-原理图"></a>Ⅳ-原理图</h2><p><img src="/k705/kk.github.io.git/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Axios%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Axios系统学习笔记原理图"></p><h2 id="Ⅴ-难点语法的理解和使用"><a href="#Ⅴ-难点语法的理解和使用" class="headerlink" title="Ⅴ-难点语法的理解和使用"></a>Ⅴ-难点语法的理解和使用</h2><h3 id="1、axios-create-config"><a href="#1、axios-create-config" class="headerlink" title="1、axios.create(config)"></a>1、axios.create(config)</h3><blockquote><ol><li><p>根据指定配置创建一个新的 axios, 也就就每个新 axios 都有自己的配置 </p></li><li><p>新 axios 只是没有取消请求和批量发请求的方法, 其它所有语法都是一致的 </p></li><li><p>为什么要设计这个语法?</p></li></ol><p>  (1) 需求: 项目中有部分接口需要的配置与另一部分接口需要的配置不太一样, 如何处理 </p><p>  (2) 解决: 创建 2 个新 axios, 每个都有自己特有的配置, 分别应用到不同要 求的接口请求中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建实例对象  /getJoke</span></span><br><span class="line">  <span class="keyword">const</span> duanzi = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.apiopen.top&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> onather = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="string">&#x27;https://b.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">2000</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//这里  duanzi 与 axios 对象的功能几近是一样的</span></span><br><span class="line">  <span class="comment">// duanzi(&#123;</span></span><br><span class="line">  <span class="comment">//     url: &#x27;/getJoke&#x27;,</span></span><br><span class="line">  <span class="comment">// &#125;).then(response =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(response);</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  duanzi.<span class="title function_">get</span>(<span class="string">&#x27;/getJoke&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2、拦截器函数-ajax-请求-请求的回调函数的调用顺序"><a href="#2、拦截器函数-ajax-请求-请求的回调函数的调用顺序" class="headerlink" title="2、拦截器函数&#x2F;ajax 请求&#x2F;请求的回调函数的调用顺序"></a>2、拦截器函数&#x2F;ajax 请求&#x2F;请求的回调函数的调用顺序</h3><blockquote><ol><li>说明: 调用 axios()并不是立即发送 ajax 请求, 而是需要经历一个较长的流程 </li><li>流程: 请求拦截器2 &#x3D;&gt; 请求拦截器1 &#x3D;&gt; 发ajax请求 &#x3D;&gt; 响应拦截器1 &#x3D;&gt; 响应拦截器 2 &#x3D;&gt; 请求的回调 </li><li>注意: 此流程是通过 promise 串连起来的, 请求拦截器传递的是 config, 响应 拦截器传递的是 response</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">// Promise</span></span><br><span class="line">  <span class="comment">// 设置请求拦截器  config 配置对象</span></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.<span class="property">params</span> = &#123;</span><br><span class="line">      <span class="attr">a</span>: <span class="number">100</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span><br><span class="line">    <span class="comment">//修改 config 中的参数</span></span><br><span class="line">    config.<span class="property">timeout</span> = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置响应拦截器</span></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// return response;</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义回调处理成功的结果&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="3、取消请求"><a href="#3、取消请求" class="headerlink" title="3、取消请求"></a>3、取消请求</h3><blockquote><ol><li>基本流程 配置 cancelToken 对象 </li><li>缓存用于取消请求的 cancel 函数 </li><li>在后面特定时机调用 cancel 函数取消请求 </li><li>在错误回调中判断如果 error 是 cancel, 做相应处理</li><li>实现功能 点击按钮, 取消某个正在请求中的请求,</li><li>实现功能 点击按钮, 取消某个正在请求中的请求</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//获取按钮</span></span><br><span class="line">  <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">  <span class="comment">//2.声明全局变量</span></span><br><span class="line">  <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//检测上一次的请求是否已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//取消上一次的请求</span></span><br><span class="line">      <span class="title function_">cancel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">axios</span>(&#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span><br><span class="line">      <span class="comment">//1. 添加配置对象的属性</span></span><br><span class="line">      <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span><br><span class="line">        <span class="comment">//3. 将 c 的值赋值给 cancel</span></span><br><span class="line">        cancel = c;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">      <span class="comment">//将 cancel 的值初始化</span></span><br><span class="line">      cancel = <span class="literal">null</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定第二个事件取消请求</span></span><br><span class="line">  btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="title function_">cancel</span>(); &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅵ-默认配置"><a href="#Ⅵ-默认配置" class="headerlink" title="Ⅵ-默认配置"></a>Ⅵ-默认配置</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认配置</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">method</span> = <span class="string">&#x27;GET&#x27;</span>;<span class="comment">//设置默认的请求类型为 GET</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&#x27;http://localhost:3000&#x27;</span>;<span class="comment">//设置基础 URL</span></span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">params</span> = &#123;<span class="attr">id</span>:<span class="number">100</span>&#125;;</span><br><span class="line">       axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">       btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">axios</span>(&#123;</span><br><span class="line">               <span class="attr">url</span>: <span class="string">&#x27;/posts&#x27;</span></span><br><span class="line">           &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="二、Axios的难点问题"><a href="#二、Axios的难点问题" class="headerlink" title="二、Axios的难点问题"></a>二、Axios的难点问题</h1><h2 id="Ⅰ-目录结构"><a href="#Ⅰ-目录结构" class="headerlink" title="Ⅰ-目录结构"></a>Ⅰ-目录结构</h2><blockquote><p>├── &#x2F;dist&#x2F; # 项目输出目录<br>├── &#x2F;lib&#x2F; # 项目源码目录<br>│ ├── &#x2F;adapters&#x2F; # 定义请求的适配器 xhr、http<br>│ │ ├── http.js # 实现 http 适配器(包装 http 包)<br>│ │ └── xhr.js # 实现 xhr 适配器(包装 xhr 对象)<br>│ ├── &#x2F;cancel&#x2F; # 定义取消功能<br>│ ├── &#x2F;core&#x2F; # 一些核心功能<br>│ │ ├── Axios.js # axios 的核心主类<br>│ │ ├── dispatchRequest.js # 用来调用 http 请求适配器方法发送请求的函数<br>│ │ ├── InterceptorManager.js # 拦截器的管理器<br>│ │ └── settle.js # 根据 http 响应状态，改变 Promise 的状态<br>│ ├── &#x2F;helpers&#x2F; # 一些辅助方法<br>│ ├── axios.js # 对外暴露接口<br>│ ├── defaults.js # axios 的默认配置<br>│ └── utils.js # 公用工具<br>├── package.json # 项目信息<br>├── index.d.ts # 配置 TypeScript 的声明文件<br>└── index.js # 入口文件</p></blockquote><h2 id="Ⅱ-axios-与-Axios-的关系"><a href="#Ⅱ-axios-与-Axios-的关系" class="headerlink" title="Ⅱ-axios 与 Axios 的关系"></a>Ⅱ-axios 与 Axios 的关系</h2><blockquote><ol><li>从<code>语法</code>上来说: axios 不是 Axios 的实例</li><li>从<code>功能</code>上来说: axios 是 Axios 的实例</li><li>axios 是 <code>Axios.prototype.request</code> 函数 bind()返回的函数</li><li>axios 作为对象有 Axios 原型对象上的所有方法, 有 Axios 对象上所有属性</li></ol></blockquote><h2 id="Ⅲ-instance-与-axios-的区别"><a href="#Ⅲ-instance-与-axios-的区别" class="headerlink" title="Ⅲ- instance 与 axios 的区别?"></a>Ⅲ- instance 与 axios 的区别?</h2><blockquote><ol><li>相同:<br>(1) 都是一个能发任意请求的函数: request(config)<br>(2) 都有发特定请求的各种方法: get()&#x2F;post()&#x2F;put()&#x2F;delete()<br>(3) 都有默认配置和拦截器的属性: defaults&#x2F;interceptors</li><li>不同:<br>(1) 默认配置很可能不一样<br>(2) instance 没有 axios 后面添加的一些方法: create()&#x2F;CancelToken()&#x2F;all()</li></ol></blockquote><h2 id="Ⅳ-axios运行的整体流程"><a href="#Ⅳ-axios运行的整体流程" class="headerlink" title="Ⅳ-axios运行的整体流程"></a>Ⅳ-axios运行的整体流程</h2><blockquote><ol><li><p>整体流程:<br> request(config) &#x3D;&#x3D;&gt; dispatchRequest(config) &#x3D;&#x3D;&gt; xhrAdapter(config)</p></li><li><p>request(config):<br> 将请求拦截器 &#x2F; dispatchRequest() &#x2F; 响应拦截器 通过 promise 链串连起来,<br>  返回 promise</p></li><li><p>dispatchRequest(config):<br> 转换请求数据 &#x3D;&#x3D;&#x3D;&gt; 调用 xhrAdapter()发请求 &#x3D;&#x3D;&#x3D;&gt; 请求返回后转换响应数<br>  据. 返回 promise</p></li><li><p>xhrAdapter(config):<br> 创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br>  返回 promise </p></li><li><p>流程图:</p></li></ol><p><img src="/k705/kk.github.io.git/Axios%E5%85%A5%E9%97%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/Axios%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Axios系统学习流程图"></p></blockquote><h2 id="Ⅴ-axios-的请求-响应拦截器是什么"><a href="#Ⅴ-axios-的请求-响应拦截器是什么" class="headerlink" title="Ⅴ-axios 的请求&#x2F;响应拦截器是什么?"></a>Ⅴ-axios 的请求&#x2F;响应拦截器是什么?</h2><blockquote><ol><li>请求拦截器:<br>Ⅰ- 在真正发送请求前执行的回调函数<br>Ⅱ- 可以对请求进行检查或配置进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 config(也必须是)<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li><li>响应拦截器<br>Ⅰ- 在请求得到响应后执行的回调函数<br>Ⅱ- 可以对响应数据进行特定处理<br>Ⅲ- 成功的回调函数, 传递的默认是 response<br>Ⅳ- 失败的回调函数, 传递的默认是 error</li></ol></blockquote><h2 id="Ⅵ-axios-的请求-响应数据转换器是什么"><a href="#Ⅵ-axios-的请求-响应数据转换器是什么" class="headerlink" title="Ⅵ-axios 的请求&#x2F;响应数据转换器是什么?"></a>Ⅵ-axios 的请求&#x2F;响应数据转换器是什么?</h2><blockquote><ol><li>请求转换器: 对请求头和请求体数据进行特定处理的函数</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (utils.<span class="title function_">isObject</span>(data)) &#123;</span><br><span class="line"> <span class="title function_">setContentTypeIfUnset</span>(headers, <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>响应转换器: 将响应体 json 字符串解析为 js 对象或数组的函数</li></ol> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.<span class="property">data</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response.<span class="property">data</span>)</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅶ-response与error-的整体结构"><a href="#Ⅶ-response与error-的整体结构" class="headerlink" title="Ⅶ- response与error  的整体结构"></a>Ⅶ- response与error  的整体结构</h2><blockquote><ol><li>response的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">data, status,statusText,headers,config,request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>error  的整体结构</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">message,response,request,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅷ-如何取消未完成的请求"><a href="#Ⅷ-如何取消未完成的请求" class="headerlink" title="Ⅷ-如何取消未完成的请求?"></a>Ⅷ-如何取消未完成的请求?</h2><blockquote><ol><li>当配置了 cancelToken 对象时, 保存 cancel 函数<br>(1) 创建一个用于将来中断请求的 cancelPromise<br>(2) 并定义了一个用于取消请求的 cancel 函数<br>(3) 将 cancel 函数传递出来</li><li>调用 cancel()取消请求<br>(1) 执行 cacel 函数, 传入错误信息 message<br>(2) 内部会让 cancelPromise 变为成功, 且成功的值为一个 Cancel 对象<br>(3) 在 cancelPromise 的成功回调中中断请求, 并让发请求的 proimse 失败,<br>失败的 reason 为 Cancel 对象</li></ol></blockquote><h1 id="三、Axios源码模拟实现"><a href="#三、Axios源码模拟实现" class="headerlink" title="三、Axios源码模拟实现"></a>三、Axios源码模拟实现</h1><h2 id="Ⅰ-axios-的创建过程模拟实现"><a href="#Ⅰ-axios-的创建过程模拟实现" class="headerlink" title="Ⅰ- axios 的创建过程模拟实现"></a>Ⅰ- axios 的创建过程模拟实现</h2><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="comment">//初始化</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">defaults</span> = config; <span class="comment">//为了创建 default 默认属性</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">intercepters</span> = &#123;</span><br><span class="line">       <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">       <span class="attr">response</span>: &#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//原型添加相关的方法</span></span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送 AJAX 请求 请求的类型为 &#x27;</span> + config.<span class="property">method</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">post</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">       <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span></span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//声明函数</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">createInstance</span>(<span class="params">config</span>) &#123;</span><br><span class="line">     <span class="comment">//实例化一个对象</span></span><br><span class="line">     <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(config); <span class="comment">// context.get()  context.post()  但是不能当做函数使用 context() X</span></span><br><span class="line">     <span class="comment">//创建请求函数</span></span><br><span class="line">     <span class="keyword">let</span> instance = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(</span><br><span class="line">     context); <span class="comment">// instance 是一个函数 并且可以 instance(&#123;&#125;)  此时 instance 不能 instance.get X</span></span><br><span class="line">     <span class="comment">//将 Axios.prototype 对象中的方法添加到instance函数对象中,才可以instance.get....</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       instance[key] = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[key].<span class="title function_">bind</span>(context); <span class="comment">// this.default  this.interceptors</span></span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//为 instance 函数对象添加属性 default 与 interceptors</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">       instance[key] = context[key];</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> axios = <span class="title function_">createInstance</span>();</span><br><span class="line">   <span class="comment">//发送请求</span></span><br><span class="line">   <span class="comment">// axios(&#123;method:&#x27;POST&#x27;&#125;);</span></span><br><span class="line">   axios.<span class="title function_">get</span>(&#123;&#125;);</span><br><span class="line">   axios.<span class="title function_">post</span>(&#123;&#125;);</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅱ-axios发送请求过程详解"><a href="#Ⅱ-axios发送请求过程详解" class="headerlink" title="Ⅱ-axios发送请求过程详解"></a>Ⅱ-axios发送请求过程详解</h2><blockquote><ol><li>整体流程:<br> request(config) &#x3D;&#x3D;&gt; dispatchRequest(config) &#x3D;&#x3D;&gt; xhrAdapter(config)</li><li>request(config):<br> 将请求拦截器 &#x2F; dispatchRequest() &#x2F; 响应拦截器 通过 promise 链串连起来,<br> 返回 promise</li><li>dispatchRequest(config):<br> 转换请求数据 &#x3D;&#x3D;&#x3D;&gt; 调用 xhrAdapter()发请求 &#x3D;&#x3D;&#x3D;&gt; 请求返回后转换响应数<br> 据. 返回 promise</li><li>xhrAdapter(config):<br> 创建 XHR 对象, 根据 config 进行相应设置, 发送特定请求, 并接收响应数据,<br> 返回 promise</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">// axios 发送请求   axios  Axios.prototype.request  bind</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//1. 声明构造函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//创建一个 promise 对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//声明一个数组</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> chains = [dispatchRequest, <span class="literal">undefined</span>]; <span class="comment">// undefined 占位</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//调用 then 方法指定回调</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">let</span> result = promise.<span class="title function_">then</span>(chains[<span class="number">0</span>], chains[<span class="number">1</span>]);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//返回 promise 的结果</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> result;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//2. dispatchRequest 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="comment">//调用适配器发送请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//响应的结果进行转换处理</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//....</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">return</span> response;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">throw</span> error;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//3. adapter 适配器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;xhrAdapter 函数执行&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//发送 AJAX 请求</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//初始化</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//发送</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="title function_">send</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       <span class="comment">//绑定事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="comment">//判断成功的条件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="comment">//成功的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="title function_">resolve</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//配置对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">config</span>: config,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应体</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">data</span>: xhr.<span class="property">response</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应头</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">headers</span>: xhr.<span class="title function_">getAllResponseHeaders</span>(), <span class="comment">//字符串  parseHeaders</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">// xhr 请求对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">request</span>: xhr,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应状态码</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="comment">//响应状态字符串</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">               <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="comment">//失败的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">             <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败 失败的状态码为&#x27;</span> + xhr.<span class="property">status</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">           &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">       &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="comment">//4. 创建 axios 函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   <span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">   &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅲ-拦截器的模拟实现"><a href="#Ⅲ-拦截器的模拟实现" class="headerlink" title="Ⅲ-拦截器的模拟实现"></a>Ⅲ-拦截器的模拟实现</h2><blockquote><ol><li>array.shift()该方法用于把数组的第一个元素从其中删除，并返回第一个元素的值</li><li>思路为先将拦截器的响应回调与请求回调都压入一个数组中,之后进行遍历运行</li><li><code>promise = promise.then(chains.shift(), chains.shift());</code> 通过循环使用promise的then链条得到最终的结果–&gt;等式前面的<code>promise</code>将被最终的结果覆盖</li></ol></blockquote><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>拦截器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">request</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">response</span>: <span class="keyword">new</span> <span class="title class_">InterceptorManager</span>(),</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求  难点与重点</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//创建一个 promise 对象</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(config);</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//创建一个数组</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">const</span> chains = [dispatchRequest, <span class="literal">undefined</span>];</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//处理拦截器</span></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//请求拦截器 将请求拦截器的回调 压入到 chains 的前面  request.handles = []</span></span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               chains.<span class="title function_">unshift</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="property">handlers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               chains.<span class="title function_">push</span>(item.<span class="property">fulfilled</span>, item.<span class="property">rejected</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">// console.log(chains);</span></span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//遍历</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">while</span>(chains.<span class="property">length</span> &gt; <span class="number">0</span>)&#123; </span></span><br><span class="line"><span class="language-javascript">               <span class="comment">//array.shift()</span></span></span><br><span class="line"><span class="language-javascript">               promise = promise.<span class="title function_">then</span>(chains.<span class="title function_">shift</span>(), chains.<span class="title function_">shift</span>());</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> promise;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//返回一个promise 队形</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">resolve</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">status</span>: <span class="number">200</span>,</span></span><br><span class="line"><span class="language-javascript">                   <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span></span></span><br><span class="line"><span class="language-javascript">               &#125;);</span></span><br><span class="line"><span class="language-javascript">           &#125;);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">      </span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//创建实例</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//创建axios函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 context 属性 config interceptors 添加至 axios 函数对象身上</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">Object</span>.<span class="title function_">keys</span>(context).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           axios[key] = context[key];</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//拦截器管理器构造函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">function</span> <span class="title function_">InterceptorManager</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">handlers</span> = [];</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="title class_">InterceptorManager</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">fulfilled, rejected</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">this</span>.<span class="property">handlers</span>.<span class="title function_">push</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               fulfilled,</span></span><br><span class="line"><span class="language-javascript">               rejected</span></span><br><span class="line"><span class="language-javascript">           &#125;)</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//以下为功能测试代码</span></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 设置请求拦截器  config 配置对象</span></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> <span class="title function_">one</span>(<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 成功 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> config;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> <span class="title function_">two</span>(<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器 失败 - 2号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">// 设置响应拦截器</span></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 1号&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 1号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 成功 2号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> response;</span></span><br><span class="line"><span class="language-javascript">       &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器 失败 2号&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span></span></span><br><span class="line"><span class="language-javascript">       &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Ⅳ-请求取消功能模拟实现"><a href="#Ⅳ-请求取消功能模拟实现" class="headerlink" title="Ⅳ-请求取消功能模拟实现"></a>Ⅳ-请求取消功能模拟实现</h2><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>取消请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">crossorigin</span>=<span class="string">&#x27;anonymous&#x27;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;script src=&quot;./node_modules/axios/dist/mine-axios.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;page-header&quot;</span>&gt;</span>axios取消请求<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span> 发送请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-warning&quot;</span>&gt;</span> 取消请求 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">Axios</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">this</span>.<span class="property">config</span> = config;</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//原型 request 方法</span></span></span><br><span class="line"><span class="language-javascript">   <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span> = <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="title function_">dispatchRequest</span>(config);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//dispatchRequest 函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">dispatchRequest</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="title function_">xhrAdapter</span>(config);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//xhrAdapter</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">xhrAdapter</span>(<span class="params">config</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//发送 AJAX 请求</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//实例化对象</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//初始化</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="title function_">open</span>(config.<span class="property">method</span>, config.<span class="property">url</span>);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//发送</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//处理结果</span></span></span><br><span class="line"><span class="language-javascript">       xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//判断结果</span></span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="comment">//设置为成功的状态</span></span></span><br><span class="line"><span class="language-javascript">             <span class="title function_">resolve</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">status</span>: xhr.<span class="property">status</span>,</span></span><br><span class="line"><span class="language-javascript">               <span class="attr">statusText</span>: xhr.<span class="property">statusText</span></span></span><br><span class="line"><span class="language-javascript">             &#125;);</span></span><br><span class="line"><span class="language-javascript">           &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求失败&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//关于取消请求的处理</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">if</span> (config.<span class="property">cancelToken</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="comment">//对 cancelToken 对象身上的 promise 对象指定成功的回调</span></span></span><br><span class="line"><span class="language-javascript">         config.<span class="property">cancelToken</span>.<span class="property">promise</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">abort</span>();</span></span><br><span class="line"><span class="language-javascript">           <span class="comment">//将整体结果设置为失败</span></span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请求已经被取消&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript">         &#125;);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//创建 axios 函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">Axios</span>(&#123;&#125;);</span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> axios = <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">request</span>.<span class="title function_">bind</span>(context);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//CancelToken 构造函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">function</span> <span class="title function_">CancelToken</span>(<span class="params">executor</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//声明一个变量</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> resolvePromise;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//为实例对象添加属性</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">this</span>.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 resolve 赋值给 resolvePromise</span></span></span><br><span class="line"><span class="language-javascript">       resolvePromise = resolve</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//调用 executor 函数</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">executor</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//执行 resolvePromise 函数</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">resolvePromise</span>();</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//获取按钮 以上为模拟实现的代码</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//2.声明全局变量</span></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">let</span> cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">   btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//检测上一次的请求是否已经完成</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">if</span> (cancel !== <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//取消上一次的请求</span></span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">cancel</span>();</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//创建 cancelToken 的值</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> cancelToken = <span class="keyword">new</span> <span class="title class_">CancelToken</span>(<span class="keyword">function</span> (<span class="params">c</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       cancel = c;</span></span><br><span class="line"><span class="language-javascript">     &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//1. 添加配置对象的属性</span></span></span><br><span class="line"><span class="language-javascript">       <span class="attr">cancelToken</span>: cancelToken</span></span><br><span class="line"><span class="language-javascript">     &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span></span><br><span class="line"><span class="language-javascript">       <span class="comment">//将 cancel 的值初始化</span></span></span><br><span class="line"><span class="language-javascript">       cancel = <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">     &#125;)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//绑定第二个事件取消请求</span></span></span><br><span class="line"><span class="language-javascript">   btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">cancel</span>();</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h1 id="四、自己对于某些问题解答与理解"><a href="#四、自己对于某些问题解答与理解" class="headerlink" title="四、自己对于某些问题解答与理解"></a>四、自己对于某些问题解答与理解</h1><h2 id="Ⅰ-axios同步与异步转换-在外部取值"><a href="#Ⅰ-axios同步与异步转换-在外部取值" class="headerlink" title="Ⅰ-axios同步与异步转换,在外部取值"></a>Ⅰ-axios同步与异步转换,在外部取值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  axios  =  <span class="built_in">require</span> (<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"> <span class="comment">//创建实例对象 </span></span><br><span class="line"> <span class="keyword">const</span> $http = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;http://localhost:53000&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">11000</span>  <span class="comment">//请求超时时间</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">resolveCommon</span> = (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=$http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//打印结果: Promise &#123; &lt;pending&gt; &#125; </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">resolveAsync</span>=<span class="keyword">async</span> (<span class="params"></span>)=&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data=<span class="keyword">await</span> $http(&#123; <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>v.<span class="property">data</span>)  <span class="comment">//等于 `.then(v=&gt;&#123;return v&#125;)`,我再then()中返回出去,让外部承接</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)  <span class="comment">//获得正确的值</span></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 打印结果&#123; id: 1000,course_name: &#x27;这是请求数据1&#x27;, autor: &#x27;袁明&#x27;, college: &#x27;金并即总变史&#x27;,category_Id: 2&#125;</span></span><br><span class="line"><span class="comment">    *  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//模拟新增数据,将上一步的结果简单加工一下</span></span><br><span class="line">   data.<span class="property">course_name</span>=data.<span class="property">course_name</span>+<span class="number">1</span></span><br><span class="line"> $http(&#123;</span><br><span class="line">   <span class="attr">url</span>:<span class="string">&quot;/test&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>:<span class="string">&quot;put&quot;</span>,</span><br><span class="line">   data</span><br><span class="line"> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(v)  <span class="comment">//直接打印了 需要再取出参照上一步</span></span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">resolveCommon</span>()  <span class="comment">//调用普通promise函数</span></span><br><span class="line"><span class="title function_">resolveAsync</span>()    <span class="comment">//调用await+async</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;#说明&quot;&gt;&lt;/a&gt;#说明&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本笔记为&lt;code&gt;尚硅谷axios入门与源码解析&lt;/code&gt;的学习笔记&lt;/p&gt;
&lt;p&gt;该课程主要讲述 ax</summary>
      
    
    
    
    
    <category term="Axios" scheme="https://k705.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>Css补缺</title>
    <link href="https://k705.github.io/2024/04/08/Css%E8%A1%A5%E7%BC%BA%E7%AC%94%E8%AE%B0/"/>
    <id>https://k705.github.io/2024/04/08/Css%E8%A1%A5%E7%BC%BA%E7%AC%94%E8%AE%B0/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-10T03:08:11.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人<a href="https://gitee.com/hongjilin/hongs-study-notes">笔记地址</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、知识点详解"><a href="#一、知识点详解" class="headerlink" title="一、知识点详解"></a>一、知识点详解</h1><h2 id="Ⅰ-css3-pointer-events"><a href="#Ⅰ-css3-pointer-events" class="headerlink" title="Ⅰ-css3 pointer-events"></a>Ⅰ-css3 <code>pointer-events</code></h2><blockquote><p>此属性会阻止hover、active、onclick等触发事件</p><ol><li><h6 id="pointer-events-更像是JavaScript，它能够："><a href="#pointer-events-更像是JavaScript，它能够：" class="headerlink" title="pointer-events 更像是JavaScript，它能够："></a><code>pointer-events </code>更像是JavaScript，它能够：</h6></li></ol><ul><li>阻止用户的点击动作产生任何效果</li><li>阻止缺省鼠标指针的显示</li><li>阻止CSS里的 <code>hover </code>和 <code>active </code>状态的变化触发事件</li><li>阻止JavaScript点击动作触发的事件</li></ul><ol start="2"><li><h6 id="具体用法："><a href="#具体用法：" class="headerlink" title="具体用法："></a>具体用法：</h6></li></ol>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pointer-events</span>:  auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit</span><br></pre></td></tr></table></figure><blockquote><p>pointer-events属性有很多值，但是对于浏览器来说，<code>只有auto和none两个值可用</code>，其它的几个是针对SVG的(本身这个属性就来自于SVG技术)。</p></blockquote><ol start="3"><li><h6 id="pointer-events属性值详解"><a href="#pointer-events属性值详解" class="headerlink" title="pointer-events属性值详解"></a>pointer-events属性值详解</h6></li></ol><ul><li>auto——效果和没有定义pointer-events属性相同，鼠标不会穿透当前层。在SVG中，该值和visiblePainted的效果相同。</li><li>none——元素不再是鼠标事件的目标，鼠标不再监听当前层而去监听下面的层中的元素。但是如果它的子元素设置了pointer-events为其它值，比如auto，鼠标还是会监听这个子元素的。</li><li>其它属性值为SVG专用，这里不再多介绍了。</li></ul></blockquote><h1 id="二、实际问题解决"><a href="#二、实际问题解决" class="headerlink" title="二、实际问题解决"></a>二、实际问题解决</h1><h2 id="Ⅰ-图片不拉伸属性-object-fit"><a href="#Ⅰ-图片不拉伸属性-object-fit" class="headerlink" title="Ⅰ-图片不拉伸属性  object-fit"></a>Ⅰ-图片不拉伸属性 <code> object-fit</code></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">     <span class="attribute">object-fit</span>: cover;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-css鼠标点击的五种状态"><a href="#Ⅱ-css鼠标点击的五种状态" class="headerlink" title="Ⅱ-css鼠标点击的五种状态"></a>Ⅱ-css鼠标点击的五种状态</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  未访问时的状态（鼠标点击前显示的状态）</span><br><span class="line">  <span class="number">2</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  鼠标悬停时的状态</span><br><span class="line">  <span class="number">3</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  已访问过的状态（鼠标点击后的状态）</span><br><span class="line">  <span class="number">4</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  鼠标点击时的状态</span><br><span class="line">  <span class="number">5</span>、<span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123;<span class="attribute">color</span>:<span class="number">#fff</span>&#125;  点击后鼠标移开保持鼠标点击时的状态（只有在&lt;<span class="selector-tag">a</span> href=&quot;#&quot;&gt;&lt;/<span class="selector-tag">a</span>&gt;时标签中有效）</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-阴影效果"><a href="#Ⅲ-阴影效果" class="headerlink" title="Ⅲ-阴影效果"></a>Ⅲ-阴影效果</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>:<span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#000</span>; //正常</span><br><span class="line"><span class="attribute">box-shadow</span>:inset <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#000</span>; //内阴影</span><br><span class="line"><span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">#000</span>;//拓展阴影长度</span><br><span class="line"><span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">3px</span> <span class="number">#bb0a0a</span>,</span><br><span class="line">           <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">6px</span> <span class="number">#2e56bf</span>,</span><br><span class="line">           <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">9px</span> <span class="number">#ea982e</span>;//多重阴影</span><br></pre></td></tr></table></figure><blockquote><p>逼真的阴影效果示例</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;box11 shadow&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"><span class="comment">/********************************************/</span></span><br><span class="line"><span class="selector-class">.box11</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">max-width</span>: <span class="number">270px</span>;</span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">1px</span> <span class="number">4px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>),</span><br><span class="line"><span class="number">0px</span> <span class="number">0px</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>) inset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">   <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="attribute">position</span>:absolute;</span><br><span class="line">   <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">   <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="attribute">position</span>:absolute;</span><br><span class="line">   <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">   <span class="attribute">bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">left</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">   <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="attribute">position</span>:absolute;</span><br><span class="line">   <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">   <span class="attribute">bottom</span>:<span class="number">15px</span>;</span><br><span class="line">   <span class="attribute">left</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">height</span>:<span class="number">20%</span>;</span><br><span class="line">   <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">15px</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.7</span>);</span><br><span class="line">   <span class="attribute">transform</span>:<span class="built_in">rotate</span>(-<span class="number">3deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadow</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">   <span class="attribute">right</span>:<span class="number">10px</span>;</span><br><span class="line">   <span class="attribute">left</span>:auto;</span><br><span class="line">   <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">3deg</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ-实现a标签禁用"><a href="#Ⅳ-实现a标签禁用" class="headerlink" title="Ⅳ-实现a标签禁用"></a>Ⅳ-实现a标签禁用</h2><blockquote><ol><li><p>需求分析:业务中遇到一个需求-根据当前数据类别进行权限限制,当我为新用户数据时,开放编辑操作,当我为旧用户数据时,禁用编辑操作</p></li><li><p>代码:</p><ol><li>css代码:</li></ol></li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**设置a标签禁用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">50</span>);</span><br><span class="line">  <span class="comment">/*IE滤镜，透明度50%*/</span></span><br><span class="line">  -moz-<span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="comment">/*Firefox私有，透明度50%*/</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="comment">/*其他，透明度50%*/</span></span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为pointer-events会阻止hover事件,所以在外层进行判断,同时变为行内元素</span></span><br><span class="line"><span class="selector-class">.disabledbox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.combox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.disabledbox</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>1. html部分调用代码--示例中是在:antd中table组件中试用</code></pre>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新旧渠道商标识</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CHANNELBZ</span> = &#123;</span><br><span class="line">  <span class="attr">OLD</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">NEW</span>: <span class="number">1</span></span><br><span class="line">&#125; </span><br><span class="line">....</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;推荐折扣&#x27;</span>,</span><br><span class="line">    <span class="attr">dataIndex</span>: <span class="string">&#x27;discount&#x27;</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function">(<span class="params">value, item</span>) =&gt;</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;item.sourceType</span> == <span class="string">CHANNELBZ.OLD</span> ? <span class="attr">style.disabledbox</span> <span class="attr">:</span> <span class="attr">style.combox</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">className</span>=<span class="string">&#123;item.sourceType</span> == <span class="string">CHANNELBZ.OLD</span> ? <span class="attr">style.disabled</span> <span class="attr">:</span> &quot;&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">marginLeft:</span> <span class="attr">10</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">              console.log(item.sourceType, &quot;itemmmmmm&quot;)</span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            编辑</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    ),</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ol start="3"><li><p>效果实现截图:</p><img src="Css补缺笔记中的图片/image-20210517184121490.png" alt="image-20210517184121490" style="zoom:80%;" /></li></ol></blockquote><h2 id="Ⅴ-实现父元素半透明，子元素不透明"><a href="#Ⅴ-实现父元素半透明，子元素不透明" class="headerlink" title="Ⅴ-实现父元素半透明，子元素不透明"></a>Ⅴ-实现父元素半透明，子元素不透明</h2><blockquote><p>CSS实现父元素半透明，子元素不透明。 很久以来大家都习惯使用opacity:0.5在新式浏览器里实现半透明，而对IE较旧的版本使用filter:Alpha(opacity&#x3D;0.5)的滤镜来实现半透明。但是这样实现的半透明有个问题，那就是这个属性会被子元素所继承。</p><p>如下代码，则子元素中也将是半透明效果，无论你将子元素的半透明值重置还是如何都不会改变这一情况。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="selector-class">.parent</span>&#123;<span class="attribute">opacity</span>:<span class="number">0.9</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>;&#125;</span><br><span class="line">&gt;<span class="selector-class">.child</span>&#123;<span class="attribute">opacity</span>:<span class="number">1.0</span>; <span class="attribute">background-color</span>:<span class="number">#fff</span>; <span class="attribute">height</span>:<span class="number">200px</span>;&#125;</span><br></pre></td></tr></table></figure><ol><li>问题效果</li></ol><img src="Css补缺笔记中的图片/image-20210616183632386.png" alt="image-20210616183632386" style="zoom:67%;" /> <ol start="2"><li>解决:其实在新的CSS3规则里面的属性 GRBA已经可以方便的实现父元素透明，而子元素不透明了。</li></ol>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用背景色透明可以限制子类不继承,防止下方按钮也变得半透明</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>) ;</span><br></pre></td></tr></table></figure>  <img src="Css补缺笔记中的图片/image-20210616183902406.png" alt="image-20210616183902406" style="zoom:67%;" /> </blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本人&lt;a href=&quot;https://gitee.com/hongjilin/hongs-study-notes&quot;&gt;笔记地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="CSS" scheme="https://k705.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Chrome拓展</title>
    <link href="https://k705.github.io/2024/04/08/Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E8%B5%84%E6%96%99%E6%91%98%E5%BD%95%E5%8F%8A%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>https://k705.github.io/2024/04/08/Chrome%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E8%B5%84%E6%96%99%E6%91%98%E5%BD%95%E5%8F%8A%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:46:02.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记是各资料整合<code>摘录</code>以及后续相关笔记补充、当时纯为了方便记录,没有记录各个知识点摘录出处;非本人洪撰写(大都是摘录,加以少许个人理解),仅供本人学习使用</p><p>本人笔记地址分享:<a href="https://gitee.com/hongjilin/hongs-study-notes"><code>全部笔记</code></a></p><p>​   学习时间:2020&#x2F;12&#x2F;1启</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="一、资料"><a href="#一、资料" class="headerlink" title="一、资料"></a>一、资料</h1><p><a href="http://kkh86.com/it/chrome-extension-doc/extensions/getstarted.html">1.非官方中文文档</a></p><p><a href="%5B%5D(https://developer.chrome.com/docs/extensions/mv2/getstarted/)">2.官方文档(英文)</a></p><h1 id="二、核心"><a href="#二、核心" class="headerlink" title="二、核心"></a>二、核心</h1><h2 id="2-0-什么是Chrome插件"><a href="#2-0-什么是Chrome插件" class="headerlink" title="2.0. 什么是Chrome插件"></a>2.0. 什么是Chrome插件</h2><p>严格来讲，我们正在说的东西应该叫Chrome扩展(<code>Chrome Extension</code>)，真正意义上的Chrome插件是更底层的浏览器功能扩展，可能需要对浏览器源码有一定掌握才有能力去开发。鉴于Chrome插件的叫法已经习惯，本文也全部采用这种叫法，但读者需深知本文所描述的Chrome插件实际上指的是Chrome扩展。</p><p>Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件，它其实就是一个由HTML、CSS、JS、图片等资源组成的一个<a href="https://developer.chrome.com/extensions/crx">.crx</a>后缀的压缩包.</p><h2 id="2-1-manifest-json"><a href="#2-1-manifest-json" class="headerlink" title="2.1. manifest.json"></a>2.1. manifest.json</h2><p>这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，<code>manifest_version</code>、<code>name</code>、<code>version</code>3个是必不可少的，<code>description</code>和<code>icons</code>是推荐的。</p><p>下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳<a href="https://developer.chrome.com/extensions/manifest">这里</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 清单文件的版本，这个必须写，而且必须是2</span></span><br><span class="line"><span class="string">&quot;manifest_version&quot;</span>: <span class="number">2</span>,</span><br><span class="line"><span class="comment">// 插件的名称</span></span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line"><span class="comment">// 插件的版本</span></span><br><span class="line"><span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line"><span class="comment">// 插件描述</span></span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;简单的Chrome扩展demo&quot;</span>,</span><br><span class="line"><span class="comment">// 图标，一般偷懒全部用一个尺寸的也没问题</span></span><br><span class="line"><span class="string">&quot;icons&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;16&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;48&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;128&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line"><span class="string">&quot;background&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;background.html&quot;</span></span><br><span class="line"><span class="comment">//&quot;scripts&quot;: [&quot;js/background.js&quot;]</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 浏览器右上角图标设置，browser_action、page_action、app必须三选一</span></span><br><span class="line"><span class="string">&quot;browser_action&quot;</span>: </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;这是一个示例Chrome插件&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 当某些特定页面打开才显示的图标</span></span><br><span class="line"><span class="comment">/*&quot;page_action&quot;:</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&quot;default_icon&quot;: &quot;img/icon.png&quot;,</span></span><br><span class="line"><span class="comment">&quot;default_title&quot;: &quot;我是pageAction&quot;,</span></span><br><span class="line"><span class="comment">&quot;default_popup&quot;: &quot;popup.html&quot;</span></span><br><span class="line"><span class="comment">&#125;,*/</span></span><br><span class="line"><span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line"><span class="string">&quot;content_scripts&quot;</span>: </span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],</span></span><br><span class="line"><span class="comment">// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址</span></span><br><span class="line"><span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>],</span><br><span class="line"><span class="comment">// 多个JS按顺序注入</span></span><br><span class="line"><span class="string">&quot;js&quot;</span>: [<span class="string">&quot;js/jquery-1.8.3.js&quot;</span>, <span class="string">&quot;js/content-script.js&quot;</span>],</span><br><span class="line"><span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line"><span class="string">&quot;css&quot;</span>: [<span class="string">&quot;css/custom.css&quot;</span>],</span><br><span class="line"><span class="comment">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line"><span class="string">&quot;run_at&quot;</span>: <span class="string">&quot;document_start&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 这里仅仅是为了演示content-script可以配置多个规则</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;*://*/*.png&quot;</span>, <span class="string">&quot;*://*/*.jpg&quot;</span>, <span class="string">&quot;*://*/*.gif&quot;</span>, <span class="string">&quot;*://*/*.bmp&quot;</span>],</span><br><span class="line"><span class="string">&quot;js&quot;</span>: [<span class="string">&quot;js/show-image-content-size.js&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 权限申请</span></span><br><span class="line"><span class="string">&quot;permissions&quot;</span>:</span><br><span class="line">[</span><br><span class="line"><span class="string">&quot;contextMenus&quot;</span>, <span class="comment">// 右键菜单</span></span><br><span class="line"><span class="string">&quot;tabs&quot;</span>, <span class="comment">// 标签</span></span><br><span class="line"><span class="string">&quot;notifications&quot;</span>, <span class="comment">// 通知</span></span><br><span class="line"><span class="string">&quot;webRequest&quot;</span>, <span class="comment">// web请求</span></span><br><span class="line"><span class="string">&quot;webRequestBlocking&quot;</span>,</span><br><span class="line"><span class="string">&quot;storage&quot;</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line"><span class="string">&quot;http://*/*&quot;</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line"><span class="string">&quot;https://*/*&quot;</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">],</span><br><span class="line"><span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line"><span class="string">&quot;web_accessible_resources&quot;</span>: [<span class="string">&quot;js/inject.js&quot;</span>],</span><br><span class="line"><span class="comment">// 插件主页，这个很重要，不要浪费了这个免费广告位</span></span><br><span class="line"><span class="string">&quot;homepage_url&quot;</span>: <span class="string">&quot;https://www.baidu.com&quot;</span>,</span><br><span class="line"><span class="comment">// 覆盖浏览器默认页面</span></span><br><span class="line"><span class="string">&quot;chrome_url_overrides&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 覆盖浏览器默认的新标签页</span></span><br><span class="line"><span class="string">&quot;newtab&quot;</span>: <span class="string">&quot;newtab.html&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line"><span class="string">&quot;options_page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line"><span class="comment">// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个</span></span><br><span class="line"><span class="string">&quot;options_ui&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line"><span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line"><span class="string">&quot;chrome_style&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line"><span class="string">&quot;omnibox&quot;</span>: &#123; <span class="string">&quot;keyword&quot;</span> : <span class="string">&quot;go&quot;</span> &#125;,</span><br><span class="line"><span class="comment">// 默认语言</span></span><br><span class="line"><span class="string">&quot;default_locale&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line"><span class="comment">// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line"><span class="string">&quot;devtools_page&quot;</span>: <span class="string">&quot;devtools.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>matches</code>的语法参考：<a href="https://developer.chrome.com/extensions/match_patterns">https://developer.chrome.com/extensions/match_patterns</a></p><h2 id="2-2-content-scripts"><a href="#2-2-content-scripts" class="headerlink" title="2.2. content-scripts"></a>2.2. content-scripts</h2><p>所谓<a href="https://developer.chrome.com/extensions/content_scripts">content-scripts</a>，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助<code>content-scripts</code>我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。</p><p>示例配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line"><span class="string">&quot;content_scripts&quot;</span>: </span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],</span></span><br><span class="line"><span class="comment">// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址</span></span><br><span class="line"><span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>],</span><br><span class="line"><span class="comment">// 多个JS按顺序注入</span></span><br><span class="line"><span class="string">&quot;js&quot;</span>: [<span class="string">&quot;js/jquery-1.8.3.js&quot;</span>, <span class="string">&quot;js/content-script.js&quot;</span>],</span><br><span class="line"><span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line"><span class="string">&quot;css&quot;</span>: [<span class="string">&quot;css/custom.css&quot;</span>],</span><br><span class="line"><span class="comment">// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line"><span class="string">&quot;run_at&quot;</span>: <span class="string">&quot;document_start&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意，如果没有主动指定<code>run_at</code>为<code>document_start</code>（默认为<code>document_idle</code>），下面这种代码是不会生效的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我被执行了！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>content-scripts</code>和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过<code>injected js</code>来实现。<code>content-scripts</code>不能访问绝大部分<code>chrome.xxx.api</code>，除了下面这4种：</p><ul><li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li><li>chrome.i18n</li><li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li><li>chrome.storage</li></ul><p>其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。</p><p>好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。</p><h2 id="2-3-background"><a href="#2-3-background" class="headerlink" title="2.3. background"></a>2.3. background</h2><p>后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p><p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置<code>CORS</code>。</p><blockquote><p>经过测试，其实不止是background，所有的直接通过<code>chrome-extension://id/xx.html</code>这种方式打开的网页都可以无限制跨域。</p></blockquote><p>配置中，<code>background</code>可以通过<code>page</code>指定一张网页，也可以通过<code>scripts</code>直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line"><span class="string">&quot;background&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;background.html&quot;</span></span><br><span class="line"><span class="comment">//&quot;scripts&quot;: [&quot;js/background.js&quot;]</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别说明的是，虽然你可以通过<code>chrome-extension://xxx/background.html</code>直接打开后台页，但是你打开的后台页和真正一直在后台运行的那个页面不是同一个，换句话说，你可以打开无数个<code>background.html</code>，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。</p><h2 id="2-4-event-pages"><a href="#2-4-event-pages" class="headerlink" title="2.4. event-pages"></a>2.4. event-pages</h2><p>这里顺带介绍一下<a href="https://developer.chrome.com/extensions/event_pages">event-pages</a>，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个<code>event-pages</code>，在配置文件上，它与background的唯一区别就是多了一个<code>persistent</code>参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;background&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: [<span class="string">&quot;event-page.js&quot;</span>],</span><br><span class="line"><span class="string">&quot;persistent&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。</p><p>除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。</p><h2 id="2-5-popup"><a href="#2-5-popup" class="headerlink" title="2.5. popup"></a>2.5. popup</h2><p><code>popup</code>是点击<code>browser_action</code>或者<code>page_action</code>图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。<code>popup</code>可以包含任意你想要的HTML内容，并且会自适应大小。可以通过<code>default_popup</code>字段来指定popup页面，也可以调用<code>setPopup()</code>方法。</p><p>配置方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;browser_action&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;这是一个示例Chrome插件&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。</p><p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过<code>chrome.extension.getBackgroundPage()</code>获取background的window对象。</p><h2 id="2-6-injected-script"><a href="#2-6-injected-script" class="headerlink" title="2.6. injected-script"></a>2.6. injected-script</h2><p>这里的<code>injected-script</code>是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？</p><p>这是因为<code>content-script</code>有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用<code>content-script</code>中的代码（包括直接写<code>onclick</code>和<code>addEventListener</code>2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。</p><p>在<code>content-script</code>中通过DOM方式向页面注入<code>inject-script</code>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向页面注入JS</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">injectCustomJs</span>(<span class="params">jsPath</span>)</span><br><span class="line">&#123;</span><br><span class="line">jsPath = jsPath || <span class="string">&#x27;js/inject.js&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">temp.<span class="title function_">setAttribute</span>(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span><br><span class="line"><span class="comment">// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js</span></span><br><span class="line">temp.<span class="property">src</span> = chrome.<span class="property">extension</span>.<span class="title function_">getURL</span>(jsPath);</span><br><span class="line">temp.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 放在页面不好看，执行完后移除掉</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你以为这样就行了？执行一下你会看到如下报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Denying load of chrome-extension://efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span><br></pre></td></tr></table></figure><p>意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line"><span class="string">&quot;web_accessible_resources&quot;</span>: [<span class="string">&quot;js/inject.js&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于<code>inject-script</code>如何调用<code>content-script</code>中的代码，后面我会在专门的一个消息通信章节详细介绍。</p><h1 id="三、Chrome插件的8种展示形式"><a href="#三、Chrome插件的8种展示形式" class="headerlink" title="三、Chrome插件的8种展示形式"></a>三、Chrome插件的8种展示形式</h1><h2 id="3-1-browserAction-浏览器右上角"><a href="#3-1-browserAction-浏览器右上角" class="headerlink" title="3.1. browserAction(浏览器右上角)"></a>3.1. browserAction(浏览器右上角)</h2><p>通过配置<code>browser_action</code>可以在浏览器的右上角增加一个图标，一个<code>browser_action</code>可以拥有一个图标，一个<code>tooltip</code>，一个<code>badge</code>和一个<code>popup</code>。</p><p>示例配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;browser_action&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;这是一个示例Chrome插件&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-1-图标"><a href="#5-1-1-图标" class="headerlink" title="5.1.1. 图标"></a>5.1.1. 图标</h3><p><code>browser_action</code>图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中<code>default_icon</code>字段配置，也可以调用setIcon()方法。</p><h3 id="5-1-2-tooltip"><a href="#5-1-2-tooltip" class="headerlink" title="5.1.2. tooltip"></a>5.1.2. tooltip</h3><p>修改<code>browser_action</code>的manifest中<code>default_title</code>字段，或者调用<code>setTitle()</code>方法。</p><h3 id="5-1-3-badge"><a href="#5-1-3-badge" class="headerlink" title="5.1.3. badge"></a>5.1.3. badge</h3><p>所谓<code>badge</code>就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用<code>setBadgeText()</code>和<code>setBadgeBackgroundColor()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeText</span>(&#123;<span class="attr">text</span>: <span class="string">&#x27;new&#x27;</span>&#125;);</span><br><span class="line">chrome.<span class="property">browserAction</span>.<span class="title function_">setBadgeBackgroundColor</span>(&#123;<span class="attr">color</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-2-pageAction-地址栏右侧"><a href="#3-2-pageAction-地址栏右侧" class="headerlink" title="3.2. pageAction(地址栏右侧)"></a>3.2. pageAction(地址栏右侧)</h2><p>所谓<code>pageAction</code>，指的是只有当某些特定页面打开才显示的图标，它和<code>browserAction</code>最大的区别是一个始终都显示，一个只在特定情况才显示。</p><p>需要特别说明的是早些版本的Chrome是将pageAction放在地址栏的最右边，左键单击弹出popup，右键单击则弹出相关默认的选项菜单</p><p>而新版的Chrome更改了这一策略，pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项</p><blockquote><p>具体是从哪一版本开始改的没去仔细考究，反正知道v50.0的时候还是前者，v58.0的时候已改为后者。</p></blockquote><p>调整之后的<code>pageAction</code>我们可以简单地把它看成是可以置灰的<code>browserAction</code>。</p><ul><li>chrome.pageAction.show(tabId) 显示图标；</li><li>chrome.pageAction.hide(tabId) 隐藏图标；</li></ul><p>示例(只有打开百度才显示图标)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;page_action&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;default_icon&quot;</span>: <span class="string">&quot;img/icon.png&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;我是pageAction&quot;</span>,</span><br><span class="line"><span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;popup.html&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;declarativeContent&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onInstalled</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">chrome.<span class="property">declarativeContent</span>.<span class="property">onPageChanged</span>.<span class="title function_">removeRules</span>(<span class="literal">undefined</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">chrome.<span class="property">declarativeContent</span>.<span class="property">onPageChanged</span>.<span class="title function_">addRules</span>([</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">conditions</span>: [</span><br><span class="line"><span class="comment">// 只有打开百度才显示pageAction</span></span><br><span class="line"><span class="keyword">new</span> chrome.<span class="property">declarativeContent</span>.<span class="title class_">PageStateMatcher</span>(&#123;<span class="attr">pageUrl</span>: &#123;<span class="attr">urlContains</span>: <span class="string">&#x27;baidu.com&#x27;</span>&#125;&#125;)</span><br><span class="line">],</span><br><span class="line"><span class="attr">actions</span>: [<span class="keyword">new</span> chrome.<span class="property">declarativeContent</span>.<span class="title class_">ShowPageAction</span>()]</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-3-右键菜单"><a href="#3-3-右键菜单" class="headerlink" title="3.3. 右键菜单"></a>3.3. 右键菜单</h2><p>通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过<code>chrome.contextMenus</code>API实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等，如果有同一个插件里面定义了多个菜单，Chrome会自动组合放到以插件名字命名的二级菜单里</p><h3 id="3-3-1-最简单的右键菜单示例"><a href="#3-3-1-最简单的右键菜单示例" class="headerlink" title="3.3.1. 最简单的右键菜单示例"></a>3.3.1. 最简单的右键菜单示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;contextMenus&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&quot;测试右键菜单&quot;</span>,</span><br><span class="line"><span class="attr">onclick</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&#x27;您点击了右键菜单！&#x27;</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-2-添加右键百度搜索"><a href="#3-3-2-添加右键百度搜索" class="headerlink" title="3.3.2. 添加右键百度搜索"></a>3.3.2. 添加右键百度搜索</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;contextMenus&quot;</span>， <span class="string">&quot;tabs&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;使用度娘搜索：%s&#x27;</span>, <span class="comment">// %s表示选中的文字</span></span><br><span class="line"><span class="attr">contexts</span>: [<span class="string">&#x27;selection&#x27;</span>], <span class="comment">// 只有当选中文字时才会出现此右键菜单</span></span><br><span class="line"><span class="attr">onclick</span>: <span class="keyword">function</span>(<span class="params">params</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 注意不能使用location.href，因为location是属于background的window对象</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">create</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;https://www.baidu.com/s?ie=utf-8&amp;wd=&#x27;</span> + <span class="built_in">encodeURI</span>(params.<span class="property">selectionText</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-3-语法说明"><a href="#3-3-3-语法说明" class="headerlink" title="3.3.3. 语法说明"></a>3.3.3. 语法说明</h3><p>这里只是简单列举一些常用的，完整API参见：<a href="https://developer.chrome.com/extensions/contextMenus">https://developer.chrome.com/extensions/contextMenus</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;normal&#x27;</span>， <span class="comment">// 类型，可选：[&quot;normal&quot;, &quot;checkbox&quot;, &quot;radio&quot;, &quot;separator&quot;]，默认 normal</span></span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;菜单的名字&#x27;</span>, <span class="comment">// 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span></span><br><span class="line"><span class="attr">contexts</span>: [<span class="string">&#x27;page&#x27;</span>], <span class="comment">// 上下文环境，可选：[&quot;all&quot;, &quot;page&quot;, &quot;frame&quot;, &quot;selection&quot;, &quot;link&quot;, &quot;editable&quot;, &quot;image&quot;, &quot;video&quot;, &quot;audio&quot;]，默认page</span></span><br><span class="line"><span class="attr">onclick</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;, <span class="comment">// 单击时触发的方法</span></span><br><span class="line"><span class="attr">parentId</span>: <span class="number">1</span>, <span class="comment">// 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span></span><br><span class="line"><span class="attr">documentUrlPatterns</span>: <span class="string">&#x27;https://*.baidu.com/*&#x27;</span> <span class="comment">// 只在某些页面显示此右键菜单</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 删除某一个菜单项</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">remove</span>(menuItemId)；</span><br><span class="line"><span class="comment">// 删除所有自定义右键菜单</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">removeAll</span>();</span><br><span class="line"><span class="comment">// 更新某一个菜单项</span></span><br><span class="line">chrome.<span class="property">contextMenus</span>.<span class="title function_">update</span>(menuItemId, updateProperties);</span><br></pre></td></tr></table></figure><h2 id="3-4-override-覆盖特定页面"><a href="#3-4-override-覆盖特定页面" class="headerlink" title="3.4. override(覆盖特定页面)"></a>3.4. override(覆盖特定页面)</h2><p>使用<code>override</code>页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。</p><p>扩展可以替代如下页面：</p><ul><li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 <a href="chrome://history/">chrome:&#x2F;&#x2F;history</a></li><li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 <a href="chrome://newtab/">chrome:&#x2F;&#x2F;newtab</a></li><li>书签：浏览器的书签，或者直接输入 <a href="chrome://bookmarks/">chrome:&#x2F;&#x2F;bookmarks</a></li></ul><p>注意：</p><ul><li>一个扩展只能替代一个页面；</li><li>不能替代隐身窗口的新标签页；</li><li>网页必须设置title，否则用户可能会看到网页的URL，造成困扰；</li></ul><p>代码（注意，一个插件只能替代一个默认页，以下仅为演示）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;chrome_url_overrides&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;newtab&quot;</span>: <span class="string">&quot;newtab.html&quot;</span>,</span><br><span class="line"><span class="string">&quot;history&quot;</span>: <span class="string">&quot;history.html&quot;</span>,</span><br><span class="line"><span class="string">&quot;bookmarks&quot;</span>: <span class="string">&quot;bookmarks.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-devtools-开发者工具"><a href="#3-5-devtools-开发者工具" class="headerlink" title="3.5. devtools(开发者工具)"></a>3.5. devtools(开发者工具)</h2><h3 id="3-5-1-预热"><a href="#3-5-1-预热" class="headerlink" title="3.5.1. 预热"></a>3.5.1. 预热</h3><p>使用过vue的应该见过这种类型的插件：</p><p><img src="http://image.liuxianan.com/201706/20170605_181456_375_7033.png"></p><p>是的，Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：</p><ul><li>自定义一个和多个和<code>Elements</code>、<code>Console</code>、<code>Sources</code>等同级别的面板；</li><li>自定义侧边栏(sidebar)，目前只能自定义<code>Elements</code>面板的侧边栏；</li></ul><h3 id="3-5-2-devtools扩展介绍"><a href="#3-5-2-devtools扩展介绍" class="headerlink" title="3.5.2. devtools扩展介绍"></a>3.5.2. devtools扩展介绍</h3><p>主页：<a href="https://developer.chrome.com/extensions/devtools">https://developer.chrome.com/extensions/devtools</a></p><p>每打开一个开发者工具窗口，都会创建devtools页面的实例，F12窗口关闭，页面也随着关闭，所以devtools页面的生命周期和devtools窗口是一致的。devtools页面可以访问一组特有的<code>DevTools API</code>以及有限的扩展API，这组特有的<code>DevTools API</code>只有devtools页面才可以访问，background都无权访问，这些API包括：</p><ul><li><code>chrome.devtools.panels</code>：面板相关；</li><li><code>chrome.devtools.inspectedWindow</code>：获取被审查窗口的有关信息；</li><li><code>chrome.devtools.network</code>：获取有关网络请求的信息；</li></ul><p>大部分扩展API都无法直接被<code>DevTools</code>页面调用，但它可以像<code>content-script</code>一样直接调用<code>chrome.extension</code>和<code>chrome.runtime</code>API，同时它也可以像<code>content-script</code>一样使用Message交互的方式与background页面进行通信。</p><h3 id="3-5-3-实例：创建一个devtools扩展"><a href="#3-5-3-实例：创建一个devtools扩展" class="headerlink" title="3.5.3. 实例：创建一个devtools扩展"></a>3.5.3. 实例：创建一个devtools扩展</h3><p>首先，要针对开发者工具开发插件，需要在清单文件声明如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line"><span class="string">&quot;devtools_page&quot;</span>: <span class="string">&quot;devtools.html&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>devtools.html</code>里面一般什么都没有，就引入一个js：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/devtools.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可以看出来，其实真正代码是<code>devtools.js</code>，html文件是“多余”的，所以这里觉得有点坑，<code>devtools_page</code>干嘛不允许直接指定JS呢？</p><p>再来看devtools.js的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建自定义面板，同一个插件可以创建多个自定义面板</span></span><br><span class="line"><span class="comment">// 几个参数依次为：panel标题、图标（其实设置了也没地方显示）、要加载的页面、加载成功后的回调</span></span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">panels</span>.<span class="title function_">create</span>(<span class="string">&#x27;MyPanel&#x27;</span>, <span class="string">&#x27;img/icon.png&#x27;</span>, <span class="string">&#x27;mypanel.html&#x27;</span>, <span class="keyword">function</span>(<span class="params">panel</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自定义面板创建成功！&#x27;</span>); <span class="comment">// 注意这个log一般看不到</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建自定义侧边栏</span></span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">panels</span>.<span class="property">elements</span>.<span class="title function_">createSidebarPane</span>(<span class="string">&quot;Images&quot;</span>, <span class="keyword">function</span>(<span class="params">sidebar</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// sidebar.setPage(&#x27;../sidebar.html&#x27;); // 指定加载某个页面</span></span><br><span class="line">sidebar.<span class="title function_">setExpression</span>(<span class="string">&#x27;document.querySelectorAll(&quot;img&quot;)&#x27;</span>, <span class="string">&#x27;All Images&#x27;</span>); <span class="comment">// 通过表达式来指定</span></span><br><span class="line"><span class="comment">//sidebar.setObject(&#123;aaa: 111, bbb: &#x27;Hello World!&#x27;&#125;); // 直接设置显示某个对象</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测jQuery</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;check_jquery&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 访问被检查的页面DOM需要使用inspectedWindow</span></span><br><span class="line"><span class="comment">// 简单例子：检测被检查页面是否使用了jQuery</span></span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="built_in">eval</span>(<span class="string">&quot;jQuery.fn.jquery&quot;</span>, <span class="keyword">function</span>(<span class="params">result, isException</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (isException) html = <span class="string">&#x27;当前页面没有使用jQuery。&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> html = <span class="string">&#x27;当前页面使用了jQuery，版本为：&#x27;</span>+result;</span><br><span class="line"><span class="title function_">alert</span>(html);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开某个资源</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;open_resource&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="built_in">eval</span>(<span class="string">&quot;window.location.href&quot;</span>, <span class="keyword">function</span>(<span class="params">result, isException</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">panels</span>.<span class="title function_">openResource</span>(result, <span class="number">20</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;资源打开成功！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 审查元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test_inspect&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="built_in">eval</span>(<span class="string">&quot;inspect(document.images[0])&quot;</span>, <span class="keyword">function</span>(<span class="params">result, isException</span>)&#123;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有资源</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;get_all_resources&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">devtools</span>.<span class="property">inspectedWindow</span>.<span class="title function_">getResources</span>(<span class="keyword">function</span>(<span class="params">resources</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(resources));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-5-4-调试技巧"><a href="#3-5-4-调试技巧" class="headerlink" title="3.5.4. 调试技巧"></a>3.5.4. 调试技巧</h3><p>修改了devtools页面的代码时，需要先在 chrome:&#x2F;&#x2F;extensions 页面按下<code>Ctrl+R</code>重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面（而且只刷新页面不刷新开发者工具的话是不会生效的）。</p><p>由于devtools本身就是开发者工具页面，所以几乎没有方法可以直接调试它，直接用 <code>chrome-extension://extid/devtools.html&quot;</code>的方式打开页面肯定报错，因为不支持相关特殊API，只能先自己写一些方法屏蔽这些错误，调试通了再放开。</p><h2 id="3-6-option-选项页"><a href="#3-6-option-选项页" class="headerlink" title="3.6. option(选项页)"></a>3.6. option(选项页)</h2><p>所谓<code>options</code>页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：</p><p>在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。</p><p>我们先看老版的<a href="https://developer.chrome.com/extensions/options">options</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line"><span class="string">&quot;options_page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个<code>选项</code>按钮入口，点进去就是打开一个网页，没啥好讲的。</p><p>再来看新版的<a href="https://developer.chrome.com/extensions/optionsV2">optionsV2</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;options_ui&quot;</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;page&quot;</span>: <span class="string">&quot;options.html&quot;</span>,</span><br><span class="line"><span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line"><span class="string">&quot;chrome_style&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几点注意：</p><ul><li>为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；</li><li>新版options中不能使用alert；</li><li>数据存储建议用chrome.storage，因为会随用户自动同步；</li></ul><h2 id="3-7-omnibox"><a href="#3-7-omnibox" class="headerlink" title="3.7. omnibox"></a>3.7. omnibox</h2><p><code>omnibox</code>是向用户提供搜索建议的一种方式</p><p>注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。</p><p>首先，配置文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line"><span class="string">&quot;omnibox&quot;</span>: &#123; <span class="string">&quot;keyword&quot;</span> : <span class="string">&quot;go&quot;</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>background.js</code>中注册监听事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// omnibox 演示</span></span><br><span class="line">chrome.<span class="property">omnibox</span>.<span class="property">onInputChanged</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">text, suggest</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inputChanged: &#x27;</span> + text);</span><br><span class="line"><span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(text == <span class="string">&#x27;美女&#x27;</span>) &#123;</span><br><span class="line"><span class="title function_">suggest</span>([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;中国&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“中国美女”吗？&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;日本&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“日本美女”吗？&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;泰国&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“泰国美女或人妖”吗？&#x27;</span>&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;韩国&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;你要找“韩国美女”吗？&#x27;</span>&#125;</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(text == <span class="string">&#x27;微博&#x27;</span>) &#123;</span><br><span class="line"><span class="title function_">suggest</span>([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;新浪&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;新浪&#x27;</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;腾讯&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;腾讯&#x27;</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;搜狐&#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;搜索&#x27;</span> + text&#125;,</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="title function_">suggest</span>([</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;百度搜索 &#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;百度搜索 &#x27;</span> + text&#125;,</span><br><span class="line">&#123;<span class="attr">content</span>: <span class="string">&#x27;谷歌搜索 &#x27;</span> + text, <span class="attr">description</span>: <span class="string">&#x27;谷歌搜索 &#x27;</span> + text&#125;,</span><br><span class="line">]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户接收关键字建议时触发</span></span><br><span class="line">chrome.<span class="property">omnibox</span>.<span class="property">onInputEntered</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inputEntered: &#x27;</span> + text);</span><br><span class="line"><span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> href = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(text.<span class="title function_">endsWith</span>(<span class="string">&#x27;美女&#x27;</span>)) href = <span class="string">&#x27;http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word=&#x27;</span> + text;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(text.<span class="title function_">startsWith</span>(<span class="string">&#x27;百度搜索&#x27;</span>)) href = <span class="string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=&#x27;</span> + text.<span class="title function_">replace</span>(<span class="string">&#x27;百度搜索 &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(text.<span class="title function_">startsWith</span>(<span class="string">&#x27;谷歌搜索&#x27;</span>)) href = <span class="string">&#x27;https://www.google.com.tw/search?q=&#x27;</span> + text.<span class="title function_">replace</span>(<span class="string">&#x27;谷歌搜索 &#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span> href = <span class="string">&#x27;https://www.baidu.com/s?ie=UTF-8&amp;wd=&#x27;</span> + text;</span><br><span class="line"><span class="title function_">openUrlCurrentTab</span>(href);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId</span>(<span class="params">callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前标签打开某个链接</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">openUrlCurrentTab</span>(<span class="params">url</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">getCurrentTabId</span>(<span class="function"><span class="params">tabId</span> =&gt;</span> &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">update</span>(tabId, &#123;<span class="attr">url</span>: url&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-桌面通知"><a href="#3-8-桌面通知" class="headerlink" title="3.8. 桌面通知"></a>3.8. 桌面通知</h2><p>Chrome提供了一个<code>chrome.notifications</code>API以便插件推送桌面通知，暂未找到<code>chrome.notifications</code>和HTML5自带的<code>Notification</code>的显著区别及优势。</p><p>在后台JS中，无论是使用<code>chrome.notifications</code>还是<code>Notification</code>都不需要申请权限（HTML5方式需要申请权限），直接使用即可。</p><p>最简单的通知：</p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">notifications</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line"><span class="attr">iconUrl</span>: <span class="string">&#x27;img/icon.png&#x27;</span>,</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;这是标题&#x27;</span>,</span><br><span class="line"><span class="attr">message</span>: <span class="string">&#x27;您刚才点击了自定义右键菜单！&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个没有深入研究，有需要的可以去<a href="https://developer.chrome.com/extensions/notifications">官方文档</a>查看更多细节。</p><h1 id="四、5种类型的JS对比"><a href="#四、5种类型的JS对比" class="headerlink" title="四、5种类型的JS对比"></a>四、5种类型的JS对比</h1><p>Chrome插件的JS主要可以分为这5类：<code>injected script</code>、<code>content-script</code>、<code>popup js</code>、<code>background js</code>和<code>devtools js</code>，</p><h2 id="4-1-权限对比"><a href="#4-1-权限对比" class="headerlink" title="4.1. 权限对比"></a>4.1. 权限对比</h2><table><thead><tr><th>JS种类</th><th>可访问的API</th><th>DOM访问情况</th><th>JS访问情况</th><th>直接跨域</th></tr></thead><tbody><tr><td>injected script</td><td>和普通JS无任何差别，不能访问任何扩展API</td><td>可以访问</td><td>可以访问</td><td>不可以</td></tr><tr><td>content script</td><td>只能访问 extension、runtime等部分API</td><td>可以访问</td><td>不可以</td><td>不可以</td></tr><tr><td>popup js</td><td>可访问绝大部分API，除了devtools系列</td><td>不可直接访问</td><td>不可以</td><td>可以</td></tr><tr><td>background js</td><td>可访问绝大部分API，除了devtools系列</td><td>不可直接访问</td><td>不可以</td><td>可以</td></tr><tr><td>devtools js</td><td>只能访问 devtools、extension、runtime等部分API</td><td>可以</td><td>可以</td><td>不可以</td></tr></tbody></table><h2 id="4-2-调试方式对比"><a href="#4-2-调试方式对比" class="headerlink" title="4.2. 调试方式对比"></a>4.2. 调试方式对比</h2><table><thead><tr><th>JS类型</th><th>调试方式</th></tr></thead><tbody><tr><td>injected script</td><td>直接普通的F12即可</td></tr><tr><td>content-script</td><td>打开Console,如图切换</td></tr><tr><td>popup-js</td><td>popup页面右键审查元素</td></tr><tr><td>background</td><td>插件管理页点击背景页即可</td></tr><tr><td>devtools-js</td><td>暂未找到有效方法</td></tr></tbody></table><h1 id="五、消息通信"><a href="#五、消息通信" class="headerlink" title="五、消息通信"></a>五、消息通信</h1><p>通信主页：<a href="https://developer.chrome.com/extensions/messaging">https://developer.chrome.com/extensions/messaging</a></p><p>前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。</p><h2 id="5-1-互相通信概览"><a href="#5-1-互相通信概览" class="headerlink" title="5.1. 互相通信概览"></a>5.1. 互相通信概览</h2><p>注：<code>-</code>表示不存在或者无意义，或者待验证。</p><table><thead><tr><th></th><th>injected-script</th><th>content-script</th><th>popup-js</th><th>background-js</th></tr></thead><tbody><tr><td>injected-script</td><td>-</td><td>window.postMessage</td><td>-</td><td>-</td></tr><tr><td>content-script</td><td>window.postMessage</td><td>-</td><td>chrome.runtime.sendMessage chrome.runtime.connect</td><td>chrome.runtime.sendMessage chrome.runtime.connect</td></tr><tr><td>popup-js</td><td>-</td><td>chrome.tabs.sendMessage chrome.tabs.connect</td><td>-</td><td>chrome.extension. getBackgroundPage()</td></tr><tr><td>background-js</td><td>-</td><td>chrome.tabs.sendMessage chrome.tabs.connect</td><td>chrome.extension.getViews</td><td>-</td></tr><tr><td>devtools-js</td><td>chrome.devtools. inspectedWindow.eval</td><td>-</td><td>chrome.runtime.sendMessage</td><td>chrome.runtime.sendMessage</td></tr></tbody></table><h2 id="5-2-通信详细介绍"><a href="#5-2-通信详细介绍" class="headerlink" title="5.2. 通信详细介绍"></a>5.2. 通信详细介绍</h2><h3 id="5-2-1-popup和background"><a href="#5-2-1-popup和background" class="headerlink" title="5.2.1. popup和background"></a>5.2.1. popup和background</h3><p>popup可以直接调用background中的JS方法，也可以直接访问background的DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;我是background！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// popup.js</span></span><br><span class="line"><span class="keyword">var</span> bg = chrome.<span class="property">extension</span>.<span class="title function_">getBackgroundPage</span>();</span><br><span class="line">bg.<span class="title function_">test</span>(); <span class="comment">// 访问bg的函数</span></span><br><span class="line"><span class="title function_">alert</span>(bg.<span class="property">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span>); <span class="comment">// 访问bg的DOM</span></span><br></pre></td></tr></table></figure><blockquote><p>小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。</p></blockquote><p>至于<code>background</code>访问<code>popup</code>如下（前提是<code>popup</code>已经打开）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> views = chrome.<span class="property">extension</span>.<span class="title function_">getViews</span>(&#123;<span class="attr">type</span>:<span class="string">&#x27;popup&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(views.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(views[<span class="number">0</span>].<span class="property">location</span>.<span class="property">href</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2-popup或者bg向content主动发送消息"><a href="#5-2-2-popup或者bg向content主动发送消息" class="headerlink" title="5.2.2. popup或者bg向content主动发送消息"></a>5.2.2. popup或者bg向content主动发送消息</h3><p>background.js或者popup.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>, message, <span class="keyword">function</span>(<span class="params">response</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(response);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sendMessageToContentScript</span>(&#123;<span class="attr">cmd</span>:<span class="string">&#x27;test&#x27;</span>, <span class="attr">value</span>:<span class="string">&#x27;你好，我是popup！&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">response</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;来自content的回复：&#x27;</span>+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>content-script.js</code>接收：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// console.log(sender.tab ?&quot;from a content script:&quot; + sender.tab.url :&quot;from the extension&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(request.<span class="property">cmd</span> == <span class="string">&#x27;test&#x27;</span>) <span class="title function_">alert</span>(request.<span class="property">value</span>);</span><br><span class="line"><span class="title function_">sendResponse</span>(<span class="string">&#x27;我收到了你的消息！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。</p><blockquote><p>网上有些老代码中用的是<code>chrome.extension.onMessage</code>，没有完全查清二者的区别(貌似是别名)，但是建议统一使用<code>chrome.runtime.onMessage</code>。</p></blockquote><h3 id="5-2-3-content-script主动发消息给后台"><a href="#5-2-3-content-script主动发消息给后台" class="headerlink" title="5.2.3. content-script主动发消息给后台"></a>5.2.3. content-script主动发消息给后台</h3><p>content-script.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123;<span class="attr">greeting</span>: <span class="string">&#x27;你好，我是content-script呀，我主动发消息给后台！&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到来自后台的回复：&#x27;</span> + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>background.js 或者 popup.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听来自content-script的消息</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到来自content-script的消息：&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(request, sender, sendResponse);</span><br><span class="line"><span class="title function_">sendResponse</span>(<span class="string">&#x27;我是后台，我已收到你的消息：&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>content_scripts向<code>popup</code>主动发消息的前提是popup必须打开！否则需要利用background作中转；</li><li>如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；</li></ul><h3 id="5-2-4-injected-script和content-script"><a href="#5-2-4-injected-script和content-script" class="headerlink" title="5.2.4. injected script和content-script"></a>5.2.4. injected script和content-script</h3><p><code>content-script</code>和页面内的脚本（<code>injected-script</code>自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：</p><ol><li>可以通过<code>window.postMessage</code>和<code>window.addEventListener</code>来实现二者消息通讯；</li><li>通过自定义DOM事件来实现；</li></ol><p>第一种方法（推荐）：</p><p><code>injected-script</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>(&#123;<span class="string">&quot;test&quot;</span>: <span class="string">&#x27;你好！&#x27;</span>&#125;, <span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><p>content script中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>第二种方法：</p><p><code>injected-script</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> customEvent = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">customEvent.<span class="title function_">initEvent</span>(<span class="string">&#x27;myCustomEvent&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fireCustomEvent</span>(<span class="params">data</span>) &#123;</span><br><span class="line">hiddenDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCustomEventDiv&#x27;</span>);</span><br><span class="line">hiddenDiv.<span class="property">innerText</span> = data</span><br><span class="line">hiddenDiv.<span class="title function_">dispatchEvent</span>(customEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fireCustomEvent</span>(<span class="string">&#x27;你好，我是普通JS！&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>content-script.js</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCustomEventDiv&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!hiddenDiv) &#123;</span><br><span class="line">hiddenDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">hiddenDiv.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(hiddenDiv);</span><br><span class="line">&#125;</span><br><span class="line">hiddenDiv.<span class="title function_">addEventListener</span>(<span class="string">&#x27;myCustomEvent&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> eventData = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCustomEventDiv&#x27;</span>).<span class="property">innerText</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到自定义事件消息：&#x27;</span> + eventData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-2-5-injected-script与popup通信"><a href="#5-2-5-injected-script与popup通信" class="headerlink" title="5.2.5. injected-script与popup通信"></a>5.2.5. injected-script与popup通信</h3><p><code>injected-script</code>无法直接和<code>popup</code>通信，必须借助<code>content-script</code>作为中间人。</p><p>&#x2F;&#x2F;TODO 示例代码有待完善。</p><h2 id="5-3-长连接和短连接"><a href="#5-3-长连接和短连接" class="headerlink" title="5.3. 长连接和短连接"></a>5.3. 长连接和短连接</h2><p>其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（<code>chrome.tabs.sendMessage</code>和<code>chrome.runtime.sendMessage</code>），一个是长连接（<code>chrome.tabs.connect</code>和<code>chrome.runtime.connect</code>）。</p><p>短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似<code>WebSocket</code>会一直建立连接，双方可以随时互发消息。</p><p>短连接上面已经有代码示例了，这里只讲一下长连接。</p><p>popup.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getCurrentTabId</span>(<span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> port = chrome.<span class="property">tabs</span>.<span class="title function_">connect</span>(tabId, &#123;<span class="attr">name</span>: <span class="string">&#x27;test-connect&#x27;</span>&#125;);</span><br><span class="line">port.<span class="title function_">postMessage</span>(&#123;<span class="attr">question</span>: <span class="string">&#x27;你是谁啊？&#x27;</span>&#125;);</span><br><span class="line">port.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;收到消息：&#x27;</span>+msg.<span class="property">answer</span>);</span><br><span class="line"><span class="keyword">if</span>(msg.<span class="property">answer</span> &amp;&amp; msg.<span class="property">answer</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;我是&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">port.<span class="title function_">postMessage</span>(&#123;<span class="attr">question</span>: <span class="string">&#x27;哦，原来是你啊！&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>content-script.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听长连接</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onConnect</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">port</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(port);</span><br><span class="line"><span class="keyword">if</span>(port.<span class="property">name</span> == <span class="string">&#x27;test-connect&#x27;</span>) &#123;</span><br><span class="line">port.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="keyword">function</span>(<span class="params">msg</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到长连接消息：&#x27;</span>, msg);</span><br><span class="line"><span class="keyword">if</span>(msg.<span class="property">question</span> == <span class="string">&#x27;你是谁啊？&#x27;</span>) port.<span class="title function_">postMessage</span>(&#123;<span class="attr">answer</span>: <span class="string">&#x27;我是你爸！&#x27;</span>&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="六、其它补充"><a href="#六、其它补充" class="headerlink" title="六、其它补充"></a>六、其它补充</h1><h2 id="6-1-动态注入或执行JS"><a href="#6-1-动态注入或执行JS" class="headerlink" title="6.1. 动态注入或执行JS"></a>6.1. 动态注入或执行JS</h2><p>虽然在<code>background</code>和<code>popup</code>中无法直接访问页面DOM，但是可以通过<code>chrome.tabs.executeScript</code>来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。</p><p>示例<code>manifest.json</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;动态JS注入演示&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;permissions&quot;</span>: [</span><br><span class="line"><span class="string">&quot;tabs&quot;</span>, <span class="string">&quot;http://*/*&quot;</span>, <span class="string">&quot;https://*/*&quot;</span></span><br><span class="line">],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态执行JS代码</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">executeScript</span>(tabId, &#123;<span class="attr">code</span>: <span class="string">&#x27;document.body.style.backgroundColor=&quot;red&quot;&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行JS文件</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">executeScript</span>(tabId, &#123;<span class="attr">file</span>: <span class="string">&#x27;some-script.js&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-2-动态注入CSS"><a href="#6-2-动态注入CSS" class="headerlink" title="6.2. 动态注入CSS"></a>6.2. 动态注入CSS</h2><p>示例<code>manifest.json</code>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;动态CSS注入演示&quot;</span>,</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;permissions&quot;</span>: [</span><br><span class="line"><span class="string">&quot;tabs&quot;</span>, <span class="string">&quot;http://*/*&quot;</span>, <span class="string">&quot;https://*/*&quot;</span></span><br><span class="line">],</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态执行CSS代码，TODO，这里有待验证</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">insertCSS</span>(tabId, &#123;<span class="attr">code</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行CSS文件</span></span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">insertCSS</span>(tabId, &#123;<span class="attr">file</span>: <span class="string">&#x27;some-style.css&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-3-获取当前窗口ID"><a href="#6-3-获取当前窗口ID" class="headerlink" title="6.3. 获取当前窗口ID"></a>6.3. 获取当前窗口ID</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrome.<span class="property">windows</span>.<span class="title function_">getCurrent</span>(<span class="keyword">function</span>(<span class="params">currentWindow</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前窗口ID：&#x27;</span> + currentWindow.<span class="property">id</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-4-获取当前标签页ID"><a href="#6-4-获取当前标签页ID" class="headerlink" title="6.4. 获取当前标签页ID"></a>6.4. 获取当前标签页ID</h2><p>一般有2种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId</span>(<span class="params">callback</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentTabId2</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">windows</span>.<span class="title function_">getCurrent</span>(<span class="keyword">function</span>(<span class="params">currentWindow</span>)</span><br><span class="line">&#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">windowId</span>: currentWindow.<span class="property">id</span>&#125;, <span class="keyword">function</span>(<span class="params">tabs</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(callback) <span class="title function_">callback</span>(tabs.<span class="property">length</span> ? tabs[<span class="number">0</span>].<span class="property">id</span>: <span class="literal">null</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-本地存储"><a href="#6-5-本地存储" class="headerlink" title="6.5. 本地存储"></a>6.5. 本地存储</h2><p>本地存储建议用<code>chrome.storage</code>而不是普通的<code>localStorage</code>，区别有好几点，个人认为最重要的2点区别是：</p><ul><li><code>chrome.storage</code>是针对插件全局的，即使你在<code>background</code>中保存的数据，在<code>content-script</code>也能获取到；</li><li><code>chrome.storage.sync</code>可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；</li></ul><p>需要声明<code>storage</code>权限，有<code>chrome.storage.sync</code>和<code>chrome.storage.local</code>2种方式可供选择，使用示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据，第一个参数是指定要读取的key以及设置默认值</span></span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, <span class="keyword">function</span>(<span class="params">items</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(items.<span class="property">color</span>, items.<span class="property">age</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(&#123;<span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存成功！&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-6-webRequest"><a href="#6-6-webRequest" class="headerlink" title="6.6. webRequest"></a>6.6. webRequest</h2><p>这里通过<code>beforeRequest</code>来简单演示一下它的冰山一角：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 权限申请</span></span><br><span class="line"><span class="string">&quot;permissions&quot;</span>:</span><br><span class="line">[</span><br><span class="line"><span class="string">&quot;webRequest&quot;</span>, <span class="comment">// web请求</span></span><br><span class="line"><span class="string">&quot;webRequestBlocking&quot;</span>, <span class="comment">// 阻塞式web请求</span></span><br><span class="line"><span class="string">&quot;storage&quot;</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line"><span class="string">&quot;http://*/*&quot;</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line"><span class="string">&quot;https://*/*&quot;</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="comment">// 是否显示图片</span></span><br><span class="line"><span class="keyword">var</span> showImage;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>(&#123;<span class="attr">showImage</span>: <span class="literal">true</span>&#125;, <span class="keyword">function</span>(<span class="params">items</span>) &#123;</span><br><span class="line">showImage = items.<span class="property">showImage</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeRequest</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// cancel 表示取消本次请求</span></span><br><span class="line"><span class="keyword">if</span>(!showImage &amp;&amp; details.<span class="property">type</span> == <span class="string">&#x27;image&#x27;</span>) <span class="keyword">return</span> &#123;<span class="attr">cancel</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="comment">// 简单的音视频检测</span></span><br><span class="line"><span class="comment">// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span></span><br><span class="line"><span class="keyword">if</span>(details.<span class="property">type</span> == <span class="string">&#x27;media&#x27;</span>) &#123;</span><br><span class="line">chrome.<span class="property">notifications</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line"><span class="attr">type</span>: <span class="string">&#x27;basic&#x27;</span>,</span><br><span class="line"><span class="attr">iconUrl</span>: <span class="string">&#x27;img/icon.png&#x27;</span>,</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;检测到音视频&#x27;</span>,</span><br><span class="line"><span class="attr">message</span>: <span class="string">&#x27;音视频地址：&#x27;</span> + details.<span class="property">url</span>,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>]&#125;, [<span class="string">&quot;blocking&quot;</span>]);</span><br></pre></td></tr></table></figure><p>几个可能经常用到的事件使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次请求前触发，可以拿到 requestBody 数据，同时可以对本次请求作出干预修改</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeRequest</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeRequest&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;blocking&#x27;</span>, <span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;requestBody&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送header之前触发，可以拿到请求headers，也可以添加、修改、删除headers</span></span><br><span class="line"><span class="comment">// 但使用有一定限制，一些特殊头部可能拿不到或者存在特殊情况，详见官网文档</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onBeforeSendHeaders</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeSendHeaders&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;blocking&#x27;</span>, <span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;requestHeaders&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始响应触发，可以拿到服务端返回的headers</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onResponseStarted</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onResponseStarted&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;responseHeaders&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求完成触发，能拿到的数据和onResponseStarted一样，注意无法拿到responseBody</span></span><br><span class="line">chrome.<span class="property">webRequest</span>.<span class="property">onCompleted</span>.<span class="title function_">addListener</span>(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onCompleted&#x27;</span>, details);</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">&#x27;&lt;all_urls&gt;&#x27;</span>]&#125;, [<span class="string">&#x27;extraHeaders&#x27;</span>, <span class="string">&#x27;responseHeaders&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>上面示例中提到，使用<code>webRequest</code>API是无法拿到<code>responseBody</code>的，想要拿到的话只能采取一些变通方法，例如：</p><ol><li>重写<code>XmlHttpRequest</code>和<code>fetch</code>，增加自定义拦截事件，缺点是实现方式可能有点脏，重写不好的话可能影响正常页面；</li><li><code>devtools</code>的<code>chrome.devtools.network.onRequestFinished</code>API可以拿到返回的body，缺点是必须打开开发者面板；</li><li>使用<code>chrome.debugger.sendCommand</code>发送<code>Network.getResponseBody</code>命令来获取body内容，缺点也很明显，会有一个恼人的提示：</li></ol><p>上述几种方法的实现方式这个链接基本上都有，可以参考下：<a href="https://stackoverflow.com/questions/18534771/chrome-extension-how-to-get-http-response-body">https://stackoverflow.com/questions/18534771/chrome-extension-how-to-get-http-response-body</a></p><h2 id="6-7-国际化"><a href="#6-7-国际化" class="headerlink" title="6.7. 国际化"></a>6.7. 国际化</h2><p>插件根目录新建一个名为<code>_locales</code>的文件夹，再在下面新建一些语言的文件夹，如<code>en</code>、<code>zh_CN</code>、<code>zh_TW</code>，然后再在每个文件夹放入一个<code>messages.json</code>，同时必须在清单文件中设置<code>default_locale</code>。</p><p><code>_locales\en\messages.json</code>内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;pluginDesc&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;A simple chrome extension demo&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;helloWorld&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World!&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_locales\zh_CN\messages.json</code>内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;pluginDesc&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;一个简单的Chrome插件demo&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;helloWorld&quot;</span>: &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;你好啊，世界！&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>manifest.json</code>和<code>CSS</code>文件中通过<code>__MSG_messagename__</code>引入，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;description&quot;</span>: <span class="string">&quot;__MSG_pluginDesc__&quot;</span>,</span><br><span class="line"><span class="comment">// 默认语言</span></span><br><span class="line"><span class="string">&quot;default_locale&quot;</span>: <span class="string">&quot;zh_CN&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS中则直接<code>chrome.i18n.getMessage(&quot;helloWorld&quot;)</code>。</p><p><img src="http://image.liuxianan.com/201706/20170621_175733_172_5903.png" alt="img"></p><h1 id="七、常见API总结"><a href="#七、常见API总结" class="headerlink" title="七、常见API总结"></a>七、常见API总结</h1><p>比较常用用的一些API系列：</p><ul><li>chrome.tabs</li><li>chrome.webRequest</li><li>chrome.window</li><li>chrome.storage</li><li>chrome.contextMenus</li><li>chrome.devtools</li><li>chrome.extension</li></ul><h2 id="7-1-chrome-cookies"><a href="#7-1-chrome-cookies" class="headerlink" title="7.1. chrome.cookies"></a>7.1. chrome.cookies</h2><p>获取某个网站的所有cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://www.baidu.com&#x27;</span>;</span><br><span class="line">chrome.<span class="property">cookies</span>.<span class="title function_">getAll</span>(&#123;url&#125;, <span class="function"><span class="params">cookies</span> =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cookies);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>清除某个网站的某个cookie：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://www.baidu.com&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cookieName = <span class="string">&#x27;userName&#x27;</span>;</span><br><span class="line">chrome.<span class="property">cookies</span>.<span class="title function_">remove</span>(&#123;url, <span class="attr">name</span>: cookieName&#125;, <span class="function"><span class="params">details</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="7-2-chrome-runtime"><a href="#7-2-chrome-runtime" class="headerlink" title="7.2. chrome.runtime"></a>7.2. chrome.runtime</h2><ul><li><code>chrome.runtime.id</code>：获取插件id</li><li><code>chrome.runtime.getURL(&#39;xxx.html&#39;)</code>：获取<code>xxx.html</code>在插件中的地址</li></ul><h1 id="八、经验总结"><a href="#八、经验总结" class="headerlink" title="八、经验总结"></a>八、经验总结</h1><h2 id="8-1-查看已安装插件路径"><a href="#8-1-查看已安装插件路径" class="headerlink" title="8.1. 查看已安装插件路径"></a>8.1. 查看已安装插件路径</h2><p>查看本地已安装的插件源码路径：<code>C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions</code>，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了：</p><p><img src="http://image.liuxianan.com/201706/20170601_100200_647_6507.png" alt="img"></p><p>如何查看某个插件的ID？进入 chrome:&#x2F;&#x2F;extensions ，然后勾线开发者模式即可看到了。</p><p><img src="http://image.liuxianan.com/201706/20170601_100408_338_3095.png" alt="img"></p><blockquote><p>Mac系统插件本地缓存位于：<code>/Users/用户名/Library/Application Support/Google/Chrome/Default/Extensions</code> 文件夹</p></blockquote><h2 id="8-2-特别注意background的报错"><a href="#8-2-特别注意background的报错" class="headerlink" title="8.2. 特别注意background的报错"></a>8.2. 特别注意background的报错</h2><p>很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。</p><h2 id="8-3-如何让popup页面不关闭"><a href="#8-3-如何让popup页面不关闭" class="headerlink" title="8.3. 如何让popup页面不关闭"></a>8.3. 如何让popup页面不关闭</h2><p>在对popup页面审查元素的时候popup会被强制打开无法关闭，只有控制台关闭了才可以关闭popup，原因很简单：如果popup关闭了控制台就没用了。这种方法在某些情况下很实用！</p><h2 id="8-4-不支持内联JavaScript的执行"><a href="#8-4-不支持内联JavaScript的执行" class="headerlink" title="8.4. 不支持内联JavaScript的执行"></a>8.4. 不支持内联JavaScript的执行</h2><p>也就是不支持将js直接写在html中，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;收藏&quot; onclick=&quot;test()&quot;/&gt;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to execute inline event handler because it violates the following Content Security Policy directive: &quot;script-src &#x27;self&#x27; blob: filesystem: chrome-extension-resource:&quot;. Either the &#x27;unsafe-inline&#x27; keyword, a hash (&#x27;sha256-...&#x27;), or a nonce (&#x27;nonce-...&#x27;) is required to enable inline execution.</span><br></pre></td></tr></table></figure><p>解决方法就是用JS绑定事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btn&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="title function_">alert</span>(<span class="string">&#x27;测试&#x27;</span>)&#125;);</span><br></pre></td></tr></table></figure><p>另外，对于A标签，这样写<code>href=&quot;javascript:;&quot;</code>然后用JS绑定事件虽然控制台会报错，但是不受影响，当然强迫症患者受不了的话只能写成<code>href=&quot;#&quot;</code>了。</p><p>如果这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;get_secret&quot;&gt;请求secret&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to execute JavaScript URL because it violates the following Content Security Policy directive: &quot;script-src &#x27;self&#x27; blob: filesystem: chrome-extension-resource:&quot;. Either the &#x27;unsafe-inline&#x27; keyword, a hash (&#x27;sha256-...&#x27;), or a nonce (&#x27;nonce-...&#x27;) is required to enable inline execution.</span><br></pre></td></tr></table></figure><h2 id="8-5-注入CSS的时候必须小心"><a href="#8-5-注入CSS的时候必须小心" class="headerlink" title="8.5. 注入CSS的时候必须小心"></a>8.5. 注入CSS的时候必须小心</h2><p>由于通过<code>content_scripts</code>注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。</p><p>之所以强调这个，是因为这个带来的问题非常隐蔽，不太容易找到，可能你正在写某个网页，昨天样式还是好好的，怎么今天就突然不行了？然后你辛辛苦苦找来找去，找了半天才发现竟然是因为插件里面的一个样式影响的！</p><p><img src="http://image.liuxianan.com/201706/20170620_175530_598_9800.png" alt="img"></p><h1 id="打包与发布"><a href="#打包与发布" class="headerlink" title="打包与发布"></a>打包与发布</h1><p>打包的话直接在插件管理页有一个打包按钮：</p><p><img src="http://image.liuxianan.com/201706/20170621_181130_362_3360.png" alt="img"></p><p>然后会生成一个<code>.crx</code>文件，要发布到Google应用商店的话需要先登录你的Google账号，然后花5个$注册为开发者，本人太穷，就懒得亲自验证了，有发布需求的自己去整吧。</p><p><img src="http://image.liuxianan.com/201707/20170710_221653_875_3099.png" alt="img"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="12-1-官方资料"><a href="#12-1-官方资料" class="headerlink" title="12.1. 官方资料"></a>12.1. 官方资料</h2><p>推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：</p><ul><li><a href="https://developer.chrome.com/extensions">Chrome插件官方文档主页</a></li><li><a href="https://developer.chrome.com/extensions/samples">Chrome插件官方示例</a></li><li><a href="https://developer.chrome.com/extensions/manifest">manifest清单文件</a></li><li><a href="https://developer.chrome.com/extensions/permissions">permissions权限</a></li><li><a href="https://developer.chrome.com/extensions/api_index">chrome.xxx.api文档</a></li><li><a href="https://developer.chrome.com/extensions/match_patterns">模糊匹配规则语法详解</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本笔记是各资料整合&lt;code&gt;摘录&lt;/code&gt;以及后续相关笔记补充、当时纯为了方便记录,没有记录各个知识点摘录出处;非本人洪撰写(大都是摘录,加以少许个人理解),仅供本人学习使用&lt;/p&gt;
&lt;p&gt;本人笔记地址分享:&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="软件" scheme="https://k705.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>对象的新增方法</title>
    <link href="https://k705.github.io/2024/04/08/Es6-10%E3%80%81Es6_%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95_day11-27/"/>
    <id>https://k705.github.io/2024/04/08/Es6-10%E3%80%81Es6_%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95_day11-27/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:31:39.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="十、对象的新增方法"><a href="#十、对象的新增方法" class="headerlink" title="十、对象的新增方法"></a>十、对象的新增方法</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p><p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（&#x3D;&#x3D;&#x3D;）的行为基本一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>如果只有一个参数，<code>Object.assign()</code>会直接返回该参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果该参数不是对象，则会先转成对象，然后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line"><span class="title class_">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line"><span class="title class_">Object</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign()</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p><code>Object.assign()</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign()</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p><p>属性名为 Symbol 值的属性，也会被<code>Object.assign()</code>拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="title class_">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">a</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">obj2.<span class="property">a</span>.<span class="property">b</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p><strong>（2）同名属性的替换</strong></p><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。</p><p>一些函数库提供<code>Object.assign()</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并。</p><p><strong>（3）数组的处理</strong></p><p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p><p><strong>（4）取值函数的处理</strong></p><p><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><code>Object.assign()</code>方法有很多用处。</p><p><strong>（1）为对象添加属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="variable language_">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p><p><strong>（2）为对象添加方法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="title function_">someMethod</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">anotherMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line"><span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">someMethod</span> = <span class="keyword">function</span> (<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">SomeClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">anotherMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中。</p><p><strong>（3）克隆对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p><p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">origin</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Object</span>.<span class="title function_">create</span>(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）合并多个对象</strong></p><p>将多个对象合并到某个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> =</span><br><span class="line">  (<span class="params">target, ...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, ...sources);</span><br></pre></td></tr></table></figure><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">merge</span> =</span><br><span class="line">  (<span class="params">...sources</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><p><strong>（5）为属性指定默认值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line">  <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processContent</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  options = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable constant_">DEFAULTS</span>, options);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign()</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p><p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULTS</span> = &#123;</span><br><span class="line">  <span class="attr">url</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">7070</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processContent</span>(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p>该方法的实现非常容易。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)) &#123;</span><br><span class="line">    result[key] = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，<code>Object.getOwnPropertyDescriptors()</code>方法配合<code>Object.defineProperties()</code>方法，就可以实现正确拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(target2, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source));</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target2, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: set foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shallowMerge</span> = (<span class="params">target, source</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(</span><br><span class="line">  target,</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(source)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = (<span class="params">obj</span>) =&gt; <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj),</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码会克隆对象<code>obj</code>。</p><p>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: prot,</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prot);</span><br><span class="line">obj.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">create</span>(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>有了<code>Object.getOwnPropertyDescriptors()</code>，我们就有了另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">  prot,</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">mix</span> = (<span class="params">object</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.<span class="title function_">reduce</span>(</span><br><span class="line">    <span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">      c, <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> d = <span class="title function_">mix</span>(c).<span class="title function_">with</span>(a, b);</span><br><span class="line"></span><br><span class="line">d.<span class="property">c</span> <span class="comment">// &quot;c&quot;</span></span><br><span class="line">d.<span class="property">b</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line">d.<span class="property">a</span> <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p><p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors()</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors()</code>方法。</p><h2 id="proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的原型对象（prototype）。目前，所有浏览器（包括 IE11）都部署了这个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5 的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(someOtherObj);</span><br><span class="line">obj.<span class="property">method</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p><p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;__proto__&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _thisObj = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">proto</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">undefined</span> || <span class="variable language_">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isObject</span>(proto)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>该方法等同于下面的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setPrototypeOf</span>(<span class="params">obj, proto</span>) &#123;</span><br><span class="line">  obj.<span class="property">__proto__</span> = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.<span class="property">y</span> = <span class="number">20</span>;</span><br><span class="line">proto.<span class="property">z</span> = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 10</span></span><br><span class="line">obj.<span class="property">y</span> <span class="comment">// 20</span></span><br><span class="line">obj.<span class="property">z</span> <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p><p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br></pre></td></tr></table></figure><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Rectangle</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(rec, <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rec) === <span class="title class_">Rectangle</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，会被自动转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) === <span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">true</span>) === <span class="title class_">Boolean</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure><h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="title class_">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> <span class="title function_">values</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj)</span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p><p><code>Object.values</code>只返回对象自身的可遍历属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;&#125;, &#123;<span class="attr">p</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure><p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p><p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">entries</span>(&#123; [<span class="title class_">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p><p><code>Object.entries</code>的基本用途是遍历对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;one&quot;: 1</span></span><br><span class="line"><span class="comment">// &quot;two&quot;: 2</span></span><br></pre></td></tr></table></figure><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>自己实现<code>Object.entries</code>方法，非常简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数的版本</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Generator函数的版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(map)</span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure><p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(<span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Symbol</title>
    <link href="https://k705.github.io/2024/04/08/Es6-11%E3%80%81Es6_Symbol_day11-27%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-11%E3%80%81Es6_Symbol_day11-27%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:31:32.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="十一、Symbol"><a href="#十一、Symbol" class="headerlink" title="十一、Symbol"></a>十一、Symbol</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;your symbol is &quot;</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can&#x27;t convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是，Symbol 值可以显式转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;My symbol&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &#x27;Symbol(My symbol)&#x27;</span></span><br></pre></td></tr></table></figure><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="title class_">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>创建 Symbol 的时候，可以添加一个描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sym</code>的描述就是字符串<code>foo</code>。</p><p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>(sym) <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">sym.<span class="title function_">toString</span>() <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br></pre></td></tr></table></figure><p>上面的用法不是很方便。<a href="https://github.com/tc39/proposal-Symbol-description">ES2019</a> 提供了一个实例属性<code>description</code>，直接返回 Symbol 的描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">sym.<span class="property">description</span> <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="property">mySymbol</span> = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="keyword">function</span> (<span class="params">arg</span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s](arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">log.<span class="property">levels</span> = &#123;</span><br><span class="line">  <span class="attr">DEBUG</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;debug&#x27;</span>),</span><br><span class="line">  <span class="attr">INFO</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;info&#x27;</span>),</span><br><span class="line">  <span class="attr">WARN</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;warn&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">DEBUG</span>, <span class="string">&#x27;debug message&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(log.<span class="property">levels</span>.<span class="property">INFO</span>, <span class="string">&#x27;info message&#x27;</span>);</span><br></pre></td></tr></table></figure><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_RED</span>    = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">COLOR_GREEN</span>  = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getComplement</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">COLOR_RED</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">COLOR_GREEN</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">COLOR_GREEN</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">COLOR_RED</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Undefined color&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p><p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p><h2 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Triangle&#x27;</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      area = <span class="number">.5</span> * options.<span class="property">width</span> * options.<span class="property">height</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... more code ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getArea</span>(<span class="string">&#x27;Triangle&#x27;</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">triangle</span>: <span class="string">&#x27;Triangle&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape, options</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.<span class="property">triangle</span>:</span><br><span class="line">      area = <span class="number">.5</span> * options.<span class="property">width</span> * options.<span class="property">height</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getArea</span>(shapeType.<span class="property">triangle</span>, &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="attr">triangle</span>: <span class="title class_">Symbol</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">Symbol</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">obj[b] = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有 Symbol 属性名。</p><p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">obj[foo] = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj) <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj) <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到 Symbol 键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj)</span><br><span class="line"><span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure><p>由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="title class_">Symbol</span>(<span class="string">&#x27;size&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">add</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>[<span class="variable language_">this</span>[size]] = item;</span><br><span class="line">    <span class="variable language_">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sizeOf</span>(<span class="params">instance</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="title class_">Collection</span>.<span class="title function_">sizeOf</span>(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(x) <span class="comment">// [&#x27;0&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(x) <span class="comment">// [&#x27;0&#x27;]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p><h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="title class_">Symbol</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor()</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s1) <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p><p>注意，<code>Symbol.for()</code>为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="title function_">foo</span>();</span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的 Symbol 值是登记在全局环境的。所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个 Symbol 值。</p><p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = <span class="title class_">String</span>(<span class="variable language_">window</span>.<span class="property">location</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line"></span><br><span class="line">iframe.<span class="property">contentWindow</span>.<span class="property">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>) === <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p><h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">global</span>.<span class="property">_foo</span>) &#123;</span><br><span class="line">  <span class="variable language_">global</span>.<span class="property">_foo</span> = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>.<span class="property">_foo</span>;</span><br></pre></td></tr></table></figure><p>然后，加载上面的<code>mod.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">foo</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>.<span class="property">_foo</span> = &#123; <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">foo</span>);</span><br></pre></td></tr></table></figure><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p><p>为了防止这种情况出现，我们就可以使用 Symbol。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>]) &#123;</span><br><span class="line">  <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>] = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="variable language_">global</span>[<span class="variable constant_">FOO_KEY</span>];</span><br></pre></td></tr></table></figure><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">global</span>[<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)] = &#123; <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FOO_KEY</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p><h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p><h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo <span class="keyword">instanceof</span> <span class="title class_">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">instanceof</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Even</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Even</span> = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Even</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Even</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">12345</span> <span class="keyword">instanceof</span> <span class="title class_">Even</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr1, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br><span class="line">arr1[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr2[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(arr2, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;c&#x27;,&#x27;d&#x27;], &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, obj, &#x27;e&#x27;]</span></span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">concat</span>(obj, <span class="string">&#x27;e&#x27;</span>) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(args);</span><br><span class="line">    <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(args);</span><br><span class="line">  &#125;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title function_">A1</span>();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title function_">A2</span>();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>(a1).<span class="title function_">concat</span>(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p><h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">MyArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"><span class="keyword">const</span> c = a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">MyArray</span> <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="title class_">MyArray</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，再来看前面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123; <span class="keyword">return</span> <span class="title class_">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">MyArray</span> <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p><p>再看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Promise</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">T1</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="title function_">r</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> <span class="variable constant_">T1</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">T2</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="title function_">r</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v) <span class="keyword">instanceof</span> <span class="variable constant_">T2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p><p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p><h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">match</span>(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="title class_">Symbol</span>.<span class="property">match</span>](<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMatcher</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">match</span>](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>.<span class="title function_">indexOf</span>(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;e&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">MyMatcher</span>()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">replace</span>(searchValue, replaceValue)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">searchValue[<span class="title class_">Symbol</span>.<span class="property">replace</span>](<span class="variable language_">this</span>, replaceValue)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line">x[<span class="title class_">Symbol</span>.<span class="property">replace</span>] = <span class="function">(<span class="params">...s</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Hello&#x27;</span>.<span class="title function_">replace</span>(x, <span class="string">&#x27;World&#x27;</span>) <span class="comment">// [&quot;Hello&quot;, &quot;World&quot;]</span></span><br></pre></td></tr></table></figure><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">search</span>(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[<span class="title class_">Symbol</span>.<span class="property">search</span>](<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySearch</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">search</span>](string) &#123;</span><br><span class="line">    <span class="keyword">return</span> string.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">MySearch</span>(<span class="string">&#x27;foo&#x27;</span>)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">split</span>(separator, limit)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">separator[<span class="title class_">Symbol</span>.<span class="property">split</span>](<span class="variable language_">this</span>, limit)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySplitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">split</span>](string) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = string.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      string.<span class="title function_">substr</span>(<span class="number">0</span>, index),</span><br><span class="line">      string.<span class="title function_">substr</span>(index + <span class="variable language_">this</span>.<span class="property">value</span>.<span class="property">length</span>)</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">MySplitter</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">MySplitter</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">MySplitter</span>(<span class="string">&#x27;baz&#x27;</span>))</span><br><span class="line"><span class="comment">// &#x27;foobar&#x27;</span></span><br></pre></td></tr></table></figure><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p><h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="variable language_">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="variable language_">this</span>[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li>Number：该场合需要转成数值</li><li>String：该场合需要转成字符串</li><li>Default：该场合可以转成数值，也可以转成字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// &#x27;3default&#x27;</span></span><br><span class="line">obj == <span class="string">&#x27;default&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">String</span>(obj) <span class="comment">// &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]: <span class="string">&#x27;Foo&#x27;</span>&#125;.<span class="title function_">toString</span>())</span><br><span class="line"><span class="comment">// &quot;[object Foo]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> <span class="title class_">Collection</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(x) <span class="comment">// &quot;[object xxx]&quot;</span></span><br></pre></td></tr></table></figure><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p><ul><li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li><li><code>Math[Symbol.toStringTag]</code>：’Math’</li><li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li><li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li><li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li><li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li><li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li><li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li><li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li><li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li><li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li><li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li><li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li><li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li><li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li><li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li><li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li></ul><h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   copyWithin: true,</span></span><br><span class="line"><span class="comment">//   entries: true,</span></span><br><span class="line"><span class="comment">//   fill: true,</span></span><br><span class="line"><span class="comment">//   find: true,</span></span><br><span class="line"><span class="comment">//   findIndex: true,</span></span><br><span class="line"><span class="comment">//   includes: true,</span></span><br><span class="line"><span class="comment">//   keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>])</span><br><span class="line"><span class="comment">// [&#x27;copyWithin&#x27;, &#x27;entries&#x27;, &#x27;fill&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;includes&#x27;, &#x27;keys&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有 unscopables 时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (<span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有 unscopables 时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  get [<span class="title class_">Symbol</span>.<span class="property">unscopables</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (<span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Set 和 Map 数据结构</title>
    <link href="https://k705.github.io/2024/04/08/Es6-12%E3%80%81Es6_Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_day11-27/"/>
    <id>https://k705.github.io/2024/04/08/Es6-12%E3%80%81Es6_Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_day11-27/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:31:26.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="十二、Set-和-Map-数据结构"><a href="#十二、Set-和-Map-数据结构" class="headerlink" title="十二、Set 和 Map 数据结构"></a>十二、Set 和 Map 数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">x</span> =&gt;</span> s.<span class="title function_">add</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">items.<span class="property">size</span> <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例三</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">document</span></span><br><span class="line"> .<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"> .<span class="title function_">forEach</span>(<span class="function"><span class="params">div</span> =&gt;</span> set.<span class="title function_">add</span>(div));</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 56</span></span><br></pre></td></tr></table></figure><p>上面代码中，例一和例二都是<code>Set</code>函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码也展示了一种去除数组重复成员的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="title class_">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="title class_">NaN</span>;</span><br><span class="line">set.<span class="title function_">add</span>(a);</span><br><span class="line">set.<span class="title function_">add</span>(b);</span><br><span class="line">set <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两次<code>NaN</code>，但是只会加入一个。这表明，在 Set 内部，两个<code>NaN</code>是相等的。</p><p>另外，两个对象总是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set.<span class="title function_">add</span>(&#123;&#125;);</span><br><span class="line">set.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>上面这些属性和方法的实例如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="number">2</span>);</span><br><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>下面是一个对比，看看在判断是否包括一个键上面，<code>Object</code>结构和<code>Set</code>结构的写法不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = &#123;</span><br><span class="line">  <span class="string">&#x27;width&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;height&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties[someName]) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set的写法</span></span><br><span class="line"><span class="keyword">const</span> properties = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line">properties.<span class="title function_">add</span>(<span class="string">&#x27;width&#x27;</span>);</span><br><span class="line">properties.<span class="title function_">add</span>(<span class="string">&#x27;height&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (properties.<span class="title function_">has</span>(someName)) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Array</span>.<span class="title function_">from</span>(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dedupe</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">dedupe</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><p><strong>（1）<code>keys()</code>，<code>values()</code>，<code>entries()</code></strong></p><p><code>keys</code>方法、<code>values</code>方法、<code>entries</code>方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>entries</code>方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的<code>values</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === <span class="title class_">Set</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">values</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略<code>values</code>方法，直接用<code>for...of</code>循环遍历 Set。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure><p><strong>（2）<code>forEach()</code></strong></p><p>Set 结构的实例与数组一样，也拥有<code>forEach</code>方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><p>上面代码说明，<code>forEach</code>方法的参数就是一个处理函数。该函数的参数与数组的<code>forEach</code>一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>另外，<code>forEach</code>方法还可以有第二个参数，表示绑定处理函数内部的<code>this</code>对象。</p><p><strong>（3）遍历的应用</strong></p><p>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环，所以也可以用于 Set 结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"><span class="keyword">let</span> arr = [...set];</span><br><span class="line"><span class="comment">// [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure><p>而且，数组的<code>map</code>和<code>filter</code>方法也可以间接用于 Set 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> !b.<span class="title function_">has</span>(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用<code>Array.from</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(set, <span class="function"><span class="params">val</span> =&gt;</span> val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">ws.<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.<span class="title function_">add</span>(<span class="title class_">Symbol</span>())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为<code>0</code>，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><p>这些特点同样适用于本章后面要介绍的 WeakMap 结构。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>WeakSet 是一个构造函数，可以使用<code>new</code>命令，创建 WeakSet 数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br></pre></td></tr></table></figure><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>a</code>是一个数组，它有两个成员，也都是数组。将<code>a</code>作为 WeakSet 构造函数的参数，<code>a</code>的成员会自动成为 WeakSet 的成员。</p><p>注意，是<code>a</code>数组的成员成为 WeakSet 的成员，而不是<code>a</code>数组本身。这意味着，数组的成员只能是对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>(b);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Invalid value used in weak set(…)</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>b</code>的成员不是对象，加入 WeakSet 就会报错。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">add</span>(<span class="variable language_">window</span>);</span><br><span class="line">ws.<span class="title function_">add</span>(obj);</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">has</span>(<span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.<span class="title function_">has</span>(foo);    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">delete</span>(<span class="variable language_">window</span>);</span><br><span class="line">ws.<span class="title function_">has</span>(<span class="variable language_">window</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">ws.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;WeakSet has &#x27;</span> + item)&#125;)</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码试图获取<code>size</code>和<code>forEach</code>属性，结果都不能成功。</p><p>WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><p>下面是 WeakSet 的另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    foos.<span class="title function_">add</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.<span class="title function_">has</span>(<span class="variable language_">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Foo.prototype.method 只能在Foo的实例上调用！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保证了<code>Foo</code>的实例方法，只能在<code>Foo</code>的实例上调用。这里使用 WeakSet 的好处是，<code>foos</code>对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑<code>foos</code>，也不会出现内存泄漏。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">&#x27;metadata&#x27;</span>;</span><br><span class="line">data[<span class="string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="comment">// &quot;metadata&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">&#x27;Hello World&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.<span class="title function_">get</span>(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(o) <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">delete</span>(o) <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码使用 Map 结构的<code>set</code>方法，将对象<code>o</code>当作<code>m</code>的一个键，然后又使用<code>get</code>方法读取这个键，接着使用<code>delete</code>方法删除了这个键。</p><p>上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.<span class="title function_">has</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">map.<span class="title function_">get</span>(<span class="string">&#x27;title&#x27;</span>) <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在新建 Map 实例时，就指定了两个键<code>name</code>和<code>title</code>。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;Author&#x27;</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">items.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.<span class="title function_">set</span>(key, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;bar&#x27;</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="title class_">Map</span>(set);</span><br><span class="line">m1.<span class="title function_">get</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;baz&#x27;</span>, <span class="number">3</span>]]);</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">new</span> <span class="title class_">Map</span>(m2);</span><br><span class="line">m3.<span class="title function_">get</span>(<span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们分别使用 Set 对象和 Map 对象，当作<code>Map</code>构造函数的参数，结果都生成了新的 Map 对象。</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(<span class="number">1</span>) <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码对键<code>1</code>连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">get</span>(<span class="string">&#x27;asfddfsasadf&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>([<span class="string">&#x27;a&#x27;</span>], <span class="number">555</span>);</span><br><span class="line">map.<span class="title function_">get</span>([<span class="string">&#x27;a&#x27;</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>set</code>和<code>get</code>方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此<code>get</code>方法无法读取该键，返回<code>undefined</code>。</p><p>同理，同样的值的两个实例，在 Map 结构中被视为两个键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">map</span><br><span class="line">.<span class="title function_">set</span>(k1, <span class="number">111</span>)</span><br><span class="line">.<span class="title function_">set</span>(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">get</span>(k1) <span class="comment">// 111</span></span><br><span class="line">map.<span class="title function_">get</span>(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>k1</code>和<code>k2</code>的值是一样的，但是它们在 Map 结构中被视为两个键。</p><p>由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如<code>0</code>和<code>-0</code>就是一个键，布尔值<code>true</code>和字符串<code>true</code>则是两个不同的键。另外，<code>undefined</code>和<code>null</code>也是两个不同的键。虽然<code>NaN</code>不严格相等于自身，但 Map 将其视为同一个键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(-<span class="number">0</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(+<span class="number">0</span>) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;true&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="number">3</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="literal">undefined</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">NaN</span>, <span class="number">123</span>);</span><br><span class="line">map.<span class="title function_">get</span>(<span class="title class_">NaN</span>) <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map 结构的实例有以下属性和操作方法。</p><p><strong>（1）size 属性</strong></p><p><code>size</code>属性返回 Map 结构的成员总数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>（2）Map.prototype.set(key, value)</strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>（3）Map.prototype.get(key)</strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);&#125;;</span><br><span class="line">m.<span class="title function_">set</span>(hello, <span class="string">&#x27;Hello ES6!&#x27;</span>) <span class="comment">// 键是函数</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(hello)  <span class="comment">// Hello ES6!</span></span><br></pre></td></tr></table></figure><p><strong>（4）Map.prototype.has(key)</strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>（5）Map.prototype.delete(key)</strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">m.<span class="title function_">delete</span>(<span class="literal">undefined</span>)</span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>（6）Map.prototype.clear()</strong></p><p><code>clear</code>方法清除所有成员，没有返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（<code>Symbol.iterator</code>属性），就是<code>entries</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] === map.<span class="property">entries</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Map 结构转为数组结构，比较快速的方法是使用扩展运算符（<code>...</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...map.<span class="title function_">keys</span>()]</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[...map.<span class="title function_">values</span>()]</span><br><span class="line"><span class="comment">// [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line"></span><br><span class="line">[...map.<span class="title function_">entries</span>()]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br><span class="line"></span><br><span class="line">[...map]</span><br><span class="line"><span class="comment">// [[1,&#x27;one&#x27;], [2, &#x27;two&#x27;], [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure><p>结合数组的<code>map</code>方法、<code>filter</code>方法，可以实现 Map 的遍历和过滤（Map 本身没有<code>map</code>和<code>filter</code>方法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map0 = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">filter</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;1 =&gt; &#x27;a&#x27;, 2 =&gt; &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="title class_">Map</span>(</span><br><span class="line">  [...map0].<span class="title function_">map</span>(<span class="function">(<span class="params">[k, v]</span>) =&gt;</span> [k * <span class="number">2</span>, <span class="string">&#x27;_&#x27;</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 产生 Map 结构 &#123;2 =&gt; &#x27;_a&#x27;, 4 =&gt; &#x27;_b&#x27;, 6 =&gt; &#x27;_c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>此外，Map 还有一个<code>forEach</code>方法，与数组的<code>forEach</code>方法类似，也可以实现遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>forEach</code>方法还可以接受第二个参数，用来绑定<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  <span class="attr">report</span>: <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">report</span>(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法的回调函数的<code>this</code>，就指向<code>reporter</code>。</p><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToObj</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  .<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToObj</span>(myMap)</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure><p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p><p><strong>（4）对象转为 Map</strong></p><p>对象转为 Map 可以通过<code>Object.entries()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure><p>此外，也可以自己实现一个转换函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objToStrMap</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    strMap.<span class="title function_">set</span>(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">objToStrMap</span>(&#123;<span class="attr">yes</span>: <span class="literal">true</span>, <span class="attr">no</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strMapToJson</span>(<span class="params">strMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">strMapToObj</span>(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).<span class="title function_">set</span>(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="title function_">strMapToJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapToArrayJson</span>(<span class="params">map</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="literal">true</span>, <span class="number">7</span>).<span class="title function_">set</span>(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line"><span class="title function_">mapToArrayJson</span>(myMap)</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToStrMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">objToStrMap</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToStrMap</span>(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonToMap</span>(<span class="params">jsonStr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonToMap</span>(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>)</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WeakMap 可以使用 set 方法添加成员</span></span><br><span class="line"><span class="keyword">const</span> wm1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> key = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line">wm1.<span class="title function_">set</span>(key, <span class="number">2</span>);</span><br><span class="line">wm1.<span class="title function_">get</span>(key) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WeakMap 也可以接受一个数组，</span></span><br><span class="line"><span class="comment">// 作为构造函数的参数</span></span><br><span class="line"><span class="keyword">const</span> k1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> k2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> wm2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[k1, <span class="string">&#x27;foo&#x27;</span>], [k2, <span class="string">&#x27;bar&#x27;</span>]]);</span><br><span class="line">wm2.<span class="title function_">get</span>(k2) <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><p>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="title class_">Symbol</span>(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果将数值<code>1</code>和<code>Symbol</code>值作为 WeakMap 的键名，都会报错。</p><p>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</p><p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">  [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。</p><p>一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候</span></span><br><span class="line"><span class="comment">// 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。</p><p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.<span class="title function_">get</span>(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象的引用计数是<code>1</code>，而不是<code>2</code>。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>总之，<code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p><p>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.<span class="title function_">set</span>(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.<span class="title function_">get</span>(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，键值<code>obj</code>是正常引用。所以，即使在 WeakMap 外部消除了<code>obj</code>的引用，WeakMap 内部的引用依然存在。</p><h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.<span class="property">size</span> <span class="comment">// undefined</span></span><br><span class="line">wm.<span class="property">forEach</span> <span class="comment">// undefined</span></span><br><span class="line">wm.<span class="property">clear</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap-的示例"><a href="#WeakMap-的示例" class="headerlink" title="WeakMap 的示例"></a>WeakMap 的示例</h3><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p><p>贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过 Node 的<code>process.memoryUsage</code>方法看出来。根据这个思路，网友<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925">vtxf</a>补充了下面的例子。</p><p>首先，打开 Node 命令行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --expose-gc</span><br></pre></td></tr></table></figure><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p><p>然后，执行下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></span><br><span class="line">&gt; <span class="variable language_">global</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">21106688</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">7376896</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">4153936</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">9059</span> &#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一个变量 key，指向一个 5*1024*1024 的数组</span></span><br><span class="line">&gt; <span class="keyword">let</span> key = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 WeakMap 实例的键名，也指向 key 数组</span></span><br><span class="line"><span class="comment">// 这时，key 数组实际被引用了两次，</span></span><br><span class="line"><span class="comment">// 变量 key 引用一次，WeakMap 的键名引用了第二次</span></span><br><span class="line"><span class="comment">// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1</span></span><br><span class="line">&gt; wm.<span class="title function_">set</span>(key, <span class="number">1</span>);</span><br><span class="line"><span class="title class_">WeakMap</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="variable language_">global</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时内存占用 heapUsed 增加到 45M 了</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">67538944</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">7376896</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">45782816</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">8945</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除变量 key 对数组的引用，</span></span><br><span class="line"><span class="comment">// 但没有手动清除 WeakMap 实例的键名对数组的引用</span></span><br><span class="line">&gt; key = <span class="literal">null</span>;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次执行垃圾回收</span></span><br><span class="line">&gt; <span class="variable language_">global</span>.<span class="title function_">gc</span>();</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存占用 heapUsed 变回 4M 左右，</span></span><br><span class="line"><span class="comment">// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收</span></span><br><span class="line">&gt; process.<span class="title function_">memoryUsage</span>();</span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">20639744</span>,</span><br><span class="line">  <span class="attr">heapTotal</span>: <span class="number">8425472</span>,</span><br><span class="line">  <span class="attr">heapUsed</span>: <span class="number">3979792</span>,</span><br><span class="line">  <span class="attr">external</span>: <span class="number">8956</span> &#125;</span><br></pre></td></tr></table></figure><p>上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。</p><p>Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。</p><h3 id="WeakMap-的用途"><a href="#WeakMap-的用途" class="headerlink" title="WeakMap 的用途"></a>WeakMap 的用途</h3><p>前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.<span class="title function_">set</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.<span class="title function_">get</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;logo&#x27;</span>));</span><br><span class="line">  logoData.<span class="property">timesClicked</span>++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>document.getElementById(&#39;logo&#39;)</code>是一个 DOM 节点，每当发生<code>click</code>事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><p>WeakMap 的另一个用处是部署私有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _counter = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _action = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Countdown</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">counter, action</span>) &#123;</span><br><span class="line">    _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">    _action.<span class="title function_">set</span>(<span class="variable language_">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dec</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.<span class="title function_">set</span>(<span class="variable language_">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.<span class="title function_">get</span>(<span class="variable language_">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Countdown</span>(<span class="number">2</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DONE&#x27;</span>));</span><br><span class="line"></span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line">c.<span class="title function_">dec</span>()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Countdown</code>类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p><h2 id="map-方法："><a href="#map-方法：" class="headerlink" title="map()方法："></a>map()方法：</h2><h3 id="map，映射，即原数组映射成一个新的数组；"><a href="#map，映射，即原数组映射成一个新的数组；" class="headerlink" title="map，映射，即原数组映射成一个新的数组；"></a>map，映射，即原数组映射成一个新的数组；</h3><p>map方法接受一个新参数，这个参数就是将原数组变成新数组的映射关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myfun_1</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> array = [];</span><br><span class="line">  arr.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    array.<span class="title function_">push</span>(item*item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myfun_2</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"> <span class="keyword">var</span> array = [];</span><br><span class="line">  arr.<span class="title function_">map</span>( <span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">  array.<span class="title function_">push</span>(item*item);</span><br><span class="line"> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">myfun_1</span>(arr3);    <span class="comment">//[1,4,9,16,25]</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="title function_">myfun_1</span>(arr1);  <span class="comment">//[25,4,1,9,16]</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>];</span><br><span class="line"><span class="title function_">myfun_2</span>(arr2);  <span class="comment">//[9,16,25,1,4,36]</span></span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure><p>在实际的应用中，我们可以通过map方法得到某一个对象数组中特定属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;小明&#x27;</span>,<span class="attr">age</span>:<span class="number">16</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;小红&#x27;</span>,<span class="attr">age</span>:<span class="number">17</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">&#x27;小白&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getter</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="title function_">map</span>( <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="property">age</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getter</span>(obj);</span><br><span class="line"><span class="comment">//16</span></span><br><span class="line"><span class="comment">//17</span></span><br><span class="line"><span class="comment">//18</span></span><br></pre></td></tr></table></figure><p>map方法的作用不难理解，即“映射”，也就是原数组被“映射”成对应新数组。下面这个例子是数值项求平方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item * item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">alert</span>(arrayOfSquares); <span class="comment">// 1, 4, 9, 16</span></span><br><span class="line">callback需要有<span class="keyword">return</span>值，如果没有，就像下面这样：</span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arrayOfSquares = data.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line">arrayOfSquares.<span class="title function_">forEach</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">数组所有项都被映射成了<span class="literal">undefined</span>：</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Reflect</title>
    <link href="https://k705.github.io/2024/04/08/Es6-14%E3%80%81Es6_Reflect_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-14%E3%80%81Es6_Reflect_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:40.148Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是 ES6 为了操作对象而提供的新 API。<code>Reflect</code>对象的设计目的有这样几个。</p><p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&#x27;assign&#x27;</span> <span class="keyword">in</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(<span class="title class_">Object</span>, <span class="string">&#x27;assign&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;property &#x27;</span> + name + <span class="string">&#x27; on &#x27;</span> + target + <span class="string">&#x27; set to &#x27;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loggedObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, target, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete&#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, name);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;has&#x27;</span> + name);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，每一个<code>Proxy</code>对象的拦截操作（<code>get</code>、<code>delete</code>、<code>has</code>），内部都调用对应的<code>Reflect</code>方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。</p><p>有了<code>Reflect</code>对象以后，很多操作会更易读。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">floor</span>, <span class="literal">undefined</span>, [<span class="number">1.75</span>]) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p><code>Reflect</code>对象一共有 13 个静态方法。</p><ul><li>Reflect.apply(target, thisArg, args)</li><li>Reflect.construct(target, args)</li><li>Reflect.get(target, name, receiver)</li><li>Reflect.set(target, name, value, receiver)</li><li>Reflect.defineProperty(target, name, desc)</li><li>Reflect.deleteProperty(target, name)</li><li>Reflect.has(target, name)</li><li>Reflect.ownKeys(target)</li><li>Reflect.isExtensible(target)</li><li>Reflect.preventExtensions(target)</li><li>Reflect.getOwnPropertyDescriptor(target, name)</li><li>Reflect.getPrototypeOf(target)</li><li>Reflect.setPrototypeOf(target, prototype)</li></ul><p>上面这些方法的作用，大部分与<code>Object</code>对象的同名方法的作用都是相同的，而且它与<code>Proxy</code>对象的方法是一一对应的。下面是对它们的解释。</p><h3 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h3><p><code>Reflect.get</code>方法查找并返回<code>target</code>对象的<code>name</code>属性，如果没有该属性，则返回<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;bar&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性部署了读取函数（getter），则读取函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">baz</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(myObject, <span class="string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.get</code>方法会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="number">1</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">get</span>(<span class="literal">false</span>, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h3><p><code>Reflect.set</code>方法设置<code>target</code>对象的<code>name</code>属性等于<code>value</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;foo&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果<code>name</code>属性设置了赋值函数，则赋值函数的<code>this</code>绑定<code>receiver</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">bar</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myReceiverObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(myObject, <span class="string">&#x27;bar&#x27;</span>, <span class="number">1</span>, myReceiverObject);</span><br><span class="line">myObject.<span class="property">foo</span> <span class="comment">// 4</span></span><br><span class="line">myReceiverObject.<span class="property">foo</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>注意，如果 <code>Proxy</code>对象和 <code>Reflect</code>对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了<code>receiver</code>，那么<code>Reflect.set</code>会触发<code>Proxy.defineProperty</code>拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy.set</code>拦截里面使用了<code>Reflect.set</code>，而且传入了<code>receiver</code>，导致触发<code>Proxy.defineProperty</code>拦截。这是因为<code>Proxy.set</code>的<code>receiver</code>参数总是指向当前的 <code>Proxy</code>实例（即上例的<code>obj</code>），而<code>Reflect.set</code>一旦传入<code>receiver</code>，就会将属性赋值到<code>receiver</code>上面（即<code>obj</code>），导致触发<code>defineProperty</code>拦截。如果<code>Reflect.set</code>没有传入<code>receiver</code>，那么就不会触发<code>defineProperty</code>拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, key, attribute</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;defineProperty&#x27;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(p, handler);</span><br><span class="line">obj.<span class="property">a</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">// set</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Reflect.set</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">set</span>(<span class="literal">false</span>, <span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h3><p><code>Reflect.has</code>方法对应<code>name in obj</code>里面的<code>in</code>运算符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="string">&#x27;foo&#x27;</span> <span class="keyword">in</span> myObject <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">has</span>(myObject, <span class="string">&#x27;foo&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.has()</code>方法的第一个参数不是对象，会报错。</p><h3 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h3><p><code>Reflect.deleteProperty</code>方法等同于<code>delete obj[name]</code>，用于删除对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">delete</span> myObj.<span class="property">foo</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(myObj, <span class="string">&#x27;foo&#x27;</span>);</span><br></pre></td></tr></table></figure><p>该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回<code>true</code>；删除失败，被删除的属性依然存在，返回<code>false</code>。</p><p>如果<code>Reflect.deleteProperty()</code>方法的第一个参数不是对象，会报错。</p><h3 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h3><p><code>Reflect.construct</code>方法等同于<code>new target(...args)</code>，这提供了一种不使用<code>new</code>，来调用构造函数的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Greeting</span>(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.construct 的写法</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Greeting</span>, [<span class="string">&#x27;张三&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.construct()</code>方法的第一个参数不是函数，会报错。</p><h3 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h3><p><code>Reflect.getPrototypeOf</code>方法用于读取对象的<code>__proto__</code>属性，对应<code>Object.getPrototypeOf(obj)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> <span class="title class_">FancyThing</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(myObj) === <span class="title class_">FancyThing</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><p><code>Reflect.getPrototypeOf</code>和<code>Object.getPrototypeOf</code>的一个区别是，如果参数不是对象，<code>Object.getPrototypeOf</code>会将这个参数转为对象，然后再运行，而<code>Reflect.getPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h3><p><code>Reflect.setPrototypeOf</code>方法用于设置目标对象的原型（prototype），对应<code>Object.setPrototypeOf(obj, newProto)</code>方法。它返回一个布尔值，表示是否设置成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(myObj, <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">myObj.<span class="property">length</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果无法设置目标对象的原型（比如，目标对象禁止扩展），<code>Reflect.setPrototypeOf</code>方法返回<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(&#123;&#125;, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;), <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如果第一个参数不是对象，<code>Object.setPrototypeOf</code>会返回第一个参数本身，而<code>Reflect.setPrototypeOf</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure><p>如果第一个参数是<code>undefined</code>或<code>null</code>，<code>Object.setPrototypeOf</code>和<code>Reflect.setPrototypeOf</code>都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Reflect.setPrototypeOf called on non-object</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-apply-func-thisArg-args"><a href="#Reflect-apply-func-thisArg-args" class="headerlink" title="Reflect.apply(func, thisArg, args)"></a>Reflect.apply(func, thisArg, args)</h3><p><code>Reflect.apply</code>方法等同于<code>Function.prototype.apply.call(func, thisArg, args)</code>，用于绑定<code>this</code>对象后执行给定函数。</p><p>一般来说，如果要绑定一个函数的<code>this</code>对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的<code>apply</code>方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用<code>Reflect</code>对象可以简化这种操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = [<span class="number">11</span>, <span class="number">33</span>, <span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">96</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="title class_">Math</span>.<span class="property">min</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(youngest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">const</span> youngest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">min</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> oldest = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>.<span class="property">max</span>, <span class="title class_">Math</span>, ages);</span><br><span class="line"><span class="keyword">const</span> type = <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>, youngest, []);</span><br></pre></td></tr></table></figure><h3 id="Reflect-defineProperty-target-propertyKey-attributes"><a href="#Reflect-defineProperty-target-propertyKey-attributes" class="headerlink" title="Reflect.defineProperty(target, propertyKey, attributes)"></a>Reflect.defineProperty(target, propertyKey, attributes)</h3><p><code>Reflect.defineProperty</code>方法基本等同于<code>Object.defineProperty</code>，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用<code>Reflect.defineProperty</code>代替它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*…*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(<span class="title class_">MyDate</span>, <span class="string">&#x27;now&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果<code>Reflect.defineProperty</code>的第一个参数不是对象，就会抛出错误，比如<code>Reflect.defineProperty(1, &#39;foo&#39;)</code>。</p><p>这个方法可以与<code>Proxy.defineProperty</code>配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, prop, descriptor</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(target, prop, descriptor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// &#123;value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line">p.<span class="property">foo</span> <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Proxy.defineProperty</code>对属性赋值设置了拦截，然后使用<code>Reflect.defineProperty</code>完成了赋值。</p><h3 id="Reflect-getOwnPropertyDescriptor-target-propertyKey"><a href="#Reflect-getOwnPropertyDescriptor-target-propertyKey" class="headerlink" title="Reflect.getOwnPropertyDescriptor(target, propertyKey)"></a>Reflect.getOwnPropertyDescriptor(target, propertyKey)</h3><p><code>Reflect.getOwnPropertyDescriptor</code>基本等同于<code>Object.getOwnPropertyDescriptor</code>，用于得到指定属性的描述对象，将来会替代掉后者。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(myObject, <span class="string">&#x27;hidden&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;hidden&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">var</span> theDescriptor = <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&#x27;hidden&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>Reflect.getOwnPropertyDescriptor</code>和<code>Object.getOwnPropertyDescriptor</code>的一个区别是，如果第一个参数不是对象，<code>Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>不报错，返回<code>undefined</code>，而<code>Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)</code>会抛出错误，表示参数非法。</p><h3 id="Reflect-isExtensible-target"><a href="#Reflect-isExtensible-target" class="headerlink" title="Reflect.isExtensible (target)"></a>Reflect.isExtensible (target)</h3><p><code>Reflect.isExtensible</code>方法对应<code>Object.isExtensible</code>，返回一个布尔值，表示当前对象是否可扩展。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.isExtensible</code>会返回<code>false</code>，因为非对象本来就是不可扩展的，而<code>Reflect.isExtensible</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-preventExtensions-target"><a href="#Reflect-preventExtensions-target" class="headerlink" title="Reflect.preventExtensions(target)"></a>Reflect.preventExtensions(target)</h3><p><code>Reflect.preventExtensions</code>对应<code>Object.preventExtensions</code>方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(myObject) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是对象，<code>Object.preventExtensions</code>在 ES5 环境报错，在 ES6 环境返回传入的参数，而<code>Reflect.preventExtensions</code>会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 环境</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(<span class="number">1</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><h3 id="Reflect-ownKeys-target"><a href="#Reflect-ownKeys-target" class="headerlink" title="Reflect.ownKeys (target)"></a>Reflect.ownKeys (target)</h3><p><code>Reflect.ownKeys</code>方法用于返回对象的所有属性，基本等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;baz&#x27;</span>)]: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;bing&#x27;</span>)]: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 旧写法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(myObject)</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(myObject)</span><br><span class="line"><span class="comment">//[Symbol(baz), Symbol(bing)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(myObject)</span><br><span class="line"><span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;, Symbol(baz), Symbol(bing)]</span></span><br></pre></td></tr></table></figure><p>如果<code>Reflect.ownKeys()</code>方法的第一个参数不是对象，会报错。</p><h2 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h2><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title function_">observable</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">observe</span>(print);</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br></pre></td></tr></table></figure><p>上面代码中，数据对象<code>person</code>是观察目标，函数<code>print</code>是观察者。一旦数据对象发生变化，<code>print</code>就会自动执行。</p><p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现<code>observable</code>和<code>observe</code>这两个函数。思路是<code>observable</code>函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，先定义了一个<code>Set</code>集合，所有观察者函数都放进这个集合。然后，<code>observable</code>函数返回原始对象的代理，拦截赋值操作。拦截函数<code>set</code>之中，会自动执行所有观察者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Proxy</title>
    <link href="https://k705.github.io/2024/04/08/Es6-13%E3%80%81Es6_Proxy_%E9%87%8D%E8%A6%81/"/>
    <id>https://k705.github.io/2024/04/08/Es6-13%E3%80%81Es6_Proxy_%E9%87%8D%E8%A6%81/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:51.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="Ⅰ-概述"><a href="#Ⅰ-概述" class="headerlink" title="Ⅰ-概述"></a>Ⅰ-概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">   <span class="comment">//拦截的对象,传入的对象属性,整个proxy对象</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, propKey, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.<span class="property">count</span></span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p><p>下面是另一个拦截读取属性行为的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">time</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// 35</span></span><br><span class="line">proxy.<span class="property">title</span> <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。<code>get</code>方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p><p>注意，要使得<code>Proxy</code>起作用，必须针对<code>Proxy</code>实例（上例是<code>proxy</code>对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p><p>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">a</span> = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">target.<span class="property">a</span> <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler</code>是一个空对象，没有任何拦截效果，访问<code>proxy</code>就等同于访问<code>target</code>。</p><p>一个技巧是将 Proxy 对象，设置到<code>object.proxy</code>属性，从而可以在<code>object</code>对象上调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="attr">proxy</span>: <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler) &#125;;</span><br></pre></td></tr></table></figure><p>Proxy 实例也可以作为其他对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">obj.<span class="property">time</span> <span class="comment">// 35</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p><p>同一个拦截器函数，可以设置拦截多个操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, name</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (name === <span class="string">&#x27;prototype&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">value</span>: args[<span class="number">1</span>]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">fproxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></span><br><span class="line">fproxy.<span class="property"><span class="keyword">prototype</span></span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">fproxy.<span class="property">foo</span> === <span class="string">&quot;Hello, foo&quot;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p><ul><li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>。</li><li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</li><li>**has(target, propKey)**：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li><li>**deleteProperty(target, propKey)**：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li>**ownKeys(target)**：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li><li>**getOwnPropertyDescriptor(target, propKey)**：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li><li>**defineProperty(target, propKey, propDesc)**：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li>**preventExtensions(target)**：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li><li>**getPrototypeOf(target)**：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li><li>**isExtensible(target)**：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li><li>**setPrototypeOf(target, proto)**：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li><li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li></ul><h2 id="Ⅱ-Proxy-实例的方法"><a href="#Ⅱ-Proxy-实例的方法" class="headerlink" title="Ⅱ-Proxy 实例的方法"></a>Ⅱ-Proxy 实例的方法</h2><p>下面是上面这些拦截方法的详细介绍。</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p><p><code>get</code>方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&quot;Prop name \&quot;&quot;</span> + propKey + <span class="string">&quot;\&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">proxy.<span class="property">age</span> <span class="comment">// 抛出一个错误</span></span><br></pre></td></tr></table></figure><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回<code>undefined</code>。</p><p><code>get</code>方法可以继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propertyKey, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;GET &#x27;</span> + propertyKey);</span><br><span class="line">    <span class="keyword">return</span> target[propertyKey];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">obj.<span class="property">foo</span> <span class="comment">// &quot;GET foo&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，拦截操作定义在<code>Prototype</code>对象上面，所以如果读取<code>obj</code>对象继承的属性时，拦截会生效。</p><p>下面的例子使用<code>get</code>拦截，实现数组读取负数的索引。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">...elements</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="title class_">Number</span>(propKey);</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        propKey = <span class="title class_">String</span>(target.<span class="property">length</span> + index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, propKey, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> target = [];</span><br><span class="line">  target.<span class="title function_">push</span>(...elements);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title function_">createArray</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">arr[-<span class="number">1</span>] <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，数组的位置参数是<code>-1</code>，就会输出数组的倒数第一个成员。</p><p>利用 Proxy，可以将读取属性的操作（<code>get</code>），转变为执行某个函数，从而实现属性的链式操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pipe = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> funcStack = [];</span><br><span class="line">  <span class="keyword">var</span> oproxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125; , &#123;</span><br><span class="line">    get : <span class="keyword">function</span> (<span class="params">pipeObject, fnName</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fnName === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> funcStack.<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">val, fn</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">fn</span>(val);</span><br><span class="line">        &#125;,value);</span><br><span class="line">      &#125;</span><br><span class="line">      funcStack.<span class="title function_">push</span>(<span class="variable language_">window</span>[fnName]);</span><br><span class="line">      <span class="keyword">return</span> oproxy;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oproxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">double</span> = n =&gt; n * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">pow</span>    = n =&gt; n * n;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">reverseInt</span> = n =&gt; n.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) | <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">pipe</span>(<span class="number">3</span>).<span class="property">double</span>.<span class="property">pow</span>.<span class="property">reverseInt</span>.<span class="property">get</span>; <span class="comment">// 63</span></span><br></pre></td></tr></table></figure><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。</p><p>下面的例子则是利用<code>get</code>拦截，实现一个生成各种 DOM 节点的通用函数<code>dom</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dom = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">attrs = &#123;&#125;, ...children</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(property);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(attrs)) &#123;</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(prop, attrs[prop]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> children) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">          child = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        el.<span class="title function_">appendChild</span>(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> el;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> el = dom.<span class="title function_">div</span>(&#123;&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, my name is &#x27;</span>,</span><br><span class="line">  dom.<span class="title function_">a</span>(&#123;<span class="attr">href</span>: <span class="string">&#x27;//example.com&#x27;</span>&#125;, <span class="string">&#x27;Mark&#x27;</span>),</span><br><span class="line">  <span class="string">&#x27;. I like:&#x27;</span>,</span><br><span class="line">  dom.<span class="title function_">ul</span>(&#123;&#125;,</span><br><span class="line">    dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;The web&#x27;</span>),</span><br><span class="line">    dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;Food&#x27;</span>),</span><br><span class="line">    dom.<span class="title function_">li</span>(&#123;&#125;, <span class="string">&#x27;…actually that\&#x27;s it&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(el);</span><br></pre></td></tr></table></figure><p>下面是一个<code>get</code>方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">proxy.<span class="property">getReceiver</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy</code>对象的<code>getReceiver</code>属性是由<code>proxy</code>对象提供的，所以<code>receiver</code>指向<code>proxy</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="title class_">Object</span>.<span class="title function_">create</span>(proxy);</span><br><span class="line">d.<span class="property">a</span> === d <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>d</code>对象本身没有<code>a</code>属性，所以读取<code>d.a</code>的时候，会去<code>d</code>的原型<code>proxy</code>对象找。这时，<code>receiver</code>就指向<code>d</code>，代表原始的读操作所在的那个对象。</p><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// TypeError: Invariant check failed</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p><p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于满足条件的 age 属性以及其他属性，直接保存</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">person.<span class="property">age</span> <span class="comment">// 100</span></span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于设置了存值函数<code>set</code>，任何不符合要求的<code>age</code>属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用<code>set</code>方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。</p><p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合<code>get</code>和<code>set</code>方法，就可以做到防止这些内部属性被外部读写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, key, value) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to get private &quot;_prop&quot; property</span></span><br><span class="line">proxy.<span class="property">_prop</span> = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to set private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p><p>下面是<code>set</code>方法第四个参数的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> === proxy <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>set</code>方法的第四个参数<code>receiver</code>，指的是原始的操作行为所在的那个对象，一般情况下是<code>proxy</code>实例本身，请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(myObj, proxy);</span><br><span class="line"></span><br><span class="line">myObj.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">myObj.<span class="property">foo</span> === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，设置<code>myObj.foo</code>属性的值时，<code>myObj</code>并没有<code>foo</code>属性，因此引擎会到<code>myObj</code>的原型链去找<code>foo</code>属性。<code>myObj</code>的原型对象<code>proxy</code>是一个 Proxy 实例，设置它的<code>foo</code>属性会触发<code>set</code>方法。这时，第四个参数<code>receiver</code>就指向原始赋值行为所在的对象<code>myObj</code>。</p><p>注意，如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj.foo</code>属性不可写，Proxy 对这个属性的<code>set</code>代理将不会生效。</p><p>注意，严格模式下，<code>set</code>代理如果没有返回<code>true</code>，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    obj[prop] = receiver;</span><br><span class="line">    <span class="comment">// 无论有没有下面这一行，都会报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="comment">// TypeError: &#x27;set&#x27; on proxy: trap returned falsish for property &#x27;foo&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，严格模式下，<code>set</code>代理返回<code>false</code>或者<code>undefined</code>，都会报错。</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p><p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;I am the target&#x27;</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;I am the proxy&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title function_">p</span>()</span><br><span class="line"><span class="comment">// &quot;I am the proxy&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>p</code>是 Proxy 的实例，当它作为函数调用时（<code>p()</code>），就会被<code>apply</code>方法拦截，返回一个字符串。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twice = &#123;</span><br><span class="line">  apply (target, ctx, args) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>) * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, twice);</span><br><span class="line"><span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 6</span></span><br><span class="line">proxy.<span class="title function_">call</span>(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment">// 22</span></span><br><span class="line">proxy.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">7</span>, <span class="number">8</span>]) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>上面代码中，每当执行<code>proxy</code>函数（直接调用或<code>call</code>和<code>apply</code>调用），就会被<code>apply</code>方法拦截。</p><p>另外，直接调用<code>Reflect.apply</code>方法，也会被拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(proxy, <span class="literal">null</span>, [<span class="number">9</span>, <span class="number">10</span>]) <span class="comment">// 38</span></span><br></pre></td></tr></table></figure><h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has()</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p><p><code>has()</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p><p>下面的例子使用<code>has()</code>方法隐藏某些属性，不被<code>in</code>运算符发现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">&#x27;_prop&#x27;</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果原对象的属性名的第一个字符是下划线，<code>proxy.has()</code>就会返回<code>false</code>，从而不会被<code>in</code>运算符发现。</p><p>如果原对象不可配置或者禁止扩展，这时<code>has()</code>拦截会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">has</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> p <span class="comment">// TypeError is thrown</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象禁止扩展，结果使用<code>has</code>拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则<code>has()</code>方法就不得“隐藏”（即返回<code>false</code>）目标对象的该属性。</p><p>值得注意的是，<code>has()</code>方法拦截的是<code>HasProperty</code>操作，而不是<code>HasOwnProperty</code>操作，即<code>has()</code>方法不判断一个属性是对象自身的属性，还是继承的属性。</p><p>另外，虽然<code>for...in</code>循环也用到了<code>in</code>运算符，但是<code>has()</code>拦截对<code>for...in</code>循环不生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stu1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">score</span>: <span class="number">59</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> stu2 = &#123;<span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>, <span class="attr">score</span>: <span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;score&#x27;</span> &amp;&amp; target[prop] &lt; <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;target.name&#125;</span> 不及格`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oproxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu1, handler);</span><br><span class="line"><span class="keyword">let</span> oproxy2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(stu2, handler);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy1</span><br><span class="line"><span class="comment">// 张三 不及格</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;score&#x27;</span> <span class="keyword">in</span> oproxy2</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> oproxy1) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy1[a]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// 59</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> b <span class="keyword">in</span> oproxy2) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(oproxy2[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 99</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>has()</code>拦截只对<code>in</code>运算符生效，对<code>for...in</code>循环不生效，导致不符合要求的属性没有被<code>for...in</code>循环所排除。</p><h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><code>construct()</code>方法用于拦截<code>new</code>命令，下面是拦截对象的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  construct (target, args, newTarget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>construct()</code>方法可以接受三个参数。</p><ul><li><code>target</code>：目标对象。</li><li><code>args</code>：构造函数的参数数组。</li><li><code>newTarget</code>：创造实例对象时，<code>new</code>命令作用的构造函数（下面例子的<code>p</code>）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called: &#x27;</span> + args.<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="title function_">p</span>(<span class="number">1</span>)).<span class="property">value</span></span><br><span class="line"><span class="comment">// &quot;called: 1&quot;</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p><code>construct()</code>方法返回的必须是一个对象，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;construct&#x27; on proxy: trap returned non-object (&#x27;1&#x27;)</span></span><br></pre></td></tr></table></figure><p>另外，由于<code>construct()</code>拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: p is not a constructor</span></span><br></pre></td></tr></table></figure><p>上面例子中，拦截的目标对象不是一个函数，而是一个对象（<code>new Proxy()</code>的第一个参数），导致报错。</p><p>注意，<code>construct()</code>方法中的<code>this</code>指向的是<code>handler</code>，而不是实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">target, args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, handler);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">p</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key, <span class="string">&#x27;delete&#x27;</span>);</span><br><span class="line">    <span class="keyword">delete</span> target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (key, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private &quot;<span class="subst">$&#123;key&#125;</span>&quot; property`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: Invalid attempt to delete private &quot;_prop&quot; property</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>deleteProperty</code>方法拦截了<code>delete</code>操作符，删除第一个字符为下划线的属性会报错。</p><p>注意，目标对象自身的不可配置（configurable）的属性，不能被<code>deleteProperty</code>方法删除，否则报错。</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty()</code>方法拦截了<code>Object.defineProperty()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  defineProperty (target, key, descriptor) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span> <span class="comment">// 不会生效</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>defineProperty()</code>方法内部没有任何操作，只返回<code>false</code>，导致添加新属性总是无效。注意，这里的<code>false</code>只是用来提示操作失败，本身并不能阻止添加新属性。</p><p>注意，如果目标对象不可扩展（non-extensible），则<code>defineProperty()</code>不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则<code>defineProperty()</code>方法不得改变这两个设置。</p><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><code>getOwnPropertyDescriptor()</code>方法拦截<code>Object.getOwnPropertyDescriptor()</code>，返回一个属性描述对象或者<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  getOwnPropertyDescriptor (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(target, key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="string">&#x27;tar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;wat&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;_foo&#x27;</span>)</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&#x27;baz&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: &#x27;tar&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>handler.getOwnPropertyDescriptor()</code>方法对于第一个字符为下划线的属性名会返回<code>undefined</code>。</p><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><code>getPrototypeOf()</code>方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(p) === proto <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getPrototypeOf()</code>方法拦截<code>Object.getPrototypeOf()</code>，返回<code>proto</code>对象。</p><p>注意，<code>getPrototypeOf()</code>方法的返回值必须是对象或者<code>null</code>，否则报错。另外，如果目标对象不可扩展（non-extensible）， <code>getPrototypeOf()</code>方法必须返回目标对象的原型对象。</p><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><code>isExtensible()</code>方法拦截<code>Object.isExtensible()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;called&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码设置了<code>isExtensible()</code>方法，在调用<code>Object.isExtensible</code>时会输出<code>called</code>。</p><p>注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p><p>这个方法有一个强限制，它的返回值必须与目标对象的<code>isExtensible</code>属性保持一致，否则就会抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy) === <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(target)</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;isExtensible&#x27; on proxy: trap result does not reflect extensibility of proxy target (which is &#x27;true&#x27;)</span></span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><code>ownKeys()</code>方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</p><ul><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for...in</code>循环</li></ul><p>下面是拦截<code>Object.keys()</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码拦截了对于<code>target</code>对象的<code>Object.keys()</code>操作，只返回<code>a</code>、<code>b</code>、<code>c</code>三个属性之中的<code>a</code>属性。</p><p>下面的例子是拦截第一个字符为下划线的属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">_bar</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">_prop</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">prop</span>: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  ownKeys (target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> key[<span class="number">0</span>] !== <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(target[key]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p>注意，使用<code>Object.keys()</code>方法时，有三类属性会被<code>ownKeys()</code>方法自动过滤，不会返回。</p><ul><li>目标对象上不存在的属性</li><li>属性名为 Symbol 值</li><li>不可遍历（<code>enumerable</code>）的属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;secret&#x27;</span>)]: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;static&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;secret&#x27;</span>), <span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownKeys()</code>方法之中，显式返回不存在的属性（<code>d</code>）、Symbol 值（<code>Symbol.for(&#39;secret&#39;)</code>）、不可遍历的属性（<code>key</code>），结果都被自动过滤掉。</p><p><code>ownKeys()</code>方法还可以拦截<code>Object.getOwnPropertyNames()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br></pre></td></tr></table></figure><p><code>for...in</code>循环也受到<code>ownKeys()</code>方法的拦截。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> proxy) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 没有任何输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownkeys()</code>指定只返回<code>a</code>和<code>b</code>属性，由于<code>obj</code>没有这两个属性，因此<code>for...in</code>循环不会有任何输出。</p><p><code>ownKeys()</code>方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">123</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: 123 is not a valid property name</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ownKeys()</code>方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。</p><p>如果目标对象自身包含不可配置的属性，则该属性必须被<code>ownKeys()</code>方法返回，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">10</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap result did not include &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象的<code>a</code>属性是不可配置的，这时<code>ownKeys()</code>方法返回的数组之中，必须包含<code>a</code>，否则会报错。</p><p>另外，如果目标对象是不可扩展的（non-extensible），这时<code>ownKeys()</code>方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(p)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;ownKeys&#x27; on proxy: trap returned extra keys but proxy target is non-extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象是不可扩展的，这时<code>ownKeys()</code>方法返回的数组之中，包含了<code>obj</code>对象的多余属性<code>b</code>，所以导致了报错。</p><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><code>preventExtensions()</code>方法拦截<code>Object.preventExtensions()</code>。该方法必须返回一个布尔值，否则会被自动转为布尔值。</p><p>这个方法有一个限制，只有目标对象不可扩展时（即<code>Object.isExtensible(proxy)</code>为<code>false</code>），<code>proxy.preventExtensions</code>才能返回<code>true</code>，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line"><span class="comment">// Uncaught TypeError: &#x27;preventExtensions&#x27; on proxy: trap returned truish but the proxy target is extensible</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>proxy.preventExtensions()</code>方法返回<code>true</code>，但这时<code>Object.isExtensible(proxy)</code>会返回<code>true</code>，因此报错。</p><p>为了防止出现这个问题，通常要在<code>proxy.preventExtensions()</code>方法里面，调用一次<code>Object.preventExtensions()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called&#x27;</span>);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy)</span><br><span class="line"><span class="comment">// &quot;called&quot;</span></span><br><span class="line"><span class="comment">// Proxy &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><code>setPrototypeOf()</code>方法主要用来拦截<code>Object.setPrototypeOf()</code>方法。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  setPrototypeOf (target, proto) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Changing the prototype is forbidden&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(proxy, proto);</span><br><span class="line"><span class="comment">// Error: Changing the prototype is forbidden</span></span><br></pre></td></tr></table></figure><p>上面代码中，只要修改<code>target</code>的原型对象，就会报错。</p><p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），<code>setPrototypeOf()</code>方法不得改变目标对象的原型。</p><h2 id="Ⅲ-Proxy-revocable"><a href="#Ⅲ-Proxy-revocable" class="headerlink" title="Ⅲ-Proxy.revocable()"></a>Ⅲ-Proxy.revocable()</h2><p><code>Proxy.revocable()</code>方法返回一个可取消的 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">123</span>;</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line">proxy.<span class="property">foo</span> <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable()</code>方法返回一个对象，该对象的<code>proxy</code>属性是<code>Proxy</code>实例，<code>revoke</code>属性是一个函数，可以取消<code>Proxy</code>实例。上面代码中，当执行<code>revoke</code>函数之后，再访问<code>Proxy</code>实例，就会抛出一个错误。</p><p><code>Proxy.revocable()</code>的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="Ⅳ-this-问题"><a href="#Ⅳ-this-问题" class="headerlink" title="Ⅳ-this 问题"></a>Ⅳ-this 问题</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">m</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">target.<span class="title function_">m</span>() <span class="comment">// false</span></span><br><span class="line">proxy.<span class="title function_">m</span>()  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，一旦<code>proxy</code>代理<code>target</code>，<code>target.m()</code>内部的<code>this</code>就是指向<code>proxy</code>，而不是<code>target</code>。</p><p>下面是一个例子，由于<code>this</code>指向的变化，导致 Proxy 无法代理目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    _name.<span class="title function_">set</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.<span class="title function_">get</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jane&#x27;</span>);</span><br><span class="line">jane.<span class="property">name</span> <span class="comment">// &#x27;Jane&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，目标对象<code>jane</code>的<code>name</code>属性，实际保存在外部<code>WeakMap</code>对象<code>_name</code>上面，通过<code>this</code>键区分。由于通过<code>proxy.name</code>访问时，<code>this</code>指向<code>proxy</code>，导致无法取到值，所以返回<code>undefined</code>。</p><p>此外，有些原生对象的内部属性，只有通过正确的<code>this</code>才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>();</span><br><span class="line"><span class="comment">// TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>getDate()</code>方法只能在<code>Date</code>对象实例上面拿到，如果<code>this</code>不是<code>Date</code>对象实例就会报错。这时，<code>this</code>绑定原始对象，就可以解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2015-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;getDate&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.<span class="property">getDate</span>.<span class="title function_">bind</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="title function_">getDate</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>另外，Proxy 拦截函数内部的<code>this</code>，指向的是<code>handler</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + key;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">target, key, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === handler);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// Hello, foo</span></span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>get()</code>和<code>set()</code>拦截函数内部的<code>this</code>，指向的都是<code>handler</code>对象。</p><h2 id="Ⅴ-实例：Web-服务的客户端"><a href="#Ⅴ-实例：Web-服务的客户端" class="headerlink" title="Ⅴ-实例：Web 服务的客户端"></a>Ⅴ-实例：Web 服务的客户端</h2><p>Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = <span class="title function_">createWebService</span>(<span class="string">&#x27;http://example.com/data&#x27;</span>);</span><br><span class="line"></span><br><span class="line">service.<span class="title function_">employees</span>().<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> employees = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(json);</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWebService</span>(<span class="params">baseUrl</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, propKey, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">httpGet</span>(baseUrl + <span class="string">&#x27;/&#x27;</span> + propKey);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，Proxy 也可以用来实现数据库的 ORM 层。</p><h2 id="Ⅵ-Proxy实现双向绑定"><a href="#Ⅵ-Proxy实现双向绑定" class="headerlink" title="Ⅵ-Proxy实现双向绑定"></a>Ⅵ-Proxy实现双向绑定</h2><blockquote><p><code>Proxy</code>就像一个代理器,当有人对目标对象进行处理(set、has、get 等等操作)的时候它会首先经过它，这时我们可以使用代码进行处理，此时<code>Proxy</code>相当于一个中介或者叫代理人,它经常被用于代理模式中,可以做字段验证、缓存代理、访问控制等等。</p></blockquote><h3 id="1-Object-defineProperty"><a href="#1-Object-defineProperty" class="headerlink" title="1.Object.defineProperty"></a>1.<code>Object.defineProperty</code></h3><blockquote><p>众所周知，<code>vue</code>使用了<code>Object.defineProperty</code>来做数据劫持，它是利用劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&gt;<span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line"> <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get val&#x27;</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set val:&#x27;</span> + newVal)</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-与Object-defineProperty相比，Proxy的优势"><a href="#2-与Object-defineProperty相比，Proxy的优势" class="headerlink" title="2.与Object.defineProperty相比，Proxy的优势"></a>2.与<code>Object.defineProperty</code>相比，<code>Proxy</code>的优势</h3><blockquote><ol><li><p>数组作为特殊的对象，但Object.defineProperty无法监听数组变化。</p></li><li><p>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p></li><li><p>Proxy 有多达 13 种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。</p></li><li><p>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</p></li><li><p>Proxy作为新标准将受到浏览器厂商重点持续的性能优化</p></li></ol></blockquote><h3 id="3-手写双向绑定代码"><a href="#3-手写双向绑定代码" class="headerlink" title="3. 手写双向绑定代码"></a>3. 手写双向绑定代码</h3><blockquote><ol><li>简单实现双向绑定</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;input_el&quot;</span> <span class="attr">oninput</span>=<span class="string">&quot;inputHandle(this)&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show_el&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  proxy_bind = <span class="function">(<span class="params">traget</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(traget, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">get</span>(<span class="params">obj, name</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果传入的key并没有,则赋初始值</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (!obj[name]) obj[name] = <span class="string">&quot;&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//根据传入的key进行相应属性返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">//拦截的对象,拦截对象的值,传入要修改的值,(第四个参数通常不用,返回整个Proxy对象)</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">set</span>(<span class="params">obj, name, val</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入&quot;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        obj[name] = val</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//将输入狂内容即修改的proxy对象属性渲染到页面节点上</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj[name]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  inputHandle = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//将输入框的值赋值给proxy对象的value属性上，此处触发proxy的`set（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj_bind.<span class="property">value</span> = e.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>: <span class="string">&quot;2&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">b</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">value</span>: <span class="string">&quot;默认值&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">let</span> obj_bind = <span class="title function_">proxy_bind</span>(obj)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">//自闭合，如果前面没有加分号 会导致压缩式合并到前面去就会报错，以防万一加分号，此处触发proxy的`get（）`</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  ;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#show_el&quot;</span>).<span class="property">innerHTML</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#input_el&quot;</span>).<span class="property">value</span> = obj_bind.<span class="property">value</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;)()</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>模拟vue实现完整双向绑定实现</li></ol>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">--------------------  html  ----------------------------</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">-------------------  js ------------------------------</span></span><br><span class="line"><span class="language-xml">class Watcher &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(vm, key, callback) &#123;</span></span><br><span class="line"><span class="language-xml">    this.vm = vm</span></span><br><span class="line"><span class="language-xml">    this.callback = callback</span></span><br><span class="line"><span class="language-xml">    this.key = key // 被订阅的数据</span></span><br><span class="line"><span class="language-xml">    this.val = this.get() // 维护更新之前的数据</span></span><br><span class="line"><span class="language-xml">    vm.$data = this.createProxy(vm.$data)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  update(newVal) &#123;</span></span><br><span class="line"><span class="language-xml">    this.callback(newVal)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  get() &#123;</span></span><br><span class="line"><span class="language-xml">    const val = this.vm.$data[this.key]</span></span><br><span class="line"><span class="language-xml">    return val</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  createProxy(data) &#123;</span></span><br><span class="line"><span class="language-xml">    let _this = this</span></span><br><span class="line"><span class="language-xml">    let handler = &#123;</span></span><br><span class="line"><span class="language-xml">      get(target, property) &#123;</span></span><br><span class="line"><span class="language-xml">        return Reflect.get(target, property)</span></span><br><span class="line"><span class="language-xml">      &#125;,</span></span><br><span class="line"><span class="language-xml">      set(target, property, value) &#123;</span></span><br><span class="line"><span class="language-xml">        let res = null</span></span><br><span class="line"><span class="language-xml">        if (target[property] != value) &#123;</span></span><br><span class="line"><span class="language-xml">          const isOk = Reflect.set(target, property, value)</span></span><br><span class="line"><span class="language-xml">          if (_this.key === property) &#123;</span></span><br><span class="line"><span class="language-xml">            // 同一层级</span></span><br><span class="line"><span class="language-xml">            res = value</span></span><br><span class="line"><span class="language-xml">          &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">            res = _this.get()</span></span><br><span class="line"><span class="language-xml">            console.log(res)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">          _this.callback(res)</span></span><br><span class="line"><span class="language-xml">          return isOk</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    return toDeepProxy(data, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    function toDeepProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">      if (!isPureObject(object)) addSubProxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      return new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function addSubProxy(object, handler) &#123;</span></span><br><span class="line"><span class="language-xml">        for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">          if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">            if (!isPureObject(object[prop])) addSubProxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">            object[prop] = new Proxy(object[prop], handler)</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        object = new Proxy(object, handler)</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      function isPureObject(object) &#123;</span></span><br><span class="line"><span class="language-xml">        if (typeof object !== &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">          return false</span></span><br><span class="line"><span class="language-xml">        &#125; else &#123;</span></span><br><span class="line"><span class="language-xml">          for (let prop in object) &#123;</span></span><br><span class="line"><span class="language-xml">            if (typeof object[prop] == &#x27;object&#x27;) &#123;</span></span><br><span class="line"><span class="language-xml">              return false</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">        return true</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">class Vue &#123;</span></span><br><span class="line"><span class="language-xml">  constructor(data) &#123;</span></span><br><span class="line"><span class="language-xml">    // 将所有data最外层属性代理到实例上</span></span><br><span class="line"><span class="language-xml">    this.$data = data</span></span><br><span class="line"><span class="language-xml">    Object.keys(data).forEach(key =&gt; this.$proxy(key))</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $watch(key, cb) &#123;</span></span><br><span class="line"><span class="language-xml">    new Watcher(this, key, cb)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">  $proxy(key) &#123;</span></span><br><span class="line"><span class="language-xml">    Reflect.defineProperty(this, key, &#123;</span></span><br><span class="line"><span class="language-xml">      configurable: true,</span></span><br><span class="line"><span class="language-xml">      enumerable: true,</span></span><br><span class="line"><span class="language-xml">      get: () =&gt; this.$data[key],</span></span><br><span class="line"><span class="language-xml">      set: val =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">        this._data[key] = val</span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    &#125;)</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const p = document.getElementById(&#x27;p&#x27;)</span></span><br><span class="line"><span class="language-xml">const input = document.getElementById(&#x27;input&#x27;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">const data = new Vue(&#123; text: &#123; a: &#x27;&#x27; &#125; &#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">input.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span></span><br><span class="line"><span class="language-xml">  data.text.a = e.target.value</span></span><br><span class="line"><span class="language-xml">&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">data.$watch(&#x27;text&#x27;, content =&gt; p.innerHTML = content.a)</span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Iterator 和 for...of 循环</title>
    <link href="https://k705.github.io/2024/04/08/Es6-16%E3%80%81Es6_Iterator%20%E5%92%8C%20for...of%20%E5%BE%AA%E7%8E%AF_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-16%E3%80%81Es6_Iterator%20%E5%92%8C%20for...of%20%E5%BE%AA%E7%8E%AF_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:15.981Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><h2 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</p><p>Iterator 的遍历过程是这样的。</p><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.<span class="property">length</span> ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Iterator 只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">idMaker</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 0</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 1</span></span><br><span class="line">it.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">idMaker</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>: index++, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和<code>next</code>方法返回值的规格可以描述如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">Iterable</span> &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() : <span class="title class_">Iterator</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="title function_">next</span>(value?: any) : <span class="title class_">IterationResult</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="title class_">IterationResult</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: any,</span><br><span class="line">  <span class="attr">done</span>: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p><p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备 Iterator 接口的数据结构如下。</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params">start, stop</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是一个类部署 Iterator 接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现指针结构的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Obj</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> iterator = &#123; <span class="attr">next</span>: next &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.<span class="property">value</span>;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.<span class="property">next</span> = two;</span><br><span class="line">two.<span class="property">next</span> = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是另一个为对象添加 Iterator 接口的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">data</span>: [ <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span> ],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署 Iterator 接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"></span><br><span class="line">[...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)] <span class="comment">// 可以执行了</span></span><br></pre></td></tr></table></figure><p>NodeList 对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p><p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">// undefined, undefined, undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="function">() =&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[...obj] <span class="comment">// TypeError: [] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历（详见下文），也可以使用<code>while</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $iterator = <span class="variable constant_">ITERABLE</span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">var</span> $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line"><span class="keyword">while</span> (!$result.<span class="property">done</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $result.<span class="property">value</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  $result = $iterator.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p><h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即<code>Symbol.iterator</code>方法），除了下文会介绍的<code>for...of</code>循环，还有几个别的场合。</p><p><strong>（1）解构赋值</strong></p><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;b&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y] = set;</span><br><span class="line"><span class="comment">// x=&#x27;a&#x27;; y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line"><span class="comment">// first=&#x27;a&#x27;; rest=[&#x27;b&#x27;,&#x27;c&#x27;];</span></span><br></pre></td></tr></table></figure><p><strong>（2）扩展运算符</strong></p><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">[...str] <span class="comment">//  [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, ...arr, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [...iterable];</span><br></pre></td></tr></table></figure><p><strong>（3）yield*</strong></p><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（4）其他场合</strong></p><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h2 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h2><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line"><span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;h&quot;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: &quot;i&quot;, done: false &#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。</p><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// [&quot;h&quot;, &quot;i&quot;]</span></span><br><span class="line"></span><br><span class="line">str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_first</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_first</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="string">&quot;bye&quot;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">_first</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// [&quot;bye&quot;]</span></span><br><span class="line">str <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，字符串 str 的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p><h2 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h2><p><code>Symbol.iterator()</code>方法的最简单实现，还是使用下一章要介绍的 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。</p><h2 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h2><p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p><p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readLinesSync</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">          file.<span class="title function_">close</span>();</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。下面的两种情况，都会触发执行<code>return()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> <span class="title function_">readLinesSync</span>(fileName)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</p><p>注意，<code>return()</code>方法必须返回一个对象，这是 Generator 语法决定的。</p><p><code>throw()</code>方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator 函数》一章。</p><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有 iterator 接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>].<span class="title function_">bind</span>(arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">element, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(element); <span class="comment">// red green blue</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index);   <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> a <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法（参见《数组的扩展》一章）。</p><p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p><h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><p>Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用<code>for...of</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;Gecko&quot;</span>, <span class="string">&quot;Trident&quot;</span>, <span class="string">&quot;Webkit&quot;</span>, <span class="string">&quot;Webkit&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>);</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;committee&quot;</span>, <span class="string">&quot;TC39&quot;</span>);</span><br><span class="line">es6.<span class="title function_">set</span>(<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;ECMA-262&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure><p>上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1</span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure><h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printArgs</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printArgs</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="string">&#x27;a\uD83D\uDC0A&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;\uD83D\uDC0A&#x27;</span></span><br></pre></td></tr></table></figure><p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> es6 = &#123;</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">committee</span>: <span class="string">&quot;TC39&quot;</span>,</span><br><span class="line">  <span class="attr">standard</span>: <span class="string">&quot;ECMA-262&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">in</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition</span></span><br><span class="line"><span class="comment">// committee</span></span><br><span class="line"><span class="comment">// standard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TypeError: es6[Symbol.iterator] is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(someObject)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法是使用 Generator 函数将对象重新包装一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">entries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">entries</span>(obj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.<span class="property">length</span>; index++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p><p><code>for...in</code>循环可以遍历数组的键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for...in</code>循环有几个缺点。</p><ul><li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li><li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><p>下面是一个使用 break 语句，跳出<code>for...of</code>循环的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p><h2 id="for…of-与-for…in区别"><a href="#for…of-与-for…in区别" class="headerlink" title="for…of 与 for…in区别"></a>for…of 与 for…in区别</h2><h3 id="for-in遍历的是数组的索引（即键名），"><a href="#for-in遍历的是数组的索引（即键名），" class="headerlink" title="for in遍历的是数组的索引（即键名），"></a>for in遍历的是数组的索引（即键名），</h3><h3 id="而for-of遍历的是数组元素值。"><a href="#而for-of遍历的是数组元素值。" class="headerlink" title="而for of遍历的是数组元素值。"></a>而for of遍历的是数组元素值。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">method</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myArray=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myArray.<span class="property">name</span>=<span class="string">&quot;数组&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index]);    <span class="comment">//0,1,2,method,name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myArray) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);    <span class="comment">//1,2,4</span></span><br></pre></td></tr></table></figure><p>除此之外还有一些细节:</p><p>for in的一些<strong>缺陷</strong>:</p><ol><li>索引是字符串型的数字，因而不能直接进行几何运算</li><li>遍历顺序可能不是实际的内部顺序</li><li>for in会遍历数组所有的可枚举属性，包括原型。例如的原型方法method和name属性</li></ol><p>故而一般用<strong>for in遍历对象而不用来遍历数组</strong></p><p> 这也就是for of存在的意义了,<strong>for of 不遍历method和name,适合用来遍历数组</strong></p><p> 那for of有缺点吗? 当然有了:</p><p><strong>for of不支持普通对象</strong>，想遍历对象的属性，可以用for in循环, 或内建的Object.keys()方法：</p><p><strong>Object.keys(myObject)获取对象的实例属性组成的数组，不包括原型方法和属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Object</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;: &quot;</span> + <span class="title class_">Object</span>[key]);</span><br></pre></td></tr></table></figure><p>但是感觉这样有些多此一举,</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Promise 对象</title>
    <link href="https://k705.github.io/2024/04/08/Es6-15%E3%80%81Es6_Promise%E5%AF%B9%E8%B1%A1_day11-30/"/>
    <id>https://k705.github.io/2024/04/08/Es6-15%E3%80%81Es6_Promise%E5%AF%B9%E8%B1%A1_day11-30/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:33.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p><p>本人有专门系统学习该知识点的笔记，与<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><code>Promise学习笔记</code></a>文件夹中</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指状态，不包含<code>rejected</code>状态。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">timeout</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadImageAsync</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.<span class="property">src</span> = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="keyword">function</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    client.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.<span class="property">onreadystatechange</span> = handler;</span><br><span class="line">    client.<span class="property">responseType</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/posts.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">json</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> json.<span class="property">post</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/post/1.json&quot;</span>).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">post</span> =&gt;</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>)</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/posts.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，<code>then()</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fulfilled:&#x27;</span>, val))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fulfilled:&#x27;</span>, val))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected:&quot;</span>, err));</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch()</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject()</code>方法的作用，等同于抛出错误。</p><p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post/1.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(post.<span class="property">commentURL</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">comments</span>) &#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch()</code>方法，而不使用<code>then()</code>方法的第二个参数。</p><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing()</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node.js 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, p</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p><p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p><p>一般总是建议，Promise 对象后面要跟<code>catch()</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch()</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch()</code>方法指定的回调函数，会接着运行后面那个<code>then()</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch()</code>方法，直接执行后面的<code>then()</code>方法。此时，要是<code>then()</code>方法里面报错，就与前面的<code>catch()</code>无关了。</p><p><code>catch()</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch()</code>方法抛出一个错误，因为后面没有别的<code>catch()</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">someAsyncThing</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">someOtherAsyncThing</span>();</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch()</code>方法用来捕获前一个<code>catch()</code>方法抛出的错误。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(port)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(server.<span class="property">stop</span>);</span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>下面是一个具体的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&#x27;/post/&#x27;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">posts</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = <span class="title function_">connectDatabase</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .<span class="title function_">then</span>(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> <span class="title function_">pickTopRecommendations</span>(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommendations</code>这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(result))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a>Promise.allSettled()</h2><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-1&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-2&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/api-3&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"><span class="title function_">removeLoadingIndicator</span>();</span><br></pre></td></tr></table></figure><p>上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。</p><p>该方法返回的新的 Promise 实例，一旦结束，状态总是<code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> allSettledPromise = <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([resolved, rejected]);</span><br><span class="line"></span><br><span class="line">allSettledPromise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;fulfilled&#x27;, value: 42 &#125;,</span></span><br><span class="line"><span class="comment">//    &#123; status: &#x27;rejected&#x27;, reason: -1 &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.allSettled()</code>的返回值<code>allSettledPromise</code>，状态只可能变成<code>fulfilled</code>。它的监听函数接收到的参数是数组<code>results</code>。该数组的每个成员都是一个对象，对应传入<code>Promise.allSettled()</code>的两个 Promise 实例。每个对象都有<code>status</code>属性，该属性的值只可能是字符串<code>fulfilled</code>或字符串<code>rejected</code>。<code>fulfilled</code>时，对象有<code>value</code>属性，<code>rejected</code>时有<code>reason</code>属性，对应两种状态的返回值。</p><p>下面是返回值用法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [ <span class="title function_">fetch</span>(<span class="string">&#x27;index.html&#x27;</span>), <span class="title function_">fetch</span>(<span class="string">&#x27;https://does-not-exist/&#x27;</span>) ];</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出成功的请求</span></span><br><span class="line"><span class="keyword">const</span> successfulPromises = results.<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤出失败的请求，并输出原因</span></span><br><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure><p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，<code>Promise.allSettled()</code>方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。<code>Promise.all()</code>方法无法做到这一点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* ... */</span> ];</span><br><span class="line"><span class="keyword">const</span> requests = urls.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">fetch</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(requests);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有请求都成功。&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;至少一个请求失败，其他请求可能还没结束。&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了<code>Promise.allSettled()</code>，这就很容易了。</p><h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a>Promise.any()</h2><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-a&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-b&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/endpoint-c&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">any</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(first);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.any()</code>方法的参数数组包含三个 Promise 操作。其中只要有一个变成<code>fulfilled</code>，<code>Promise.any()</code>返回的 Promise 对象就变成<code>fulfilled</code>。如果所有三个操作都变成<code>rejected</code>，那么<code>await</code>命令就会抛出错误。</p><p><code>Promise.any()</code>抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被<code>rejected</code>的操作所抛出的错误。下面是 AggregateError 的实现示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">AggregateError</span>() <span class="keyword">extends</span> <span class="title class_">Array</span> -&gt; <span class="title class_">AggregateError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">AggregateError</span>();</span><br><span class="line">err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;first error&quot;</span>));</span><br><span class="line">err.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;second error&quot;</span>));</span><br><span class="line"><span class="keyword">throw</span> err;</span><br></pre></td></tr></table></figure><p>捕捉错误时，如果不用<code>try...catch</code>结构和 await 命令，可以像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>(promises).<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">first</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Any of the promises was fulfilled.</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// All of the promises were rejected.</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolved = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">var</span> rejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> alsoRejected = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Infinity</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([resolved, rejected, alsoRejected]).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([rejected, alsoRejected]).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">results</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results); <span class="comment">// [-1, Infinity]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>($.<span class="title function_">ajax</span>(<span class="string">&#x27;/whatever.json&#x27;</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve()</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then()</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then()</code>方法指定的回调函数，输出42。</p><p><strong>（3）参数不是具有<code>then()</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then()</code>方法的对象，则<code>Promise.resolve()</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve()</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject()</code>方法的参数是一个字符串，后面<code>catch()</code>方法的参数<code>e</code>就是这个字符串。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="keyword">function</span> (<span class="params">path</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">    image.<span class="property">onload</span>  = resolve;</span><br><span class="line">    image.<span class="property">onerror</span> = reject;</span><br><span class="line">    image.<span class="property">src</span> = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getFoo</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> <span class="title function_">getFoo</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (generator) &#123;</span><br><span class="line">  <span class="keyword">const</span> it = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));</span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">go</span>(it.<span class="title function_">next</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; <span class="title function_">f</span>())()</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>第二种写法是使用<code>new Promise()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(</span><br><span class="line">    <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="title function_">f</span>())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUsername</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user.<span class="property">name</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.<span class="title function_">then</span>(...)</span><br><span class="line">.<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">try</span>(<span class="function">() =&gt;</span> database.<span class="property">users</span>.<span class="title function_">get</span>(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本人有专门系统学习该知识点的笔记，与&lt;a href=&quot;https://gitee.com/hongjilin</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Generator 函数的异步应用</title>
    <link href="https://k705.github.io/2024/04/08/Es6-18%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8_day11-30(%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5)/"/>
    <id>https://k705.github.io/2024/04/08/Es6-18%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8_day11-30(%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5)/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:28:54.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h1><p>异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍 Generator 函数如何完成异步操作。</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>ES6 诞生以前，异步编程的方法，大概有下面四种。</p><ul><li>回调函数</li><li>事件监听</li><li>发布&#x2F;订阅</li><li>Promise 对象</li></ul><p>Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p><p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字<code>callback</code>，直译过来就是”重新调用”。</p><p>读取文件进行处理，是这样写的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>readFile</code>函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象<code>err</code>（如果没有错误，该参数就是<code>null</code>）？</p><p>原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取<code>A</code>文件之后，再读取<code>B</code>文件，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(fileA, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  fs.<span class="title function_">readFile</span>(fileB, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。</p><p>Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">&#x27;fs-readfile-promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFile</span>(fileA)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，我使用了<code>fs-readfile-promise</code>模块，它的作用就是返回一个 Promise 版本的<code>readFile</code>函数。Promise 提供<code>then</code>方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise 的写法只是回调函数的改进，使用<code>then</code>方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆<code>then</code>，原来的语义变得很不清楚。</p><p>那么，有没有更好的写法呢？</p><h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><ul><li>第一步，协程<code>A</code>开始执行。</li><li>第二步，协程<code>A</code>执行到一半，进入暂停，执行权转移到协程<code>B</code>。</li><li>第三步，（一段时间后）协程<code>B</code>交还执行权。</li><li>第四步，协程<code>A</code>恢复执行。</li></ul><p>上面流程的协程<code>A</code>，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>asyncJob</code>是一个协程，它的奥妙就在其中的<code>yield</code>命令。它表示执行到此处，执行权将交给其他协程。也就是说，<code>yield</code>命令是异步两个阶段的分界线。</p><p>协程遇到<code>yield</code>命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除<code>yield</code>命令，简直一模一样。</p><h3 id="协程的-Generator-函数实现"><a href="#协程的-Generator-函数实现" class="headerlink" title="协程的 Generator 函数实现"></a>协程的 Generator 函数实现</h3><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用<code>yield</code>语句注明。Generator 函数的执行方法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）<code>g</code>。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针<code>g</code>的<code>next</code>方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的<code>yield</code>语句，上例是执行到<code>x + 2</code>为止。</p><p>换言之，<code>next</code>方法的作用是分阶段执行<code>Generator</code>函数。每次调用<code>next</code>方法，会返回一个对象，表示当前阶段的信息（<code>value</code>属性和<code>done</code>属性）。<code>value</code>属性是<code>yield</code>语句后面表达式的值，表示当前阶段的值；<code>done</code>属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p><h3 id="Generator-函数的数据交换和错误处理"><a href="#Generator-函数的数据交换和错误处理" class="headerlink" title="Generator 函数的数据交换和错误处理"></a>Generator 函数的数据交换和错误处理</h3><p>Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p><p><code>next</code>返回值的 value 属性，是 Generator 函数向外输出数据；<code>next</code>方法还可以接受参数，向 Generator 函数体内输入数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>next</code>方法的<code>value</code>属性，返回表达式<code>x + 2</code>的值<code>3</code>。第二个<code>next</code>方法带有参数<code>2</code>，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量<code>y</code>接收。因此，这一步的<code>value</code>属性，返回的就是<code>2</code>（变量<code>y</code>的值）。</p><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params">x</span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>(<span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一行，Generator 函数体外，使用指针对象的<code>throw</code>方法抛出的错误，可以被函数体内的<code>try...catch</code>代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">bio</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了<code>yield</code>命令。</p><p>执行这段代码的方法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> result = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line">result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> data.<span class="title function_">json</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用<code>next</code>方法（第二行），执行异步任务的第一阶段。由于<code>Fetch</code>模块返回的是一个 Promise 对象，因此要用<code>then</code>方法调用下一个<code>next</code>方法。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h2 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h2><p>Thunk 函数是自动执行 Generator 函数的一种方法。</p><h3 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h3><p>Thunk 函数早在上个世纪 60 年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面代码先定义函数<code>f</code>，然后向它传入表达式<code>x + 5</code>。请问，这个表达式应该何时求值？</p><p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于 6），再将这个值传入函数<code>f</code>。C 语言就采用这种策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传值调用时，等同于</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>另一种意见是“传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 传名调用时，等同于</span></span><br><span class="line">(x + <span class="number">5</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure><p>传值调用和传名调用，哪一种比较好？</p><p>回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(<span class="number">3</span> * x * x - <span class="number">2</span> * x - <span class="number">1</span>, x);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p><h3 id="Thunk-函数的含义"><a href="#Thunk-函数的含义" class="headerlink" title="Thunk 函数的含义"></a>Thunk 函数的含义</h3><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数 f 的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p><p>这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p><h3 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h3><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fs.<span class="title function_">readFile</span>(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title class_">Thunk</span>(fileName);</span><br><span class="line"><span class="title function_">readFileThunk</span>(callback);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>fs</code>模块的<code>readFile</code>方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p><p>任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5版本</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>)&#123;</span><br><span class="line">      args.<span class="title function_">push</span>(callback);</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6版本</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用上面的转换器，生成<code>fs.readFile</code>的 Thunk 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title class_">Thunk</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">readFileThunk</span>(fileA)(callback);</span><br></pre></td></tr></table></figure><p>下面是另一个完整的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, cb</span>) &#123;</span><br><span class="line">  <span class="title function_">cb</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ft = <span class="title class_">Thunk</span>(f);</span><br><span class="line"></span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h3><p>生产环境的转换器，建议使用 Thunkify 模块。</p><p>首先是安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install thunkify</span><br></pre></td></tr></table></figure><p>使用方式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;package.json&#x27;</span>)(<span class="keyword">function</span>(<span class="params">err, str</span>)&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Thunkify 的源码与上一节那个简单的转换器非常像。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thunkify</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; ++i) &#123;</span><br><span class="line">      args[i] = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">      args.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.<span class="title function_">apply</span>(<span class="literal">null</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">done</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的源码主要多了一个检查机制，变量<code>called</code>确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, callback</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = a + b;</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">  <span class="title function_">callback</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft = <span class="title function_">thunkify</span>(f);</span><br><span class="line"><span class="keyword">var</span> print = <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于<code>thunkify</code>只允许回调函数执行一次，所以只输出一行结果。</p><h3 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h3><p>你可能会问， Thunk 函数有什么用？回答是以前确实没什么用，但是 ES6 有了 Generator 函数，Thunk 函数现在可以用于 Generator 函数的自动流程管理。</p><p>Generator 函数可以自动执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!res.<span class="property">done</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">  res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>gen</code>会自动执行完所有步骤。</p><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk 函数就能派上用处。以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p><p>这种方法就是 Thunk 函数，因为它可以在回调函数里，将执行权交还给 Generator 函数。为了便于理解，我们先看如何手动执行上面这个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> r2 = g.<span class="title function_">next</span>(data);</span><br><span class="line">  r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>g</code>是 Generator 函数的内部指针，表示目前执行到哪一步。<code>next</code>方法负责将指针移动到下一步，并返回该步的信息（<code>value</code>属性和<code>done</code>属性）。</p><p>仔细查看上面的代码，可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入<code>next</code>方法的<code>value</code>属性。这使得我们可以用递归来自动完成这个过程。</p><h3 id="Thunk-函数的自动流程管理"><a href="#Thunk-函数的自动流程管理" class="headerlink" title="Thunk 函数的自动流程管理"></a>Thunk 函数的自动流程管理</h3><p>Thunk 函数真正的威力，在于可以自动执行 Generator 函数。下面就是一个基于 Thunk 函数的 Generator 执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> gen = <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span>;</span><br><span class="line">    result.<span class="title function_">value</span>(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码的<code>run</code>函数，就是一个 Generator 函数的自动执行器。内部的<code>next</code>函数就是 Thunk 的回调函数。<code>next</code>函数先将指针移到 Generator 函数的下一步（<code>gen.next</code>方法），然后判断 Generator 函数是否结束（<code>result.done</code>属性），如果没结束，就将<code>next</code>函数再传入 Thunk 函数（<code>result.value</code>属性），否则就直接退出。</p><p>有了这个执行器，执行 Generator 函数方便多了。不管内部有多少个异步操作，直接把 Generator 函数传入<code>run</code>函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在<code>yield</code>命令后面的必须是 Thunk 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileA&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileB&#x27;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;fileN&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>g</code>封装了<code>n</code>个异步的读取文件操作，只要执行<code>run</code>函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p>Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p><h2 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><a href="https://github.com/tj/co">co 模块</a>是著名程序员 TJ Holowaychuk 于 2013 年 6 月发布的一个小工具，用于 Generator 函数的自动执行。</p><p>下面是一个 Generator 函数，用于依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>co 模块可以让你不用编写 Generator 函数的执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="title function_">co</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数只要传入<code>co</code>函数，就会自动执行。</p><p><code>co</code>函数返回一个<code>Promise</code>对象，因此可以用<code>then</code>方法添加回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator 函数执行完成&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，等到 Generator 函数执行结束，就会输出一行提示。</p><h3 id="co-模块的原理"><a href="#co-模块的原理" class="headerlink" title="co 模块的原理"></a>co 模块的原理</h3><p>为什么 co 可以自动执行 Generator 函数？</p><p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p><p>（2）Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</p><p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p><p>上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。</p><h3 id="基于-Promise-对象的自动执行"><a href="#基于-Promise-对象的自动执行" class="headerlink" title="基于 Promise 对象的自动执行"></a>基于 Promise 对象的自动执行</h3><p>还是沿用上面的例子。首先，把<code>fs</code>模块的<code>readFile</code>方法包装成一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* ()&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，手动执行上面的 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    g.<span class="title function_">next</span>(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手动执行其实就是用<code>then</code>方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">gen</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">      <span class="title function_">next</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen);</span><br></pre></td></tr></table></figure><p>上面代码中，只要 Generator 函数还没执行到最后一步，<code>next</code>函数就调用自身，以此实现自动执行。</p><h3 id="co-模块的源码"><a href="#co-模块的源码" class="headerlink" title="co 模块的源码"></a>co 模块的源码</h3><p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回的 Promise 对象里面，co 先检查参数<code>gen</code>是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，co 将 Generator 函数的内部指针对象的<code>next</code>方法，包装成<code>onFulfilled</code>函数。这主要是为了能够捕捉抛出的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.<span class="title function_">call</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.<span class="property">next</span> !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(gen);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onFulfilled</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">onFulfilled</span>(<span class="params">res</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.<span class="title function_">next</span>(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">next</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是关键的<code>next</code>函数，它会反复调用自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">ret</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">done</span>) <span class="keyword">return</span> <span class="title function_">resolve</span>(ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">var</span> value = toPromise.<span class="title function_">call</span>(ctx, ret.<span class="property">value</span>);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">isPromise</span>(value)) <span class="keyword">return</span> value.<span class="title function_">then</span>(onFulfilled, onRejected);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">onRejected</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(</span><br><span class="line">      <span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span></span><br><span class="line">      + <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span></span><br><span class="line">      + <span class="title class_">String</span>(ret.<span class="property">value</span>)</span><br><span class="line">      + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>next</code>函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，是 Promise 对象。</p><p>第三行，使用<code>then</code>方法，为返回值加上回调函数，然后通过<code>onFulfilled</code>函数再次调用<code>next</code>函数。</p><p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为<code>rejected</code>，从而终止执行。</p><h3 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h3><p>co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在<code>yield</code>语句后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(onerror);</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line">  <span class="keyword">yield</span> values.<span class="title function_">map</span>(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">somethingAsync</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">// do something async</span></span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码允许并发三个<code>somethingAsync</code>异步操作，等到它们全部完成，才会进行下一步。</p><h3 id="实例：处理-Stream"><a href="#实例：处理-Stream" class="headerlink" title="实例：处理 Stream"></a>实例：处理 Stream</h3><p>Node 提供 Stream 模式读写数据，特点是一次只处理数据的一部分，数据分成一块块依次处理，就好像“数据流”一样。这对于处理大规模数据非常有利。Stream 模式使用 EventEmitter API，会释放三个事件。</p><ul><li><code>data</code>事件：下一块数据块已经准备好了。</li><li><code>end</code>事件：整个“数据流”处理完了。</li><li><code>error</code>事件：发生错误。</li></ul><p>使用<code>Promise.race()</code>函数，可以判断这三个事件之中哪一个最先发生，只有当<code>data</code>事件最先发生时，才进入下一个数据块的处理。从而，我们可以通过一个<code>while</code>循环，完成所有数据的读取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./les_miserables.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> valjeanCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">yield</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.<span class="title function_">once</span>(<span class="string">&#x27;data&#x27;</span>, resolve)),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> stream.<span class="title function_">once</span>(<span class="string">&#x27;end&#x27;</span>, resolve)),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> stream.<span class="title function_">once</span>(<span class="string">&#x27;error&#x27;</span>, reject))</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stream.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    stream.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line">    stream.<span class="title function_">removeAllListeners</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    valjeanCount += (res.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/valjean/ig</span>) || []).<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count:&#x27;</span>, valjeanCount); <span class="comment">// count: 1120</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码采用 Stream 模式读取《悲惨世界》的文本文件，对于每个数据块都使用<code>stream.once</code>方法，在<code>data</code>、<code>end</code>、<code>error</code>三个事件上添加一次性回调函数。变量<code>res</code>只有在<code>data</code>事件发生时才有值，然后累加每个数据块之中<code>valjean</code>这个词出现的次数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Generator 函数的语法</title>
    <link href="https://k705.github.io/2024/04/08/Es6-17%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/"/>
    <id>https://k705.github.io/2024/04/08/Es6-17%E3%80%81Es6_Generator%20%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95_day11-30%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8F%AF%E5%BF%BD%E7%95%A5%EF%BC%89/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:29:03.762Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码一共调用了四次<code>next</code>方法。</p><p>第一次调用，Generator 函数开始执行，直到遇到第一个<code>yield</code>表达式为止。<code>next</code>方法返回一个对象，它的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>hello</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第二次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到下一个<code>yield</code>表达式。<code>next</code>方法返回的对象的<code>value</code>属性就是当前<code>yield</code>表达式的值<code>world</code>，<code>done</code>属性的值<code>false</code>，表示遍历还没有结束。</p><p>第三次调用，Generator 函数从上次<code>yield</code>表达式停下的地方，一直执行到<code>return</code>语句（如果没有<code>return</code>语句，就执行到函数结束）。<code>next</code>方法返回的对象的<code>value</code>属性，就是紧跟在<code>return</code>语句后面的表达式的值（如果没有<code>return</code>语句，则<code>value</code>属性的值为<code>undefined</code>），<code>done</code>属性的值<code>true</code>，表示遍历已经结束。</p><p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code>方法返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code>属性为<code>true</code>。以后再调用<code>next</code>方法，返回的都是这个值。</p><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>ES6 没有规定，<code>function</code>关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br><span class="line"><span class="keyword">function</span>*<span class="title function_">foo</span>(<span class="params">x, y</span>) &#123; ··· &#125;</span><br></pre></td></tr></table></figure><p>由于 Generator 函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在<code>function</code>关键字后面。本书也采用这种写法。</p><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><p>由于 Generator 函数返回的遍历器对象，只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code>表达式就是暂停标志。</p><p>遍历器对象的<code>next</code>方法的运行逻辑如下。</p><p>（1）遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（2）下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式。</p><p>（3）如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</p><p>（4）如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code>。</p><p>需要注意的是，<code>yield</code>表达式后面的表达式，只有当调用<code>next</code>方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>  <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>后面的表达式<code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p><p><code>yield</code>表达式与<code>return</code>语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）<code>return</code>语句，但是可以执行多次（或者说多个）<code>yield</code>表达式。正常函数只能返回一个值，因为只能执行一次<code>return</code>；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（英语中，generator 这个词是“生成器”的意思）。</p><p>Generator 函数可以不用<code>yield</code>表达式，这时就变成了一个单纯的暂缓执行函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了！&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  generator.<span class="title function_">next</span>()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>如果是普通函数，在为变量<code>generator</code>赋值时就会执行。但是，函数<code>f</code>是一个 Generator 函数，就变成只有调用<code>next</code>方法时，函数<code>f</code>才会执行。</p><p>另外需要注意，<code>yield</code>表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure><p>上面代码在一个普通函数中使用<code>yield</code>表达式，结果产生一个句法错误。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="keyword">function</span>* (a) &#123;</span><br><span class="line">  a.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* <span class="title function_">flat</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> <span class="title function_">flat</span>(arr))&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也会产生句法错误，因为<code>forEach</code>方法的参数是一个普通函数，但是在里面使用了<code>yield</code>表达式（这个函数里面还使用了<code>yield*</code>表达式，详细介绍见后文）。一种修改方法是改用<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="keyword">function</span>* (a) &#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* <span class="title function_">flat</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> <span class="title function_">flat</span>(arr)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><p>另外，<code>yield</code>表达式如果用在另一个表达式之中，必须放在圆括号里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yield</code>表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>上一章说过，任意一个对象的<code>Symbol.iterator</code>方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的<code>Symbol.iterator</code>属性，从而使得该对象具有 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数赋值给<code>Symbol.iterator</code>属性，从而使得<code>myIterable</code>对象具有了 Iterator 接口，可以被<code>...</code>运算符遍历了。</p><p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有<code>Symbol.iterator</code>属性，执行后返回自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>gen</code>是一个 Generator 函数，调用它会生成一个遍历器对象<code>g</code>。它的<code>Symbol.iterator</code>属性，也是一个遍历器对象生成函数，执行后返回它自己。</p><h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。<code>next</code>方法可以带一个参数，该参数就会被当作上一个<code>yield</code>表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码先定义了一个可以无限运行的 Generator 函数<code>f</code>，如果<code>next</code>方法没有参数，每次运行到<code>yield</code>表达式，变量<code>reset</code>的值总是<code>undefined</code>。当<code>next</code>方法带一个参数<code>true</code>时，变量<code>reset</code>就被重置为这个参数（即<code>true</code>），因此<code>i</code>会等于<code>-1</code>，下一轮循环就会从<code>-1</code>开始递增。</p><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过<code>next</code>方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>再看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二次运行<code>next</code>方法的时候不带参数，导致 y 的值等于<code>2 * undefined</code>（即<code>NaN</code>），除以 3 以后还是<code>NaN</code>，因此返回对象的<code>value</code>属性也等于<code>NaN</code>。第三次运行<code>Next</code>方法的时候不带参数，所以<code>z</code>等于<code>undefined</code>，返回对象的<code>value</code>属性等于<code>5 + NaN + undefined</code>，即<code>NaN</code>。</p><p>如果向<code>next</code>方法提供参数，返回结果就完全不一样了。上面代码第一次调用<code>b</code>的<code>next</code>方法时，返回<code>x+1</code>的值<code>6</code>；第二次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>12</code>，因此<code>y</code>等于<code>24</code>，返回<code>y / 3</code>的值<code>8</code>；第三次调用<code>next</code>方法，将上一次<code>yield</code>表达式的值设为<code>13</code>，因此<code>z</code>等于<code>13</code>，这时<code>x</code>等于<code>5</code>，<code>y</code>等于<code>24</code>，所以<code>return</code>语句的值等于<code>42</code>。</p><p>注意，由于<code>next</code>方法的参数表示上一个<code>yield</code>表达式的返回值，所以在第一次使用<code>next</code>方法时，传递参数是无效的。V8 引擎直接忽略第一次使用<code>next</code>方法时的参数，只有从第二次使用<code>next</code>方法开始，参数才是有效的。从语义上讲，第一个<code>next</code>方法用来启动遍历器对象，所以不用带有参数。</p><p>再看一个通过<code>next</code>方法的参数，向 Generator 函数内部输入值的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">dataConsumer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Started&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = <span class="title function_">dataConsumer</span>();</span><br><span class="line">genObj.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.<span class="title function_">next</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.<span class="title function_">next</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure><p>上面代码是一个很直观的例子，每次通过<code>next</code>方法向 Generator 函数输入值，然后打印出来。</p><p>如果想要第一次调用<code>next</code>方法时，就能够输入值，可以在 Generator 函数外面再包一层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wrapper</span>(<span class="params">generatorFunction</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> generatorObject = <span class="title function_">generatorFunction</span>(...args);</span><br><span class="line">    generatorObject.<span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">return</span> generatorObject;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = <span class="title function_">wrapper</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`First input: <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;DONE&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">wrapped</span>().<span class="title function_">next</span>(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line"><span class="comment">// First input: hello!</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数如果不用<code>wrapper</code>先包一层，是无法第一次调用<code>next</code>方法，就输入参数的。</p><h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p><code>for...of</code>循环可以自动遍历 Generator 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><p>上面代码使用<code>for...of</code>循环，依次显示 5 个<code>yield</code>表达式的值。这里需要注意，一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止，且不包含该返回对象，所以上面代码的<code>return</code>语句返回的<code>6</code>，不包括在<code>for...of</code>循环之中。</p><p>下面是一个利用 Generator 函数和<code>for...of</code>循环，实现斐波那契数列的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">fibonacci</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> <span class="title function_">fibonacci</span>()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可见，使用<code>for...of</code>语句时不需要使用<code>next</code>方法。</p><p>利用<code>for...of</code>循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用<code>for...of</code>循环，通过 Generator 函数为它加上这个接口，就可以用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>jane</code>原生不具备 Iterator 接口，无法用<code>for...of</code>遍历。这时，我们通过 Generator 函数<code>objectEntries</code>为它加上遍历器接口，就可以用<code>for...of</code>遍历了。加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="variable language_">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">jane[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = objectEntries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>除了<code>for...of</code>循环以外，扩展运算符（<code>...</code>）、解构赋值和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* numbers () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...<span class="title function_">numbers</span>()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = <span class="title function_">numbers</span>();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> <span class="title function_">numbers</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个<code>throw</code>方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>i</code>连续抛出两个错误。第一个错误被 Generator 函数体内的<code>catch</code>语句捕获。<code>i</code>第二次抛出错误，由于 Generator 函数内部的<code>catch</code>语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的<code>catch</code>语句捕获。</p><p><code>throw</code>方法可以接受一个参数，该参数会被<code>catch</code>语句接收，建议抛出<code>Error</code>对象的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line">i.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>));</span><br><span class="line"><span class="comment">// Error: 出错了！(…)</span></span><br></pre></td></tr></table></figure><p>注意，不要混淆遍历器对象的<code>throw</code>方法和全局的<code>throw</code>命令。上面代码的错误，是用遍历器对象的<code>throw</code>方法抛出的，而不是用<code>throw</code>命令抛出的。后者只能被函数体外的<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">&#x27;a&#x27;</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure><p>上面代码之所以只捕获了<code>a</code>，是因为函数体外的<code>catch</code>语句块，捕获了抛出的<code>a</code>错误以后，就不会再继续<code>try</code>代码块里面剩余的语句了。</p><p>如果 Generator 函数内部没有部署<code>try...catch</code>代码块，那么<code>throw</code>方法抛出的错误，将被外部<code>try...catch</code>代码块捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>g</code>内部没有部署<code>try...catch</code>代码块，所以抛出的错误直接被外部<code>catch</code>代码块捕获。</p><p>如果 Generator 函数内部和外部，都没有部署<code>try...catch</code>代码块，那么程序将报错，直接中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line">g.<span class="keyword">throw</span>();</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// Uncaught undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>抛出错误以后，没有任何<code>try...catch</code>代码块可以捕获这个错误，导致程序报错，中断执行。</p><p><code>throw</code>方法抛出的错误要被内部捕获，前提是必须至少执行过一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="keyword">throw</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Uncaught 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw(1)</code>执行时，<code>next</code>方法一次都没有执行过。这时，抛出的错误不会被内部捕获，而是直接在外部抛出，导致程序出错。这种行为其实很好理解，因为第一次执行<code>next</code>方法，等同于启动执行 Generator 函数的内部代码，否则 Generator 函数还没有开始执行，这时<code>throw</code>方法抛错只可能抛出在函数外部。</p><p><code>throw</code>方法被捕获以后，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次<code>next</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// a</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// b</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>g.throw</code>方法被捕获以后，自动执行了一次<code>next</code>方法，所以会打印<code>b</code>。另外，也可以看到，只要 Generator 函数内部部署了<code>try...catch</code>代码块，那么遍历器的<code>throw</code>方法抛出的错误，不影响下一次遍历。</p><p>另外，<code>throw</code>命令与<code>g.throw</code>方法是无关的，两者互不影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>命令抛出的错误不会影响到遍历器的状态，所以两次执行<code>next</code>方法，都进行了正确的操作。</p><p>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个<code>yield</code>表达式，可以只用一个<code>try...catch</code>代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次<code>catch</code>语句就可以了。</p><p>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的<code>catch</code>捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.<span class="title function_">next</span>(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next</code>方法向函数体内传入一个参数 42，数值是没有<code>toUpperCase</code>方法的，所以会抛出一个 TypeError 错误，被函数体外的<code>catch</code>捕获。</p><p>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用<code>next</code>方法，将返回一个<code>value</code>属性等于<code>undefined</code>、<code>done</code>属性等于<code>true</code>的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;throwing an exception&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;generator broke!&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">generator</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> v;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;starting generator&#x27;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.<span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第一次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.<span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第二次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.<span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;第三次运行next方法&#x27;</span>, v);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕捉错误&#x27;</span>, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;caller done&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="title function_">g</span>());</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure><p>上面代码一共三次运行<code>next</code>方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator 函数就已经结束了，不再执行下去了。</p><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象，还有一个<code>return()</code>方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &quot;foo&quot;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，遍历器对象<code>g</code>调用<code>return()</code>方法后，返回值的<code>value</code>属性就是<code>return()</code>方法的参数<code>foo</code>。并且，Generator 函数的遍历就终止了，返回值的<code>done</code>属性为<code>true</code>，以后再调用<code>next()</code>方法，<code>done</code>属性总是返回<code>true</code>。</p><p>如果<code>return()</code>方法调用时，不提供参数，则返回值的<code>value</code>属性为<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>()        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>如果 Generator 函数内部有<code>try...finally</code>代码块，且正在执行<code>try</code>代码块，那么<code>return()</code>方法会导致立刻进入<code>finally</code>代码块，执行完以后，整个函数才会结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* numbers () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">numbers</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>return()</code>方法后，就开始执行<code>finally</code>代码块，不执行<code>try</code>里面剩下的代码了，然后等到<code>finally</code>代码块执行完，再返回<code>return()</code>方法指定的返回值。</p><h2 id="next-、throw-、return-的共同点"><a href="#next-、throw-、return-的共同点" class="headerlink" title="next()、throw()、return() 的共同点"></a>next()、throw()、return() 的共同点</h2><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p><p><code>next()</code>是将<code>yield</code>表达式替换成一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="keyword">function</span>* (x, y) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> x + y;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">g</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gen.<span class="title function_">next</span>(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>(<span class="number">1</span>); <span class="comment">// Object &#123;value: 1, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = 1;</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>next(1)</code>方法就相当于将<code>yield</code>表达式替换成一个值<code>1</code>。如果<code>next</code>方法没有参数，就相当于替换成<code>undefined</code>。</p><p><code>throw()</code>是将<code>yield</code>表达式替换成一个<code>throw</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.<span class="keyword">throw</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)); <span class="comment">// Uncaught Error: 出错了</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span></span><br></pre></td></tr></table></figure><p><code>return()</code>是将<code>yield</code>表达式替换成一个<code>return</code>语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen.<span class="keyword">return</span>(<span class="number">2</span>); <span class="comment">// Object &#123;value: 2, done: true&#125;</span></span><br><span class="line"><span class="comment">// 相当于将 let result = yield x + y</span></span><br><span class="line"><span class="comment">// 替换成 let result = return 2;</span></span><br></pre></td></tr></table></figure><h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="comment">// 手动遍历 foo()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">bar</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// y</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>foo</code>和<code>bar</code>都是 Generator 函数，在<code>bar</code>里面调用<code>foo</code>，就需要手动遍历<code>foo</code>。如果有多个 Generator 函数嵌套，写起来就非常麻烦。</p><p>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">bar</span>())&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;x&quot;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="comment">// &quot;y&quot;</span></span><br></pre></td></tr></table></figure><p>再来看一个对比的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outer1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">inner</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">outer1</span>()</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// 返回一个遍历器对象</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;close&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">outer2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;open&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">inner</span>()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;close&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">outer2</span>()</span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;open&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;hello!&quot;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;close&quot;</span></span><br></pre></td></tr></table></figure><p>上面例子中，<code>outer2</code>使用了<code>yield*</code>，<code>outer1</code>没使用。结果就是，<code>outer1</code>返回一个遍历器对象，<code>outer2</code>返回该遍历器对象的内部值。</p><p>从语法角度看，如果<code>yield</code>表达式后面跟的是一个遍历器对象，需要在<code>yield</code>表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为<code>yield*</code>表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Bye!&#x27;</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Greetings!&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;Ok, bye.&#x27;</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;Greetings!</span></span><br><span class="line"><span class="comment">// &quot;Hello!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Bye!&quot;</span></span><br><span class="line"><span class="comment">// &quot;Ok, bye.&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>delegatingIterator</code>是代理者，<code>delegatedIterator</code>是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个 Generator 函数，有递归的效果。</p><p><code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），等同于在 Generator 函数内部，部署一个<code>for...of</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">concat</span>(<span class="params">iter1, iter2</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，<code>yield*</code>后面的 Generator 函数（没有<code>return</code>语句时），不过是<code>for...of</code>的一种简写形式，完全可以用后者替代前者。反之，在有<code>return</code>语句时，则需要用<code>var value = yield* iterator</code>的形式获取<code>return</code>语句的值。</p><p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">gen</span>().<span class="title function_">next</span>() <span class="comment">// &#123; value:&quot;a&quot;, done:false &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。</p><p>实际上，任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code>遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">read.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">read.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &quot;h&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>yield</code>表达式返回整个字符串，<code>yield*</code>语句返回单个字符。因为字符串具有 Iterator 接口，所以被<code>yield*</code>遍历。</p><p>如果被代理的 Generator 函数有<code>return</code>语句，那么就可以向代理它的 Generator 函数返回数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;v: &quot;</span> + v);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">bar</span>();</span><br><span class="line"></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>();</span><br><span class="line"><span class="comment">// &quot;v: foo&quot;</span></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">it.<span class="title function_">next</span>()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码在第四次调用<code>next</code>方法的时候，屏幕上会有输出，这是因为函数<code>foo</code>的<code>return</code>语句，向函数<code>bar</code>提供了返回值。</p><p>再看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genFuncWithReturn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;The result&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">logReturned</span>(<span class="params">genObj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span>* genObj;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">logReturned</span>(<span class="title function_">genFuncWithReturn</span>())]</span><br><span class="line"><span class="comment">// The result</span></span><br><span class="line"><span class="comment">// 值为 [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure><p>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数<code>logReturned</code>返回的遍历器对象，第二次是<code>yield*</code>语句遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数<code>genFuncWithReturn</code>返回的遍历器对象。所以，最后的数据表达式得到的值等于<code>[ &#39;a&#39;, &#39;b&#39; ]</code>。但是，函数<code>genFuncWithReturn</code>的<code>return</code>语句的返回值<code>The result</code>，会返回给函数<code>logReturned</code>内部的<code>result</code>变量，因此会有终端输出。</p><p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">iterTree</span>(<span class="params">tree</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; tree.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* <span class="title function_">iterTree</span>(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [ <span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">iterTree</span>(tree)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure><p>由于扩展运算符<code>...</code>默认调用 Iterator 接口，所以上面这个函数也可以用于嵌套数组的平铺。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="title function_">iterTree</span>(tree)] <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，</span></span><br><span class="line"><span class="comment">// 三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Tree</span>(<span class="params">left, label, right</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">left</span> = left;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">label</span> = label;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">right</span> = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数。</span></span><br><span class="line"><span class="comment">// 由于返回的是一个遍历器，所以要用generator函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">inorder</span>(<span class="params">t</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">inorder</span>(t.<span class="property">left</span>);</span><br><span class="line">    <span class="keyword">yield</span> t.<span class="property">label</span>;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">inorder</span>(t.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">make</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (array.<span class="property">length</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tree</span>(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tree</span>(<span class="title function_">make</span>(array[<span class="number">0</span>]), array[<span class="number">1</span>], <span class="title function_">make</span>(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = <span class="title function_">make</span>([[[<span class="string">&#x27;a&#x27;</span>], <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>]], <span class="string">&#x27;d&#x27;</span>, [[<span class="string">&#x27;e&#x27;</span>], <span class="string">&#x27;f&#x27;</span>, [<span class="string">&#x27;g&#x27;</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> <span class="title function_">inorder</span>(tree)) &#123;</span><br><span class="line">  result.<span class="title function_">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h2><p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * <span class="title function_">myGeneratorMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>myGeneratorMethod</code>属性前面有一个星号，表示这个属性是一个 Generator 函数。</p><p>它的完整形式如下，与上面的写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">myGeneratorMethod</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h2><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的<code>prototype</code>对象上的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">g.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hi!&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">g</span>();</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// &#x27;hi!&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator 函数<code>g</code>返回的遍历器<code>obj</code>，是<code>g</code>的实例，而且继承了<code>g.prototype</code>。但是，如果把<code>g</code>当作普通的构造函数，并不会生效，因为<code>g</code>返回的总是遍历器对象，而不是<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">g</span>();</span><br><span class="line">obj.<span class="title function_">next</span>();</span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，Generator 函数<code>g</code>在<code>this</code>对象上面添加了一个属性<code>a</code>，但是<code>obj</code>对象拿不到这个属性。</p><p>Generator 函数也不能跟<code>new</code>命令一起用，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">y</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line"><span class="comment">// TypeError: F is not a constructor</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new</code>命令跟构造函数<code>F</code>一起使用，结果报错，因为<code>F</code>不是构造函数。</p><p>那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用<code>next</code>方法，又可以获得正常的<code>this</code>？</p><p>下面是一个变通方法。首先，生成一个空对象，使用<code>call</code>方法绑定 Generator 函数内部的<code>this</code>。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">obj.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">obj.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，首先是<code>F</code>内部的<code>this</code>对象绑定<code>obj</code>对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次<code>next</code>方法（因为<code>F</code>内部有两个<code>yield</code>表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在<code>obj</code>对象上了，因此<code>obj</code>对象也就成了<code>F</code>的实例。</p><p>上面代码中，执行的是遍历器对象<code>f</code>，但是生成的对象实例是<code>obj</code>，有没有办法将这两个对象统一呢？</p><p>一个办法就是将<code>obj</code>换成<code>F.prototype</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(F.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>再将<code>F</code>改成构造函数，就可以对它执行<code>new</code>命令了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> gen.<span class="title function_">call</span>(gen.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.<span class="title function_">next</span>();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><h3 id="Generator-与状态机"><a href="#Generator-与状态机" class="headerlink" title="Generator 与状态机"></a>Generator 与状态机</h3><p>Generator 是实现状态机的最佳结构。比如，下面的<code>clock</code>函数就是一个状态机。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> clock = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>clock</code>函数一共有两种状态（<code>Tick</code>和<code>Tock</code>），每运行一次，就改变一次状态。这个函数如果用 Generator 实现，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量<code>ticking</code>，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p><h3 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h3><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><p><strong>（1）协程与子例程的差异</strong></p><p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p>从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p><p><strong>（2）协程与普通线程的差异</strong></p><p>不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p>由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p>Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p>如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用<code>yield</code>表达式交换控制权。</p><h3 id="Generator-与上下文"><a href="#Generator-与上下文" class="headerlink" title="Generator 与上下文"></a>Generator 与上下文</h3><p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p><p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p><p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到<code>yield</code>命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行<code>next</code>命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  g.<span class="title function_">next</span>().<span class="property">value</span>,</span><br><span class="line">  g.<span class="title function_">next</span>().<span class="property">value</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，第一次执行<code>g.next()</code>时，Generator 函数<code>gen</code>的上下文会加入堆栈，即开始运行<code>gen</code>内部的代码。等遇到<code>yield 1</code>时，<code>gen</code>上下文退出堆栈，内部状态冻结。第二次执行<code>g.next()</code>时，<code>gen</code>上下文重新加入堆栈，变成当前的上下文，重新恢复执行。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。</p><h3 id="（1）异步操作的同步化表达"><a href="#（1）异步操作的同步化表达" class="headerlink" title="（1）异步操作的同步化表达"></a>（1）异步操作的同步化表达</h3><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在<code>yield</code>表达式里面，等到调用<code>next</code>方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在<code>yield</code>表达式下面，反正要等到调用<code>next</code>方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">loadUI</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">showLoadingScreen</span>();</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">loadUIDataAsynchronously</span>();</span><br><span class="line">  <span class="title function_">hideLoadingScreen</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = <span class="title function_">loadUI</span>();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><p>上面代码中，第一次调用<code>loadUI</code>函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用<code>next</code>方法，则会显示<code>Loading</code>界面（<code>showLoadingScreen</code>），并且异步加载数据（<code>loadUIDataAsynchronously</code>）。等到数据加载完成，再一次使用<code>next</code>方法，则会隐藏<code>Loading</code>界面。可以看到，这种写法的好处是所有<code>Loading</code>界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p>Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&quot;http://some.url&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(result);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(resp.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="title function_">makeAjaxCall</span>(url, <span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">    it.<span class="title function_">next</span>(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">main</span>();</span><br><span class="line">it.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><p>上面代码的<code>main</code>函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个<code>yield</code>，它几乎与同步操作的写法完全一样。注意，<code>makeAjaxCall</code>函数中的<code>next</code>方法，必须加上<code>response</code>参数，因为<code>yield</code>表达式，本身是没有值的，总是等于<code>undefined</code>。</p><p>下面是另一个例子，通过 Generator 函数逐行读取文本文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;numbers.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.<span class="property">eof</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.<span class="title function_">readLine</span>(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    file.<span class="title function_">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码打开文本文件，使用<code>yield</code>表达式可以手动逐行读取文件。</p><h3 id="（2）控制流管理"><a href="#（2）控制流管理" class="headerlink" title="（2）控制流管理"></a>（2）控制流管理</h3><p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span>(<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span>(<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span>(<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// Do something with value4</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>采用 Promise 改写上面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(step1)</span><br><span class="line">  .<span class="title function_">then</span>(step2)</span><br><span class="line">  .<span class="title function_">then</span>(step3)</span><br><span class="line">  .<span class="title function_">then</span>(step4)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value4</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">done</span>();</span><br></pre></td></tr></table></figure><p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量 Promise 的语法。Generator 函数可以进一步改善代码运行流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">longRunningTask</span>(<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="keyword">yield</span> <span class="title function_">step1</span>(value1);</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="keyword">yield</span> <span class="title function_">step2</span>(value2);</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="keyword">yield</span> <span class="title function_">step3</span>(value3);</span><br><span class="line">    <span class="keyword">var</span> value5 = <span class="keyword">yield</span> <span class="title function_">step4</span>(value4);</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，使用一个函数，按次序自动执行所有步骤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">scheduler</span>(<span class="title function_">longRunningTask</span>(initialValue));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scheduler</span>(<span class="params">task</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> taskObj = task.<span class="title function_">next</span>(task.<span class="property">value</span>);</span><br><span class="line">  <span class="comment">// 如果Generator函数未结束，就继续调用</span></span><br><span class="line">  <span class="keyword">if</span> (!taskObj.<span class="property">done</span>) &#123;</span><br><span class="line">    task.<span class="property">value</span> = taskObj.<span class="property">value</span></span><br><span class="line">    <span class="title function_">scheduler</span>(task);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上面这种做法，只适合同步操作，即所有的<code>task</code>都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p><p>下面，利用<code>for...of</code>循环会自动依次执行<code>yield</code>命令的特性，提供一种更一般的控制流管理的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateSteps</span>(<span class="params">steps</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; steps.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">step</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>steps</code>封装了一个任务的多个步骤，Generator 函数<code>iterateSteps</code>则是依次为这些步骤加上<code>yield</code>命令。</p><p>将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jobs = [job1, job2, job3];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">iterateJobs</span>(<span class="params">jobs</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; jobs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> job = jobs[i];</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">iterateSteps</span>(job.<span class="property">steps</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>jobs</code>封装了一个项目的多个任务，Generator 函数<code>iterateJobs</code>则是依次为这些任务加上<code>yield*</code>命令。</p><p>最后，就可以用<code>for...of</code>循环一次性依次执行所有任务的所有步骤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> step <span class="keyword">of</span> <span class="title function_">iterateJobs</span>(jobs))&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(step.<span class="property">id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p><p><code>for...of</code>的本质是一个<code>while</code>循环，所以上面的代码实质上执行的是下面的逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = <span class="title function_">iterateJobs</span>(jobs);</span><br><span class="line"><span class="keyword">var</span> res = it.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.<span class="property">done</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = res.<span class="property">value</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）部署-Iterator-接口"><a href="#（3）部署-Iterator-接口" class="headerlink" title="（3）部署 Iterator 接口"></a>（3）部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">iterEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">iterEntries</span>(myObj)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>myObj</code>是一个普通对象，通过<code>iterEntries</code>函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署<code>next</code>方法。</p><p>下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">makeSimpleGenerator</span>(<span class="params">array</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; array.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> array[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="title function_">makeSimpleGenerator</span>([<span class="string">&#x27;yo&#x27;</span>, <span class="string">&#x27;ya&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &#x27;yo&#x27;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">value</span> <span class="comment">// &#x27;ya&#x27;</span></span><br><span class="line">gen.<span class="title function_">next</span>().<span class="property">done</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="（4）作为数据结构"><a href="#（4）作为数据结构" class="headerlink" title="（4）作为数据结构"></a>（4）作为数据结构</h3><p>Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;hello.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;world.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;and-such.txt&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是依次返回三个函数，但是由于使用了 Generator 函数，导致可以像处理数组那样，处理这三个返回的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (task <span class="keyword">of</span> <span class="title function_">doStuff</span>()) &#123;</span><br><span class="line">  <span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，如果用 ES5 表达，完全可以用数组模拟 Generator 的这种用法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;hello.txt&#x27;</span>),</span><br><span class="line">    fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;world.txt&#x27;</span>),</span><br><span class="line">    fs.<span class="property">readFile</span>.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="string">&#x27;and-such.txt&#x27;</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数，可以用一模一样的<code>for...of</code>循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>async 函数</title>
    <link href="https://k705.github.io/2024/04/08/Es6-19%E3%80%81Es6_async%20%E5%87%BD%E6%95%B0_day11-30/"/>
    <id>https://k705.github.io/2024/04/08/Es6-19%E3%80%81Es6_async%20%E5%87%BD%E6%95%B0_day11-30/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:28:43.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p><p>本人有对此知识更为详细的学习笔记，于<a href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><code>Promise学习笔记</code></a>中</p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数，依次读取两个文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span>(<span class="params">error, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的函数<code>gen</code>可以写成<code>async</code>函数，就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f1.<span class="title function_">toString</span>());</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(f2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一比较就会发现，<code>async</code>函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code>，仅此而已。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncReadFile</span>();</span><br></pre></td></tr></table></figure><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。</p><p>进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStockPriceByName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> <span class="title function_">getStockSymbol</span>(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> <span class="title function_">getStockPrice</span>(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getStockPriceByName</span>(<span class="string">&#x27;goog&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码是一个获取股票报价的函数，函数前面的<code>async</code>关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个<code>Promise</code>对象。</p><p>下面是另一个例子，指定多少毫秒后输出一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">timeout</span>(ms);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码指定 50 毫秒以后，输出<code>hello world</code>。</p><p>由于<code>async</code>函数返回的是 Promise 对象，可以作为<code>await</code>命令的参数。所以，上面的例子也可以写成下面的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncPrint</span>(<span class="params">value, ms</span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">timeout</span>(ms);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncPrint</span>(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>async 函数有多种使用形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cachePromise</span> = caches.<span class="title function_">open</span>(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">getAvatar</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">cachePromise</span>;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">match</span>(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">Storage</span>();</span><br><span class="line">storage.<span class="title function_">getAvatar</span>(<span class="string">&#x27;jake&#x27;</span>).<span class="title function_">then</span>(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>async</code>函数的语法规则总体上比较简单，难点是错误处理机制。</p><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。</p><p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部<code>return</code>命令返回的值，会被<code>then</code>方法回调函数接收到。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>, v),</span><br><span class="line">  <span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;reject&#x27;</span>, e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">//reject Error: 出错了</span></span><br></pre></td></tr></table></figure><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getTitle</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">  <span class="keyword">return</span> html.<span class="title function_">match</span>(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getTitle</span>(<span class="string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>getTitle</code>内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行<code>then</code>方法里面的<code>console.log</code>。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 等同于</span></span><br><span class="line">  <span class="comment">// return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令的参数是数值<code>123</code>，这时等同于<code>return 123</code>。</p><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">timeout</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">timeout</span> = timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - startTime),</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timeout</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> sleepTime = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sleepTime);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令后面是一个<code>Sleep</code>对象的实例。这个实例不是 Promise 对象，但是因为定义了<code>then</code>方法，<code>await</code>会将其视为<code>Promise</code>处理。</p><p>这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助<code>await</code>命令就可以让程序停顿指定的时间。下面给出了一个简化的<code>sleep</code>实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">interval</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, interval);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">one2FiveInAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">one2FiveInAsync</span>();</span><br></pre></td></tr></table></figure><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>方法的回调函数接收到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>注意，上面代码中，<code>await</code>语句前面没有<code>return</code>，但是<code>reject</code>方法的参数依然传入了<code>catch</code>方法的回调函数。这里如果在<code>await</code>前面加上<code>return</code>，效果是一样的。</p><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>await</code>语句是不会执行的，因为第一个<code>await</code>语句状态变成了<code>reject</code>。</p><p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>另一种方法是<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法，处理前面可能出现的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>async</code>函数<code>f</code>执行后，<code>await</code>后面的 Promise 对象会抛出一个错误对象，导致<code>catch</code>方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。</p><p>防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">await</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有多个<code>await</code>命令，可以统一放在<code>try...catch</code>结构中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> val1 = <span class="keyword">await</span> <span class="title function_">firstStep</span>();</span><br><span class="line">    <span class="keyword">const</span> val2 = <span class="keyword">await</span> <span class="title function_">secondStep</span>(val1);</span><br><span class="line">    <span class="keyword">const</span> val3 = <span class="keyword">await</span> <span class="title function_">thirdStep</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Final: &#x27;</span>, val3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的例子使用<code>try...catch</code>结构，实现多次重复尝试。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">&#x27;superagent&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NUM_RETRIES</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="variable constant_">NUM_RETRIES</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> superagent.<span class="title function_">get</span>(<span class="string">&#x27;http://google.com/this-throws-an-error&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，如果<code>await</code>操作成功，就会使用<code>break</code>语句退出循环；如果失败，会被<code>catch</code>语句捕捉，然后进入下一轮循环。</p><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">somethingThatReturnsAPromise</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会报错，因为<code>await</code>用在普通函数之中了。但是，如果将<code>forEach</code>方法的参数改成<code>async</code>函数，也有问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">doc</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可能不会正常工作，原因是这时三个<code>db.post()</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用<code>for</code>循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是使用数组的<code>reduce()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (_, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> _;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;, <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，<code>reduce()</code>方法的第一个参数是<code>async</code>函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用<code>await</code>等待它操作结束。另外，<code>reduce()</code>方法返回的是<code>docs</code>数组最后一个成员的<code>async</code>函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上<code>await</code>。</p><p>上面的<code>reduce()</code>的参数函数里面没有<code>return</code>语句，原因是这个函数的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函数不管有没有<code>return</code>语句，总是返回一个 Promise 对象，所以这里的<code>return</code>是不必要的。</p><p>如果确实希望多个请求并发执行，可以使用<code>Promise.all</code>方法。当三个请求都会<code>resolved</code>时，下面两种写法效果相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四点，async 函数可以保留运行堆栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title function_">b</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">c</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>a</code>内部运行了一个异步任务<code>b()</code>。当<code>b()</code>运行的时候，函数<code>a()</code>不会中断，而是继续执行。等到<code>b()</code>运行结束，可能<code>a()</code>早就运行结束了，<code>b()</code>所在的上下文环境已经消失了。如果<code>b()</code>或<code>c()</code>报错，错误堆栈将不包括<code>a()</code>。</p><p>现在将这个例子改成<code>async</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">a</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">b</span>();</span><br><span class="line">  <span class="title function_">c</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>b()</code>运行的时候，<code>a()</code>是暂停执行，上下文环境都保存着。一旦<code>b()</code>或<code>c()</code>报错，错误堆栈将包括<code>a()</code>。</p><h2 id="async-函数的实现原理"><a href="#async-函数的实现原理" class="headerlink" title="async 函数的实现原理"></a>async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的<code>async</code>函数都可以写成上面的第二种形式，其中的<code>spawn</code>函数就是自动执行器。</p><p>下面给出<code>spawn</code>函数的实现，基本就是前文自动执行器的翻版。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">genF</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = <span class="title function_">genF</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">nextF</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = <span class="title function_">nextF</span>();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(next.<span class="property">value</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(next.<span class="property">value</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="title function_">next</span>(v); &#125;);</span><br><span class="line">      &#125;, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="keyword">throw</span>(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">step</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> gen.<span class="title function_">next</span>(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与其他异步处理方法的比较"><a href="#与其他异步处理方法的比较" class="headerlink" title="与其他异步处理方法的比较"></a>与其他异步处理方法的比较</h2><p>我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。</p><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是 Promise 的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空的Promise</span></span><br><span class="line">  <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用then方法，添加所有动画</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">    p = p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class="line">  <span class="keyword">return</span> p.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（<code>then</code>、<code>catch</code>等等），操作本身的语义反而不容易看出来。</p><p>接着是 Generator 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">spawn</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在<code>spawn</code>函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的<code>spawn</code>函数就是自动执行器，它返回一个 Promise 对象，而且必须保证<code>yield</code>语句后面的表达式，必须返回一个 Promise。</p><p>最后是 async 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> <span class="title function_">anim</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。</p><h2 id="实例：按顺序完成异步操作"><a href="#实例：按顺序完成异步操作" class="headerlink" title="实例：按顺序完成异步操作"></a>实例：按顺序完成异步操作</h2><p>实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>Promise 的写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 远程读取所有URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  textPromises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">chain, textPromise</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chain.<span class="title function_">then</span>(<span class="function">() =&gt;</span> textPromise)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">text</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(text));</span><br><span class="line">  &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用<code>fetch</code>方法，同时远程读取一组 URL。每个<code>fetch</code>操作都返回一个 Promise 对象，放入<code>textPromises</code>数组。然后，<code>reduce</code>方法依次处理每个 Promise 对象，然后使用<code>then</code>，将所有 Promise 对象连起来，因此就可以依次输出结果。</p><p>这种写法不太直观，可读性比较差。下面是 async 函数实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> response.<span class="title function_">text</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">logInOrder</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.<span class="title function_">map</span>(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><h2 id="顶层-await"><a href="#顶层-await" class="headerlink" title="顶层 await"></a>顶层 await</h2><p>根据语法规格，<code>await</code>命令只能出现在 async 函数内部，否则都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>await</code>命令独立使用，没有放在 async 函数里面，就会报错。</p><p>目前，有一个<a href="https://github.com/tc39/proposal-top-level-await">语法提案</a>，允许在模块的顶层独立使用<code>await</code>命令，使得上面那行代码不会报错了。这个提案的目的，是借用<code>await</code>解决模块异步加载的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，模块<code>awaiting.js</code>的输出值<code>output</code>，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量<code>output</code>才会有值，否则就返回<code>undefined</code>。</p><p>上面的代码也可以写成立即执行函数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>下面是加载这个模块的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>outputPlusValue()</code>的执行结果，完全取决于执行的时间。如果<code>awaiting.js</code>里面的异步操作没执行完，加载进来的<code>output</code>的值就是<code>undefined</code>。</p><p>目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">let</span> output;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dynamic = <span class="keyword">await</span> <span class="keyword">import</span>(someMission);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">  output = <span class="title function_">someProcess</span>(dynamic.<span class="property">default</span>, data);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">export</span> &#123; output &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>awaiting.js</code>除了输出<code>output</code>，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。</p><p>下面是加载这个模块的新的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> promise, &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，将<code>awaiting.js</code>对象的输出，放在<code>promise.then()</code>里面，这样就能保证异步操作完成以后，才去读取<code>output</code>。</p><p>这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的<code>usage.js</code>又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。</p><p>顶层的<code>await</code>命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// awaiting.js</span></span><br><span class="line"><span class="keyword">const</span> dynamic = <span class="keyword">import</span>(someMission);</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">fetch</span>(url);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> output = <span class="title function_">someProcess</span>((<span class="keyword">await</span> dynamic).<span class="property">default</span>, <span class="keyword">await</span> data);</span><br></pre></td></tr></table></figure><p>上面代码中，两个异步操作在输出的时候，都加上了<code>await</code>命令。只有等到异步操作完成，这个模块才会输出值。</p><p>加载这个模块的写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; output &#125; <span class="keyword">from</span> <span class="string">&quot;./awaiting.js&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputPlusValue</span>(<span class="params">value</span>) &#123; <span class="keyword">return</span> output + value &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">outputPlusValue</span>(<span class="number">100</span>), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。</p><p>这时，模块的加载会等待依赖模块（上例是<code>awaiting.js</code>）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的<code>output</code>，不会因为加载时机的不同，而得到不一样的值。</p><p>注意，顶层<code>await</code>只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的<code>require()</code>是同步加载，如果有顶层<code>await</code>，就没法处理加载了。</p><p>下面是顶层<code>await</code>的一些使用场景。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import() 方法加载</span></span><br><span class="line"><span class="keyword">const</span> strings = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">`/i18n/<span class="subst">$&#123;navigator.language&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作</span></span><br><span class="line"><span class="keyword">const</span> connection = <span class="keyword">await</span> <span class="title function_">dbConnector</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖回滚</span></span><br><span class="line"><span class="keyword">let</span> jQuery;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  jQuery = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn-a.com/jQuery&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  jQuery = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn-b.com/jQuery&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果加载多个包含顶层<code>await</code>命令的模块，加载命令是同步执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(r, <span class="number">1000</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;X2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// y.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// z.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./x.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./y.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Z&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面代码有三个模块，最后的<code>z.js</code>加载<code>x.js</code>和<code>y.js</code>，打印结果是<code>X1</code>、<code>Y</code>、<code>X2</code>、<code>Z</code>。这说明，<code>z.js</code>并没有等待<code>x.js</code>加载完成，再去加载<code>y.js</code>。</p><p>顶层的<code>await</code>命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本人有对此知识更为详细的学习笔记，于&lt;a href=&quot;https://gitee.com/hongjilin</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Class 的继承</title>
    <link href="https://k705.github.io/2024/04/08/Es6-21%E3%80%81Es6_Class%20%E7%9A%84%E7%BB%A7%E6%89%BF_day11-30/"/>
    <id>https://k705.github.io/2024/04/08/Es6-21%E3%80%81Es6_Class%20%E7%9A%84%E7%BB%A7%E6%89%BF_day11-30/</id>
    <published>2024-04-08T06:36:10.000Z</published>
    <updated>2024-04-09T09:28:15.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此笔记为网上<a href="http://caibaojian.com/es6/let.html">API文档摘录</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="#目录"></a>#目录</h1><blockquote><p>[TOC]</p></blockquote><h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p><p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColorPoint</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y, color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="variable language_">super</span>(x, y);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类的<code>constructor</code>方法没有调用<code>super</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super</code>方法之后就是正确的。</p><p>下面是生成子类实例的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">25</span>, <span class="number">8</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line"></span><br><span class="line">cp <span class="keyword">instanceof</span> <span class="title class_">ColorPoint</span> <span class="comment">// true</span></span><br><span class="line">cp <span class="keyword">instanceof</span> <span class="title class_">Point</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p><p>最后，父类的静态方法，也会被子类继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">hello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="title function_">hello</span>()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">ColorPoint</span>) === <span class="title class_">Point</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>B</code>的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例，因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">A</span>() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">B</span>() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">p</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">p</span>()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p><p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">p</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">m</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="property">p</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="property">m</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>) <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br><span class="line">b.<span class="title function_">m</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是<code>2</code>，而不是<code>1</code>。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="property">x</span>); <span class="comment">// undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.x</code>赋值为<code>3</code>，这时等同于对<code>this.x</code>赋值为<code>3</code>。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;static&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">myMethod</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">myMethod</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="title function_">myMethod</span>(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child.<span class="title function_">myMethod</span>(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">print</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">x</span> = <span class="number">3</span>;</span><br><span class="line">B.<span class="title function_">m</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>); <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>.<span class="title function_">valueOf</span>() <span class="keyword">instanceof</span> B); <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向<code>B</code>的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyObject: &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">toString</span>(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure><h2 id="类的-prototype-属性和-proto-属性"><a href="#类的-prototype-属性和-proto-属性" class="headerlink" title="类的 prototype 属性和__proto__属性"></a>类的 prototype 属性和__proto__属性</h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.<span class="property">__proto__</span> === A <span class="comment">// true</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 的实例继承 A 的实例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>, A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 继承 A 的静态属性</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title function_">B</span>();</span><br></pre></td></tr></table></figure><p>《对象的扩展》一章给出过<code>Object.setPrototypeOf</code>方法的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">setPrototypeOf</span> = <span class="keyword">function</span> (<span class="params">obj, proto</span>) &#123;</span><br><span class="line">  obj.<span class="property">__proto__</span> = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，就得到了上面的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B.<span class="property"><span class="keyword">prototype</span></span>, A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = A.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(B, A);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.<span class="property">__proto__</span> = A;</span><br></pre></td></tr></table></figure><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(A.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> = A.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure><p><code>extends</code>关键字后面可以跟多种类型的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被<code>B</code>继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Object</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property">__proto__</span> === <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p><p>第二种情况，不存在任何继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p><h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 proto 属性"></a>实例的 <strong>proto</strong> 属性</h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">ColorPoint</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.<span class="property">__proto__</span> === p1.<span class="property">__proto__</span> <span class="comment">// false</span></span><br><span class="line">p2.<span class="property">__proto__</span>.<span class="property">__proto__</span> === p1.<span class="property">__proto__</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">printName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Ha&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">printName</span>() <span class="comment">// &quot;Ha&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p><h2 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyArray</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">MyArray</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个继承 Array 的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">colors.<span class="property">length</span>  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Error</span>.<span class="title function_">call</span>(e))</span><br><span class="line"><span class="comment">// [ &#x27;stack&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(e)</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">MyArray</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.<span class="property">length</span> <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VersionedArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span> = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">commit</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">history</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="title function_">slice</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">revert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">length</span>, ...<span class="variable language_">this</span>.<span class="property">history</span>[<span class="variable language_">this</span>.<span class="property">history</span>.<span class="property">length</span> - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">VersionedArray</span>();</span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">2</span>);</span><br><span class="line">x <span class="comment">// [1, 2]</span></span><br><span class="line">x.<span class="property">history</span> <span class="comment">// [[]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">commit</span>();</span><br><span class="line">x.<span class="property">history</span> <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">push</span>(<span class="number">3</span>);</span><br><span class="line">x <span class="comment">// [1, 2, 3]</span></span><br><span class="line">x.<span class="property">history</span> <span class="comment">// [[], [1, 2]]</span></span><br><span class="line"></span><br><span class="line">x.<span class="title function_">revert</span>();</span><br><span class="line">x <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendableError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stack</span> = (<span class="keyword">new</span> <span class="title class_">Error</span>()).<span class="property">stack</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">constructor</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">ExtendableError</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">m</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myerror = <span class="keyword">new</span> <span class="title class_">MyError</span>(<span class="string">&#x27;ll&#x27;</span>);</span><br><span class="line">myerror.<span class="property">message</span> <span class="comment">// &quot;ll&quot;</span></span><br><span class="line">myerror <span class="keyword">instanceof</span> <span class="title class_">Error</span> <span class="comment">// true</span></span><br><span class="line">myerror.<span class="property">name</span> <span class="comment">// &quot;MyError&quot;</span></span><br><span class="line">myerror.<span class="property">stack</span></span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//     at MyError.ExtendableError</span></span><br><span class="line"><span class="comment">//     ...</span></span><br></pre></td></tr></table></figure><p>注意，继承<code>Object</code>的子类，有一个<a href="http://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object">行为差异</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewObj</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Object</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">NewObj</span>(&#123;<span class="attr">attr</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">o.<span class="property">attr</span> === <span class="literal">true</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p><h2 id="Mixin-模式的实现"><a href="#Mixin-模式的实现" class="headerlink" title="Mixin 模式的实现"></a>Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">...mixins</span>) &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Mix</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        <span class="title function_">copyProperties</span>(<span class="variable language_">this</span>, <span class="keyword">new</span> <span class="title function_">mixin</span>()); <span class="comment">// 拷贝实例属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>, mixin); <span class="comment">// 拷贝静态属性</span></span><br><span class="line">    <span class="title function_">copyProperties</span>(<span class="title class_">Mix</span>.<span class="property"><span class="keyword">prototype</span></span>, mixin.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 拷贝原型属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mix</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyProperties</span>(<span class="params">target, source</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key !== <span class="string">&#x27;constructor&#x27;</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">&#x27;prototype&#x27;</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">&#x27;name&#x27;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">let</span> desc = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(source, key);</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, desc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedEdit</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mix</span>(<span class="title class_">Loggable</span>, <span class="title class_">Serializable</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此笔记为网上&lt;a href=&quot;http://caibaojian.com/es6/let.html&quot;&gt;API文档摘录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="ES" scheme="https://k705.github.io/tags/ES/"/>
    
  </entry>
  
</feed>
