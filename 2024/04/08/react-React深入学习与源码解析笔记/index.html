<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>深入学习React并尝试阅读理解React源码 | Hexo</title>
  <meta name="description" content="#说明 本笔记为本人洪深入学习React并尝试阅读理解React源码所记录笔记   –&gt;源码版本16.9.0 建议预备知识:react基础 学习过程及笔记记录时查阅借鉴的相关资料官方文档的源码概览;ILoveDevelop的React 源码解析;知乎的全栈潇晨的React系列文章、万字长文+图文并茂+全面解析 React 源码 - render 篇;前端桃园的Deep In React之浅谈">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习React并尝试阅读理解React源码">
<meta property="og:url" content="https://k705.github.io/2024/04/08/react-React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:description" content="#说明 本笔记为本人洪深入学习React并尝试阅读理解React源码所记录笔记   –&gt;源码版本16.9.0 建议预备知识:react基础 学习过程及笔记记录时查阅借鉴的相关资料官方文档的源码概览;ILoveDevelop的React 源码解析;知乎的全栈潇晨的React系列文章、万字长文+图文并茂+全面解析 React 源码 - render 篇;前端桃园的Deep In React之浅谈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://k705.github.io/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715165316019.png">
<meta property="og:image" content="https://k705.github.io/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715171023093.png">
<meta property="og:image" content="https://k705.github.io/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715180450728.png">
<meta property="og:image" content="https://k705.github.io/2024/04/08/react-React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715182038527.png">
<meta property="og:image" content="https://k705.github.io/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715184238480.png">
<meta property="article:published_time" content="2024-04-08T06:36:10.000Z">
<meta property="article:modified_time" content="2024-04-09T08:42:38.610Z">
<meta property="article:author" content="KK">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://k705.github.io/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715165316019.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://k705.github.io/2024/04/08/react-React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/index.html">
  
    <link rel="alternate" href="/atom.xml" title="KK" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/k705.github.io/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 7.1.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/k705.github.io/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">KK</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">前端工程师</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/k705.github.io/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/k705.github.io/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/k705.github.io/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/k705.github.io/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/k705.github.io/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/k705.github.io/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/k705.github.io/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/k705.github.io/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/k705.github.io/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Ajax/" rel="tag">Ajax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/AntDesign/" rel="tag">AntDesign</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Axios/" rel="tag">Axios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/ES/" rel="tag">ES</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Git/" rel="tag">Git</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/HTML-CSS/" rel="tag">HTML+CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Html/" rel="tag">Html</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/JS/" rel="tag">JS</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Java/" rel="tag">Java</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Js/" rel="tag">Js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Js%E5%B7%A5%E5%85%B7%E5%BA%93/" rel="tag">Js工具库</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/TS/" rel="tag">TS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Umi/" rel="tag">Umi</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Vue2/" rel="tag">Vue2</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/Vue3/" rel="tag">Vue3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/antDesign/" rel="tag">antDesign</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/go/" rel="tag">go</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/jQuery/" rel="tag">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/react/" rel="tag">react</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">云服务器</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag">代码规范</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E5%89%8D%E7%AB%AFUI%E5%BA%93/" rel="tag">前端UI库</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E5%B0%81%E8%A3%85JavaScript%E5%B7%A5%E5%85%B7%E5%8C%85/" rel="tag">封装JavaScript工具包</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/" rel="tag">底层知识</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" rel="tag">快速参考备忘清单</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/k705.github.io/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">23</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/k705.github.io/tags/Ajax/" style="font-size: 13px;">Ajax</a> <a href="/k705.github.io/tags/AntDesign/" style="font-size: 13px;">AntDesign</a> <a href="/k705.github.io/tags/Axios/" style="font-size: 13.08px;">Axios</a> <a href="/k705.github.io/tags/CSS/" style="font-size: 13.31px;">CSS</a> <a href="/k705.github.io/tags/ES/" style="font-size: 13.92px;">ES</a> <a href="/k705.github.io/tags/Git/" style="font-size: 13.23px;">Git</a> <a href="/k705.github.io/tags/HTML-CSS/" style="font-size: 13px;">HTML+CSS</a> <a href="/k705.github.io/tags/Html/" style="font-size: 13px;">Html</a> <a href="/k705.github.io/tags/JS/" style="font-size: 13.77px;">JS</a> <a href="/k705.github.io/tags/Java/" style="font-size: 13.54px;">Java</a> <a href="/k705.github.io/tags/Js/" style="font-size: 13px;">Js</a> <a href="/k705.github.io/tags/Js%E5%B7%A5%E5%85%B7%E5%BA%93/" style="font-size: 13.23px;">Js工具库</a> <a href="/k705.github.io/tags/Mysql/" style="font-size: 13.08px;">Mysql</a> <a href="/k705.github.io/tags/TS/" style="font-size: 13.15px;">TS</a> <a href="/k705.github.io/tags/Umi/" style="font-size: 13.08px;">Umi</a> <a href="/k705.github.io/tags/Vue/" style="font-size: 13.38px;">Vue</a> <a href="/k705.github.io/tags/Vue2/" style="font-size: 13.77px;">Vue2</a> <a href="/k705.github.io/tags/Vue3/" style="font-size: 13px;">Vue3</a> <a href="/k705.github.io/tags/antDesign/" style="font-size: 13px;">antDesign</a> <a href="/k705.github.io/tags/go/" style="font-size: 13px;">go</a> <a href="/k705.github.io/tags/jQuery/" style="font-size: 13px;">jQuery</a> <a href="/k705.github.io/tags/nodejs/" style="font-size: 13.46px;">nodejs</a> <a href="/k705.github.io/tags/react/" style="font-size: 13.54px;">react</a> <a href="/k705.github.io/tags/webpack/" style="font-size: 13.23px;">webpack</a> <a href="/k705.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.23px;">云服务器</a> <a href="/k705.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 13px;">代码规范</a> <a href="/k705.github.io/tags/%E5%89%8D%E7%AB%AFUI%E5%BA%93/" style="font-size: 13.38px;">前端UI库</a> <a href="/k705.github.io/tags/%E5%B0%81%E8%A3%85JavaScript%E5%B7%A5%E5%85%B7%E5%8C%85/" style="font-size: 13.69px;">封装JavaScript工具包</a> <a href="/k705.github.io/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.08px;">工具</a> <a href="/k705.github.io/tags/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/" style="font-size: 13.62px;">底层知识</a> <a href="/k705.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 13px;">微信小程序</a> <a href="/k705.github.io/tags/%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" style="font-size: 14px;">快速参考备忘清单</a> <a href="/k705.github.io/tags/%E6%AD%A3%E5%88%99/" style="font-size: 13.08px;">正则</a> <a href="/k705.github.io/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 13.62px;">软件</a> <a href="/k705.github.io/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">配置</a> <a href="/k705.github.io/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.85px;">面试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/k705.github.io/archives/2024/04/">四月 2024</a><span class="archive-list-count">241</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/k705.github.io/2024/04/25/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" class="title">代码规范</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-25T09:08:57.000Z" itemprop="datePublished">2024-04-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/k705.github.io/2024/04/25/%E5%B7%A5%E5%85%B7-vscode%20%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E5%B7%A7/" class="title">vscode 功能与技巧</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-25T03:22:46.000Z" itemprop="datePublished">2024-04-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/k705.github.io/2024/04/22/Vue3-pure-admin/" class="title">Vue3-pure-admin</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-22T01:58:28.000Z" itemprop="datePublished">2024-04-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/k705.github.io/2024/04/08/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="title">Ajax笔记</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-08T06:36:10.000Z" itemprop="datePublished">2024-04-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/k705.github.io/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-Table%E5%8F%8A%E5%85%B6%E7%AD%9B%E9%80%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/" class="title">AntDesign封装</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-08T06:36:10.000Z" itemprop="datePublished">2024-04-08</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-react-React深入学习与源码解析笔记" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      深入学习React并尝试阅读理解React源码
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/k705.github.io/2024/04/08/react-React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/" class="article-date">
	  <time datetime="2024-04-08T06:36:10.000Z" itemprop="datePublished">2024-04-08</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/k705.github.io/tags/react/" rel="tag">react</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/k705.github.io/2024/04/08/react-React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote>
<p>本笔记为本人<code>洪</code>深入学习React并尝试阅读理解React源码所记录笔记   –&gt;<code>源码版本16.9.0</code></p>
<p>建议预备知识:react基础</p>
<p>学习过程及笔记记录时查阅借鉴的相关资料官方文档的<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/codebase-overview.html">源码概览</a>;ILoveDevelop的<a target="_blank" rel="noopener" href="https://react.jokcy.me/"><code>React 源码解析</code></a>;知乎的<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/qbtqiuqiu">全栈潇晨</a>的React系列文章、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022105022"><code>万字长文+图文并茂+全面解析 React 源码 - render 篇</code></a>;前端桃园的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556940&idx=1&sn=d40506db3d4d78da9a94ae6c7dc61af6&chksm=80255b8db752d29bbb8edc79eb40ce4122f3fddca121a53a5c3f859259cf4b1d7402ff676a84&scene=21#wechat_redirect"><code>Deep In React之浅谈 React Fiber 架构</code></a>;还有<code>公司前辈的技术分享</code></p>
<p>除此笔记外大家可以看我其他笔记 :<strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master">全栈笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E7%AE%97%E6%B3%95%E5%8F%8A%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">编程_前端开发学习笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">编程_后台服务端学习笔记</a></strong> 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java">Java</a>** 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Nodejs">Nodejs</a>** 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HTML+CSS+JS%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/JavaScript%E7%AC%94%E8%AE%B0">JavaScript笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0">编程工具使用笔记</a>** 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/A_%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83">前端代码规范</a>** 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ES6%E5%8F%8A%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">ES6及后续版本学习笔记</a>** 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88">Vue笔记整合</a>** 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0">React笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">微信小程序学习笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chrome%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Chrome开发使用及学习笔记</a>** 以及许多其他笔记就不一一例举了</p>
<p>本人的React学习笔记分类(也是对应本人技术成长路程):[<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0/React%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><code>想快速入门看这部分</code></a>]、[<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Scss%E7%AC%94%E8%AE%B0"><code>想对React基础系统全面进行学习的同学看这里</code></a>]、[<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0"><code>对基础学习完成且有了一定开发经验,想尝试解析源码的看这里</code></a>]</p>
</blockquote>
<h1 id="目录​"><a href="#目录​" class="headerlink" title="#目录	​"></a>#目录	​</h1><blockquote>
<p>[TOC]</p>
</blockquote>
<h1 id="一、React基础知识总结"><a href="#一、React基础知识总结" class="headerlink" title="一、React基础知识总结"></a>一、React基础知识总结</h1><blockquote>
<p>在深入学习前,还是先捋一捋对于React基础知识的理解与总结</p>
<p>如果想看详细的React基础知识点笔记,可以看本人 <strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0">React系统学习笔记</a></strong> </p>
</blockquote>
<h2 id="1、JSX"><a href="#1、JSX" class="headerlink" title="1、JSX"></a>1、JSX</h2><blockquote>
<p>这东西不用解释我为啥放在第一位说了吧,基本上我们大部分React开发者都是用jsx进行代码编写的</p>
<p>这里不着重讲解基础语法,只是给出自己的理解与总结,有需要了解基础语法的同学  –&gt;<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/jsx-in-depth.html">点我跳转</a></p>
</blockquote>
<h3 id="Ⅰ-我们认为的JSX是什么"><a href="#Ⅰ-我们认为的JSX是什么" class="headerlink" title="Ⅰ-我们认为的JSX是什么?"></a>Ⅰ-我们认为的JSX是什么?</h3><blockquote>
<p>我们认为的JSX是什么? &#x3D;&#x3D;&#x3D;&gt;  <code> 类HTML的语法?  React里面的模板语法?  语法糖?</code></p>
<ul>
<li>其实应该都算是对的,但是有好像不是完全对.如果只讲里面的一点的话又有所欠缺的感觉</li>
</ul>
<blockquote>
<p>JSX是(JavaScript XML)的缩写,其实他本质上还是属于JavaScript,<code>不一定用在React上</code></p>
</blockquote>
<ul>
<li>此处借用React中文官网的一句话:</li>
</ul>
<blockquote>
<p>React不强制要求使用JSX,但是大多数人发现,在JS代码中将JSX与UI放在一起时,在视觉上会有辅助作用.它还可以使得React显示更多有用的错误和警告信息</p>
</blockquote>
<ul>
<li>它本身可以理解为是一个规范,开发者在JSX的帮助下,避免重复地学习不同框架或者库,因为在JSX的规范中,他产生的结果是一致的.用React的思想来说,JSX最终的作用是把模板语法解析成Component、props、children….等等;而具体怎么利用这些产物,就是不同的框架或者库的特性了,比如下面的一个组件它被解析以后其实产生的是一段代码段,并且有固定的参数位置</li>
</ul>
<blockquote>
<p><img src="/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715165316019.png" alt="image-20210715165316019"></p>
<p>由上图可以看出JSX的产物(h函数名称和h函数的参数),它很像虚拟DOM</p>
</blockquote>
</blockquote>
<h3 id="Ⅱ-JSX的产物"><a href="#Ⅱ-JSX的产物" class="headerlink" title="Ⅱ-JSX的产物"></a>Ⅱ-JSX的产物</h3><h4 id="①-简单的JSX产物"><a href="#①-简单的JSX产物" class="headerlink" title="① 简单的JSX产物"></a>① 简单的JSX产物</h4><blockquote>
<p>以下是一个最简单的JSX编译后的结果</p>
<p><img src="/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715171023093.png" alt="image-20210715171023093"> </p>
<p>JSX的产物可以理解是基于JSX代码,利用一个函数模板(如同<a href="#%E2%85%A0-%E6%88%91%E4%BB%AC%E8%AE%A4%E4%B8%BA%E7%9A%84JSX%E6%98%AF%E4%BB%80%E4%B9%88?"><code>Ⅰ</code></a>中图示的[h]函数),生成一段[<code>调用</code>]函数模板,然后里面的函数名可能在不同的框架或者库中是不一样的,他没有实现h函数,需要框架或者库自己实现</p>
<p>可以得出一个大胆的结论:<code>JSX理论上是完全跨平台的,只要有人实现它在对应平台的[h]函数,它甚至可以在任何支持JS语言的平台上运行</code></p>
</blockquote>
<h4 id="②-Rreact中的JSX产物"><a href="#②-Rreact中的JSX产物" class="headerlink" title="② Rreact中的JSX产物"></a>② Rreact中的JSX产物</h4><blockquote>
<ul>
<li>作为React的官方指定语法,JSX允许用户在JS代码中插入HTML代码.但是这种写法<code>浏览器是无法解析的</code>,他们就需要一个转换器</li>
</ul>
<blockquote>
<p><code>Babel</code>就充当了这样一个角色，他在JSX代码编译时候将其转换成JS文件，这样浏览器就能解析了。</p>
</blockquote>
<ul>
<li>JSX有JS和HTMl两种写法，本身就是JS写法的其实是不需要转换的</li>
</ul>
<blockquote>
<p>当然也不能说的这么绝对，有时候Babel会为了兼容性的缘故将高版本的语法翻译到低版本，这部分不在讨论范围。我们要关注的其实是HTMl的处理方式</p>
</blockquote>
</blockquote>
<h5 id="代码转换示例与解析"><a href="#代码转换示例与解析" class="headerlink" title="代码转换示例与解析"></a>代码转换示例与解析</h5><blockquote>
<ol>
<li>比如下面这行代码：</li>
</ol>
<blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;name&#x27;</span>&gt;</span>Tom and Jerry<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;---------------通过<span class="title class_">Babel</span>转换后生成的代码是：-------------------------</span><br><span class="line"> </span><br><span class="line">&gt;<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="string">&quot;name&quot;</span></span><br><span class="line">&gt;&#125;, <span class="string">&quot;Tom and Jerry&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>HTML语法转变成了JS语法，简单来说，我们所写的JSX最终变成了JS。</p>
</blockquote>
<ol start="2">
<li>复杂点的例子</li>
</ol>
<blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;wrapper&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;id_wrapper&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">span</span>&gt;</span>Jerry<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&gt;----------- 通过<span class="title class_">Babel</span>转换后生成的代码是： ---------------------</span><br><span class="line"> </span><br><span class="line">&gt;<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line"> <span class="attr">class</span>: <span class="string">&quot;wrapper&quot;</span>,</span><br><span class="line"> <span class="attr">id</span>: <span class="string">&quot;id_wrapper&quot;</span></span><br><span class="line">&gt;&#125;, <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Tom&quot;</span>), <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Jerry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>转换规则是比较简单的，React.createElement的第一个参数是节点类型；第二个参数是该节点的属性，以key：value的形式作为一个对象，后面的所有参数都是该节点的子节点。</p>
</blockquote>
<ol start="3">
<li>自定义组件</li>
</ol>
<blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Comp</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;&lt;div&gt;Tom and Jerry&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">Comp</span>&gt;</span><span class="tag">&lt;/<span class="name">Comp</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;-------------- 通过<span class="title class_">Babel</span>转换后生成的代码是：  ---------------------------------</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Comp</span>(<span class="params"></span>) &#123;  <span class="keyword">return</span> <span class="string">&#x27;&lt;div&gt;Tom and Jerry&lt;/div&gt;&#x27;</span>; &#125;</span><br><span class="line">&gt;<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Comp</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>可以看出，React.createElement的第一个参数变成了一个变量，而不是一个字符串，<code>尝试将函数Comp首字母小写</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">comp</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;&lt;div&gt;Tom and Jerry&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">comp</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;--------------  通过<span class="title class_">Babel</span>转换后生成的代码是：-------------------------------------------</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">comp</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;&lt;div&gt;Tom and Jerry&lt;/div&gt;&#x27;</span>; &#125;</span><br><span class="line">&gt;<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;comp&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>React.createElement的第一个参数又变成了一个字符串。<br>这也就是我们在React中写组件的时候，<code>为什么会要求首字母大写的原因</code>，Babel在编译的时候会将首字母小写的组件视为原生的HTMl节点进行处理，如果我们将自定义组件首字母小写，后续的程序将无法识别这个组件，最终会报错。</p>
</blockquote>
</blockquote>
<h3 id="Ⅲ-React为什么选择JSX"><a href="#Ⅲ-React为什么选择JSX" class="headerlink" title="Ⅲ-React为什么选择JSX?"></a>Ⅲ-React为什么选择JSX?</h3><blockquote>
<ul>
<li><p>对于一个人喜欢的事物,很多可以用一句话概括:<code>之所以选择X,是因为Y和Z不好,然后X有一个点能吸引你,那么X就是好的</code></p>
</li>
<li><p>但是放到技术上,要回答好这个问题,就需要先了解React可选的其他解决方案有什么不好的地方</p>
</li>
<li><p>其实相关的方案很多,最直观的就是<code>模板</code>:</p>
</li>
</ul>
<blockquote>
<p>其实Vue与Angular都是用的模板语法,他们上手简单这是事实,但是<code>对于React团队来说它并不纯粹!!</code></p>
<p>它引入了很多新的概念,需要去学习模板指令、模板语法等(如Vue需要理解v-if、v-for等),而JSX就没前者这么复杂,它不需要学习新的开发方式,虽然它也有模板的味道,但它本身能直接支持JS写法(如条件表达式和循环等)</p>
</blockquote>
</blockquote>
<h2 id="2、ReactElement"><a href="#2、ReactElement" class="headerlink" title="2、ReactElement"></a>2、ReactElement</h2><blockquote>
<p>为何这个放在JSX下方,因为此知识有jsx做铺垫就容易理解很多,有做对比更易理解</p>
</blockquote>
<h3 id="Ⅰ-React-createElement函数"><a href="#Ⅰ-React-createElement函数" class="headerlink" title="Ⅰ-React.createElement函数"></a>Ⅰ-React.createElement函数</h3><blockquote>
<p>通过Babel编译后的JS代码，频繁出现React.createElement这个函数。这个函数的返回值就是ReactElement，通过上面的示例可以看出，React.createElement函数的入参有三个，或者说三类</p>
</blockquote>
<h4 id="①-type"><a href="#①-type" class="headerlink" title="① type"></a>① type</h4><blockquote>
<p>type指代这个<code>ReactElement的类型</code></p>
<ol>
<li>字符串比如div，p代表原生DOM，称为HostComponent</li>
<li>Class类型是我们继承自Component或者PureComponent的组件，称为ClassComponent</li>
<li>方法就是functional Component</li>
<li>原生提供的Fragment、AsyncMode等是Symbol，会被特殊处理</li>
</ol>
</blockquote>
<h4 id="②-config"><a href="#②-config" class="headerlink" title="② config"></a>② config</h4><blockquote>
<p>参照上面Babel编译后的代码，所有节点的属性都会以Key:Value的形式放到config对象中。</p>
</blockquote>
<h4 id="③-children"><a href="#③-children" class="headerlink" title="③ children"></a>③ children</h4><blockquote>
<p>子节点不止会有一个，所以children不只有一个，从第二个参数以后的所有参数都是children，它是一个数组</p>
</blockquote>
<h3 id="Ⅱ-ReactElement的结构"><a href="#Ⅱ-ReactElement的结构" class="headerlink" title="Ⅱ-ReactElement的结构"></a>Ⅱ-ReactElement的结构</h3><blockquote>
<ol>
<li>[<code>$$typeof</code>] 是一个常量，所有通过React.createElement生成的元素都有这个值。一般使用 React 的组件都是挂到父组件的 this.props.children 上面，但是也有例外，比如要实现一个模态框，就需要将模态框挂载到body节点下，这个时候需要使用ReactDOM.createPortals(child, container)这个函数实现，这个函数生成的$$typeof值就是REACT_PORTAL_TYPE。 –&gt;<code>用于确定是否属于ReactElement</code></li>
<li>[<code>type</code>]指代这个ReactElement的类型 –&gt;<code>用作判断如何创建节点</code></li>
<li>[<code>key]</code>和[<code>ref</code>]都是从config对象中找到的特殊配置，将其单独抽取出来，放在ReactElement下</li>
<li>[<code>props</code>]包含了两部分，第一部分是去除了key和ref的config，第二部分是children数组，数组的成员也是通过React.createElement生成的对象  –&gt;<code>新的属性内容</code></li>
<li>_owner在16.7的版本上是Fiber，Fiber是react16+版本的核心,也是调度算法</li>
</ol>
<p>这些信息对于后期构建应用的树结构是非常重要的,<strong><code>而React通过提供这种类型的数据，来脱离平台的限制</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="comment">// 这个标签允许我们唯一地将其标识为React元素  </span></span><br><span class="line">  <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//属于元素的内置属性  </span></span><br><span class="line">  <span class="attr">type</span>: type,</span><br><span class="line">  <span class="attr">key</span>: key,</span><br><span class="line">  <span class="attr">ref</span>: ref,</span><br><span class="line">  <span class="attr">props</span>: props,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录负责创建此元素的组件。</span></span><br><span class="line">  <span class="attr">_owner</span>: owner,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它就是一个简单的对象，为了看清楚这个对象的创建规则，我们举个例子。 首先是我们写的JSX：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;class_name&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;id_name&#x27;</span> <span class="attr">key</span>=<span class="string">&#x27;key_name&#x27;</span> <span class="attr">ref</span>=<span class="string">&#x27;ref_name&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Jerry<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>它会被Babel编译为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">class</span>: <span class="string">&quot;class_name&quot;</span>,</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;id_name&quot;</span>,</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;key_name&quot;</span>,</span><br><span class="line">  <span class="attr">ref</span>: <span class="string">&quot;ref_name&quot;</span></span><br><span class="line">&gt;&#125;, <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Tom&quot;</span>), <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Jerry&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>它会生成这样一个Element</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">  <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_ELEMENT_TYPE</span>,</span><br><span class="line">  type：<span class="string">&#x27;div&#x27;</span>，</span><br><span class="line">  <span class="attr">key</span>: <span class="string">&#x27;key_name&#x27;</span>,</span><br><span class="line">  <span class="attr">ref</span>: <span class="string">&quot;ref_name&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">class</span>: <span class="string">&quot;class_name&quot;</span>,</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;id_name&quot;</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">          <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Tom&quot;</span>),</span><br><span class="line">          <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Jerry&quot;</span>)</span><br><span class="line">      ]</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="attr">_owner</span>: <span class="title class_">ReactCurrentOwner</span>.<span class="property">current</span>,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3、React-API-梳理"><a href="#3、React-API-梳理" class="headerlink" title="3、React API 梳理"></a>3、React API 梳理</h2><h3 id="Ⅰ-暴露出来的API"><a href="#Ⅰ-暴露出来的API" class="headerlink" title="Ⅰ-暴露出来的API"></a>Ⅰ-暴露出来的API</h3><blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\React.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">React</span> = &#123;</span><br><span class="line"> <span class="title class_">Children</span>: &#123;</span><br><span class="line">   map,</span><br><span class="line">   forEach,</span><br><span class="line">   count,</span><br><span class="line">   toArray,</span><br><span class="line">   only,</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> createRef,</span><br><span class="line"> <span class="title class_">Component</span>,</span><br><span class="line"> <span class="title class_">PureComponent</span>,</span><br><span class="line"></span><br><span class="line"> createContext,</span><br><span class="line"> forwardRef,</span><br><span class="line"> lazy,</span><br><span class="line"> memo,</span><br><span class="line"></span><br><span class="line"> useCallback,</span><br><span class="line"> useContext,</span><br><span class="line"> useEffect,</span><br><span class="line"> useImperativeHandle,</span><br><span class="line"> useDebugValue,</span><br><span class="line"> useLayoutEffect,</span><br><span class="line"> useMemo,</span><br><span class="line"> useReducer,</span><br><span class="line"> useRef,</span><br><span class="line"> useState,</span><br><span class="line"></span><br><span class="line"> <span class="title class_">Fragment</span>: <span class="variable constant_">REACT_FRAGMENT_TYPE</span>,</span><br><span class="line"> <span class="title class_">Profiler</span>: <span class="variable constant_">REACT_PROFILER_TYPE</span>,</span><br><span class="line"> <span class="title class_">StrictMode</span>: <span class="variable constant_">REACT_STRICT_MODE_TYPE</span>,</span><br><span class="line"> <span class="title class_">Suspense</span>: <span class="variable constant_">REACT_SUSPENSE_TYPE</span>,</span><br><span class="line"> <span class="attr">unstable_SuspenseList</span>: <span class="variable constant_">REACT_SUSPENSE_LIST_TYPE</span>,</span><br><span class="line"></span><br><span class="line"> <span class="attr">createElement</span>: __DEV__ ? createElementWithValidation : createElement,</span><br><span class="line"> <span class="attr">cloneElement</span>: __DEV__ ? cloneElementWithValidation : cloneElement,</span><br><span class="line"> <span class="attr">createFactory</span>: __DEV__ ? createFactoryWithValidation : createFactory,</span><br><span class="line"> <span class="attr">isValidElement</span>: isValidElement,</span><br><span class="line"></span><br><span class="line"> <span class="attr">version</span>: <span class="title class_">ReactVersion</span>,</span><br><span class="line"></span><br><span class="line"> <span class="attr">unstable_withSuspenseConfig</span>: withSuspenseConfig,</span><br><span class="line"></span><br><span class="line"> <span class="attr">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>: <span class="title class_">ReactSharedInternals</span>,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>挑一些常见的分析下用法和源码</p>
</blockquote>
<h3 id="Ⅱ-createRef"><a href="#Ⅱ-createRef" class="headerlink" title="Ⅱ-createRef"></a>Ⅱ-createRef</h3><blockquote>
<p>react获得ref的方式有三种</p>
<ul>
<li>String ref 方式(被废弃)</li>
<li>callback ref 方式</li>
<li><code>React.createRef</code> (16.3版本新增特性)</li>
</ul>
<p>代码举例:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;----------------------- string ref -------------------------</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">myRef</span>.<span class="title function_">focus</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;myRef&quot;</span> /&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;------------------------ callback ref-------------------------</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="title function_">focus</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(ele)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">     this.myRef = ele;</span></span><br><span class="line"><span class="language-xml">   &#125;&#125; /&gt;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;---------------------- <span class="title class_">React</span>.<span class="property">createRef</span> ------------------------</span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>(props);</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>查看 React.createRef 的源码，<code>发现只是生成了一个对象，用于保存 current 的值</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactCreateRef.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createRef</span>(<span class="params"></span>): <span class="title class_">RefObject</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> refObject = &#123;</span><br><span class="line">   <span class="attr">current</span>: <span class="literal">null</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> refObject;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><code>React.createRef 并不负责将 dom 节点绑定 current 上面，它只负责生成对应的结构</code>。</p>
<p><code>真正做事的是 react-dom</code>。react 这么拆分，将公共的部分放在 react 中，而与平台相关的单独抽离，比如在移动端，负责将页面元素挂在到 current 字段上的就不是 <code>react-dom</code> 了，而是<code>react-native</code>。</p>
</blockquote>
<h3 id="Ⅲ-Component-PureComponent"><a href="#Ⅲ-Component-PureComponent" class="headerlink" title="Ⅲ-Component &amp; PureComponent"></a>Ⅲ-Component &amp; PureComponent</h3><h4 id="①-Component"><a href="#①-Component" class="headerlink" title="① Component:"></a>① Component:</h4><blockquote>
<p>Component源码</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactBaseClasses.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props, context, updater</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">props</span> = props;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">context</span> = context;</span><br><span class="line">&gt;<span class="comment">// 如果一个组件有字符串引用，我们将在以后分配一个不同的对象。  </span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">refs</span> = emptyObject;</span><br><span class="line">&gt;<span class="comment">// 初始化默认更新器，但真正的更新器由 renderer.</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">updater</span> = updater || <span class="title class_">ReactNoopUpdateQueue</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span>(<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forceUpdate</span> = <span class="keyword">function</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueForceUpdate</span>(<span class="variable language_">this</span>, callback, <span class="string">&#x27;forceUpdate&#x27;</span>);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>Component 中维护了4个变量，props，context，refs 以及 updater。前三者都是我们常见的，updater 是与平台相关的，他基本负责了 react 中的所有任务，包括数据更新，界面渲染等一系列的工作。</p>
<p>以下是 Component 的数据结构，f 表示函数，省略号表示暂时不用关注</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line">&gt;props<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;context<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;refs<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;updater<span class="punctuation">:</span> <span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;state<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">&gt;__proto__<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">constructor<span class="punctuation">:</span> class Demo，</span><br><span class="line">render<span class="punctuation">:</span> f</span><br><span class="line">__proto__<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  constructor<span class="punctuation">:</span> f<span class="punctuation">,</span></span><br><span class="line">  setState<span class="punctuation">:</span> f<span class="punctuation">,</span></span><br><span class="line">  forceUpdate<span class="punctuation">:</span> f<span class="punctuation">,</span></span><br><span class="line">  isReactComponent<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>eact 中的声明周期不是在 Component 中定义的</code>，这一点在后续的章节会详细讲解。</p>
</blockquote>
<h4 id="②-PureComponent"><a href="#②-PureComponent" class="headerlink" title="② PureComponent"></a>② PureComponent</h4><blockquote>
<p>和 Component 是基本一致的，只是比 Component 多了一个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;pureComponentPrototype.<span class="property">isPureReactComponent</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>以下是 PureComponent 的数据结构</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line">&gt;props<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;context<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;refs<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;updater<span class="punctuation">:</span> <span class="punctuation">&#123;</span>...<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">&gt;state<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">&gt;__proto__<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">constructor<span class="punctuation">:</span> class Demo，</span><br><span class="line">render<span class="punctuation">:</span> f</span><br><span class="line">__proto__<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  constructor<span class="punctuation">:</span> f<span class="punctuation">,</span></span><br><span class="line">  setState<span class="punctuation">:</span> f<span class="punctuation">,</span></span><br><span class="line">  forceUpdate<span class="punctuation">:</span> f<span class="punctuation">,</span></span><br><span class="line">  isReactComponent<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span>，</span><br><span class="line">  isPureReactComponent<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>  <span class="comment">//多了这个</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="③-多出的-isPureReactComponent-有什么用"><a href="#③-多出的-isPureReactComponent-有什么用" class="headerlink" title="③ 多出的[isPureReactComponent]有什么用?"></a>③ 多出的[<code>isPureReactComponent</code>]有什么用?</h4><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (ctor.<span class="property"><span class="keyword">prototype</span></span> &amp;&amp; ctor.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isPureReactComponent</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   !<span class="title function_">shallowEqual</span>(oldProps, newProps) || !<span class="title function_">shallowEqual</span>(oldState, newState)</span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这是检查组件是否需要更新的一个判断，<code>ctor</code>就是你声明的继承自<code>Component or PureComponent</code>的类，他会判断你是否继承自<code>PureComponent</code>，如果是的话就<code>shallowEqual</code>比较<code>state</code>和<code>props</code>。</p>
<p>顺便说一下：<strong>React中对比一个ClassComponent是否需要更新，只有两个地方。一是看有没有<code>shouldComponentUpdate</code>方法，二就是这里的<code>PureComponent</code>判断</strong></p>
</blockquote>
<h3 id="Ⅳ-createContext"><a href="#Ⅳ-createContext" class="headerlink" title="Ⅳ-createContext"></a>Ⅳ-createContext</h3><blockquote>
<p>createContext 是官方定稿的 context 方案，在这之前我们一直在用的老的 context API 都是 React 不推荐的 API，官方在17大版本会把老 API 去除。</p>
<p>Context 通过<code>组件树</code>提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。下面的例子展示了在顶层组件通过 [<code>Provider</code>] 的方式提供了一个值，在下层组件可以通过 [<code>Consumer</code>] 拿到，中间不需要任何的 props 传参。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;default&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Top</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> state = &#123; <span class="attr">contextValue</span>: <span class="string">&#x27;123&#x27;</span> &#125;;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.state.contextValue&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Bottom</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       &#123;value =&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>contextValue: &#123;value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Consumer</span>&gt;</span></span></span><br><span class="line">   )    </span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">Top</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">Bottom</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">Top</span>&gt;</span></span></span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure>

<p>查看React.createContext的源码，我摘出其中的重要代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactContext.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> createContext&lt;T&gt;(</span><br><span class="line"> <span class="attr">defaultValue</span>: T,</span><br><span class="line"> <span class="attr">calculateChangedBits</span>: ?<span class="function">(<span class="params">a: T, b: T</span>) =&gt;</span> number,</span><br><span class="line">&gt;): <span class="title class_">ReactContext</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> <span class="attr">context</span>: <span class="title class_">ReactContext</span>&lt;T&gt; = &#123;</span><br><span class="line">     <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_CONTEXT_TYPE</span>,</span><br><span class="line">     <span class="attr">_calculateChangedBits</span>: calculateChangedBits,</span><br><span class="line">     <span class="comment">//作为支持多个并发渲染器的解决方案，我们将其分类  </span></span><br><span class="line">     <span class="comment">//一些渲染器是主要的，另一些是次要的。 我们只希望  </span></span><br><span class="line">     <span class="comment">//最多有两个并发渲染器:React Native (primary)和  </span></span><br><span class="line">     <span class="comment">//面料(二级); React DOM(主要)和React ART(次要)。  </span></span><br><span class="line">     <span class="comment">//二级渲染器将它们的上下文值存储在单独的字段中。  </span></span><br><span class="line">     <span class="attr">_currentValue</span>: defaultValue,</span><br><span class="line">     <span class="attr">_currentValue2</span>: defaultValue,</span><br><span class="line">     <span class="comment">//用于跟踪当前有多少并发渲染此上下文  </span></span><br><span class="line">     <span class="comment">//在单个渲染器中支持。 例如并行服务器呈现。  </span></span><br><span class="line">     <span class="attr">_threadCount</span>: <span class="number">0</span>,</span><br><span class="line">     <span class="comment">// These are circular</span></span><br><span class="line">     <span class="title class_">Provider</span>: (<span class="attr">null</span>: any),</span><br><span class="line">     <span class="title class_">Consumer</span>: (<span class="attr">null</span>: any),</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> context.<span class="property">Provider</span> = &#123;</span><br><span class="line">   <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_PROVIDER_TYPE</span>,</span><br><span class="line">   <span class="attr">_context</span>: context,</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> context.<span class="property">Consumer</span> = context;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> context;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>createContext接收的是一个 <code>defaultValue</code> ，还有一个是 <code>calculateChangedBits</code> 。这是一个方法，这个方法接受 newValue 与 oldValue 的函数，返回值作为 changedBits，在 Provider 中，当 changedBits &#x3D; 0，将不再触发更新。</p>
<p>方法里面声明了一个 context 对象，有一个 $$typeof 属性，需要注意的是，<code>这个 [$$typeof]</code> 跟 <code>ReactElement的 [$$typeof] 是不一样的</code>。</p>
<p>下面列出了两个$$typeof的不同之处。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="punctuation">&#123;</span></span><br><span class="line"> $$typeof<span class="punctuation">:</span> REACT_ELEMENT_TYPE <span class="comment">// 其实是一个Symbol类型的标志</span></span><br><span class="line"> type<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   $$typeof<span class="punctuation">:</span> REACT_PROVIDER_TYPE <span class="comment">// 其实是一个Symbol类型的标志</span></span><br><span class="line">   _currentValue<span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">   ...</span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line">&gt;<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>_currentValue ， _currentValue2 这两个属性是一样的，只是用到的地方不一样。 _currentValue 这个 value 是用来记录 Provider 里面的这个 value 。 他有变化的情况下就会更新到这个 _currentValue 。是用来记录最新的 context 的值的。</p>
<p>context.Provider 有个属性 _context ，这个属性会指向这个 context。context.Consumer &#x3D; context。 <code>也就是说 Consumer 是等于自己的</code>。</p>
</blockquote>
<h3 id="Ⅴ-forwardRef"><a href="#Ⅴ-forwardRef" class="headerlink" title="Ⅴ-forwardRef"></a>Ⅴ-forwardRef</h3><blockquote>
<p><code>forwardRef</code>是用来解决HOC组件传递<code>ref</code>的问题的，所谓HOC就是<code>Higher Order Component(高阶组件)</code>，比如使用<code>redux</code>的时候，我们用<code>connect</code>来给组件绑定需要的state，这其中其实就是给我们的组件在外部包了一层组件，然后通过<code>...props</code>的方式把外部的<code>props</code>传入到实际组件</p>
<p>在低版本使用string ref的时候，ref 是不能加在 Component 上的。原因也很简单，ref 这个字段会被单独处理，不会传递到子组件上（<a href="#2%E3%80%81ReactElement"><code>详见ReactElement部分</code></a>）。React16之后，通过 forwardRef 就能实现父组件向子组件自动传递引用 ref。这种需求通常发生在需要处理焦点，动画，或者是集成第三方 Dom 库的时候。下面列举了一个处理输入框焦点的例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span>, createRef, forwardRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="comment">//forwardRef使用方式举例</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">FocusInput</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&gt;));</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">ForwardRef</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">     <span class="variable language_">super</span>(props);</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="title function_">createRef</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; current &#125; = <span class="variable language_">this</span>.<span class="property">ref</span>;</span><br><span class="line">   current.<span class="title function_">focus</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>forward ref<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">FocusInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.ref&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ForwardRef</span>;</span><br></pre></td></tr></table></figure>

<p>查看 forwardRef 源码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\forwardRef.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> forwardRef&lt;<span class="title class_">Props</span>, <span class="title class_">ElementType</span>: <span class="title class_">React</span>$ElementType&gt;(</span><br><span class="line">  <span class="comment">//render函数作为参数--&gt;即包装的FunctionComponent</span></span><br><span class="line"> <span class="attr">render</span>: <span class="function">(<span class="params">props: Props, ref: React$Ref&lt;ElementType&gt;</span>) =&gt;</span> <span class="title class_">React</span>$Node,</span><br><span class="line">&gt;) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">$$typeof</span>: <span class="variable constant_">REACT_FORWARD_REF_TYPE</span>,</span><br><span class="line">   render,</span><br><span class="line"> &#125;;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>被forwardRef包裹后，组件内部的$$typeof是<code>REACT_FORWARD_REF_TYPE</code></li>
<li>render即包装的FunctionComponent，ClassComponent是不用forwardRef的</li>
</ol>
</blockquote>
<h3 id="Ⅵ-四个类型"><a href="#Ⅵ-四个类型" class="headerlink" title="Ⅵ-四个类型"></a>Ⅵ-四个类型</h3><blockquote>
<ol>
<li>Fragment: REACT_FRAGMENT_TYPE</li>
<li>Profiler: REACT_PROFILER_TYPE</li>
<li>StrictMode: REACT_STRICT_MODE_TYPE</li>
<li>Suspense: REACT_SUSPENSE_TYPE</li>
</ol>
<p>这四个都是React提供的组件，但他们其实都只是占位符，都是一个Symbol，在React实际检测到他们的时候会做一些特殊的处理。</p>
</blockquote>
<h4 id="①-Fragment"><a href="#①-Fragment" class="headerlink" title="① Fragment"></a>① Fragment</h4><blockquote>
<p><code>Fragment 是我们使用最多的</code>，React 中一个常见模式是为一个组件返回多个元素。Fragments 可以让你聚合一个子元素列表，并且不在DOM中增加额外节点。 &lt;&gt; 是 的语法糖。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;&gt;</span> //<span class="tag">&lt;<span class="name">Fragment</span>&gt;</span><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span> 等同</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">ChildA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">ChildB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="②-Profiler"><a href="#②-Profiler" class="headerlink" title="② Profiler"></a>② Profiler</h4><blockquote>
<p>Profiler是用来测量渲染性能的，几乎不用。</p>
</blockquote>
<h4 id="③-StrictMode"><a href="#③-StrictMode" class="headerlink" title="③ StrictMode"></a>③ StrictMode</h4><blockquote>
<p>StrictMode 是一个用来突出显示应用程序中潜在问题的工具。与 Fragment 一样，StrictMode 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ExampleApplication</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">ComponentOne</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">ComponentTwo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的示例中，不会对 Header 和 Footer 组件运行严格模式检查。但是，<code>ComponentOne</code> 和 <code>ComponentTwo</code> 以及<code>它们的所有后代元素</code>都将进行检查。</p>
</blockquote>
<h4 id="④-Suspense"><a href="#④-Suspense" class="headerlink" title="④ Suspense"></a>④ Suspense</h4><blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>OtherComponent是通过懒加载加载进来的，所以渲染页面的时候可能会有延迟，<code>但使用了Suspense之后，可优化交互</code>。 在外面使用Suspense标签，并在fallback中声明OtherComponent加载完成前做的事，即可优化整个页面的交互</p>
<p>fallback 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 Suspense 组件置于懒加载组件之上的任何位置。你甚至可以用一个 Suspense 组件包裹多个懒加载组件。</p>
</blockquote>
<h3 id="Ⅶ-四个Element-API"><a href="#Ⅶ-四个Element-API" class="headerlink" title="Ⅶ-四个Element API"></a>Ⅶ-四个Element API</h3><h4 id="①-createElement"><a href="#①-createElement" class="headerlink" title="① createElement &amp;"></a>① createElement &amp;</h4><blockquote>
<p><code>createElement</code>可谓是React中最重要的API了，他是用来创建<code>ReactElement</code>的，但是很多同学却从没见过也没用过，这是为啥呢？因为你用了JSX，JSX并不是标准的js，所以要经过编译才能变成可运行的js，而编译之后，<code>createElement</code>就出现了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// jsx</span></span><br><span class="line">&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// js</span></span><br><span class="line">&gt;<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125;, <span class="string">&#x27;content&#x27;</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="②-cloneElement"><a href="#②-cloneElement" class="headerlink" title="② cloneElement"></a>② cloneElement</h4><blockquote>
<p><code>cloneElement</code>就很明显了，是用来克隆一个<code>ReactElement</code>的</p>
</blockquote>
<h4 id="③-createFactory"><a href="#③-createFactory" class="headerlink" title="③ createFactory"></a>③ createFactory</h4><blockquote>
<p><code>createFactory</code>是用来创建专门用来创建某一类<code>ReactElement</code>的工厂的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFactory</span>(<span class="params">type</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> factory = createElement.<span class="title function_">bind</span>(<span class="literal">null</span>, type);</span><br><span class="line">factory.<span class="property">type</span> = type;</span><br><span class="line">  <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>他其实就是绑定了第一个参数的<code>createElement</code>，一般我们用JSX进行编程的时候不会用到这个API</p>
</blockquote>
<h4 id="④-isValidElement"><a href="#④-isValidElement" class="headerlink" title="④ isValidElement"></a>④ isValidElement</h4><blockquote>
<p><code>isValidElement</code>顾名思义就是用来验证是否是一个<code>ReactElement</code>的，基本也用不太到</p>
</blockquote>
<h2 id="4、React-Children"><a href="#4、React-Children" class="headerlink" title="4、React Children"></a>4、React Children</h2><blockquote>
<p>此处为什么不放在<code>API梳理</code>中而是单独拿出来讲? [<code>同学们可以忽略不看此部分</code>]</p>
<p>一方面平时不怎么用，另一方面跟数组处理功能差不多，不深究实现是比较容易理解的.但是观阅许多相关资料后,觉得这个还是可以记录一下</p>
<p>以[<code>React.Children.map</code>]进行分析</p>
<p><code>map</code>和<code>forEach</code>的最大区别就是有没有<code>return result</code>。</p>
</blockquote>
<h3 id="Ⅰ-使用方式"><a href="#Ⅰ-使用方式" class="headerlink" title="Ⅰ- 使用方式"></a>Ⅰ- 使用方式</h3><blockquote>
<p>首先看下这个 API 的用法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ChildrenDemo</span>(<span class="params">props</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(props.<span class="property">children</span>, <span class="function"><span class="params">c</span> =&gt;</span> [c, c])</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">default</span> () =&gt; (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">ChildrenDemo</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>Tom and Jerry<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">ChildrenDemo</span>&gt;</span></span></span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure>

<p>界面上显示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Tom</span> and <span class="title class_">Jerry</span></span><br><span class="line">&gt;<span class="title class_">Tom</span> and <span class="title class_">Jerry</span></span><br></pre></td></tr></table></figure>

<p>如果将上述的代码稍微调整</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ChildrenDemo</span>(<span class="params">props</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="title class_">React</span>.<span class="property">Children</span>.<span class="title function_">map</span>(props.<span class="property">children</span>, <span class="function"><span class="params">c</span> =&gt;</span> [c, [c, c]])</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的事情发生了，界面上显示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title class_">Tom</span> and <span class="title class_">Jerry</span></span><br><span class="line">&gt;<span class="title class_">Tom</span> and <span class="title class_">Jerry</span></span><br><span class="line">&gt;<span class="title class_">Tom</span> and <span class="title class_">Jerry</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Ⅱ-源码分析"><a href="#Ⅱ-源码分析" class="headerlink" title="Ⅱ- 源码分析"></a>Ⅱ- 源码分析</h3><blockquote>
<p>接下来从代码的角度分析，为什么出现这种情况，从React入口文件开始</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\React.js</span></span><br><span class="line">&gt;<span class="keyword">import</span> &#123;forEach, map, count, toArray, only&#125; <span class="keyword">from</span> <span class="string">&#x27;./ReactChildren&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">React</span> = &#123;</span><br><span class="line">&gt;<span class="title class_">Children</span>: &#123;</span><br><span class="line">&gt;map,</span><br><span class="line">&gt;forEach,</span><br><span class="line">&gt;count,</span><br><span class="line">&gt;toArray,</span><br><span class="line">&gt;only,</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;...</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，React Clildren 的所有 API 来自 ReactChildren.js 文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactChildren.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> &#123;</span><br><span class="line">&gt;forEachChildren <span class="keyword">as</span> forEach,</span><br><span class="line">&gt;mapChildren <span class="keyword">as</span> map,</span><br><span class="line">&gt;countChildren <span class="keyword">as</span> count,</span><br><span class="line">&gt;onlyChild <span class="keyword">as</span> only,</span><br><span class="line">&gt;toArray,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><code>map 只是个别名，真正的函数是 mapChildren</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactChildren.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">mapChildren</span>(<span class="params">children, func, context</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> children;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> result = [];</span><br><span class="line">&gt;<span class="title function_">mapIntoWithKeyPrefixInternal</span>(children, result, <span class="literal">null</span>, func, context);</span><br><span class="line">&gt;<span class="comment">// map和forEach的最大区别就是有没有return result。</span></span><br><span class="line">&gt;<span class="keyword">return</span> result;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">mapIntoWithKeyPrefixInternal</span>(<span class="params">children, array, prefix, func, context</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> escapedPrefix = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 用来生成key的</span></span><br><span class="line">&gt;<span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;escapedPrefix = escapeUserProvidedKey(prefix) + <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">const</span> traverseContext = <span class="title function_">getPooledTraverseContext</span>(</span><br><span class="line">&gt;array,</span><br><span class="line">&gt;escapedPrefix,</span><br><span class="line">&gt;func,</span><br><span class="line">&gt;context,</span><br><span class="line">&gt;);</span><br><span class="line">&gt;<span class="title function_">traverseAllChildren</span>(children, mapSingleChildIntoContext, traverseContext);</span><br><span class="line">&gt;<span class="title function_">releaseTraverseContext</span>(traverseContext);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p><code>map</code>和<code>forEach</code>的最大区别就是有没有<code>return result</code>。</p>
</blockquote>
<h4 id="①-分析-getPooledTraverseContext-和-releaseTraverseContext"><a href="#①-分析-getPooledTraverseContext-和-releaseTraverseContext" class="headerlink" title="① 分析 getPooledTraverseContext 和 releaseTraverseContext"></a>① 分析 getPooledTraverseContext 和 releaseTraverseContext</h4><blockquote>
<p>getPooledTraverseContext 就是从 pool 里面找一个对象，releaseTraverseContext 会把当前的 context 对象清空然后放回到 pool 中。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactChildren.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">POOL_SIZE</span> = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> traverseContextPool = [];</span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">getPooledTraverseContext</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;mapResult,</span></span><br><span class="line"><span class="params">&gt;keyPrefix,</span></span><br><span class="line"><span class="params">&gt;mapFunction,</span></span><br><span class="line"><span class="params">&gt;mapContext,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (traverseContextPool.<span class="property">length</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> traverseContext = traverseContextPool.<span class="title function_">pop</span>();</span><br><span class="line">&gt;<span class="comment">// set attrs</span></span><br><span class="line">&gt;<span class="keyword">return</span> traverseContext;</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> &#123;</span><br><span class="line">&gt;<span class="attr">result</span>: mapResult,</span><br><span class="line">&gt;<span class="attr">keyPrefix</span>: keyPrefix,</span><br><span class="line">&gt;<span class="attr">func</span>: mapFunction,</span><br><span class="line"><span class="attr">context</span>: mapContext,</span><br><span class="line"><span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">releaseTraverseContext</span>(<span class="params">traverseContext</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// clear attrs</span></span><br><span class="line">&gt;<span class="keyword">if</span> (traverseContextPool.<span class="property">length</span> &lt; <span class="variable constant_">POOL_SIZE</span>) &#123;</span><br><span class="line">&gt;traverseContextPool.<span class="title function_">push</span>(traverseContext);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这么做主要是为了节省对象重复创建带来的性能消耗，React 中后续还会有一些这样的管理对象的方式。</p>
<p>那么按照这个流程来看，是不是<code>pool</code>永远都只有一个值呢，毕竟推出之后操作完了就推入了，这么循环着。答案肯定是否的，这就要讲到<code>React.Children.map</code>的一个特性了，那就是对每个节点的<code>map</code>返回的如果是数组，那么还会继续展开，这是一个递归的过程。接下去我们就来<code>分析traverseAllChildren</code>。</p>
</blockquote>
<h4 id="②-分析traverseAllChildren-方法"><a href="#②-分析traverseAllChildren-方法" class="headerlink" title="② 分析traverseAllChildren 方法"></a>② 分析traverseAllChildren 方法</h4><blockquote>
<p><code>traverseContext</code> 对象<code>封装完毕</code>后，调用 traverseAllChildren 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactChildren.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">traverseAllChildren</span>(<span class="params">children, callback, traverseContext</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">traverseAllChildrenImpl</span>(children, <span class="string">&#x27;&#x27;</span>, callback, traverseContext);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用 traverseAllChildrenImpl 方法,<code>下方代码是连着上面的,只是拆出来更清晰 </code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactChildren.js</span></span><br><span class="line">&gt;<span class="comment">// children: ReactElement</span></span><br><span class="line">&gt;<span class="comment">// nameSoFar: &#x27;&#x27;</span></span><br><span class="line">&gt;<span class="comment">// callback: 是个函数 mapSingleChildIntoContext，在mapChildren 函数中传入</span></span><br><span class="line">&gt;<span class="comment">// traverseContext： &#123; result: [], keyPrefix: &quot;&quot;, func: c =&gt; [c, [c, c]], context: undefined, count: 0&#125;</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">traverseAllChildrenImpl</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;children,</span></span><br><span class="line"><span class="params">&gt;nameSoFar,</span></span><br><span class="line"><span class="params"> callback,</span></span><br><span class="line"><span class="params"> traverseContext,</span></span><br><span class="line"><span class="params"> </span>) &#123;</span><br><span class="line"> <span class="comment">// children一般是一个React Element，或者是多个React Element</span></span><br><span class="line">&gt;<span class="keyword">const</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 判断children的合理性</span></span><br><span class="line">&gt;<span class="keyword">if</span> (type === <span class="string">&#x27;undefined&#x27;</span> || type === <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line"> children = <span class="literal">null</span></span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">let</span> invokeCallback = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对于单个节点，invokeCallback = true</span></span><br><span class="line">&gt;<span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line"> invokeCallback = <span class="literal">true</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (type) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">       invokeCallback = <span class="literal">true</span></span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">case</span> <span class="string">&#x27;object&#x27;</span>:</span><br><span class="line">       <span class="keyword">switch</span> (children.<span class="property">$$typeof</span>) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="attr">REACT_ELEMENT_TYPE</span>:</span><br><span class="line">         <span class="keyword">case</span> <span class="attr">REACT_PORTAL_TYPE</span>:</span><br><span class="line">           invokeCallback = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">&gt;<span class="comment">// callback 指的是 mapSingleChildIntoContext</span></span><br><span class="line"> <span class="title function_">callback</span>(</span><br><span class="line">   traverseContext,</span><br><span class="line">     children,</span><br><span class="line">        <span class="comment">//此处是设置Key的代码</span></span><br><span class="line">     nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> + <span class="title function_">getComponentKey</span>(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">    )</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&gt;<span class="keyword">let</span> child;</span><br><span class="line"> <span class="keyword">let</span> nextName;</span><br><span class="line"> <span class="keyword">let</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line"> <span class="keyword">const</span> nextNamePrefix =</span><br><span class="line"> nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> : nameSoFar + <span class="variable constant_">SUBSEPARATOR</span>;</span><br><span class="line">   </span><br><span class="line">&gt;<span class="comment">// 对于本例，第一次进入这个函数 clildren 是两个 span，是一个array</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    child = children[i];</span><br><span class="line">     nextName = nextNamePrefix + <span class="title function_">getComponentKey</span>(child, i);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 递归调用 traverseAllChildrenImpl</span></span><br><span class="line">     subtreeCount += <span class="title function_">traverseAllChildrenImpl</span>(</span><br><span class="line">       child,</span><br><span class="line">       nextName,</span><br><span class="line">       callback,</span><br><span class="line">       traverseContext,</span><br><span class="line">     );</span><br><span class="line">    &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// 针对的是那些不是Array类型，但是有迭代器，能遍历的情况，正常代码不会这样，可以忽略</span></span><br><span class="line">   <span class="keyword">const</span> iteratorFn = <span class="title function_">getIteratorFn</span>(children);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> iterator = iteratorFn.<span class="title function_">call</span>(children);</span><br><span class="line">     <span class="keyword">let</span> step;</span><br><span class="line">     <span class="keyword">let</span> ii = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (!(step = iterator.<span class="title function_">next</span>()).<span class="property">done</span>) &#123;</span><br><span class="line">       child = step.<span class="property">value</span>;</span><br><span class="line">       nextName = nextNamePrefix + <span class="title function_">getComponentKey</span>(child, ii++);</span><br><span class="line">       subtreeCount += <span class="title function_">traverseAllChildrenImpl</span>(</span><br><span class="line">         child,</span><br><span class="line">         nextName,</span><br><span class="line">         callback,</span><br><span class="line">         traverseContext,</span><br><span class="line">       );</span><br><span class="line">     &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> addendum = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">     <span class="keyword">const</span> childrenString = <span class="string">&#x27;&#x27;</span> + children;</span><br><span class="line">     <span class="title function_">invariant</span>(</span><br><span class="line">       <span class="literal">false</span>,</span><br><span class="line">       <span class="string">&#x27;Objects are not valid as a React child (found: %s).%s&#x27;</span>,</span><br><span class="line">       childrenString === <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">         ? <span class="string">&#x27;object with keys &#123;&#x27;</span> + <span class="title class_">Object</span>.<span class="title function_">keys</span>(children).<span class="title function_">join</span>(<span class="string">&#x27;, &#x27;</span>) + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">         : childrenString,</span><br><span class="line">       addendum,</span><br><span class="line">     );</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&gt;<span class="keyword">return</span> subtreeCount;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>traverseAllChildrenImpl</code> 函数做的事情比较简单，children如果是可循环的，遍历children中的每个元素，<code>递归调用本身</code>，直到是一个节点的情况， 然后调用callback，也就是 mapSingleChildIntoContext。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactChildren.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">mapSingleChildIntoContext</span>(<span class="params">bookKeeping, child, childKey</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line"> </span><br><span class="line">&gt;<span class="comment">// child 调用 我们传入的函数 c =&gt; [c, [c, c]]</span></span><br><span class="line"> <span class="keyword">let</span> mappedChild = func.<span class="title function_">call</span>(context, child, bookKeeping.<span class="property">count</span>++);</span><br><span class="line"> </span><br><span class="line">&gt;<span class="comment">// 如果 返回的值依然是个数组，递归调用mapIntoWithKeyPrefixInternal</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(mappedChild)) &#123;</span><br><span class="line"> <span class="comment">// 注意 c =&gt; c </span></span><br><span class="line">   <span class="title function_">mapIntoWithKeyPrefixInternal</span>(mappedChild, result, childKey, <span class="function"><span class="params">c</span> =&gt;</span> c);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果返回的值是个合格的Element，将结果放入result中</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">isValidElement</span>(mappedChild)) &#123;</span><br><span class="line">    mappedChild = <span class="title function_">cloneAndReplaceKey</span>(</span><br><span class="line">       mappedChild,</span><br><span class="line">       <span class="comment">// Keep both the (mapped) and old keys if they differ, just as</span></span><br><span class="line">       <span class="comment">// traverseAllChildren used to do for objects as children</span></span><br><span class="line">       keyPrefix +</span><br><span class="line">         (mappedChild.<span class="property">key</span> &amp;&amp; (!child || child.<span class="property">key</span> !== mappedChild.<span class="property">key</span>)</span><br><span class="line">           ? escapeUserProvidedKey(mappedChild.<span class="property">key</span>) + <span class="string">&#x27;/&#x27;</span></span><br><span class="line">           : <span class="string">&#x27;&#x27;</span>) +</span><br><span class="line">         childKey,</span><br><span class="line">     );</span><br><span class="line">    &#125;</span><br><span class="line">   result.<span class="title function_">push</span>(mappedChild);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>mapSingleChildIntoContext 这个方法其实就是调用 React.Children.map(children, callback) 这里的callback，就是我们传入的第二个参数，并得到map之后的结果。</p>
<ul>
<li>如果<code>map</code>之后的节点还是一个数组，那么再次进入<code>mapIntoWithKeyPrefixInternal</code>，那么这个时候我们就会再次从<code>pool</code>里面去<code>context</code>了，而<code>pool</code>的意义大概也就是在这里了，如果循环嵌套多了，可以减少很多对象创建和<code>gc</code>的损耗。</li>
<li>而如果不是数组并且是一个合规的ReactElement，就触达顶点了，替换一下key就推入result了。</li>
<li>React 将重复对象放在Pool中是因为对Children的处理一般在render里面，所以会比较频繁，所以设置一个pool减少声明和gc的开销。</li>
</ul>
</blockquote>
<h4 id="③-React-这么实现的目的"><a href="#③-React-这么实现的目的" class="headerlink" title="③ React 这么实现的目的"></a>③ React 这么实现的目的</h4><blockquote>
<ol>
<li>拆分<code>map</code>出来的数组</li>
<li>因为对<code>Children</code>的处理一般在<code>render</code>里面，所以会比较频繁，所以设置一个<code>pool</code>减少声明和<code>gc</code>的开销</li>
</ol>
</blockquote>
<h3 id="Ⅲ-Key值的设置"><a href="#Ⅲ-Key值的设置" class="headerlink" title="Ⅲ-Key值的设置"></a>Ⅲ-Key值的设置</h3><blockquote>
<p>将原先的一个children映射为多个children的过程中，涉及到了一些key值的变换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//源码</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">traverseAllChildrenImpl</span>(<span class="params"></span>) &#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">   <span class="title function_">callback</span>(</span><br><span class="line">     traverseContext,</span><br><span class="line">     children,</span><br><span class="line">  		 <span class="comment">//如果它是唯一的子元素，那么就把它当作包装在数组中  </span></span><br><span class="line">	<span class="comment">//如果孩子的数量增长，它是一致的。  </span></span><br><span class="line">     nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> + <span class="title function_">getComponentKey</span>(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">   );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">   nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> : nameSoFar + <span class="variable constant_">SUBSEPARATOR</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     child = children[i];</span><br><span class="line">     nextName = nextNamePrefix + <span class="title function_">getComponentKey</span>(child, i);</span><br><span class="line">     subtreeCount += <span class="title function_">traverseAllChildrenImpl</span>(</span><br><span class="line">       child,</span><br><span class="line">       nextName,</span><br><span class="line">       callback,</span><br><span class="line">       traverseContext,</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>举例来说明key的生成过程</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// React.Children.map(props.children, c =&gt; c)</span></span><br><span class="line">&gt;<span class="function">() =&gt;</span> (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span>Tom<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span>Jerry<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure>

<p>如果 children 是一个数组，那么首先会计算一个 nextNamePrefix，计算的规则如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// const SEPARATOR = &#x27;.&#x27;;</span></span><br><span class="line">&gt;<span class="comment">// const SUBSEPARATOR = &#x27;:&#x27;;</span></span><br><span class="line">&gt;<span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">   nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> : nameSoFar + <span class="variable constant_">SUBSEPARATOR</span>;</span><br></pre></td></tr></table></figure>

<p>nameSoFar &#x3D;&#x3D;&#x3D; ‘’ 成立， nextNamePrefix 是 SEPARATOR ，也就是 “.”。在遍历数组的过程中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nextName = nextNamePrefix + <span class="title function_">getComponentKey</span>(child, i);</span><br></pre></td></tr></table></figure>

<p>getComponentKey 会获得元素上的key值，如果没有key值，那么就是 i， i代表数组中的index。对于一个对象调用callback的过程中，key的规则是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> + <span class="title function_">getComponentKey</span>(children, <span class="number">0</span>) : nameSoFar</span><br></pre></td></tr></table></figure>

<p>由于此时nameSoFar不为空串， Tom 的 key是 “.0”, Jerry 的 key 是 “.1”。</p>
<p>如果 c &#x3D;&gt; [ c, c ]，即映射出的是数组，那么在 mapSingleChildIntoContext 函数中 会走到这个分支</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(mappedChild)) &#123;</span><br><span class="line">   <span class="title function_">mapIntoWithKeyPrefixInternal</span>(mappedChild, result, childKey, <span class="function"><span class="params">c</span> =&gt;</span> c);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>此时会重新调用 mapIntoWithKeyPrefixInternal，也就是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (prefix != <span class="literal">null</span>) &#123;</span><br><span class="line">   escapedPrefix = escapeUserProvidedKey(prefix) + <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>执行完毕后，key后面多加了 ‘&#x2F;’ 。继续执行 traverseAllChildrenImpl，nameSoFar &#x3D;&#x3D;&#x3D; ‘’ 成立， nextNamePrefix 是 SEPARATOR ，也就是 ‘.’， key后面多加了 ‘.’。再次执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> + <span class="title function_">getComponentKey</span>(children, <span class="number">0</span>) : nameSoFar</span><br></pre></td></tr></table></figure>

<p>最终生成的4个key分别是</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;.0/.0</span><br><span class="line">&gt;.0/.1</span><br><span class="line">&gt;.1/.0</span><br><span class="line">&gt;.1/.1</span><br></pre></td></tr></table></figure>

<p>如果 c &#x3D;&gt; [ c, [c, c] ]，那么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">   nameSoFar === <span class="string">&#x27;&#x27;</span> ? <span class="variable constant_">SEPARATOR</span> : nameSoFar + <span class="variable constant_">SUBSEPARATOR</span>;</span><br></pre></td></tr></table></figure>

<p>会被循环调用，第二次进入循环的时候，nameSoFar &#x3D;&#x3D;&#x3D; ‘’这个条件不满足，key后面会加一个 ‘SUBSEPARATOR’，也就是 ‘:’，其余流程不变。</p>
<p>最终生成的6个key分别是</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;.0/.0</span><br><span class="line">&gt;.0/.1:0</span><br><span class="line">&gt;.0/.1:1</span><br><span class="line">&gt;.1/.0</span><br><span class="line">&gt;.1/.1:0</span><br><span class="line">&gt;.1/.1:1</span><br></pre></td></tr></table></figure>

<p><code>还需要注意的是，如果component设置了key，会使用component上的key，不使用index，此时会如果两个元素的key相同，react会给出警告。</code></p>
</blockquote>
<h2 id="5、React的数据结构"><a href="#5、React的数据结构" class="headerlink" title="5、React的数据结构"></a>5、React的数据结构</h2><blockquote>
<p><code>了解即可,可跳过</code></p>
</blockquote>
<h3 id="Ⅰ-FiberRoot"><a href="#Ⅰ-FiberRoot" class="headerlink" title="Ⅰ-FiberRoot"></a>Ⅰ-FiberRoot</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&gt;type <span class="title class_">BaseFiberRootProperties</span> = &#123;|</span><br><span class="line"> <span class="comment">// root节点，render方法接收的第二个参数</span></span><br><span class="line"> <span class="attr">containerInfo</span>: any,</span><br><span class="line"> <span class="comment">// 只有在持久更新中会用到，也就是不支持增量更新的平台，react-dom不会用到</span></span><br><span class="line"> <span class="attr">pendingChildren</span>: any,</span><br><span class="line"> <span class="comment">// 当前应用对应的Fiber对象，是Root Fiber</span></span><br><span class="line"> <span class="attr">current</span>: <span class="title class_">Fiber</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 一下的优先级是用来区分</span></span><br><span class="line"> <span class="comment">// 1) 没有提交(committed)的任务</span></span><br><span class="line"> <span class="comment">// 2) 没有提交的挂起任务</span></span><br><span class="line"> <span class="comment">// 3) 没有提交的可能被挂起的任务</span></span><br><span class="line"> <span class="comment">// 我们选择不追踪每个单独的阻塞登记，为了兼顾性能</span></span><br><span class="line"> <span class="comment">// The earliest and latest priority levels that are suspended from committing.</span></span><br><span class="line"> <span class="comment">// 最老和新的在提交的时候被挂起的任务</span></span><br><span class="line"> <span class="attr">earliestSuspendedTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="attr">latestSuspendedTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="comment">// The earliest and latest priority levels that are not known to be suspended.</span></span><br><span class="line"> <span class="comment">// 最老和最新的不确定是否会挂起的优先级（所有任务进来一开始都是这个状态）</span></span><br><span class="line"> <span class="attr">earliestPendingTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="attr">latestPendingTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="comment">// The latest priority level that was pinged by a resolved promise and can</span></span><br><span class="line"> <span class="comment">// be retried.</span></span><br><span class="line"> <span class="comment">// 最新的通过一个promise被reslove并且可以重新尝试的优先级</span></span><br><span class="line"> <span class="attr">latestPingedTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果有错误被抛出并且没有更多的更新存在，我们尝试在处理错误前同步重新从头渲染</span></span><br><span class="line"> <span class="comment">// 在`renderRoot`出现无法处理的错误时会被设置为`true`</span></span><br><span class="line"> <span class="attr">didError</span>: boolean,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 正在等待提交的任务的`expirationTime`</span></span><br><span class="line"> <span class="attr">pendingCommitExpirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="comment">// 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null</span></span><br><span class="line"> <span class="comment">// 在commit阶段只会处理这个值对应的任务</span></span><br><span class="line"> <span class="attr">finishedWork</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 在任务被挂起的时候通过setTimeout设置的返回内容，用来下一次如果有新的任务挂起时清理还没触发的timeout</span></span><br><span class="line"> <span class="attr">timeoutHandle</span>: <span class="title class_">TimeoutHandle</span> | <span class="title class_">NoTimeout</span>,</span><br><span class="line"> <span class="comment">// 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用</span></span><br><span class="line"> <span class="attr">context</span>: <span class="title class_">Object</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="attr">pendingContext</span>: <span class="title class_">Object</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 用来确定第一次渲染的时候是否需要融合</span></span><br><span class="line"> +<span class="attr">hydrate</span>: boolean,</span><br><span class="line"> <span class="comment">// 当前root上剩余的过期时间</span></span><br><span class="line"> <span class="comment">// <span class="doctag">TODO:</span> 提到renderer里面区处理</span></span><br><span class="line"> <span class="attr">nextExpirationTimeToWorkOn</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="comment">// 当前更新对应的过期时间</span></span><br><span class="line"> <span class="attr">expirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"> <span class="comment">// List of top-level batches. This list indicates whether a commit should be</span></span><br><span class="line"> <span class="comment">// deferred. Also contains completion callbacks.</span></span><br><span class="line"> <span class="comment">// <span class="doctag">TODO:</span> Lift this into the renderer</span></span><br><span class="line"> <span class="comment">// 顶层批次（批处理任务？）这个变量指明一个commit是否应该被推迟</span></span><br><span class="line"> <span class="comment">// 同时包括完成之后的回调</span></span><br><span class="line"> <span class="comment">// 貌似用在测试的时候？</span></span><br><span class="line"> <span class="attr">firstBatch</span>: <span class="title class_">Batch</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// root之间关联的链表结构</span></span><br><span class="line"> <span class="attr">nextScheduledRoot</span>: <span class="title class_">FiberRoot</span> | <span class="literal">null</span>,</span><br><span class="line">&gt;|&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Ⅱ-Fiber"><a href="#Ⅱ-Fiber" class="headerlink" title="Ⅱ-Fiber"></a>Ⅱ-Fiber</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// Fiber对应一个组件需要被处理或者已经处理了，一个组件可以有一个或者多个Fiber</span></span><br><span class="line">&gt;type <span class="title class_">Fiber</span> = &#123;|</span><br><span class="line"> <span class="comment">// 标记不同的组件类型</span></span><br><span class="line"> <span class="attr">tag</span>: <span class="title class_">WorkTag</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ReactElement里面的key</span></span><br><span class="line"> <span class="attr">key</span>: <span class="literal">null</span> | string,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ReactElement.type，也就是我们调用`createElement`的第一个参数</span></span><br><span class="line"> <span class="attr">elementType</span>: any,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// The resolved function/class/ associated with this fiber.</span></span><br><span class="line"> <span class="comment">// 异步组件resolved之后返回的内容，一般是`function`或者`class`</span></span><br><span class="line"> <span class="attr">type</span>: any,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// The local state associated with this fiber.</span></span><br><span class="line"> <span class="comment">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span></span><br><span class="line"> <span class="attr">stateNode</span>: any,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line"> <span class="attr">return</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 单链表树结构</span></span><br><span class="line"> <span class="comment">// 指向自己的第一个子节点</span></span><br><span class="line"> <span class="attr">child</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 指向自己的兄弟结构</span></span><br><span class="line"> <span class="comment">// 兄弟节点的return指向同一个父节点</span></span><br><span class="line"> <span class="attr">sibling</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="attr">index</span>: number,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ref属性</span></span><br><span class="line"> <span class="attr">ref</span>: <span class="literal">null</span> | ((<span class="function">(<span class="params">handle: mixed</span>) =&gt;</span> <span class="keyword">void</span>) &amp; &#123;<span class="attr">_stringRef</span>: ?string&#125;) | <span class="title class_">RefObject</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 新的变动带来的新的props</span></span><br><span class="line"> <span class="attr">pendingProps</span>: any, </span><br><span class="line"> <span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line"> <span class="attr">memoizedProps</span>: any,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line"> <span class="attr">updateQueue</span>: <span class="title class_">UpdateQueue</span>&lt;any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line"> <span class="attr">memoizedState</span>: any,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 一个列表，存放这个Fiber依赖的context</span></span><br><span class="line"> <span class="attr">firstContextDependency</span>: <span class="title class_">ContextDependency</span>&lt;mixed&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用来描述当前Fiber和他子树的`Bitfield`</span></span><br><span class="line"> <span class="comment">// 共存的模式表示这个子树是否默认是异步渲染的</span></span><br><span class="line"> <span class="comment">// Fiber被创建的时候他会继承父Fiber</span></span><br><span class="line"> <span class="comment">// 其他的标识也可以在创建的时候被设置</span></span><br><span class="line"> <span class="comment">// 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前</span></span><br><span class="line"> <span class="attr">mode</span>: <span class="title class_">TypeOfMode</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Effect</span></span><br><span class="line"> <span class="comment">// 用来记录Side Effect</span></span><br><span class="line"> <span class="attr">effectTag</span>: <span class="title class_">SideEffectTag</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line"> <span class="attr">nextEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 子树中第一个side effect</span></span><br><span class="line"> <span class="attr">firstEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 子树中最后一个side effect</span></span><br><span class="line"> <span class="attr">lastEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line"> <span class="comment">// 不包括他的子树产生的任务</span></span><br><span class="line"> <span class="attr">expirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line"> <span class="attr">childExpirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span></span><br><span class="line"> <span class="comment">// 我们称他为`current &lt;==&gt; workInProgress`</span></span><br><span class="line"> <span class="comment">// 在渲染完成之后他们会交换位置</span></span><br><span class="line"> <span class="attr">alternate</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 下面是调试相关的，收集每个Fiber和子树渲染时间的</span></span><br><span class="line"></span><br><span class="line"> actualDuration?: number,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// If the Fiber is currently active in the &quot;render&quot; phase,</span></span><br><span class="line"> <span class="comment">// This marks the time at which the work began.</span></span><br><span class="line"> <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line"> actualStartTime?: number,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Duration of the most recent render time for this Fiber.</span></span><br><span class="line"> <span class="comment">// This value is not updated when we bailout for memoization purposes.</span></span><br><span class="line"> <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line"> selfBaseDuration?: number,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Sum of base times for all descedents of this Fiber.</span></span><br><span class="line"> <span class="comment">// This value bubbles up during the &quot;complete&quot; phase.</span></span><br><span class="line"> <span class="comment">// This field is only set when the enableProfilerTimer flag is enabled.</span></span><br><span class="line"> treeBaseDuration?: number,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Conceptual aliases</span></span><br><span class="line"> <span class="comment">// workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens</span></span><br><span class="line"> <span class="comment">// to be the same as work in progress.</span></span><br><span class="line"> <span class="comment">// __DEV__ only</span></span><br><span class="line"> _debugID?: number,</span><br><span class="line"> _debugSource?: <span class="title class_">Source</span> | <span class="literal">null</span>,</span><br><span class="line"> _debugOwner?: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"> _debugIsCurrentlyTiming?: boolean,</span><br><span class="line">&gt;|&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Ⅲ-sideEffects"><a href="#Ⅲ-sideEffects" class="headerlink" title="Ⅲ-sideEffects"></a>Ⅲ-sideEffects</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* Copyright (c) Facebook, Inc. and its affiliates.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This source code is licensed under the MIT license found in the</span></span><br><span class="line"><span class="comment">* LICENSE file in the root directory of this source tree.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@flow</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> type <span class="title class_">SideEffectTag</span> = number;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Don&#x27;t change these two values. They&#x27;re used by React Dev Tools.</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoEffect</span> = <span class="comment">/*              */</span> <span class="number">0b00000000000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PerformedWork</span> = <span class="comment">/*         */</span> <span class="number">0b00000000001</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// You can change the rest (and add more).</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Placement</span> = <span class="comment">/*             */</span> <span class="number">0b00000000010</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Update</span> = <span class="comment">/*                */</span> <span class="number">0b00000000100</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">PlacementAndUpdate</span> = <span class="comment">/*    */</span> <span class="number">0b00000000110</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Deletion</span> = <span class="comment">/*              */</span> <span class="number">0b00000001000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContentReset</span> = <span class="comment">/*          */</span> <span class="number">0b00000010000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Callback</span> = <span class="comment">/*              */</span> <span class="number">0b00000100000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">DidCapture</span> = <span class="comment">/*            */</span> <span class="number">0b00001000000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Ref</span> = <span class="comment">/*                   */</span> <span class="number">0b00010000000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Snapshot</span> = <span class="comment">/*              */</span> <span class="number">0b00100000000</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Update &amp; Callback &amp; Ref &amp; Snapshot</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LifecycleEffectMask</span> = <span class="comment">/*   */</span> <span class="number">0b00110100100</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Union of all host effects</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostEffectMask</span> = <span class="comment">/*        */</span> <span class="number">0b00111111111</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Incomplete</span> = <span class="comment">/*            */</span> <span class="number">0b01000000000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ShouldCapture</span> = <span class="comment">/*         */</span> <span class="number">0b10000000000</span>;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="Ⅳ-ReactWorkTag"><a href="#Ⅳ-ReactWorkTag" class="headerlink" title="Ⅳ-ReactWorkTag"></a>Ⅳ-ReactWorkTag</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">FunctionComponent</span> = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ClassComponent</span> = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IndeterminateComponent</span> = <span class="number">2</span>; <span class="comment">// Before we know whether it is function or class</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostRoot</span> = <span class="number">3</span>; <span class="comment">// Root of a host tree. Could be nested inside another node.</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostPortal</span> = <span class="number">4</span>; <span class="comment">// A subtree. Could be an entry point to a different renderer.</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostComponent</span> = <span class="number">5</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">HostText</span> = <span class="number">6</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Fragment</span> = <span class="number">7</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Mode</span> = <span class="number">8</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextConsumer</span> = <span class="number">9</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ContextProvider</span> = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ForwardRef</span> = <span class="number">11</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Profiler</span> = <span class="number">12</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SuspenseComponent</span> = <span class="number">13</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="number">14</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SimpleMemoComponent</span> = <span class="number">15</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LazyComponent</span> = <span class="number">16</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">IncompleteClassComponent</span> = <span class="number">17</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Ⅴ-Update-UpdateQueue"><a href="#Ⅴ-Update-UpdateQueue" class="headerlink" title="Ⅴ-Update &amp; UpdateQueue"></a>Ⅴ-Update &amp; UpdateQueue</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">export</span> type <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; = &#123;</span><br><span class="line"> <span class="comment">// 更新的过期时间</span></span><br><span class="line"> <span class="attr">expirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// export const UpdateState = 0;</span></span><br><span class="line"> <span class="comment">// export const ReplaceState = 1;</span></span><br><span class="line"> <span class="comment">// export const ForceUpdate = 2;</span></span><br><span class="line"> <span class="comment">// export const CaptureUpdate = 3;</span></span><br><span class="line"> <span class="comment">// 指定更新的类型，值为以上几种</span></span><br><span class="line"> <span class="attr">tag</span>: <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>,</span><br><span class="line"> <span class="comment">// 更新内容，比如`setState`接收的第一个参数</span></span><br><span class="line"> <span class="attr">payload</span>: any,</span><br><span class="line"> <span class="comment">// 对应的回调，`setState`，`render`都有</span></span><br><span class="line"> <span class="attr">callback</span>: (<span class="function">() =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指向下一个更新</span></span><br><span class="line"> <span class="attr">next</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 指向下一个`side effect`</span></span><br><span class="line"> <span class="attr">nextEffect</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> type <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">State</span>&gt; = &#123;</span><br><span class="line"> <span class="comment">// 每次操作完更新之后的`state`</span></span><br><span class="line"> <span class="attr">baseState</span>: <span class="title class_">State</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 队列中的第一个`Update`</span></span><br><span class="line"> <span class="attr">firstUpdate</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 队列中的最后一个`Update`</span></span><br><span class="line"> <span class="attr">lastUpdate</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 第一个捕获类型的`Update`</span></span><br><span class="line"> <span class="attr">firstCapturedUpdate</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 最后一个捕获类型的`Update`</span></span><br><span class="line"> <span class="attr">lastCapturedUpdate</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 第一个`side effect`</span></span><br><span class="line"> <span class="attr">firstEffect</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"> <span class="comment">// 最后一个`side effect`</span></span><br><span class="line"> <span class="attr">lastEffect</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 第一个和最后一个捕获产生的`side effect`</span></span><br><span class="line"> <span class="attr">firstCapturedEffect</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line"> <span class="attr">lastCapturedEffect</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt; | <span class="literal">null</span>,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="6、对虚拟DOM的理解"><a href="#6、对虚拟DOM的理解" class="headerlink" title="6、对虚拟DOM的理解"></a>6、对虚拟DOM的理解</h2><h3 id="Ⅰ-什么是虚拟DOM"><a href="#Ⅰ-什么是虚拟DOM" class="headerlink" title="Ⅰ-什么是虚拟DOM"></a>Ⅰ-什么是虚拟DOM</h3><blockquote>
<ul>
<li><p>在React、Vue还没有出现的时候,我们要操作页面上的元素,需要<code>先找到那个元素</code>,然后<code>再进行修改样式、内容或者结构等</code>–&gt;这很明显性能特别差,也会特别消耗资源!</p>
</li>
<li><p>于是就有人会这样思考:如果在操作DOM之前就知道这一次数据更新期望改变的[<code>节点和</code>]怎么修改的话,那么这很明显可以提升页面渲染效率</p>
</li>
<li><blockquote>
<p>举个栗子:渲染列表时比如有100条数据,我删除其中一条,那么我只是在<code>虚拟DOM数据</code>上删除此条数据,然后剩余的经过diff算法对比,其实只是删除了一条,其余的只是调整了在页面上的位置没有重新渲染;直接操作dom就会导致数据重绘(临时举例不够贴切勿怪)</p>
</blockquote>
</li>
<li><p>于是[<code>虚拟DOM</code>]出现了,<code>它其实是一个数据结构</code>,是针对当前DOM构建的一个数据结构</p>
</li>
<li><p>以下是一个React的虚拟DOM结构</p>
</li>
</ul>
<p><img src="/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715180450728.png" alt="image-20210715180450728"> </p>
</blockquote>
<h3 id="Ⅱ-为什么需要虚拟DOM"><a href="#Ⅱ-为什么需要虚拟DOM" class="headerlink" title="Ⅱ-为什么需要虚拟DOM"></a>Ⅱ-为什么需要虚拟DOM</h3><blockquote>
<p>其实在上面说明[<a href="#%E2%85%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9FDOM">什么是虚拟DOM</a>]的时候就已经大概说明了为什么需要虚拟DOM了.因为<code>一个新事物只有被需要、能解决某一痛点的时候才会被创造</code></p>
<ul>
<li><p>无脑的渲染是否真的必要?</p>
</li>
<li><blockquote>
<p>很明显不需要.但是在没有虚拟DOM之前,我们能依靠的只有直接操作DOM,尽管我们知道操作DOM而产生的<code>重绘</code>会对页面性能产生巨大影响</p>
</blockquote>
</li>
<li><p>当一个项目大到一种境界的时候,如果还是用查找元素然后进行修改的话,对代码的维护难度会呈现指数级飙升</p>
</li>
<li><p>它是Diff算法的技术,也是数据驱动UI的前提</p>
</li>
</ul>
<p>个人理解的虚拟DOM大致流程图(公司前辈讲解的)</p>
<img src="React深入学习与源码解析笔记中的图片/image-20210715182038527.png" alt="image-20210715182038527" style="zoom:80%;" /> 
</blockquote>
<h3 id="Ⅲ-误区-虚拟DOM比直接操作DOM快"><a href="#Ⅲ-误区-虚拟DOM比直接操作DOM快" class="headerlink" title="Ⅲ- 误区:虚拟DOM比直接操作DOM快?"></a>Ⅲ- 误区:虚拟DOM比直接操作DOM快?</h3><blockquote>
<ul>
<li>很多人有这个误区,甚至我在之前很长的一段时间中都是这样认为的.其实不然,通过上面的流程图其实可以很好理解:<code>直接操作DOM是最快的</code>.</li>
<li>如果通过虚拟DOM计算出的更新策略是需要重绘10次,而直接操作DOM的次数也是重绘10次,那么直接操作应该是更快的,因为它省去了中间虚拟DOM构建、Diff算法、制定更新策略等;</li>
<li>当然,正常情况下针对一个[<code>state</code>(状态)]变化后期望产生结果得出的<code>更新次数是远小于直接操作DOM</code>的,预知更新策略比直接无脑操作虽然会花费一部分内存,但是直接操作减少了,性能肯定会更好,做出来的应用的会更加健壮</li>
</ul>
</blockquote>
<h4 id="无图无真相"><a href="#无图无真相" class="headerlink" title="无图无真相"></a>无图无真相</h4><blockquote>
<p>网络上有人做了一个操作更新组件各种样式1000次的时间点对比(设定重绘次数一致):</p>
<p><img src="/k705.github.io/React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210715184238480.png" alt="image-20210715184238480"></p>
<p>可以看出,直接操作DOM是最快的!<code>但是React需要的渲染时间可能是0</code>,下限更低,也正是因为计算出来某些[<code>state</code>(状态)]不需要更新DOM</p>
</blockquote>
<h1 id="二、创建更新"><a href="#二、创建更新" class="headerlink" title="二、创建更新"></a>二、创建更新</h1><blockquote>
<p>react创建更新的方式有三种</p>
<ul>
<li>ReactDOM.render</li>
<li>setState</li>
<li>forceUpdate</li>
</ul>
</blockquote>
<h2 id="1、ReactDOM-render"><a href="#1、ReactDOM-render" class="headerlink" title="1、ReactDOM.render"></a>1、ReactDOM.render</h2><h3 id="Ⅰ-使用概述"><a href="#Ⅰ-使用概述" class="headerlink" title="Ⅰ-使用概述"></a>Ⅰ-使用概述</h3><blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// index.js</span></span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line">&gt;<span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line">&gt;<span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>ReactDOM.render 是 React 程序的起点。ReactDom 中包含了 createPortal，findDOMNode， render 等方法，这里需要注意的是 <code>hydrate</code> 和 <code>render</code> 方法，这两个方法其实调用的是一个函数，<code>只是一个参数不同</code>，hydrate 一般用于服务端渲染，它会复用服务端返回的Html结构。我们这次只分析 render，hydrate后续会单独分析。</p>
</blockquote>
<h3 id="Ⅱ-ReactDOM源码示例"><a href="#Ⅱ-ReactDOM源码示例" class="headerlink" title="Ⅱ-ReactDOM源码示例"></a>Ⅱ-ReactDOM源码示例</h3><blockquote>
<p>[<code>unstable_createRoot</code>] 和 [<code>unstable_createSyncRoot</code>] 这两个接口需要注意下，特别是 <code>createRoot</code>，其实就是 16.9 之前的 [Concurrent Mode] 的<code>替代</code>，会启用 React 的并行模型。</p>
<p>创建<code>ReactRoot</code>，并且根据情况调用<code>root.legacy_renderSubtreeIntoContainer</code>或者<code>root.render</code>，前者是遗留的 API 将来应该会删除，根据<code>ReactDOM.render</code>的调用情况也可以发现<code>parentComponent</code>是写死的<code>null</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-dom\src\client\ReactDOM.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">ReactDOM</span>: <span class="title class_">Object</span> = &#123;</span><br><span class="line">&gt;<span class="title function_">hydrate</span>(<span class="params">element: React$Node, container: DOMContainer, callback: ?<span class="built_in">Function</span></span>) &#123;</span><br><span class="line">&gt;<span class="comment">// <span class="doctag">TODO:</span> throw or warn if we couldn&#x27;t hydrate?</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">element,</span><br><span class="line">container,</span><br><span class="line"><span class="literal">true</span>,</span><br><span class="line">callback,</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;,</span><br><span class="line"></span><br><span class="line">&gt;<span class="title function_">render</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;element: React$Element&lt;any&gt;,</span></span><br><span class="line"><span class="params">&gt;container: DOMContainer,</span></span><br><span class="line"><span class="params">&gt;callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">element,</span><br><span class="line">container,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line">callback,</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;，</span><br><span class="line"></span><br><span class="line">&gt;<span class="attr">unstable_createRoot</span>: createRoot,</span><br><span class="line">&gt;<span class="attr">unstable_createSyncRoot</span>: createSyncRoot,</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Ⅲ-render源码解析"><a href="#Ⅲ-render源码解析" class="headerlink" title="Ⅲ-render源码解析"></a>Ⅲ-render源码解析</h3><blockquote>
<p>render 接受三个参数，第一个参数是<code>ReactElement</code>，第二个参数为<code>组件所要挂载的DOM节点</code>，第三个参数为<code>回调函数</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="title function_">render</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;element: React$Element&lt;any&gt;,</span></span><br><span class="line"><span class="params">&gt;container: DOMContainer, <span class="comment">//组件索要挂在的DOM节点</span></span></span><br><span class="line"><span class="params">&gt;callback: ?<span class="built_in">Function</span>, <span class="comment">//回调函数</span></span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line"><span class="comment">//将继承来的render渲染成容器</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">element,</span><br><span class="line">container,</span><br><span class="line"><span class="literal">false</span>,</span><br><span class="line">callback,</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;，</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="①-legacyRenderSubtreeIntoContainer"><a href="#①-legacyRenderSubtreeIntoContainer" class="headerlink" title="① legacyRenderSubtreeIntoContainer"></a>① legacyRenderSubtreeIntoContainer</h4><blockquote>
<p>[<code>legacyRenderSubtreeIntoContainer</code>] 函数第一个入参 parentComponent 是写死的 null，函数首先生成了一个 root 对象， 调用的方法是 [<code>legacyCreateRootFromDOMContainer</code>]。</p>
<p>首先会创建<code>ReactRoot</code>对象，然后调用他的<code>render</code>方法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-dom\src\client\ReactDOM.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;parentComponent: ?React$Component&lt;any, any&gt;, <span class="comment">// null</span></span></span><br><span class="line"><span class="params">&gt;children: ReactNodeList, <span class="comment">// ReactElement</span></span></span><br><span class="line"><span class="params">&gt;container: DOMContainer, <span class="comment">// dom节点</span></span></span><br><span class="line"><span class="params">&gt;forceHydrate: boolean,</span></span><br><span class="line"><span class="params">&gt;callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 第一次 container 上没有 _reactRootContainer 属性，所以初次渲染为 null</span></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="attr">root</span>: _ReactSyncRoot = (container.<span class="property">_reactRootContainer</span>: any);</span><br><span class="line">&gt;<span class="keyword">let</span> fiberRoot;</span><br><span class="line">&gt;<span class="keyword">if</span> (!root) &#123;</span><br><span class="line">&gt;<span class="comment">// 生成一个 root 节点    ==根据DOM容器生成一个 根节点</span></span><br><span class="line">&gt;root = container.<span class="property">_reactRootContainer</span> = <span class="title function_">legacyCreateRootFromDOMContainer</span>(</span><br><span class="line">&gt;container,</span><br><span class="line">&gt;forceHydrate,</span><br><span class="line">&gt;);</span><br><span class="line">&gt;fiberRoot = root.<span class="property">_internalRoot</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 处理回调函数</span></span><br><span class="line">&gt;<span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> originalCallback = callback;</span><br><span class="line">&gt;callback = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 其实就是 root.current.child.stateNode</span></span><br><span class="line">&gt;<span class="keyword">const</span> instance = <span class="title function_">getPublicRootInstance</span>(fiberRoot);</span><br><span class="line">&gt;<span class="comment">//以instance的身份调用回调函数</span></span><br><span class="line">&gt;originalCallback.<span class="title function_">call</span>(instance);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//DOMRenderer.unbatchedUpdates制定不使用batchedUpdates，因为这是初次渲染，需要尽快完成。    </span></span><br><span class="line">&gt;<span class="comment">// 不会进行批量策略的更新</span></span><br><span class="line">&gt;<span class="title function_">unbatchedUpdates</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);</span><br><span class="line">&gt;&#125;);</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;<span class="comment">// root已经存在的情况，会复用之前生成的root，暂时不考虑这种情况</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">getPublicRootInstance</span>(fiberRoot);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>下一步运行<code>legacyCreateRootFromDOMContainer</code> –&gt;[③ legacyCreateRootFromDOMContainer](#③ legacyCreateRootFromDOMContainer)</p>
<p>接着解析初次渲染不会进入的[<code>updateContainer</code>]函数</p>
</blockquote>
<h4 id="②-updateContainer"><a href="#②-updateContainer" class="headerlink" title="② updateContainer"></a>② updateContainer</h4><blockquote>
<p>此处虽然初次渲染先不会进入[<code>updateContainer</code>]函数,但仍在此处给出部分解析,在[⑦ createFiber](#⑦ createFiber)创建完RootFiber后将会回到此处运行</p>
<p>其中<code>DOMRenderer</code>是<code>react-reconciler/src/ReactFiberReconciler</code>，他的<code>updateContainer</code>如下在这里计算了一个时间，这个时间叫做<code>expirationTime</code>，顾名思义就是这次更新的 <strong>超时时间</strong>。</p>
<p>关于时间是如何计算的   –&gt;请看[<a href="#2%E3%80%81expirationTime%E8%AE%A1%E7%AE%97">expiration Time</a>]部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberReconciler</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params"> element: ReactNodeList,</span></span><br><span class="line"><span class="params"> container: OpaqueRoot,</span></span><br><span class="line"><span class="params"> parentComponent: ?React$Component&lt;any, any&gt;,</span></span><br><span class="line"><span class="params"> callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">&gt;</span>): <span class="title class_">ExpirationTime</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> current = container.<span class="property">current</span></span><br><span class="line"> <span class="keyword">const</span> currentTime = <span class="title function_">requestCurrentTime</span>()</span><br><span class="line"> <span class="comment">// 计算超时时间</span></span><br><span class="line"> <span class="keyword">const</span> expirationTime = <span class="title function_">computeExpirationForFiber</span>(currentTime, current)</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">updateContainerAtExpirationTime</span>(</span><br><span class="line">   element,</span><br><span class="line">   container,</span><br><span class="line">   parentComponent,</span><br><span class="line">   expirationTime,</span><br><span class="line">   callback,</span><br><span class="line"> )</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateContainerAtExpirationTime</span>(<span class="params"></span></span><br><span class="line"><span class="params"> element: ReactNodeList,</span></span><br><span class="line"><span class="params"> container: OpaqueRoot,</span></span><br><span class="line"><span class="params"> parentComponent: ?React$Component&lt;any, any&gt;,</span></span><br><span class="line"><span class="params"> expirationTime: ExpirationTime,</span></span><br><span class="line"><span class="params"> callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line"> <span class="comment">// <span class="doctag">TODO:</span> If this is a nested container, this won&#x27;t be the root.</span></span><br><span class="line"> <span class="keyword">const</span> current = container.<span class="property">current</span></span><br><span class="line"> <span class="keyword">const</span> context = <span class="title function_">getContextForSubtree</span>(parentComponent)</span><br><span class="line"> <span class="keyword">if</span> (container.<span class="property">context</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">   container.<span class="property">context</span> = context</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   container.<span class="property">pendingContext</span> = context</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//这个方法中开始了调度。</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">scheduleRootUpdate</span>(current, element, expirationTime, callback)</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用了<code>updateContainerAtExpirationTime</code>，在这个方法里调用了<code>scheduleRootUpdate</code>,这个方法中开始了调度。</p>
<p>首先要生成一个<code>update</code>，不管你是<code>setState</code>还是<code>ReactDOM.render</code>造成的 React 更新，都会生成一个叫<code>update</code>的对象，并且会赋值给<code>Fiber.updateQueue</code></p>
<p>关于<code>update</code>请看此部分</p>
</blockquote>
<h5 id="scheduleWork"><a href="#scheduleWork" class="headerlink" title="scheduleWork"></a>scheduleWork</h5><blockquote>
<p>然后就是调用<code>scheduleWork</code>。注意到这里之前<code>setState</code>和<code>ReactDOM.render</code>是不一样，但进入<code>schedulerWork</code>之后，就是任务调度的事情了，跟之前你是怎么调用的没有任何关系</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberReconciler</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">scheduleRootUpdate</span>(<span class="params"></span></span><br><span class="line"><span class="params"> current: Fiber, <span class="comment">// RootFiber 对象</span></span></span><br><span class="line"><span class="params"> element: ReactNodeList,<span class="comment">// ReactElement</span></span></span><br><span class="line"><span class="params"> expirationTime: ExpirationTime,<span class="comment">// 计算出的超时时间</span></span></span><br><span class="line"><span class="params"> suspenseConfig: <span class="literal">null</span> | SuspenseConfig, <span class="comment">// null</span></span></span><br><span class="line"><span class="params"> callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">  <span class="comment">//创建Updater</span></span><br><span class="line"> <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(expirationTime)</span><br><span class="line"><span class="comment">//设置payload为React Element</span></span><br><span class="line"> update.<span class="property">payload</span> = &#123; element &#125;</span><br><span class="line"></span><br><span class="line"> callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback</span><br><span class="line"> <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="title function_">warningWithoutStack</span>(</span><br><span class="line">     <span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;render(...): Expected the last optional `callback` argument to be a &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;function. Instead received: %s.&#x27;</span>,</span><br><span class="line">     callback,</span><br><span class="line">   )</span><br><span class="line">   <span class="comment">//设置回调  </span></span><br><span class="line">   update.<span class="property">callback</span> = callback</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">//赋值给Fiber.updateQueue </span></span><br><span class="line"> <span class="title function_">enqueueUpdate</span>(current, update)</span><br><span class="line">&gt;<span class="comment">//任务调度,此部分就于后面部分详解</span></span><br><span class="line"> <span class="title function_">scheduleWork</span>(current, expirationTime)</span><br><span class="line"> <span class="keyword">return</span> expirationTime</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看<code>createUpdate</code>创建Updater</p>
</blockquote>
<h5 id="createUpdate"><a href="#createUpdate" class="headerlink" title="createUpdate"></a>createUpdate</h5><blockquote>
<p>首先要做的就是创建一个 Updater， React 中所有的更新都要创建 Updater</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactUpdateQueue.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createUpdate</span>(<span class="params"></span></span><br><span class="line"><span class="params"> expirationTime: ExpirationTime,</span></span><br><span class="line"><span class="params"> suspenseConfig: <span class="literal">null</span> | SuspenseConfig,</span></span><br><span class="line"><span class="params">&gt;</span>): <span class="title class_">Update</span>&lt;*&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> <span class="attr">update</span>: <span class="title class_">Update</span>&lt;*&gt; = &#123;</span><br><span class="line">   <span class="comment">// 更新的过期时间</span></span><br><span class="line">   expirationTime,</span><br><span class="line">   suspenseConfig,</span><br><span class="line">   <span class="comment">// export const UpdateState = 0;</span></span><br><span class="line">   <span class="comment">// export const ReplaceState = 1;</span></span><br><span class="line">   <span class="comment">// export const ForceUpdate = 2;</span></span><br><span class="line">   <span class="comment">// export const CaptureUpdate = 3;</span></span><br><span class="line">   <span class="comment">// 指定更新的类型，值为以上几种</span></span><br><span class="line">   <span class="attr">tag</span>: <span class="title class_">UpdateState</span>,</span><br><span class="line">   <span class="comment">// 更新内容，比如`setState`接收的第一个参数</span></span><br><span class="line">   <span class="attr">payload</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 对应的回调，`setState`，`render`都有</span></span><br><span class="line">   <span class="attr">callback</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 指向下一个更新</span></span><br><span class="line">   <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 指向下一个`side effect`</span></span><br><span class="line">   <span class="attr">nextEffect</span>: <span class="literal">null</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> update;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会对 update 中的成员变量赋值，之后执行 enqueueUpdate</p>
</blockquote>
<h5 id="enqueueUpdate"><a href="#enqueueUpdate" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate</h5><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactUpdateQueue.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> enqueueUpdate&lt;<span class="title class_">State</span>&gt;(<span class="attr">fiber</span>: <span class="title class_">Fiber</span>, <span class="attr">update</span>: <span class="title class_">Update</span>&lt;<span class="title class_">State</span>&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//alternate即workInProgress</span></span><br><span class="line">&gt;<span class="comment">//fiber即current</span></span><br><span class="line">&gt;<span class="comment">//current到alternate有一个映射关系</span></span><br><span class="line">&gt;<span class="comment">//所以要保证current和workInProgress的updateQueue是一致的</span></span><br><span class="line">&gt;<span class="keyword">const</span> alternate = fiber.<span class="property">alternate</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// current的队列</span></span><br><span class="line">&gt;<span class="keyword">let</span> queue1;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//alternate的队列</span></span><br><span class="line">&gt;<span class="keyword">let</span> queue2;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 如果 alternate 为null，说明此时没有更新，没有workInProgress，只更新queue1</span></span><br><span class="line">&gt;<span class="keyword">if</span> (alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// There&#x27;s only one fiber.</span></span><br><span class="line">&gt;queue1 = fiber.<span class="property">updateQueue</span>;</span><br><span class="line">&gt;queue2 = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 初始化更新队列，赋值给fiber.updateQueue</span></span><br><span class="line">queue1 = fiber.<span class="property">updateQueue</span> = <span class="title function_">createUpdateQueue</span>(fiber.<span class="property">memoizedState</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;<span class="comment">// There are two owners.</span></span><br><span class="line">&gt;<span class="comment">// /如果alternate不为空，则取各自的更新队列</span></span><br><span class="line">&gt;queue1 = fiber.<span class="property">updateQueue</span>;</span><br><span class="line">&gt;queue2 = alternate.<span class="property">updateQueue</span>;</span><br><span class="line">&gt;<span class="keyword">if</span> (queue1 === <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue2 === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// Neither fiber has an update queue. Create new ones.</span></span><br><span class="line">  queue1 = fiber.<span class="property">updateQueue</span> = <span class="title function_">createUpdateQueue</span>(fiber.<span class="property">memoizedState</span>);</span><br><span class="line">  queue2 = alternate.<span class="property">updateQueue</span> = <span class="title function_">createUpdateQueue</span>(</span><br><span class="line">    alternate.<span class="property">memoizedState</span>,</span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class="line">  <span class="comment">// 如果queue2存在但queue1不存在的话，则根据queue2复制queue1</span></span><br><span class="line">  <span class="comment">// 复制的时候 firstUpdate， lastUpdate 是共用的</span></span><br><span class="line">  queue1 = fiber.<span class="property">updateQueue</span> = <span class="title function_">cloneUpdateQueue</span>(queue2);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (queue2 === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// Only one fiber has an update queue. Clone to create a new one.</span></span><br><span class="line">  queue2 = alternate.<span class="property">updateQueue</span> = <span class="title function_">cloneUpdateQueue</span>(queue1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Both owners have an update queue.</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 经理上述步骤后，只可能是 queue2 为 null， queue1不可能为null</span></span><br><span class="line">&gt;<span class="keyword">if</span> (queue2 === <span class="literal">null</span> || queue1 === queue2) &#123;</span><br><span class="line">&gt;<span class="comment">// There&#x27;s only a single queue.</span></span><br><span class="line">&gt;<span class="comment">// 将update放入queue1中</span></span><br><span class="line">&gt;<span class="title function_">appendUpdateToQueue</span>(queue1, update);</span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;<span class="comment">// There are two queues. We need to append the update to both queues,</span></span><br><span class="line">&gt;<span class="comment">// while accounting for the persistent structure of the list — we don&#x27;t</span></span><br><span class="line">&gt;<span class="comment">// want the same update to be added multiple times.</span></span><br><span class="line">&gt;<span class="keyword">if</span> (queue1.<span class="property">lastUpdate</span> === <span class="literal">null</span> || queue2.<span class="property">lastUpdate</span> === <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// One of the queues is not empty. We must add the update to both queues.</span></span><br><span class="line"><span class="comment">// react不想多次将同一个的update放入队列中</span></span><br><span class="line"><span class="comment">// 如果两个都是空队列，则添加update</span></span><br><span class="line"><span class="title function_">appendUpdateToQueue</span>(queue1, update);</span><br><span class="line"><span class="title function_">appendUpdateToQueue</span>(queue2, update);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 如果两个都不是空队列，由于两个结构共享，所以只在queue1加入update</span></span><br><span class="line">&gt;<span class="comment">// 在queue2中，将lastUpdate指向update</span></span><br><span class="line">&gt;&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Both queues are non-empty. The last update is the same in both lists,</span></span><br><span class="line"><span class="comment">// because of structural sharing. So, only append to one of the lists.</span></span><br><span class="line"><span class="title function_">appendUpdateToQueue</span>(queue1, update);</span><br><span class="line"><span class="comment">// But we still need to update the `lastUpdate` pointer of queue2.</span></span><br><span class="line">queue2.<span class="property">lastUpdate</span> = update;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看着复杂，但实际上做的事情很简单，首先，初始化fiber对象上的updateQueue，没有的话新建一个，然后将这个update放到updateQueue中，其中让人迷惑的点在于为什么有两个queue，以及alternate的作用，简单来讲，在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber， 我们称他为<code>current &lt;==&gt; workInProgress</code>，在渲染完成之后他们会交换位置，这样就保证了更新过程中Fiber本身不变，两个queue也就这么产生了。</p>
<p><code>alternate</code>即workInProgress,current到alternate有一个映射关系</p>
</blockquote>
<h5 id="createUpdateQueue"><a href="#createUpdateQueue" class="headerlink" title="createUpdateQueue"></a>createUpdateQueue</h5><blockquote>
<p>createUpdateQueue 就是创建了对象，如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactUpdateQueue.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> createUpdateQueue&lt;<span class="title class_">State</span>&gt;(<span class="attr">baseState</span>: <span class="title class_">State</span>): <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">State</span>&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;<span class="title class_">State</span>&gt; = &#123;</span><br><span class="line">    <span class="comment">// 每次操作完更新之后的`state`</span></span><br><span class="line">   baseState,</span><br><span class="line">   <span class="comment">// 队列中的第一个`Update`</span></span><br><span class="line">   <span class="attr">firstUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 队列中的最后一个`Update`</span></span><br><span class="line">   <span class="attr">lastUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 第一个捕获类型的`Update`</span></span><br><span class="line">   <span class="attr">firstCapturedUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 最后一个捕获类型的`Update`</span></span><br><span class="line">   <span class="attr">lastCapturedUpdate</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 第一个`side effect`</span></span><br><span class="line">   <span class="attr">firstEffect</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 最后一个`side effect`</span></span><br><span class="line">   <span class="attr">lastEffect</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="comment">// 第一个和最后一个捕获产生的`side effect`</span></span><br><span class="line">   <span class="attr">firstCapturedEffect</span>: <span class="literal">null</span>,</span><br><span class="line">   <span class="attr">lastCapturedEffect</span>: <span class="literal">null</span>,</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">return</span> queue;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>到此，React 将更新放到了Fiber队列中，接下来就是使用scheduleWork来进行调度了，这个后续章节讲。</p>
</blockquote>
<h4 id="③-legacyCreateRootFromDOMContainer"><a href="#③-legacyCreateRootFromDOMContainer" class="headerlink" title="③ legacyCreateRootFromDOMContainer"></a>③ legacyCreateRootFromDOMContainer</h4><blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-dom\src\client\ReactDOM.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">legacyCreateRootFromDOMContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;container: DOMContainer,</span></span><br><span class="line"><span class="params">&gt;forceHydrate: boolean,</span></span><br><span class="line"><span class="params">&gt;</span>): _ReactSyncRoot &#123;</span><br><span class="line">&gt;<span class="comment">// 判断 forceHydrate 参数，render 函数插入的是false</span></span><br><span class="line">&gt;<span class="comment">// shouldHydrateDueToLegacyHeuristic 函数主要是判断我们传入的Dom元素上是否有 data-reactroot 属性，这个属性一般是服务端渲染的时候赋给的</span></span><br><span class="line">&gt;<span class="comment">//[shouldHydrate]用作后续判断是否复用页面上的DOM节点</span></span><br><span class="line">&gt;<span class="keyword">const</span> shouldHydrate =</span><br><span class="line">&gt;forceHydrate || <span class="title function_">shouldHydrateDueToLegacyHeuristic</span>(container);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 如果不复用页面上的 DOM 节点，那么调用 removeChild 方法将 DOM 节点的子节点全部清除 </span></span><br><span class="line">&gt;<span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">&gt;<span class="keyword">let</span> warned = <span class="literal">false</span>;</span><br><span class="line">&gt;<span class="keyword">let</span> rootSibling;</span><br><span class="line">&gt;<span class="comment">//循环删除每一个子节点</span></span><br><span class="line">&gt;<span class="keyword">while</span> ((rootSibling = container.<span class="property">lastChild</span>)) &#123;</span><br><span class="line">&gt;container.<span class="title function_">removeChild</span>(rootSibling);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 通过 new 创建对象</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactSyncRoot</span>(</span><br><span class="line">&gt;container,</span><br><span class="line">&gt;<span class="title class_">LegacyRoot</span>,<span class="comment">//LegacyRoot 是一个常量，代表的是传统的同步的渲染方式。</span></span><br><span class="line">&gt;shouldHydrate <span class="comment">//上面讲过 [这个属性一般是服务端渲染的时候赋给的,然后进行了判断],所以此处是判断是否为服务端渲染</span></span><br><span class="line">&gt;? &#123;</span><br><span class="line">&gt;<span class="attr">hydrate</span>: <span class="literal">true</span>,</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;: <span class="literal">undefined</span>,</span><br><span class="line">&gt;);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>LegacyRoot 是一个常量，代表的是传统的同步的渲染方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// shared\ReactRootTags.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">LegacyRoot</span> = <span class="number">0</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">BatchedRoot</span> = <span class="number">1</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ConcurrentRoot</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>接着看 <code>ReactSyncRoot</code> 函数</p>
</blockquote>
<h4 id="④-ReactSyncRoot"><a href="#④-ReactSyncRoot" class="headerlink" title="④  ReactSyncRoot"></a>④  ReactSyncRoot</h4><blockquote>
<p>创建<code>ReactRoot</code>的时候会调用<code>DOMRenderer.createContainer</code>创建<code>FiberRoot</code>，在后期调度更新的过程中这个节点非常重要</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-dom\src\client\ReactDOM.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ReactSyncRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;container: DOMContainer,</span></span><br><span class="line"><span class="params">&gt;tag: RootTag, <span class="comment">// Tag is either LegacyRoot or Concurrent Root</span></span></span><br><span class="line"><span class="params">&gt;options: <span class="keyword">void</span> | RootOptions, <span class="comment">//前方传来的[服务端渲染判断]相关参数</span></span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">&gt;<span class="keyword">const</span> hydrate = options != <span class="literal">null</span> &amp;&amp; options.<span class="property">hydrate</span> === <span class="literal">true</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> hydrationCallbacks =</span><br><span class="line">&gt;(options != <span class="literal">null</span> &amp;&amp; options.<span class="property">hydrationOptions</span>) || <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> root = <span class="title function_">createContainer</span>(container, tag, hydrate, hydrationCallbacks);</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 可以看出，new 出来的对象上，只有一个 _internalRoot 属性</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">_internalRoot</span> = root;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>实际调用的是 <code>createContainer</code> 函数</p>
<p>需要注意的是，如果不是ReactDOM.render，而是ReactDOM.unstable_createRoot，那么程序也会走到 createContainer 这步，但是 tag 就不是 RootTag，而是 ConcurrentRoot。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberReconciler.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;containerInfo: Container,</span></span><br><span class="line"><span class="params">&gt;tag: RootTag, <span class="comment">// 0</span></span></span><br><span class="line"><span class="params">&gt;hydrate: boolean, <span class="comment">// false</span></span></span><br><span class="line"><span class="params">&gt;hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks, </span></span><br><span class="line"><span class="params">&gt;</span>): <span class="title class_">OpaqueRoot</span> &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">createFiberRoot</span>(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用 <code>createFiberRoot</code> 函数</p>
</blockquote>
<h4 id="⑤-createFiberRoot"><a href="#⑤-createFiberRoot" class="headerlink" title="⑤ createFiberRoot"></a>⑤ createFiberRoot</h4><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberRoot.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createFiberRoot</span>(<span class="params"></span></span><br><span class="line"><span class="params"> containerInfo: any, <span class="comment">// div</span></span></span><br><span class="line"><span class="params"> tag: RootTag, <span class="comment">// 0</span></span></span><br><span class="line"><span class="params"> hydrate: boolean,<span class="comment">// false //是否服务端渲染</span></span></span><br><span class="line"><span class="params"> hydrationCallbacks: <span class="literal">null</span> | SuspenseHydrationCallbacks,<span class="comment">// null --&gt;根据是否服务端渲染决定此参数</span></span></span><br><span class="line"><span class="params">&gt;</span>): <span class="title class_">FiberRoot</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// new 一个 FiberRoot 对象</span></span><br><span class="line"> <span class="keyword">const</span> <span class="attr">root</span>: <span class="title class_">FiberRoot</span> = (<span class="keyword">new</span> <span class="title class_">FiberRootNode</span>(containerInfo, tag, hydrate): any);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// false 不用管</span></span><br><span class="line"> <span class="keyword">if</span> (enableSuspenseCallback) &#123;</span><br><span class="line">   root.<span class="property">hydrationCallbacks</span> = hydrationCallbacks;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Cyclic construction. This cheats the type system right now because</span></span><br><span class="line"> <span class="comment">// stateNode is any.</span></span><br><span class="line"> <span class="comment">// 创建了一个Fiber对象，由于是root节点的Fiber</span></span><br><span class="line"> <span class="keyword">const</span> uninitializedFiber = <span class="title function_">createHostRootFiber</span>(tag);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// FiberRoot 通过 current 指向 [uninitializedFiber] 对象</span></span><br><span class="line"> root.<span class="property">current</span> = uninitializedFiber;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// [uninitializedFiber] 通过 stateNode 指向 dom 节点</span></span><br><span class="line"> uninitializedFiber.<span class="property">stateNode</span> = root;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回 FiberRoot</span></span><br><span class="line"> <span class="keyword">return</span> root;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>调用 new FiberRootNode 创建了一个 FiberRoot 对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberRoot.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">FiberRootNode</span>(<span class="params">containerInfo, tag, hydrate</span>) &#123;</span><br><span class="line"> <span class="comment">// LegacyRoot | BatchedRoot | ConcurrentRoot</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line"> <span class="comment">// 当前应用对应的Fiber对象，是Root Fiber</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">current</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// root节点，render方法接收的第二个参数</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">containerInfo</span> = containerInfo;</span><br><span class="line">  <span class="comment">// react-dom不会用到</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">pendingChildren</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">pingCache</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">finishedExpirationTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line"> <span class="comment">// 已经完成的任务的FiberRoot对象，如果你只有一个Root，那他永远只可能是这个Root对应的Fiber，或者是null</span></span><br><span class="line"> <span class="comment">// 在commit阶段只会处理这个值对应的任务</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">finishedWork</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">timeoutHandle</span> = noTimeout;</span><br><span class="line"> <span class="comment">// 顶层context对象，只有主动调用`renderSubtreeIntoContainer`时才会有用</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">context</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">pendingContext</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">// 用来确定第一次渲染的时候是否需要融合</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">hydrate</span> = hydrate;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">firstBatch</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">callbackNode</span> = <span class="literal">null</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">callbackExpirationTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line"> <span class="comment">// 存在root中，最早的挂起时间</span></span><br><span class="line"> <span class="comment">// 不确定是否挂起的状态（所有任务一开始均是该状态）</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">firstPendingTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line"> <span class="comment">// 存在root中，最新的挂起时间</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">lastPendingTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">pingTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>createHostRootFiber</code> 创建一个Fiber对象</p>
</blockquote>
<h4 id="⑥-createHostRootFiber"><a href="#⑥-createHostRootFiber" class="headerlink" title="⑥ createHostRootFiber"></a>⑥ createHostRootFiber</h4><blockquote>
<p>此处会调用[createFiberRoot](#④ createFiberRoot)函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiber.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createHostRootFiber</span>(<span class="params">tag: RootTag</span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 通过tag来生成mode</span></span><br><span class="line"> <span class="keyword">let</span> mode;</span><br><span class="line"> <span class="keyword">if</span> (tag === <span class="title class_">ConcurrentRoot</span>) &#123;</span><br><span class="line">   mode = <span class="title class_">ConcurrentMode</span> | <span class="title class_">BatchedMode</span> | <span class="title class_">StrictMode</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="title class_">BatchedRoot</span>) &#123;</span><br><span class="line">   mode = <span class="title class_">BatchedMode</span> | <span class="title class_">StrictMode</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   mode = <span class="title class_">NoMode</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;</span><br><span class="line">   <span class="comment">// Always collect profile timings when DevTools are present.</span></span><br><span class="line">   <span class="comment">// This enables DevTools to start capturing timing at any point–</span></span><br><span class="line">   <span class="comment">// Without some nodes in the tree having empty base times.</span></span><br><span class="line">   mode |= <span class="title class_">ProfileMode</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// HostRoot 也是一个常量，用做标记，因为 root 节点的 Fiber 对象是Fiber树的头节点。后续会用的上</span></span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">createFiber</span>(<span class="title class_">HostRoot</span>, <span class="literal">null</span>, <span class="literal">null</span>, mode);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactTypeOfMode.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">NoMode</span> = <span class="number">0b0000</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">StrictMode</span> = <span class="number">0b0001</span>;</span><br><span class="line">&gt;<span class="comment">// <span class="doctag">TODO:</span> Remove BatchedMode and ConcurrentMode by reading from the root</span></span><br><span class="line">&gt;<span class="comment">// tag instead</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">BatchedMode</span> = <span class="number">0b0010</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ConcurrentMode</span> = <span class="number">0b0100</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ProfileMode</span> = <span class="number">0b1000</span>;</span><br></pre></td></tr></table></figure>

<p>在生成 mode 的过程中，用到了上面这些常量，是二进制的值。0b0100 | 0b0001 &#x3D; 0b0101。使用按位或操作，不仅能提高运行速度，在常量的判断上也很方便</p>
<p>接着调用<code>createFiber</code></p>
</blockquote>
<h4 id="⑦-createFiber"><a href="#⑦-createFiber" class="headerlink" title="⑦ createFiber"></a>⑦ createFiber</h4><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiber.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> createFiber = <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;tag: WorkTag,</span></span><br><span class="line"><span class="params">&gt;pendingProps: mixed,</span></span><br><span class="line"><span class="params">&gt;key: <span class="literal">null</span> | string,</span></span><br><span class="line"><span class="params">&gt;mode: TypeOfMode,</span></span><br><span class="line"><span class="params">&gt;</span>): <span class="title class_">Fiber</span> &#123;</span><br><span class="line">&gt;<span class="comment">// $FlowFixMe: the shapes are exact here but Flow doesn&#x27;t like constructors</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FiberNode</span>(tag, pendingProps, key, mode);</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiber.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;tag: WorkTag,</span></span><br><span class="line"><span class="params">&gt;pendingProps: mixed,</span></span><br><span class="line"><span class="params">&gt;key: <span class="literal">null</span> | string,</span></span><br><span class="line"><span class="params">&gt;mode: TypeOfMode,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// Instance</span></span><br><span class="line">&gt;<span class="comment">// 标记不同的组件类型</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">&gt;<span class="comment">// ReactElement里面的key</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">&gt;<span class="comment">// ReactElement.type，也就是我们调用`createElement`的第一个参数</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 异步组件resolved之后返回的内容，一般是`function`或者`class`</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">//跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Fiber</span></span><br><span class="line">&gt;<span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 单链表树结构</span></span><br><span class="line">&gt;<span class="comment">// 指向自己的第一个子节点</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 指向自己的兄弟结构</span></span><br><span class="line">&gt;<span class="comment">// 兄弟节点的return指向同一个父节点</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// ref属性</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 新的变动带来的新的props</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">&gt;<span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 一个列表，存放这个Fiber依赖的context</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 用来描述当前Fiber和他子树的`Bitfield`</span></span><br><span class="line">&gt;<span class="comment">// 共存的模式表示这个子树是否默认是异步渲染的</span></span><br><span class="line">&gt;<span class="comment">// Fiber被创建的时候他会继承父Fiber</span></span><br><span class="line">&gt;<span class="comment">// 其他的标识也可以在创建的时候被设置</span></span><br><span class="line">&gt;<span class="comment">// 但是在创建之后不应该再被修改，特别是他的子Fiber创建之前</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Effects</span></span><br><span class="line">&gt;<span class="comment">// 用来记录Side Effect</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>;</span><br><span class="line">&gt;<span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 子树中第一个side effect</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;<span class="comment">// 子树中最后一个side effect</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line">&gt;<span class="comment">// 不包括他的子树产生的任务</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">expirationTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line">&gt;<span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">childExpirationTime</span> = <span class="title class_">NoWork</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span></span><br><span class="line">&gt;<span class="comment">// 我们称他为`current &lt;==&gt; workInProgress`</span></span><br><span class="line">&gt;<span class="comment">// 在渲染完成之后他们会交换位置</span></span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>终于把这个 RootFiber 创建出来了。接下来回到 legacyRenderSubtreeIntoContainer 函数，<code>执行 updateContainer(children, fiberRoot, parentComponent, callback)</code>。children是传入的 React 组件， fiberRoot 是一个 FiberRoot 对象，parentComponent 是 null。    </p>
<p>updateContainer在前方②处已经给出详解–&gt;[② updateContainer](#② updateContainer)</p>
</blockquote>
<h2 id="2、expirationTime计算公式"><a href="#2、expirationTime计算公式" class="headerlink" title="2、expirationTime计算公式"></a>2、expirationTime计算公式</h2><blockquote>
<p>expirationTime代表任务在未来的哪个时间点应该被完成。[<code>1、ReactDOM.render的</code>[② updateContainer](#② updateContainer)]中略过了它的计算分析，这里重新梳理下逻辑。</p>
</blockquote>
<h3 id="Ⅰ-回到updateContainer方法开始分析"><a href="#Ⅰ-回到updateContainer方法开始分析" class="headerlink" title="Ⅰ-回到updateContainer方法开始分析"></a>Ⅰ-回到<code>updateContainer</code>方法开始分析</h3><blockquote>
<p>[② updateContainer](#② updateContainer)</p>
<p>在生成一个新的Fiber节点后，需要更新这个Fibre节点的一些字段，调用 <code>updateContainer</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberReconciler.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">updateContainer</span>(<span class="params"></span></span><br><span class="line"><span class="params"> element: ReactNodeList,</span></span><br><span class="line"><span class="params"> container: OpaqueRoot,</span></span><br><span class="line"><span class="params"> parentComponent: ?React$Component&lt;any, any&gt;,</span></span><br><span class="line"><span class="params"> callback: ?<span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">&gt;</span>): <span class="title class_">ExpirationTime</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> current = container.<span class="property">current</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当前时间的一个变换</span></span><br><span class="line"> <span class="keyword">const</span> currentTime = <span class="title function_">requestCurrentTime</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 忽略，返回null</span></span><br><span class="line"> <span class="keyword">const</span> suspenseConfig = <span class="title function_">requestCurrentSuspenseConfig</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算过期时间</span></span><br><span class="line"> <span class="keyword">const</span> expirationTime = <span class="title function_">computeExpirationForFiber</span>(</span><br><span class="line">   currentTime,</span><br><span class="line">   current,</span><br><span class="line">   suspenseConfig,</span><br><span class="line"> );</span><br><span class="line"> <span class="keyword">return</span> <span class="title function_">updateContainerAtExpirationTime</span>(</span><br><span class="line">   element,</span><br><span class="line">   container,</span><br><span class="line">   parentComponent,</span><br><span class="line">   expirationTime,</span><br><span class="line">   suspenseConfig,</span><br><span class="line">   callback,</span><br><span class="line"> );</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Ⅱ-requestCurrentTime"><a href="#Ⅱ-requestCurrentTime" class="headerlink" title="Ⅱ- requestCurrentTime"></a>Ⅱ- requestCurrentTime</h3><blockquote>
<p>首先看下其中调用的 <code>requestCurrentTime</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberReconciler.js</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">requestCurrentTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">&gt;<span class="keyword">if</span> ((executionContext &amp; (<span class="title class_">RenderContext</span> | <span class="title class_">CommitContext</span>)) !== <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 我们在React内部，所以可以读取实际时间。  </span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">msToExpirationTime</span>(<span class="title function_">now</span>());</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 我们不在React中，所以我们可能在浏览器事件的中间</span></span><br><span class="line">&gt;<span class="keyword">if</span> (currentEventTime !== <span class="title class_">NoWork</span>) &#123;</span><br><span class="line">&gt;<span class="comment">//所有更新使用相同的开始时间，直到我们再次进入React。  </span></span><br><span class="line">&gt;<span class="keyword">return</span> currentEventTime;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// 这是React推出以来的第一次更新。 计算一个新的开始时间。  </span></span><br><span class="line">&gt;currentEventTime = <span class="title function_">msToExpirationTime</span>(<span class="title function_">now</span>());<span class="comment">//msToExpirationTime 函数是用一个固定值减去当前 ms 值除以10取整</span></span><br><span class="line">&gt;<span class="keyword">return</span> currentEventTime;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>我们一句一句看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> ((executionContext &amp; (<span class="title class_">RenderContext</span> | <span class="title class_">CommitContext</span>)) !== <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">&gt;<span class="comment">// 我们在React内部，所以可以读取实际时间。  </span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="title function_">msToExpirationTime</span>(<span class="title function_">now</span>());<span class="comment">//msToExpirationTime 函数是用一个固定值减去当前 ms 值除以10取整</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要看一个全局变量， 那就是 <code>executionContext</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">NoContext</span> = <span class="comment">/*                    */</span> <span class="number">0b000000</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">BatchedContext</span> = <span class="comment">/*               */</span> <span class="number">0b000001</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">EventContext</span> = <span class="comment">/*                 */</span> <span class="number">0b000010</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">DiscreteEventContext</span> = <span class="comment">/*         */</span> <span class="number">0b000100</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">LegacyUnbatchedContext</span> = <span class="comment">/*       */</span> <span class="number">0b001000</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">RenderContext</span> = <span class="comment">/*                */</span> <span class="number">0b010000</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">CommitContext</span> = <span class="comment">/*                */</span> <span class="number">0b100000</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">let</span> <span class="attr">executionContext</span>: <span class="title class_">ExecutionContext</span> = <span class="title class_">NoContext</span>;</span><br></pre></td></tr></table></figure>

<p>可以看出， <code>executionContext 是一个二进制的枚举值</code>， 初始值为 NoContext。</p>
<p>executionContext &amp; (RenderContext | CommitContext)) !&#x3D;&#x3D; NoContext 这句话其实是<code>判断当前 executionContext 是否处在 RenderContext 或者是 CommitContext 的阶段。</code></p>
<p>那么什么时候 executionContext 会是 RenderContext 或者是 CommitContext 的阶段呢。只有在你 <code>renderRoot</code> 的时候， executionContext有可能是这两个值。<code>RenderContext代表着React正在计算更新</code>，<code>CommitContext代表着React正在提交更新</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Sync</span> = <span class="variable constant_">MAX_SIGNED_31_BIT_INT</span>;</span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Batched</span> = <span class="title class_">Sync</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">UNIT_SIZE</span> = <span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">const</span> <span class="variable constant_">MAGIC_NUMBER_OFFSET</span> = <span class="title class_">Batched</span> - <span class="number">1</span>;</span><br><span class="line">&gt;<span class="comment">//msToExpirationTime 函数是用一个固定值减去当前 ms 值除以10取整</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">msToExpirationTime</span>(<span class="params">ms: number</span>): <span class="title class_">ExpirationTime</span> &#123;</span><br><span class="line">&gt;<span class="comment">// 总是添加偏移量，这样我们就不会与NoWork的神奇数字发生冲突。</span></span><br><span class="line">&gt;<span class="keyword">return</span> <span class="variable constant_">MAGIC_NUMBER_OFFSET</span> - ((ms / <span class="variable constant_">UNIT_SIZE</span>) | <span class="number">0</span>);</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">//expirationTimeToMs 是将expirationTime还原为 ms 值。</span></span><br><span class="line">&gt;<span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">expirationTimeToMs</span>(<span class="params">expirationTime: ExpirationTime</span>): number &#123;</span><br><span class="line">&gt;<span class="keyword">return</span> (<span class="variable constant_">MAGIC_NUMBER_OFFSET</span> - expirationTime) * <span class="variable constant_">UNIT_SIZE</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">ceiling</span>(<span class="params">num: number, precision: number</span>): number &#123;</span><br><span class="line"> <span class="keyword">return</span> (((num / precision) | <span class="number">0</span>) + <span class="number">1</span>) * precision</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>msToExpirationTime 函数是用一个固定值减去当前 ms 值除以10取整。expirationTimeToMs 是将expirationTime还原为 ms 值。 <code>这里为什么要除以10呢，原因是可以抹平10ms以内的误差，前后很近的两次更新，计算出的 expirationTime 是一样的，有利于批量更新</code>。</p>
<p><code>根据这个规则，优先级越高的任务，计算出的 expirationTime 越大（这和之前版本是完全反着的）</code>。Sync 是最大的， 它等以MAX_SIGNED_31_BIT_INT，是0b111111111111111111111111111111。</p>
<p>综上，我们可以认为:</p>
<ol>
<li>在 render 和 commit 阶段我们直接获取当前真实时间。</li>
<li><code>而且currentEventTime不处于NoWork就说明react正在处理浏览器事件，React想让来自同一事件的相同优先级的更新的保持相同的时间，因此直接返回之前的时间</code>。</li>
</ol>
<ul>
<li>React 这么设计抹相当于抹平了<code>25ms</code>内计算过期时间的误差，那他为什么要这么做呢？我思考了很久都没有得到答案，直到有一天我盯着代码发呆，看到<code>LOW_PRIORITY_BATCH_SIZE</code>这个字样，<code>bacth</code>，是不是就对应<code>batchedUpdates</code>？再细想了一下，这么做也许是为了让非常相近的两次更新得到相同的<code>expirationTime</code>，然后在一次更新中完成，相当于一个自动的<code>batchedUpdates</code>。</li>
</ul>
<ol start="3">
<li>如果没有任务我们计算一个新的当前时间并赋给全局变量。</li>
<li>另外一个要提的就是<code>msToExpirationTime</code>和<code>expirationTimeToMs</code>方法，他们是想换转换的关系。<strong>有一点非常重要，那就是用来计算<code>expirationTime</code>的<code>currentTime</code>是通过<code>msToExpirationTime(now)</code>得到的，也就是预先处理过的，先处以<code>10</code>再加了<code>2</code>，所以后面计算<code>expirationTime</code>要减去<code>2</code>也就不奇怪了</strong></li>
</ol>
</blockquote>
<h3 id="Ⅲ-各种不同的expirationTime"><a href="#Ⅲ-各种不同的expirationTime" class="headerlink" title="Ⅲ-各种不同的expirationTime"></a>Ⅲ-各种不同的expirationTime</h3><blockquote>
<p>在 React 的调度过程中存在着非常多不同的*<code>expirationTime</code>*变量帮助 React 去实现在单线程环境中调度不同优先级的任务这个需求</p>
<ul>
<li><code>root.expirationTime</code></li>
<li><code>root.nextExpirationTimeToWorkOn</code></li>
<li><code>root.childExpirationTime</code></li>
<li><code>root.earliestPendingTime &amp; root.lastestPendingTime</code></li>
<li><code>root.earliestSuspendedTime &amp; root.lastestSuspendedTime</code></li>
<li><code>root.lastestPingedTime</code></li>
<li><code>nextFlushedExpirationTime</code></li>
<li><code>nextLatestAbsoluteTimeoutMs</code></li>
<li><code>currentRendererTime</code></li>
<li><code>currentSchedulerTime</code></li>
</ul>
<p>另外，所有节点都会具有<code>expirationTime</code>和<code>childExpirationTime</code>两个属性</p>
<p>以上所有值初始都是<code>NoWork</code>也就是<code>0</code>，以及他们一共会有三种情况：</p>
<ul>
<li><code>NoWork</code>，代表没有更新</li>
<li><code>Sync</code>，代表同步执行，不会被调度也不会被打断</li>
<li><code>async</code>模式下计算出来的过期时间，一个时间戳</li>
</ul>
<p>更详细请看官方文档叙述,这里不再赘述</p>
</blockquote>
<h2 id="3、setState"><a href="#3、setState" class="headerlink" title="3、setState"></a>3、setState</h2><blockquote>
<p>setState 用于更新 state 的状态，也是我们最常用的一个 API。举个栗子:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//栗子</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"> state = &#123;  <span class="attr">num</span>: <span class="number">1</span> &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="title function_">updateNum1</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> newNum = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span> + <span class="number">1</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">     &#123;<span class="attr">num</span>: newNum&#125;，</span><br><span class="line">     <span class="comment">//这里打印的是最新的state值</span></span><br><span class="line">     () =&gt; &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span>); &#125;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="title function_">updateNum2</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> newNum = <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span> + <span class="number">1</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">     <span class="function">(<span class="params">preState</span>) =&gt;</span> &#123;<span class="attr">num</span>: preState.<span class="property">num</span> + <span class="number">1</span>&#125;,</span><br><span class="line">     <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">num</span>); &#125;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>setState 的第一个参数可以传对象，也可以传方法，如果传对象，这个对象表示的就是新的 state，如果传方法，方法的返回值就是新的 state，方法入参则是当前的 state。第二个参数是一个回调函数，代表的是 setState 更新成功后执行的方法。这也是我们都知道的知识点了</p>
</blockquote>
<h3 id="Ⅰ-setState-的定义来源于-React-Component"><a href="#Ⅰ-setState-的定义来源于-React-Component" class="headerlink" title="Ⅰ-setState 的定义来源于 React.Component"></a>Ⅰ-setState 的定义来源于 React.Component</h3><blockquote>
<p>setState 的定义来源于 React.Component</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactBaseClasses.js</span></span><br><span class="line">&gt;<span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span>(<span class="params">partialState, callback</span>) &#123;</span><br><span class="line"> <span class="title function_">invariant</span>(</span><br><span class="line">   <span class="keyword">typeof</span> partialState === <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">     <span class="keyword">typeof</span> partialState === <span class="string">&#x27;function&#x27;</span> ||</span><br><span class="line">     partialState == <span class="literal">null</span>,</span><br><span class="line">     <span class="comment">//警告</span></span><br><span class="line">   <span class="string">&#x27;setState(...): takes an object of state variables to update or a &#x27;</span> +</span><br><span class="line">     <span class="string">&#x27;function which returns an object of state variables.&#x27;</span>,</span><br><span class="line"> );</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>可以很明显的看到，<code>setState 的第一参数需要判断是否是对象，或者是函数，而且不能为空</code>。</p>
</blockquote>
<h3 id="Ⅱ-this-updater-是什么时候赋值的呢？"><a href="#Ⅱ-this-updater-是什么时候赋值的呢？" class="headerlink" title="Ⅱ-this.updater 是什么时候赋值的呢？"></a>Ⅱ-this.updater 是什么时候赋值的呢？</h3><blockquote>
<p>这里有一个问题就是 this.updater 是什么时候赋值的呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactBaseClasses.js</span></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props, context, updater</span>) &#123;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;<span class="variable language_">this</span>.<span class="property">updater</span> = updater || <span class="title class_">ReactNoopUpdateQueue</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>Component 在初始化的时候，如果 updater 没有传入，默认使用ReactNoopUpdateQueue 进行初始化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react\src\ReactNoopUpdateQueue.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="title class_">ReactNoopUpdateQueue</span> = &#123;</span><br><span class="line">&gt;...</span><br><span class="line">&gt;<span class="attr">enqueueSetState</span>: <span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">&gt;publicInstance,</span></span><br><span class="line"><span class="params">&gt;partialState,</span></span><br><span class="line"><span class="params">&gt;callback,</span></span><br><span class="line"><span class="params">&gt;callerName,</span></span><br><span class="line"><span class="params">&gt;</span>) &#123;</span><br><span class="line">&gt;<span class="title function_">warnNoop</span>(publicInstance, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">&gt;&#125;,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>ReactNoopUpdateQueue 主要起到一个在非生产版本中警告(warning)的作用。真正的 updater 是在 render 中注入(inject)的。<code>因此如果你在 constructor 中尝试调用 setState,也会给出相应的警告表明在非安装或已卸载的组件中不能使用setState。</code></p>
</blockquote>
<h3 id="Ⅲ-为什么这么设计呢"><a href="#Ⅲ-为什么这么设计呢" class="headerlink" title="Ⅲ-为什么这么设计呢?"></a>Ⅲ-为什么这么设计呢?</h3><blockquote>
<p>React 源码大量地依赖于注入原则，实现在其他平台环境的渲染，即它可用于React Native，在浏览器端或服务器端运行的 ReactDOM。真实的update 的注入会在后续讲到。这里假设这个 updater 已经注入完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberClassComponent.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line">&gt;isMounted,</span><br><span class="line"> <span class="title function_">enqueueSetState</span>(<span class="params">inst, payload, callback</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line">&gt;<span class="keyword">const</span> currentTime = <span class="title function_">requestCurrentTime</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> suspenseConfig = <span class="title function_">requestCurrentSuspenseConfig</span>();</span><br><span class="line">&gt;<span class="keyword">const</span> expirationTime = <span class="title function_">computeExpirationForFiber</span>(</span><br><span class="line">currentTime,</span><br><span class="line">fiber,</span><br><span class="line">suspenseConfig,</span><br><span class="line">&gt;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(expirationTime, suspenseConfig);</span><br><span class="line"> update.<span class="property">payload</span> = payload;</span><br><span class="line">   <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    update.<span class="property">callback</span> = callback;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="title function_">enqueueUpdate</span>(fiber, update);</span><br><span class="line">   <span class="title function_">scheduleWork</span>(fiber, expirationTime);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;...</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>enqueueSetState 的代码和 之前讲的 scheduleRootUpdate 的代码基本上是一模一样的，就不加赘述了。</p>
</blockquote>
<h3 id="Ⅳ-forceUpdate"><a href="#Ⅳ-forceUpdate" class="headerlink" title="Ⅳ-forceUpdate"></a>Ⅳ-forceUpdate</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// react-reconciler\src\ReactFiberClassComponent.js</span></span><br><span class="line">&gt;<span class="keyword">const</span> classComponentUpdater = &#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="title function_">enqueueForceUpdate</span>(<span class="params">inst, callback</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> fiber = <span class="title function_">getInstance</span>(inst);</span><br><span class="line">   <span class="keyword">const</span> currentTime = <span class="title function_">requestCurrentTime</span>();</span><br><span class="line">   <span class="keyword">const</span> suspenseConfig = <span class="title function_">requestCurrentSuspenseConfig</span>();</span><br><span class="line">   <span class="keyword">const</span> expirationTime = <span class="title function_">computeExpirationForFiber</span>(</span><br><span class="line">     currentTime,</span><br><span class="line">     fiber,</span><br><span class="line">     suspenseConfig,</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> update = <span class="title function_">createUpdate</span>(expirationTime, suspenseConfig);</span><br><span class="line">   update.<span class="property">tag</span> = <span class="title class_">ForceUpdate</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (callback !== <span class="literal">undefined</span> &amp;&amp; callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">     update.<span class="property">callback</span> = callback;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="title function_">enqueueUpdate</span>(fiber, update);</span><br><span class="line">   <span class="title function_">scheduleWork</span>(fiber, expirationTime);</span><br><span class="line"> &#125;,</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>

<p>setState和forceUpdate的代码我们可以看到，几乎是一模一样的。唯一的区别是Update.tag</p>
</blockquote>
<h1 id="三、任务调度"><a href="#三、任务调度" class="headerlink" title="三、任务调度"></a>三、任务调度</h1><blockquote>
<p>从一开始React 创建了update，并且将 update 放入 updateQueue 中,接下来就是任务调度的过程。任务调度的起点是 <code>scheduleWork</code> 方法</p>
<ol>
<li>不同模式调度</li>
</ol>
<ul>
<li>同步模式 &#x3D;&gt; 是否是初次挂载 &#x3D;&gt; 是 &#x3D;&gt; 直接调用renderRoot渲染更新</li>
<li>同步模式 &#x3D;&gt; 是否是初次挂载 &#x3D;&gt; 否 &#x3D;&gt; 调用 scheduleCallbackForRoot 进行callback调度</li>
<li>异步模式 &#x3D;&gt; 获取优先级 &#x3D;&gt; 调用 scheduleCallbackForRoot 进行 callback 调度</li>
</ul>
<ol start="2">
<li>总结</li>
</ol>
<ul>
<li>React 中调度的基本单位是 task，目前看来，task 有两类，一类是同步的时候，task 其实是 flushSyncCallbackQueue，异步的时候是 renderRoot。这两个任务其实都是 renderRoot，只是调度的方式不同，同步任务会一次性的遍历所有任务并执行（因为 flushSyncCallbackQueue 将任务队列看成是一个任务），异步任务维度更细，是一个一个的调度。</li>
<li>同步任务其实并没有实际上做任何的调度，原因在于同步的时候，只有一个任务，那就是 flushSyncCallbackQueue，只会有一个，在这个任务中，完成所有用户提交的变更，之后再次生成一个 flushSyncCallbackQueue 任务。</li>
</ul>
</blockquote>
<h3 id="Ⅰ-scheduleWork"><a href="#Ⅰ-scheduleWork" class="headerlink" title="Ⅰ-scheduleWork"></a>Ⅰ-scheduleWork</h3><h4 id="①-scheduleWork源码"><a href="#①-scheduleWork源码" class="headerlink" title="① scheduleWork源码"></a>① scheduleWork源码</h4><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">scheduleWork</span>(<span class="params">fiber: Fiber, expirationTime: ExpirationTime</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> root = <span class="title function_">scheduleWorkToRoot</span>(fiber, expirationTime)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (enableSchedulerTracing) &#123;</span><br><span class="line">   <span class="title function_">storeInteractionsForExpirationTime</span>(root, expirationTime, <span class="literal">true</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line">   !isWorking &amp;&amp;</span><br><span class="line">   nextRenderExpirationTime !== <span class="title class_">NoWork</span> &amp;&amp;</span><br><span class="line">   expirationTime &lt; nextRenderExpirationTime</span><br><span class="line"> ) &#123;</span><br><span class="line">   <span class="comment">// This is an interruption. (Used for performance tracking.)</span></span><br><span class="line">   interruptedBy = fiber</span><br><span class="line">   <span class="title function_">resetStack</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">markPendingPriorityLevel</span>(root, expirationTime)</span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line">   <span class="comment">// If we&#x27;re in the render phase, we don&#x27;t need to schedule this root</span></span><br><span class="line">   <span class="comment">// for an update, because we&#x27;ll do it before we exit...</span></span><br><span class="line">   !isWorking ||</span><br><span class="line">   isCommitting ||</span><br><span class="line">   <span class="comment">// ...unless this is a different root than the one we&#x27;re rendering.</span></span><br><span class="line">   nextRoot !== root</span><br><span class="line"> ) &#123;</span><br><span class="line">   <span class="keyword">const</span> rootExpirationTime = root.<span class="property">expirationTime</span></span><br><span class="line">   <span class="title function_">requestWork</span>(root, rootExpirationTime)</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">scheduleWorkToRoot</span>(<span class="params">fiber: Fiber, expirationTime</span>): <span class="title class_">FiberRoot</span> | <span class="literal">null</span> &#123;</span><br><span class="line"> <span class="comment">// Update the source fiber&#x27;s expiration time</span></span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line">   fiber.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span> ||</span><br><span class="line">   fiber.<span class="property">expirationTime</span> &gt; expirationTime</span><br><span class="line"> ) &#123;</span><br><span class="line">   fiber.<span class="property">expirationTime</span> = expirationTime</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> alternate = fiber.<span class="property">alternate</span></span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line">   alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">   (alternate.<span class="property">expirationTime</span> === <span class="title class_">NoWork</span> ||</span><br><span class="line">     alternate.<span class="property">expirationTime</span> &gt; expirationTime)</span><br><span class="line"> ) &#123;</span><br><span class="line">   alternate.<span class="property">expirationTime</span> = expirationTime</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Walk the parent path to the root and update the child expiration time.</span></span><br><span class="line"> <span class="keyword">let</span> node = fiber.<span class="property">return</span></span><br><span class="line"> <span class="keyword">if</span> (node === <span class="literal">null</span> &amp;&amp; fiber.<span class="property">tag</span> === <span class="title class_">HostRoot</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> fiber.<span class="property">stateNode</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">   alternate = node.<span class="property">alternate</span></span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">     node.<span class="property">childExpirationTime</span> === <span class="title class_">NoWork</span> ||</span><br><span class="line">     node.<span class="property">childExpirationTime</span> &gt; expirationTime</span><br><span class="line">   ) &#123;</span><br><span class="line">     node.<span class="property">childExpirationTime</span> = expirationTime</span><br><span class="line">     <span class="keyword">if</span> (</span><br><span class="line">       alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">       (alternate.<span class="property">childExpirationTime</span> === <span class="title class_">NoWork</span> ||</span><br><span class="line">         alternate.<span class="property">childExpirationTime</span> &gt; expirationTime)</span><br><span class="line">     ) &#123;</span><br><span class="line">       alternate.<span class="property">childExpirationTime</span> = expirationTime</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">     alternate !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">     (alternate.<span class="property">childExpirationTime</span> === <span class="title class_">NoWork</span> ||</span><br><span class="line">       alternate.<span class="property">childExpirationTime</span> &gt; expirationTime)</span><br><span class="line">   ) &#123;</span><br><span class="line">     alternate.<span class="property">childExpirationTime</span> = expirationTime</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (node.<span class="property">return</span> === <span class="literal">null</span> &amp;&amp; node.<span class="property">tag</span> === <span class="title class_">HostRoot</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> node.<span class="property">stateNode</span></span><br><span class="line">   &#125;</span><br><span class="line">   node = node.<span class="property">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">resetStack</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (nextUnitOfWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> interruptedWork = nextUnitOfWork.<span class="property">return</span></span><br><span class="line">   <span class="keyword">while</span> (interruptedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="title function_">unwindInterruptedWork</span>(interruptedWork)</span><br><span class="line">     interruptedWork = interruptedWork.<span class="property">return</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> nextRoot = <span class="literal">null</span></span><br><span class="line"> nextRenderExpirationTime = <span class="title class_">NoWork</span></span><br><span class="line"> nextLatestAbsoluteTimeoutMs = -<span class="number">1</span></span><br><span class="line"> nextRenderDidError = <span class="literal">false</span></span><br><span class="line"> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="②-scheduleWork初步解析"><a href="#②-scheduleWork初步解析" class="headerlink" title="② scheduleWork初步解析"></a>② scheduleWork初步解析</h4><blockquote>
<p>这里先<code>scheduleWorkToRoot</code>，这一步非常重要，他主要做了一下几个任务</p>
<ul>
<li>找到当前<code>Fiber</code>的 root</li>
<li>给更新节点的父节点链上的每个节点的<code>expirationTime</code>设置为这个<code>update</code>的<code>expirationTime</code>，除非他本身时间要小于<code>expirationTime</code></li>
<li>给更新节点的父节点链上的每个节点的<code>childExpirationTime</code>设置为这个<code>update</code>的<code>expirationTime</code>，除非他本身时间要小于<code>expirationTime</code></li>
</ul>
<p>最终返回 root 节点的<code>Fiber</code>对象</p>
<p>然后进入一个判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (</span><br><span class="line"> !isWorking &amp;&amp;</span><br><span class="line"> nextRenderExpirationTime !== <span class="title class_">NoWork</span> &amp;&amp;</span><br><span class="line"> expirationTime &lt; nextRenderExpirationTime</span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure>

<p>我们来解释一下这几个变量的意思</p>
<ol>
<li><code>isWorking</code>代表是否正在工作，在开始<code>renderRoot</code>和<code>commitRoot</code>的时候会设置为 true，也就是在<code>render</code>和<code>commit</code>两个阶段都会为<code>true</code></li>
<li><code>nextRenderExpirationTime</code>在是新的<code>renderRoot</code>的时候会被设置为当前任务的<code>expirationTime</code>，而且一旦他被，只有当下次任务是<code>NoWork</code>的时候他才会被再次设置为<code>NoWork</code>，当然最开始也是<code>NoWork</code></li>
</ol>
<p>那么这个条件就很明显了：<strong>目前没有任何任务在执行，并且之前有执行过任务，同时当前的任务比之前执行的任务过期时间要早（也就是优先级要高）</strong></p>
<p>那么这种情况会出现在什么时候呢？答案就是：<strong>上一个任务是异步任务（优先级很低，超时时间是 502ms），并且在上一个时间片（初始是 33ms）任务没有执行完，而且等待下一次<code>requestIdleCallback</code>的时候新的任务进来了，并且超时时间很短（52ms 或者 22ms 甚至是 Sync），那么优先级就变成了先执行当前任务，也就意味着上一个任务被打断了（interrupted）</strong></p>
<p>被打断的任务会从当前节点开始往上推出<code>context</code>，因为在 React 只有一个<code>stack</code>，而下一个任务会从头开始的，所以在开始之前需要清空之前任务的的<code>stack</code>。</p>
<p>然后重置所有的公共变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;nextRoot = <span class="literal">null</span></span><br><span class="line">&gt;nextRenderExpirationTime = <span class="title class_">NoWork</span></span><br><span class="line">&gt;nextLatestAbsoluteTimeoutMs = -<span class="number">1</span></span><br><span class="line">&gt;nextRenderDidError = <span class="literal">false</span></span><br><span class="line">&gt;nextUnitOfWork = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="②-markPendingPriorityLevel"><a href="#②-markPendingPriorityLevel" class="headerlink" title="② markPendingPriorityLevel"></a>② markPendingPriorityLevel</h4><blockquote>
<p>这个方法会记录当前的<code>expirationTime</code>到<code>pendingTime</code>，让<code>expirationTime</code>处于<code>earliestPendingTime</code>和<code>latestPendingTime</code>之间</p>
<p>并且会设置<code>root.nextExpirationTimeToWorkOn</code>和<code>root.expirationTime = expirationTime</code>分别是：</p>
<ul>
<li>最早的<code>pendingTime</code>或者<code>pingedTime</code>，如果都没有则是<code>lastestSuspendTime</code></li>
<li><code>suspendedTime</code>和<code>nextExpirationTimeToWorkOn</code>中较早的一个</li>
</ul>
</blockquote>
<h4 id="③-调用-requestWork"><a href="#③-调用-requestWork" class="headerlink" title="③ 调用 requestWork"></a>③ 调用 requestWork</h4><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span> (</span><br><span class="line"> !isWorking ||</span><br><span class="line"> isCommitting ||</span><br><span class="line"> nextRoot !== root</span><br><span class="line">&gt;)</span><br></pre></td></tr></table></figure>

<p>这个判断条件就比较简单了，<code>!isWorking || isCommitting</code>简单来说就是要么处于没有 work 的状态，要么只能在 render 阶段，不能处于 commit 阶段（比较好奇什么时候会在 commit 阶段有新的任务进来，commit 都是同步的无法打断）。还有一个选项<code>nextRoot !== root</code>，这个的意思就是你的 APP 如果有两个不同的 root，这时候也符合条件。</p>
<p>在符合条件之后就<code>requestWork</code>了 </p>
</blockquote>
<h2 id="Ⅱ-requestWork"><a href="#Ⅱ-requestWork" class="headerlink" title="Ⅱ-requestWork"></a>Ⅱ-requestWork</h2><h3 id="①-requestWork源码"><a href="#①-requestWork源码" class="headerlink" title="① requestWork源码"></a>① requestWork源码</h3><blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">requestWork</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) &#123;</span><br><span class="line"> <span class="title function_">addRootToSchedule</span>(root, expirationTime)</span><br><span class="line"> <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">   <span class="comment">// Prevent reentrancy. Remaining work will be scheduled at the end of</span></span><br><span class="line">   <span class="comment">// the currently rendering batch.</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (isBatchingUpdates) &#123;</span><br><span class="line">   <span class="comment">// Flush work at the end of the batch.</span></span><br><span class="line">   <span class="keyword">if</span> (isUnbatchingUpdates) &#123;</span><br><span class="line">     nextFlushedRoot = root</span><br><span class="line">     nextFlushedExpirationTime = <span class="title class_">Sync</span></span><br><span class="line">     <span class="title function_">performWorkOnRoot</span>(root, <span class="title class_">Sync</span>, <span class="literal">true</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (expirationTime === <span class="title class_">Sync</span>) &#123;</span><br><span class="line">   <span class="title function_">performSyncWork</span>()</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="title function_">scheduleCallbackWithExpirationTime</span>(root, expirationTime)</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">function</span> <span class="title function_">addRootToSchedule</span>(<span class="params">root: FiberRoot, expirationTime: ExpirationTime</span>) &#123;</span><br><span class="line"> <span class="comment">// Add the root to the schedule.</span></span><br><span class="line"> <span class="comment">// Check if this root is already part of the schedule.</span></span><br><span class="line"> <span class="keyword">if</span> (root.<span class="property">nextScheduledRoot</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">// This root is not already scheduled. Add it.</span></span><br><span class="line">   root.<span class="property">expirationTime</span> = expirationTime</span><br><span class="line">   <span class="keyword">if</span> (lastScheduledRoot === <span class="literal">null</span>) &#123;</span><br><span class="line">     firstScheduledRoot = lastScheduledRoot = root</span><br><span class="line">     root.<span class="property">nextScheduledRoot</span> = root</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     lastScheduledRoot.<span class="property">nextScheduledRoot</span> = root</span><br><span class="line">     lastScheduledRoot = root</span><br><span class="line">     lastScheduledRoot.<span class="property">nextScheduledRoot</span> = firstScheduledRoot</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// This root is already scheduled, but its priority may have increased.</span></span><br><span class="line">   <span class="keyword">const</span> remainingExpirationTime = root.<span class="property">expirationTime</span></span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">     remainingExpirationTime === <span class="title class_">NoWork</span> ||</span><br><span class="line">     expirationTime &lt; remainingExpirationTime</span><br><span class="line">   ) &#123;</span><br><span class="line">     <span class="comment">// Update the priority.</span></span><br><span class="line">     root.<span class="property">expirationTime</span> = expirationTime</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="②-解析"><a href="#②-解析" class="headerlink" title="② 解析"></a>② 解析</h3><blockquote>
<p><code>addRootToSchedule</code>把 root 加入到调度队列，但是要注意一点，不会存在两个相同的 root 前后出现在队列中</p>
<p>可以看出来，如果第一次调用<code>addRootToSchedule</code>的时候，<code>nextScheduledRoot</code>是<code>null</code>，这时候公共变量<code>firstScheduledRoot</code>和<code>lastScheduledRoot</code>也是<code>null</code>，所以会把他们都赋值成<code>root</code>，同时<code>root.nextScheduledRoot = root</code>。然后第二次进来的时候，如果前后<code>root</code>是同一个，那么之前的<code>firstScheduledRoot</code>和<code>lastScheduledRoot</code>都是 root，所以<code>lastScheduledRoot.nextScheduledRoot = root</code>就等于<code>root.nextScheduledRoot = root</code></p>
<p>这么做是因为同一个<code>root</code>不需要存在两个，因为前一次调度如果中途被打断，下一次调度进入还是从同一个<code>root</code>开始，就会把新的任务一起执行了。</p>
<p>之后根据<code>expirationTime</code>调用<code>performSyncWork</code>还是<code>scheduleCallbackWithExpirationTime</code></p>
<p><code>scheduleCallbackWithExpirationTime</code>是根据时间片来执行任务的，会涉及到<code>requestIdleCallback</code></p>
<p><code>isBatchingUpdates</code>和<code>isUnbatchingUpdates</code>涉及到事件系统</p>
<p>他们最终都要调用<code>performWork</code></p>
</blockquote>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://k705.github.io/2024/04/08/react-React%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%AC%94%E8%AE%B0/" title="深入学习React并尝试阅读理解React源码" target="_blank" rel="external">https://k705.github.io/2024/04/08/react-React深入学习与源码解析笔记/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/k705.github.io/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">KK</span><small class="ml-1x">前端工程师</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/k705.github.io/2024/04/08/react-%E8%82%86%E3%80%81%E6%8F%92%E6%A7%BD%E3%80%81%E8%B7%AF%E7%94%B1%E3%80%81redux_day12-3/" title="插槽、路由、redux"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/k705.github.io/2024/04/08/react-%E8%B4%B0%E3%80%81React%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81props_day12-3/" title="渲染、事件、props"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/k705.github.io/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/k705.github.io/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/k705.github.io/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/k705.github.io/js/plugin.min.js"></script>


<script src="/k705.github.io/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/k705.github.io/',
        CONTENT_URL: '/k705.github.io/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/k705.github.io/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>