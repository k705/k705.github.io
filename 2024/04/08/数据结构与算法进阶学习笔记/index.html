<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Java数据结构与java算法 | Hexo</title>
  <meta name="description" content="基础掌握后就需要结合实例进行巩固理解,此处选择用Java语言作为笔记中例子实现语言,前端的同学不用慌,这边用到的就是Java基础,只要你有学前端ES6的class知识点,栗子中的代码基本与JS一摸一样  #说明  本笔记为观看B站的: 尚硅谷Java数据结构与java算法（Java数据结构与算法） 、其他多个相关博客与资料进行整理记录,里面加了大量个人对于这门课程的注解&#x2F;图解与理解,欢">
<meta property="og:type" content="article">
<meta property="og:title" content="Java数据结构与java算法">
<meta property="og:url" content="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="KK">
<meta property="og:description" content="基础掌握后就需要结合实例进行巩固理解,此处选择用Java语言作为笔记中例子实现语言,前端的同学不用慌,这边用到的就是Java基础,只要你有学前端ES6的class知识点,栗子中的代码基本与JS一摸一样  #说明  本笔记为观看B站的: 尚硅谷Java数据结构与java算法（Java数据结构与算法） 、其他多个相关博客与资料进行整理记录,里面加了大量个人对于这门课程的注解&#x2F;图解与理解,欢">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183612161.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183704191.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183820014.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409184136272.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409184239439.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409184435397.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409185126535.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409185325615.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409185404472.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413170353329.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413180656594.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413180729037.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413184647572.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416104152170.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B%E5%9B%BE.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416104715422.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416115735161.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B%E5%9B%BE.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416140539441.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%A4%B4%E6%8F%92%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.gif">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%E5%AE%9E%E4%BE%8B%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B%E5%9B%BE.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416171953411.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0%E7%A4%BA%E4%BE%8B%E5%9B%BE.gif">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E4%BE%8B%E6%80%9D%E8%B7%AF%E5%9B%BE.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94%E5%9B%BE.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E5%8A%A8%E6%80%81%E5%9B%BE%E8%A7%A3.gif">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210420142532651.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210420142614947.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90%E5%9B%BE2.gif">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210426093842922.png">
<meta property="og:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210426144425068.png">
<meta property="article:published_time" content="2024-04-08T06:36:10.000Z">
<meta property="article:modified_time" content="2024-04-09T10:07:00.274Z">
<meta property="article:author" content="KK">
<meta property="article:tag" content="底层知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183612161.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
  
    <link rel="alternate" href="/atom.xml" title="KK" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 7.1.1"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/blog/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">KK</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">前端工程师</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shanghai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/blog/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/blog/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/blog/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/blog/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/blog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Ajax/" rel="tag">Ajax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/AntDesign/" rel="tag">AntDesign</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Axios/" rel="tag">Axios</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/CSS/" rel="tag">CSS</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/ES/" rel="tag">ES</a><span class="tag-list-count">25</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Git/" rel="tag">Git</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/HTML-CSS/" rel="tag">HTML+CSS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Html/" rel="tag">Html</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/JS/" rel="tag">JS</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Java/" rel="tag">Java</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Js/" rel="tag">Js</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Js%E5%B7%A5%E5%85%B7%E5%BA%93/" rel="tag">Js工具库</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/TS/" rel="tag">TS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Umi/" rel="tag">Umi</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Vue/" rel="tag">Vue</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Vue2/" rel="tag">Vue2</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Vue3/" rel="tag">Vue3</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/antDesign/" rel="tag">antDesign</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/go/" rel="tag">go</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/jQuery/" rel="tag">jQuery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/nodejs/" rel="tag">nodejs</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/react/" rel="tag">react</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/webpack/" rel="tag">webpack</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">云服务器</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" rel="tag">代码规范</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%89%8D%E7%AB%AFUI%E5%BA%93/" rel="tag">前端UI库</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%B0%81%E8%A3%85JavaScript%E5%B7%A5%E5%85%B7%E5%8C%85/" rel="tag">封装JavaScript工具包</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/" rel="tag">底层知识</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">微信小程序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" rel="tag">快速参考备忘清单</a><span class="tag-list-count">34</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">23</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/blog/tags/Ajax/" style="font-size: 13px;">Ajax</a> <a href="/blog/tags/AntDesign/" style="font-size: 13px;">AntDesign</a> <a href="/blog/tags/Axios/" style="font-size: 13.08px;">Axios</a> <a href="/blog/tags/CSS/" style="font-size: 13.31px;">CSS</a> <a href="/blog/tags/ES/" style="font-size: 13.92px;">ES</a> <a href="/blog/tags/Git/" style="font-size: 13.23px;">Git</a> <a href="/blog/tags/HTML-CSS/" style="font-size: 13px;">HTML+CSS</a> <a href="/blog/tags/Html/" style="font-size: 13px;">Html</a> <a href="/blog/tags/JS/" style="font-size: 13.77px;">JS</a> <a href="/blog/tags/Java/" style="font-size: 13.54px;">Java</a> <a href="/blog/tags/Js/" style="font-size: 13px;">Js</a> <a href="/blog/tags/Js%E5%B7%A5%E5%85%B7%E5%BA%93/" style="font-size: 13.23px;">Js工具库</a> <a href="/blog/tags/Mysql/" style="font-size: 13.08px;">Mysql</a> <a href="/blog/tags/TS/" style="font-size: 13.15px;">TS</a> <a href="/blog/tags/Umi/" style="font-size: 13.08px;">Umi</a> <a href="/blog/tags/Vue/" style="font-size: 13.38px;">Vue</a> <a href="/blog/tags/Vue2/" style="font-size: 13.77px;">Vue2</a> <a href="/blog/tags/Vue3/" style="font-size: 13px;">Vue3</a> <a href="/blog/tags/antDesign/" style="font-size: 13px;">antDesign</a> <a href="/blog/tags/go/" style="font-size: 13px;">go</a> <a href="/blog/tags/jQuery/" style="font-size: 13px;">jQuery</a> <a href="/blog/tags/nodejs/" style="font-size: 13.46px;">nodejs</a> <a href="/blog/tags/react/" style="font-size: 13.54px;">react</a> <a href="/blog/tags/webpack/" style="font-size: 13.23px;">webpack</a> <a href="/blog/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.23px;">云服务器</a> <a href="/blog/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 13px;">代码规范</a> <a href="/blog/tags/%E5%89%8D%E7%AB%AFUI%E5%BA%93/" style="font-size: 13.38px;">前端UI库</a> <a href="/blog/tags/%E5%B0%81%E8%A3%85JavaScript%E5%B7%A5%E5%85%B7%E5%8C%85/" style="font-size: 13.69px;">封装JavaScript工具包</a> <a href="/blog/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 13.08px;">工具</a> <a href="/blog/tags/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/" style="font-size: 13.62px;">底层知识</a> <a href="/blog/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 13px;">微信小程序</a> <a href="/blog/tags/%E5%BF%AB%E9%80%9F%E5%8F%82%E8%80%83%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" style="font-size: 14px;">快速参考备忘清单</a> <a href="/blog/tags/%E6%AD%A3%E5%88%99/" style="font-size: 13.08px;">正则</a> <a href="/blog/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 13.62px;">软件</a> <a href="/blog/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">配置</a> <a href="/blog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13.85px;">面试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2024/04/">四月 2024</a><span class="archive-list-count">241</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/blog/2024/04/25/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" class="title">代码规范</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-25T09:08:57.000Z" itemprop="datePublished">2024-04-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/blog/2024/04/25/%E5%B7%A5%E5%85%B7-vscode%20%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%8A%80%E5%B7%A7/" class="title">vscode 功能与技巧</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-25T03:22:46.000Z" itemprop="datePublished">2024-04-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/blog/2024/04/22/Vue3-pure-admin/" class="title">Vue3-pure-admin</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-22T01:58:28.000Z" itemprop="datePublished">2024-04-22</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/blog/2024/04/08/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="title">Ajax笔记</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-08T06:36:10.000Z" itemprop="datePublished">2024-04-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/blog/2024/04/08/AntDesignOfReact%E5%B0%81%E8%A3%85-Table%E5%8F%8A%E5%85%B6%E7%AD%9B%E9%80%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/" class="title">AntDesign封装</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-08T06:36:10.000Z" itemprop="datePublished">2024-04-08</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-数据结构与算法进阶学习笔记" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java数据结构与java算法
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/blog/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
	  <time datetime="2024-04-08T06:36:10.000Z" itemprop="datePublished">2024-04-08</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/blog/tags/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86/" rel="tag">底层知识</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/blog/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <blockquote>
<p><code>基础掌握后就需要结合实例进行巩固理解,此处选择用Java语言作为笔记中例子实现语言,前端的同学不用慌,这边用到的就是Java基础,只要你有学前端ES6的class知识点,栗子中的代码基本与JS一摸一样</code></p>
</blockquote>
<h1 id="说明"><a href="#说明" class="headerlink" title="#说明"></a>#说明</h1><blockquote>
<ol>
<li>本笔记为观看B站的: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1E4411H73v?share_source=copy_web"><code>尚硅谷Java数据结构与java算法（Java数据结构与算法）</code></a> 、其他多个相关博客与资料进行整理记录,里面加了大量个人对于这门课程的注解&#x2F;图解与理解,欢迎大家指出不足之处,我也会及时进行校正</li>
<li>本人目前岗位为前端,但有较好的java基础,所以选定该学习视频,学习过程笔记也会使用<code>Java语言进行demo实现</code>,毕竟是概念部分还是跟紧老师学习,但用的都是基础语法,js与java其实都差不多并不会影响理解,甚至这部分代码js写法与java相差无几。</li>
<li>不过在随后<code>leetCode</code>部分,我将会用<code>java</code>与<code>javaScript</code>两种语言分别实现与记录,所以前后端的同学都将是可以看得懂的</li>
<li>个人跟随课程进程编写出的相关练习也会上传在此笔记同级文件目录下</li>
<li>数据结构与算法吃透比学完更重要,要确保吸收知识点且不影响工作的前提下,预计学习过程将持续几个月。但也坚信慢工出细活,形成的笔记以及知识体系也会更详细完整</li>
<li>除此笔记外大家可以看我其他笔记 :<strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master">全栈笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">编程_前端开发学习笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Vue%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88">Vue笔记整合</a></strong> 、**<a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/React%E7%AC%94%E8%AE%B0">React笔记</a><strong>、 <strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ReactHooks%E7%AC%94%E8%AE%B0">ReactHooks笔记</a></strong> 、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">微信小程序学习笔记</a><strong>、</strong><a target="_blank" rel="noopener" href="https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Chrome%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Chrome开发使用及学习笔记</a>** 以及许多其他笔记就不一一例举了</li>
</ol>
</blockquote>
<h1 id="目录-更新中"><a href="#目录-更新中" class="headerlink" title="#目录(更新中)"></a>#目录(<code>更新中</code>)</h1><blockquote>
<p>[TOC]</p>
</blockquote>
<hr>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><blockquote>
<ol>
<li><p>算法是程序的灵魂，优秀的程序可以在海量数据计算时，依然保持高速计算 </p>
</li>
<li><p>一般来讲 程序会使用了内存计算框架(比如 Spark)和缓存技术(比如 Redis 等)来优化程序,再深入的思考一下，这 些计算框架和缓存技术， 它的核心功能是哪个部分呢？ </p>
</li>
<li><p>拿实际工作经历来说, 在 Unix 下开发服务器程序，功能是要支持上千万人同时在线，在上线前做内测，一切OK,可上线后，服务器就支撑不住了, 公司的 CTO 对代码进行优化，再次上线，坚如磐石。你就能感受到程序 是有灵魂的，就是算法。 </p>
</li>
<li><p>目前程序员面试的门槛越来越高，很多一线 IT 公司(大厂)，都会有数据结构和算法面试题(负责的告诉你，肯定有的) </p>
</li>
<li><p>如果你不想永远都是代码工人,那就花时间来研究下数据结构和算法</p>
</li>
</ol>
</blockquote>
<h2 id="一、数据结构与算法概述以及经典题目举例"><a href="#一、数据结构与算法概述以及经典题目举例" class="headerlink" title="一、数据结构与算法概述以及经典题目举例"></a>一、数据结构与算法概述以及经典题目举例</h2><h3 id="1、数据结构和算法的关系"><a href="#1、数据结构和算法的关系" class="headerlink" title="1、数据结构和算法的关系"></a>1、数据结构和算法的关系</h3><blockquote>
<ol>
<li><p>数据 data 结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以 编写出更加漂亮,更加有效率的代码。 </p>
</li>
<li><p>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决. </p>
</li>
<li><p><code>程序 = 数据结构 + 算法</code></p>
</li>
<li><p>数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。</p>
</li>
</ol>
</blockquote>
<h3 id="2、线性结构与非线性结构"><a href="#2、线性结构与非线性结构" class="headerlink" title="2、线性结构与非线性结构"></a>2、线性结构与非线性结构</h3><blockquote>
<p>数据结构包括：线性结构和非线性结构。</p>
</blockquote>
<h4 id="Ⅰ-线性结构"><a href="#Ⅰ-线性结构" class="headerlink" title="Ⅰ-线性结构"></a>Ⅰ-线性结构</h4><blockquote>
<ol>
<li><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系 </p>
</li>
<li><p>线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序 表，顺序表中的存储元素是连续的 </p>
</li>
<li><p>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地 址信息 </p>
</li>
<li><p>线性结构常见的有：数组、队列、链表和栈</p>
</li>
</ol>
</blockquote>
<h4 id="Ⅱ-非线性结构"><a href="#Ⅱ-非线性结构" class="headerlink" title="Ⅱ-非线性结构"></a>Ⅱ-非线性结构</h4><blockquote>
<p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p>
</blockquote>
<h3 id="3、经典面试题"><a href="#3、经典面试题" class="headerlink" title="3、经典面试题"></a>3、经典面试题</h3><h4 id="Ⅰ-字符串匹配问题："><a href="#Ⅰ-字符串匹配问题：" class="headerlink" title="Ⅰ-字符串匹配问题："></a>Ⅰ-字符串匹配问题：</h4><blockquote>
<ol>
<li><p>有一个字符串 str1&#x3D; “”硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好””，和一个子串 str2&#x3D;”尚硅谷你尚 硅你”</p>
</li>
<li><p>现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 </p>
</li>
<li><p>要求用最快的速度来完成匹配 4)</p>
</li>
</ol>
<p>解: 1. 暴力匹配 [简单，但是效率低] 2.  <code>KMP 算法《部分匹配表》</code></p>
</blockquote>
<h4 id="Ⅱ-汉诺塔游戏"><a href="#Ⅱ-汉诺塔游戏" class="headerlink" title="Ⅱ-汉诺塔游戏"></a>Ⅱ-汉诺塔游戏</h4><blockquote>
<p>请完成汉诺塔游戏的代码: 要求：</p>
<ol>
<li><p>将 A 塔的所有圆盘移动到 C 塔。并且规定，在 </p>
</li>
<li><p>小圆盘上不能放大圆盘，</p>
</li>
</ol>
<p>3)在三根柱子之间一次只能移动一个圆盘</p>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183612161.png" alt="image-20210409183612161"></p>
</blockquote>
<h4 id="Ⅲ-八皇后问题"><a href="#Ⅲ-八皇后问题" class="headerlink" title="Ⅲ-八皇后问题:"></a>Ⅲ-八皇后问题:</h4><blockquote>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法。【92】&#x3D;&gt; <code>分治算法</code></p>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183704191.png" alt="image-20210409183704191"></p>
</blockquote>
<h4 id="Ⅳ-马踏棋盘算法"><a href="#Ⅳ-马踏棋盘算法" class="headerlink" title="Ⅳ-马踏棋盘算法"></a>Ⅳ-马踏棋盘算法</h4><blockquote>
<ol>
<li><p>马踏棋盘算法也被称为骑士周游问题 </p>
</li>
<li><p>将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求 每个方格只进入一次，走遍棋盘上全部 64 个方格 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.4399.com/flash/146267_2.html">游戏演示:</a></p>
</li>
<li><p>会使用到图的<code>深度优化遍历算法(DFS) + 贪心算法优化</code></p>
</li>
</ol>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409183820014.png" alt="image-20210409183820014"></p>
</blockquote>
<h3 id="4、几个实际编程中遇到的问题"><a href="#4、几个实际编程中遇到的问题" class="headerlink" title="4、几个实际编程中遇到的问题"></a>4、几个实际编程中遇到的问题</h3><h4 id="Ⅰ-字符串替换问题"><a href="#Ⅰ-字符串替换问题" class="headerlink" title="Ⅰ-字符串替换问题"></a>Ⅰ-字符串替换问题</h4><blockquote>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409184136272.png" alt="image-20210409184136272"></p>
</blockquote>
<h4 id="Ⅱ-一个五子棋程序"><a href="#Ⅱ-一个五子棋程序" class="headerlink" title="Ⅱ-一个五子棋程序"></a>Ⅱ-一个五子棋程序</h4><blockquote>
<p>如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能 </p>
<ol>
<li><p>棋盘 二维数组&#x3D;&gt;(稀疏数组)-&gt; 写入文件 【存档功能】 </p>
</li>
<li><p>读取文件-》稀疏数组-》二维数组 -》 棋盘 【接上局】</p>
</li>
</ol>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409184239439.png" alt="image-20210409184239439"></p>
</blockquote>
<h4 id="Ⅲ-约瑟夫-Josephu-问题-丢手帕问题"><a href="#Ⅲ-约瑟夫-Josephu-问题-丢手帕问题" class="headerlink" title="Ⅲ-约瑟夫(Josephu)问题(丢手帕问题)"></a>Ⅲ-约瑟夫(Josephu)问题(丢手帕问题)</h4><blockquote>
<ol>
<li><p>Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;&#x3D;k&lt;&#x3D;n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止， 由此产生一个出队编号的序列。 </p>
</li>
<li><p>提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表（单向环形链 表），然后由 k 结点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点 又从 1 开始计数，直到最后一个结点从链表中删除算法结束。 </p>
</li>
<li><p>小结：<code>该问题解决自 -&gt;第四章链表的6小节 --环形链表实现 </code></p>
</li>
</ol>
</blockquote>
<h4 id="Ⅳ-其它常见算法问题"><a href="#Ⅳ-其它常见算法问题" class="headerlink" title="Ⅳ-其它常见算法问题:"></a>Ⅳ-其它常见算法问题:</h4><blockquote>
<ol>
<li><p>修路问题 &#x3D;&gt; 最小生成树(加权值)【数据结构】+ <code>普利姆算法 </code></p>
</li>
<li><p>最短路径问题 &#x3D;&gt; <code>图+弗洛伊德算法</code> </p>
</li>
<li><p>汉诺塔 &#x3D;&gt; <code>分支算法</code> </p>
</li>
<li><p>八皇后问题 &#x3D;&gt; <code>回溯</code></p>
</li>
</ol>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409184435397.png" alt="image-20210409184435397"></p>
</blockquote>
<h2 id="二、稀疏数组与队列"><a href="#二、稀疏数组与队列" class="headerlink" title="二、稀疏数组与队列"></a>二、稀疏数组与队列</h2><h3 id="1、稀疏-sparsearray-数组"><a href="#1、稀疏-sparsearray-数组" class="headerlink" title="1、稀疏 sparsearray 数组"></a>1、稀疏 sparsearray 数组</h3><h4 id="Ⅰ-需求分析"><a href="#Ⅰ-需求分析" class="headerlink" title="Ⅰ-需求分析"></a>Ⅰ-需求分析</h4><blockquote>
<p>需求举例:编写的五子棋程序中，有存盘退出和续上盘的功能</p>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409185126535.png" alt="image-20210409185126535"></p>
<p>分析:因为该二维数组的很多值是默认值 0, 因此记录了<code>很多没有意义的数据.-&gt;稀疏数组</code>。</p>
</blockquote>
<h4 id="Ⅱ-基本介绍"><a href="#Ⅱ-基本介绍" class="headerlink" title="Ⅱ-基本介绍"></a>Ⅱ-基本介绍</h4><blockquote>
<p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 稀疏数组的处理方法是: </p>
<ol>
<li><p>记录数组一共有<code>几行几列，有多少个不同</code>的值 </p>
</li>
<li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<code>缩小程序的规模</code></p>
</li>
</ol>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409185325615.png" alt="image-20210409185325615"> </p>
</blockquote>
<h4 id="Ⅲ-应用实例"><a href="#Ⅲ-应用实例" class="headerlink" title="Ⅲ-应用实例"></a>Ⅲ-应用实例</h4><blockquote>
<ol>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) </p>
</li>
<li><p>把稀疏数组存盘，并且可以从新恢复原来的二维数组数 </p>
</li>
<li><p>整体思路分析</p>
</li>
</ol>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210409185404472.png" alt="image-20210409185404472"></p>
<ol start="4">
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//创建一个原始的二维数组11*11</span></span><br><span class="line">       <span class="comment">/* 0:表示没有棋子,1表示黑子,2表示蓝子 */</span></span><br><span class="line">       <span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">       chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">       chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">       chessArr1[<span class="number">5</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="comment">//输出原始的二维数组</span></span><br><span class="line">       System.out.println(<span class="string">&quot;原始的二维数组&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr1) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">               System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//将二维数组转稀疏数组</span></span><br><span class="line">       <span class="comment">//1.先遍历二维数组,得到非0数据的个数</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) sum++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">       <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">       <span class="comment">//给稀疏数组赋值  --&gt;存行列长度,有效数据</span></span><br><span class="line">       sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">       sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">       sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">       <span class="comment">//遍历二维数组,</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//给稀疏数组当计数器</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">               <span class="comment">//当数组中遇到不为0时,给稀疏数组插入(push同效果):行 列 有效数</span></span><br><span class="line">               <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                   count++;</span><br><span class="line">                   sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                   sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                   sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;有效数据&quot;</span> + sum);</span><br><span class="line">       <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">       System.out.println(<span class="string">&quot;&#x27;得到稀疏数组为~~&#x27;&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;将稀疏数组回复成原始的二维数组&quot;</span>);</span><br><span class="line">       <span class="comment">//1. 先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</span></span><br><span class="line">       <span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">       <span class="comment">//2. 在读稀疏数组后几行的数据(从第二行开始,所以i=1),并赋值给原始的二维数组即可</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">           chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">       System.out.println(<span class="string">&quot;输出恢复后的二维数组&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr2) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">               System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>练习 要求： 1) 在前面的基础上，将稀疏数组保存到磁盘上，比如 map.data 2) 恢复原来的数组时，读取 map.data 进行恢复</li>
</ol>
</blockquote>
<h3 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h3><h4 id="Ⅰ-队列介绍"><a href="#Ⅰ-队列介绍" class="headerlink" title="Ⅰ-队列介绍"></a>Ⅰ-队列介绍</h4><blockquote>
<ol>
<li><p>队列是一个有序列表，可以用数组或是链表来实现。 </p>
</li>
<li><p>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p>
</li>
</ol>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413170353329.png" alt="image-20210413170353329"> </p>
</blockquote>
<h4 id="Ⅱ-数组模拟队列"><a href="#Ⅱ-数组模拟队列" class="headerlink" title="Ⅱ-数组模拟队列"></a>Ⅱ-数组模拟队列</h4><blockquote>
<ol>
<li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图, 其中 maxSize 是该队列的最大容量。 </p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front 及 rear 分别记录队列前后端的下标， front 会随着数据输出而改变，而 rear 则是随着数据输入而改变，如队列介绍中图所示</p>
</li>
<li><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：思路分析:</p>
</li>
</ol>
<blockquote>
<ul>
<li><p>将尾指针往后移：rear+1 , 当 front &#x3D;&#x3D; rear 【空】 </p>
</li>
<li><p>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear 所指的数组元素中，否则无法存入数据</p>
</li>
</ul>
</blockquote>
<ol start="4">
<li><p><code>注意</code>:front并没有直接指向数据,而是数据前一位,所以当你要用front读取队列头时需要<code>front+1</code></p>
</li>
<li><p>代码实现</p>
</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit):退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head):查看队列头的数据&quot;</span>);</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接受一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入一个数字&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//不用再new一个新得scanner</span></span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;表头是%d\n&quot;</span>, head);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    scanner.close();<span class="comment">//关闭不释放会有异常</span></span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr; <span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;<span class="comment">//指向队列头部,分析出front是只想队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部,只想队列尾部数据(即队列最后一个数据)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>; <span class="comment">//当队列为指向数组最后一位时就是队列满</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front; <span class="comment">//当队列头与尾部相等时,说明该队列没有值了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满,不能加入数据~~~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++; <span class="comment">//让rear 往后移动一位</span></span><br><span class="line">        arr[rear] = n; <span class="comment">//以后移后的rear作为数组下标进行赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 获取队列的数据,出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空//抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">        front++; <span class="comment">//front后移 出队列</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空的 没有数据&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据,注意不是取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的,没有数据~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>]; <span class="comment">//front并没有直接指向数据,而是数据前一位,所以需要+1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>问题分析与优化方向:</li>
</ol>
<ol>
<li>目前数组使用一次就不能用， 没有达到复用的效果.</li>
</ol>
<p> ​	<code>原因</code>:取出数据时是将列表头(<code>front++</code>)向后移动,导致队列前面的空间并没有被释放,如上图第三个队列示例图 </p>
<ol start="2">
<li>将这个数组使用算法，改进成一个环形的队列 取模：%</li>
</ol>
</blockquote>
<h4 id="Ⅲ-数组模拟环形队列思路分析"><a href="#Ⅲ-数组模拟环形队列思路分析" class="headerlink" title="Ⅲ-数组模拟环形队列思路分析"></a>Ⅲ-数组模拟环形队列思路分析</h4><blockquote>
<ol>
<li><p>对前面的数组模拟队列的优化，充分利用数组. 因此将数组看做是一个环形的。(通过取模的方式来实现即可)</p>
</li>
<li><p>分析说明:</p>
<ol>
<li><p>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize &#x3D;&#x3D; front 满]</p>
</li>
<li><p>rear &#x3D;&#x3D; front [空]</p>
</li>
</ol>
</li>
<li><p>思路分析示例图3-2-3-1</p>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413180656594.png" alt="image-20210413180656594"></p>
</li>
<li><p>环形队列示例图</p>
</li>
</ol>
<p>  <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413180729037.png" alt="image-20210413180729037"></p>
</blockquote>
<h4 id="Ⅳ-个人对于环形队列的理解与总结"><a href="#Ⅳ-个人对于环形队列的理解与总结" class="headerlink" title="Ⅳ-个人对于环形队列的理解与总结"></a>Ⅳ-个人对于环形队列的理解与总结</h4><blockquote>
<p>个人对于思路分析示例图3-2-3-1理解与总结:</p>
<ol>
<li><code>rear</code>初始化为0:因为当队列为空时,<code>rear</code>队列尾应是指向<code>-1</code>位置,因为整个队列是空的</li>
</ol>
<blockquote>
<p>所以符合调整:rear指向队列的最后一个元素的后一个位置,可以留出一个空间作为约定(用来<code>判断是队空还是队满</code>)</p>
</blockquote>
<ol start="2">
<li><p><code>front</code>初始化为0:因为要指向队列第一个位置,所以为0</p>
</li>
<li><p>队列满条件:<code>(rear+1)%maxSize==front</code>–&gt;原理如上方环形队列示例图</p>
</li>
</ol>
<blockquote>
<p>当<code>(rear+1)%maxSize==front</code>时,队列情况如环形队列示例图右边部分 –&gt;例: (4+1)%10&#x3D;&#x3D;5</p>
</blockquote>
<ol start="4">
<li><p>队列为空<code>rear==front</code>:假使你队列曾经加到8个数据,所以你<code>rear==8</code>,但当你将队列一个一个取出时front发生如下变化:<code>front==0--&gt;front++*n--&gt;front==8</code>,所以当front&#x3D;&#x3D;rear&#x3D;&#x3D;8时,就可以判断队列为空</p>
</li>
<li><p>队列的有效数据个数:<code>(rear+maxSize-font)%maxSize</code> –&gt;</p>
</li>
</ol>
<blockquote>
<p>提出疑惑:为什么要先加<code>maxSize</code>–&gt;可能出现队尾rear小于队首front的情况</p>
</blockquote>
<p>  通过这个环形队列图(里面数字是<code>数组下标</code>不是数据)你应该可以很容易理解:假使队列长8、队尾在2的位置、队首在6的位置</p>
<p>​	解决:如图所示</p>
<p> <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210413184647572.png" alt="image-20210413184647572"></p>
<blockquote>
<p>再次提出疑惑:老铁!!!我看图上<code>6~2</code>,甚至还用手指去数,明明就是五个数据啊!为什么还能算成<code>4</code>?</p>
</blockquote>
<p>​	解:注意<code>rear</code>的定义:rear指向队列的最后一个元素的后一个位置,所以这时候最后一个队列数据是在<code>1</code>的位置,所以<code>6~1</code>是4位</p>
</blockquote>
<h4 id="Ⅴ-环形队列代码实现"><a href="#Ⅴ-环形队列代码实现" class="headerlink" title="Ⅴ-环形队列代码实现"></a>Ⅴ-环形队列代码实现</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.queue;</span><br><span class="line">&gt;<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//创建一个环形队列</span></span><br><span class="line">       System.out.println(<span class="string">&quot;创建一个环形队列&quot;</span>);</span><br><span class="line">       <span class="type">CircleArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">       <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户输入</span></span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="comment">//输出一个菜单</span></span><br><span class="line">       <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">        .....<span class="comment">//同上面队列代码调用,省略</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">CircleArrayQueue</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">//队列头</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> rear; <span class="comment">//队列尾部</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数据用于存放数据,模拟队列</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建队列的构造器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">CircleArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">       <span class="comment">//注意:如果要能存3个有效数据,arrMaxSize就要为`4`,因为预留了一个位置,所以需要传入的数字要+1</span></span><br><span class="line">       maxSize = arrMaxSize + <span class="number">1</span>;</span><br><span class="line">       arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1. 此处front含义做出调整:front指向队列的第一个元素,也就是说arr[front]就是队列的第一个元素,front的初始值为0*</span></span><br><span class="line"><span class="comment">        * 2.此处rear含义做出调整:rear指向队列的最后一个元素的后一个位置,因为希望空出一个空间作为约定(判断栈满栈空),rear的初始值为0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       front = rear = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1. 判断队列是否满</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//此时队满条件发生变化,因为rear预留了一个位置</span></span><br><span class="line">       <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. 判断队列是否为空</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> front == rear;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3.获取队列的有效数量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> int  此函数结果用来在 遍历队列数组时防止下标越界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4. 添加数据到队列</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="comment">//判断是否队满</span></span><br><span class="line">       <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;队列满,不能加入数据~~~~~&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       arr[rear] = n;<span class="comment">//这里需要先赋值再将rear+1,因为rear指向最后一个有效数据</span></span><br><span class="line">       <span class="comment">//让rear后移一位,但是需要注意`%`,因为栈尾可以回到下标为`0`处,原因看我画的图</span></span><br><span class="line">       rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5. 获取队列数据 出队列(类似删除数组第一位)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//判断队列是否为空,抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空,不能取数据&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//这里需要先将`front`的值保存下来(或者直接保存arr[front],再去return),因为front此时对应的是第一个有效数据,如果＋1后再返回,将指向错误的有效数据</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">thisFront</span> <span class="operator">=</span> front;</span><br><span class="line">       <span class="comment">//front后移,原因与注意点同rear</span></span><br><span class="line">       front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">       <span class="keyword">return</span> arr[thisFront];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//6. 显示所有队列的数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;队列为空,没有数据&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1.首先front指向队列第一位,所以要从front开始遍历</span></span><br><span class="line"><span class="comment">        * 2.结束</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + getSize(); i++) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//7. 显示队列的头数据,注意不是取出数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//判断是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的,没有数据~~~~&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//front是直接指向队列第一位的,所以这里可以直接返回</span></span><br><span class="line">       <span class="keyword">return</span> arr[front];</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="三、链表"><a href="#三、链表" class="headerlink" title="三、链表"></a>三、链表</h2><h3 id="1、链表-Linked-List-介绍"><a href="#1、链表-Linked-List-介绍" class="headerlink" title="1、链表(Linked List)介绍"></a>1、链表(Linked List)介绍</h3><blockquote>
<ol>
<li><p>链表是以节点的方式来存储,是链式存储 </p>
</li>
<li><p>每一个结点包含 data 域、next 域。其中 next 域存放的是下一个结点的地址(双向链表还有一个<code>prev</code>)</p>
</li>
<li><p>如图：发现链表的各个节点不一定是连续存储. </p>
<blockquote>
<p>​	<img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416104152170.png" alt="image-20210416104152170"> </p>
</blockquote>
</li>
<li><p>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p>
</li>
<li><p>单链表(带头结点) 逻辑结构示意图如下</p>
<blockquote>
<img src="数据结构与算法进阶学习笔记中的图片/单链表结构示例图.png" alt="单链表结构示例图" style="zoom:50%;" /> 
</blockquote>
</li>
<li><p>代码描述节点:</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> ListNode&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;				<span class="comment">// 本结点的信息	</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> ListNode next; 		<span class="comment">// 下一个结点的地址</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</blockquote>
<h3 id="2、单链表的应用实例"><a href="#2、单链表的应用实例" class="headerlink" title="2、单链表的应用实例"></a>2、单链表的应用实例</h3><blockquote>
<p>使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作</p>
</blockquote>
<h4 id="Ⅰ-添加方法一-在添加英雄时，直接添加到链表的尾部"><a href="#Ⅰ-添加方法一-在添加英雄时，直接添加到链表的尾部" class="headerlink" title="Ⅰ-添加方法一:在添加英雄时，直接添加到链表的尾部"></a>Ⅰ-添加方法一:在添加英雄时，直接添加到链表的尾部</h4><blockquote>
<ol>
<li><p>思路分析示意图:</p>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416104715422.png" alt="image-20210416104715422"></p>
</li>
<li><p>演示最基础的链表插入:<code>插入到链表的最后面</code>,不考虑顺序</p>
<blockquote>
<ul>
<li>首先我们需要创建一个头结点，该结点的作用就是表示单链表的头，如果没有头结点，我们是无法知道链表的首个结点是谁、在哪；</li>
<li>单链表是单向的，所以我们需要从头结点开始遍历整个链表直到末尾，然后增加结点到链表的末尾；</li>
<li>需要注意的是，头结点是万万不能乱动的，所以我们最好将头结点复制到一个临时结点变量中，对临时变量进行遍历。</li>
</ul>
</blockquote>
</li>
<li><p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.firstadd;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示最基础的链表插入,插入到链表的最后面,不考虑顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstAdd</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先创建节点对象,一个节点就是一个节点英雄</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表对象</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//不按顺序添加</span></span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        <span class="comment">//调用打印</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString;里不打印next,是因为如果这样打印的话,会将整个链表全部打印出来</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二、定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 返回头节点,get方法</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 添加节点到单链表后</span></span><br><span class="line"><span class="comment">     * 思路:不考虑编号顺序,直接插入到链表最后</span></span><br><span class="line"><span class="comment">     * 1)找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2)将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//4. 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="Ⅱ-添加方法二-根据排名将英雄插入到指定位置"><a href="#Ⅱ-添加方法二-根据排名将英雄插入到指定位置" class="headerlink" title="Ⅱ-添加方法二:根据排名将英雄插入到指定位置"></a>Ⅱ-添加方法二:根据排名将英雄插入到指定位置</h4><blockquote>
<ol>
<li><p>如果有这个排名(即no重复)，则添加失败，并给出提示</p>
</li>
<li><p>思路分析示意图:</p>
</li>
</ol>
<blockquote>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416115735161.png" alt="image-20210416115735161"> </p>
</blockquote>
<ol start="3">
<li>代码中实例场景示例图:</li>
</ol>
<blockquote>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%AE%9E%E4%BE%8B%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="image-20210416115627100"> </p>
</blockquote>
<ol start="4">
<li>思路分析:</li>
</ol>
<blockquote>
<ul>
<li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li>
<li>如果出现某个结点（假设是 A 结点）的下一个结点（假设是 B 结点）的编号大于待插入结点的情况，那么就首先将 B 结点记录在待插入的结点中，然后再将这个待插入结点插入到 A 结点之后；</li>
<li>如果遍历到了链表末尾还没找到编号更大的，就直接插入到末尾即可。</li>
</ul>
</blockquote>
<ol start="5">
<li>代码实现:(只是将第一方法代码示例中的<code>add()</code>替换未<code>addByOrder</code>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">    <span class="comment">/*因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line"><span class="comment">       因为单链表,所以我们找的temp 必须为于添加位置的前一个节点,否则插入不了*/</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标识添加的编号是否存在,默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明temp已经在链表的最后,就在链表插入(此时temp已经在链表尾部了)</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明位置已经找到,就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode编号已经存在</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移,直到找到符合上面条件为止</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将heroNode插入到链表的temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------- main()中调用  ------------------------</span><br><span class="line"> singleLinkedList.addByOrder(hero2);</span><br><span class="line"> singleLinkedList.addByOrder(hero4);</span><br><span class="line"> singleLinkedList.addByOrder(hero4);</span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="Ⅲ-修改节点"><a href="#Ⅲ-修改节点" class="headerlink" title="Ⅲ-修改节点"></a>Ⅲ-修改节点</h4><blockquote>
<ol>
<li>思路(1) 先找到该节点，通过遍历，(2) temp.name &#x3D; newHeroNode.name ; temp.nickname&#x3D; newHeroNode.nickname</li>
</ol>
<blockquote>
<ul>
<li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li>
<li>遍历过程中，比对每个结点的编号与要更新的结点的编号是否一致，如果一致则说明找到了要更新的结点。接着将找到的结点中的数据替换成要更新的数据即可；</li>
<li>如果遍历结束还没找到对应编号的结点，说明链表中不存在这个结点；</li>
</ul>
</blockquote>
<ol start="2">
<li>代码实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//5. 修改节点信息,根据no编号来修改,即no编号不能改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ;</span><br><span class="line">        <span class="comment">//定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line">----------------- main()调用测试 ----------------------------------------</span><br><span class="line">  <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试修改后的&quot;</span>);</span><br><span class="line">        singleLinkedList.list();    </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Ⅳ-删除节点"><a href="#Ⅳ-删除节点" class="headerlink" title="Ⅳ-删除节点"></a>Ⅳ-删除节点</h4><blockquote>
<ol>
<li>思路分析:</li>
</ol>
<blockquote>
<p><img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416140539441.png" alt="image-20210416140539441"></p>
<ul>
<li>其实就是方法二中<code>实例场景示例图</code>的逆推</li>
<li>首先还是要创建一个头结点，然后拷贝一个头结点作为辅助变量，使用辅助变量来遍历整个链表；</li>
<li>如果 遍历到某个结点的编号与要查找的给定的编号相同，那么就找到了结点；</li>
<li>如果遍历结束还没找到，说明该编号不在链表的结点中。</li>
</ul>
</blockquote>
<ol start="2">
<li>代码示例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//6. 删除节点1.head不能动,所以需要一个temp辅助节点找到待删除节点前的一个节点</span></span><br><span class="line">    <span class="comment">//         2.我们比较时,时temp.next.no和待删除节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明到了链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//表示找到了待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) temp.next=temp.next.next; <span class="comment">//如果找到,进行删除</span></span><br><span class="line">        <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>,no);</span><br><span class="line">    &#125;</span><br><span class="line">----------------- main()调用 ------------------------------</span><br><span class="line">   <span class="comment">//删除一个节点</span></span><br><span class="line">    singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">    singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">    singleLinkedList.list();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Ⅴ-全部代码"><a href="#Ⅴ-全部代码" class="headerlink" title="Ⅴ-全部代码"></a>Ⅴ-全部代码</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.linkedlist.secondadd;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecondAdd</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//先创建节点对象,一个节点就是一个节点英雄</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">       <span class="comment">//创建链表对象</span></span><br><span class="line">       <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">       <span class="comment">//1. 不按顺序添加:方法一</span></span><br><span class="line">&gt;<span class="comment">//        singleLinkedList.add(hero1);</span></span><br><span class="line">&gt;<span class="comment">//        singleLinkedList.add(hero4);</span></span><br><span class="line">&gt;<span class="comment">//        singleLinkedList.add(hero2);</span></span><br><span class="line">&gt;<span class="comment">//        singleLinkedList.add(hero3);</span></span><br><span class="line">       <span class="comment">//2. 添加方法二</span></span><br><span class="line">       singleLinkedList.addByOrder(hero1);</span><br><span class="line">       singleLinkedList.addByOrder(hero3);</span><br><span class="line">       singleLinkedList.addByOrder(hero2);</span><br><span class="line">       singleLinkedList.addByOrder(hero4);</span><br><span class="line">       singleLinkedList.addByOrder(hero4);</span><br><span class="line">       <span class="comment">//调用打印</span></span><br><span class="line">       singleLinkedList.list();</span><br><span class="line">       <span class="comment">//3. 测试修改节点的代码</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">       singleLinkedList.update(newHeroNode);</span><br><span class="line">       System.out.println(<span class="string">&quot;测试修改后的&quot;</span>);</span><br><span class="line">       singleLinkedList.list();</span><br><span class="line">       <span class="comment">//4. 删除一个节点</span></span><br><span class="line">       singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">       singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">       singleLinkedList.list();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**-------下面 `面试题部分`方法可以放在这个地方进行运行 编写的是静态方法----------------*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;...&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> K)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedHead</span><span class="params">(HeroNode head)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;&#125;</span><br><span class="line">   <span class="comment">/**-------下面 `面试题部分`方法可以放在这个地方进行运行----------------*/</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> String nickname;</span><br><span class="line">   <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//构造器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.no = no;</span><br><span class="line">       <span class="built_in">this</span>.name = name;</span><br><span class="line">       <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//二、定义SingleLinkedList管理我们的英雄</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">   <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2. 返回头节点,get方法  这个方法是配合下面面试题时使用,使外面也能获得私有变量</span></span><br><span class="line">   <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3. 添加节点到单链表后-----------------弃用的,用来对比`addByOrder()`</span></span><br><span class="line"><span class="comment">    * 思路:不考虑编号顺序,直接插入到链表最后</span></span><br><span class="line"><span class="comment">    * 1)找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">    * 2)将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">       <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">       <span class="comment">//将最后这个节点的next指向新的节点</span></span><br><span class="line">       temp.next = heroNode;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4. 添加节点到单链表后,按no排序</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">   <span class="comment">/*因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line"><span class="comment">      因为单链表,所以我们找的temp 必须为于添加位置的前一个节点,否则插入不了*/</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">//flag标识添加的编号是否存在,默认为false</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明temp已经在链表的最后,就在链表插入(此时temp已经在链表尾部了)</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明位置已经找到,就在temp的后面插入</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode编号已经存在</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;<span class="comment">//temp后移,直到找到符合上面条件为止</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//将heroNode插入到链表的temp后面</span></span><br><span class="line">           heroNode.next = temp.next;</span><br><span class="line">           temp.next = heroNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5. 修改节点信息,根据no编号来修改,即no编号不能改</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       ;</span><br><span class="line">       <span class="comment">//定义一个辅助变量</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">           <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">           temp.name = newHeroNode.name;</span><br><span class="line">           temp.nickname = newHeroNode.nickname;</span><br><span class="line">       &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//6. 删除节点1.head不能动,所以需要一个temp辅助节点找到待删除节点前的一个节点</span></span><br><span class="line">   <span class="comment">//         2.我们比较时,时temp.next.no和待删除节点的no比较</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">&gt;<span class="comment">//        if (head.next == null) &#123;</span></span><br><span class="line">&gt;<span class="comment">//            System.out.println(&quot;链表为空&quot;);</span></span><br><span class="line">&gt;<span class="comment">//            return;</span></span><br><span class="line">&gt;<span class="comment">//        &#125;此处可以不加,与下面代码功能重复</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明到了链表的最后</span></span><br><span class="line">           <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">               <span class="comment">//表示找到了待删除节点的前一个节点temp</span></span><br><span class="line">               flag = <span class="literal">true</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (flag) temp.next = temp.next.next; <span class="comment">//如果找到,进行删除</span></span><br><span class="line">       <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//7. 显示链表[遍历]</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//判断链表是否为空</span></span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">//输出节点信息</span></span><br><span class="line">           System.out.println(temp);</span><br><span class="line">           <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">           temp = temp.next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3、单链表-面试题"><a href="#3、单链表-面试题" class="headerlink" title="3、单链表 面试题"></a>3、单链表 面试题</h3><blockquote>
<p>单链表的常见面试题有如下:</p>
<p>1)求单链表中有效节点的个数</p>
<p>2)查找单链表中的倒数第k个结点 【新浪面试题】</p>
<p>3)单链表的反转【腾讯面试题，有点难度】</p>
<p>4)从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】</p>
<p>5)合并两个有序的单链表，合并之后的链表依然有序【课后练习.】</p>
<p>以下例子将在<code>2</code>部分的全部代码中实现,在上面代码中<code>已经预留位置</code></p>
</blockquote>
<h4 id="Ⅰ-求单链表中有效节点的个数"><a href="#Ⅰ-求单链表中有效节点的个数" class="headerlink" title="Ⅰ-求单链表中有效节点的个数"></a>Ⅰ-求单链表中有效节点的个数</h4><blockquote>
<p>就是直接遍历 没得分析,直接上代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 求单链表中有效节点的个数</span></span><br><span class="line"><span class="comment">    * 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空链表</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//声明一个累加器</span></span><br><span class="line">       <span class="comment">//定义一个辅助的变量,这里我们没有统计头节点(--&gt;head.next)</span></span><br><span class="line">       <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//当当前节点 为空时退出累计遍历</span></span><br><span class="line">           length++;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> length;</span><br><span class="line">   &#125;;</span><br><span class="line">&gt;-----------------main()调用  ---------------------------</span><br><span class="line">&gt;System.out.println(<span class="string">&quot;有效的节点个数=&quot;</span> + getLength(singleLinkedList.getHead()));<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Ⅱ-查找单链表中的倒数第k个结点-【新浪面试题】"><a href="#Ⅱ-查找单链表中的倒数第k个结点-【新浪面试题】" class="headerlink" title="Ⅱ-查找单链表中的倒数第k个结点 【新浪面试题】"></a>Ⅱ-查找单链表中的倒数第k个结点 【新浪面试题】</h4><blockquote>
<ol>
<li>思路分析:</li>
</ol>
<blockquote>
<p> 1)编写一个方法，接收head节点，同时接收一个K</p>
<p> 2)K表示是倒数第K个节点</p>
<p> 3)先把链表从头到尾遍历，得到链表的总的长度 getLength</p>
<p> 4)得到size 后，我们从链表的第一个开始遍历 (size-K)个，就可以得到</p>
<p> 5)如果找到了，则返回该节点，否则返回null</p>
</blockquote>
<ol start="2">
<li>代码示例:</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**2.查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 要进行查找的单向链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> K 传入倒数第几位 数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该位置的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//空链表,无法找到</span></span><br><span class="line">        <span class="comment">//1. 获得链表的长度(总个数)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="comment">//2. 做一个K的校验,明显K不能为负数以及大于总长度</span></span><br><span class="line">        <span class="keyword">if</span> (K &lt;= <span class="number">0</span> || K &gt; size) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 定义给辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//4. 遍历 倒数第K个节点 就是`size-K`的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (size - K); i++) &#123;</span><br><span class="line">            cur = cur.next; <span class="comment">//cur后移到符合条件的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">-----------------main()调用  ---------------------------</span><br><span class="line"> <span class="comment">//测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line"> <span class="type">HeroNode</span> <span class="variable">res</span> <span class="operator">=</span> findLastIndexNode(singleLinkedList.getHead(), <span class="number">2</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Ⅲ-单链表的反转【腾讯面试题，有点难度】"><a href="#Ⅲ-单链表的反转【腾讯面试题，有点难度】" class="headerlink" title="Ⅲ-单链表的反转【腾讯面试题，有点难度】"></a>Ⅲ-单链表的反转【腾讯面试题，有点难度】</h4><blockquote>
<ol>
<li>解决这个问题的核心就是<code>头插法</code>。</li>
</ol>
<blockquote>
<ul>
<li>首先创建一个临时头结点用于记录反转过程中的链表；</li>
<li>遍历单链表，每遍历到一个有效结点，就让该有效结点指向临时头结点指向的结点；</li>
<li>临时头结点再指向该有效结点，</li>
<li>原单链表遍历结束之后，再让原头结点指向临时头结点指向的结点。</li>
</ul>
</blockquote>
<ol start="5">
<li><p>图片示例(该动图取自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuxian1277">RonzL</a>的博客):<img src="数据结构与算法进阶学习笔记中的图片/头插法进行反转链表.gif" style="zoom: 33%;" /></p>
</li>
<li><p>具体举例图解<img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%E5%AE%9E%E4%BE%8B%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="image-20210416164158096"></p>
</li>
<li><p>代码实现:</p>
<blockquote>
<p>实现方法一:</p>
</blockquote>
</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 3.单链表的反转【腾讯面试题，有点难度】</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> head 传入需要进行反转的单链表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseLinkedHead</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 当链表为空或者只有一个节点时候,直接返回,无需反转</span></span><br><span class="line">       <span class="keyword">if</span> (head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//2. 定义一个辅助的指针遍历,帮助我们遍历原来的链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//3. 定义一个next,辅助变量,来指向当前节点[cur]的下一个节点,用来进行位置互换</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//4. 初始化一个新的头节点,用来暂时存放反转链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 遍历原来的链表,每遍历一个节点,就将其取出,并放在新的链表reverseHead的最前端</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//当当前节点 为空时退出累计遍历</span></span><br><span class="line">            next = cur.next; <span class="comment">//先暂时保存当前节点的下一个节点,后面换完位置后需要复原cur的下一位,否则无法遍历</span></span><br><span class="line">            cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            reverseHead.next = cur;<span class="comment">//将cur链接到新的链表上</span></span><br><span class="line">            cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结束,将head.next指向reverseHead.next 接管链表,实现单链表的反转</span></span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">-----------------main()调用  ---------------------------</span><br><span class="line">   <span class="comment">//7. 测试一下单链表的反转功能</span></span><br><span class="line">	System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">	singleLinkedList.list();</span><br><span class="line">	System.out.println(<span class="string">&quot;反转单链表~~&quot;</span>);</span><br><span class="line">	reverseLinkedHead(singleLinkedList.getHead());</span><br><span class="line">	singleLinkedList.list();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现方法二(只是写法改变,但代码显得更容易理解):</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> SingleLinkedList <span class="title function_">reverse</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">SingleLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="comment">// 遍历待反转的链表，将结点依次添加到新链表</span></span><br><span class="line">   <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (tmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        linkedList.addFirst(tmp.next.item);</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> linkedList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addFirst</span><span class="params">(Integer item)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(item, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// tmp 指向头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">    newNode.next = tmp.next;</span><br><span class="line">    tmp.next = newNode;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="Ⅳ-从尾到头打印单链表"><a href="#Ⅳ-从尾到头打印单链表" class="headerlink" title="Ⅳ-从尾到头打印单链表"></a>Ⅳ-从尾到头打印单链表</h4><blockquote>
<ol>
<li><p>【百度面试题，要求方式1：反向遍历(上一个问题解决) 。 方式2：Stack栈   方法3: 递归】</p>
</li>
<li><p><code>栈方法</code></p>
</li>
<li><p>思路分析图解:<img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210416171953411.png" alt="image-20210416171953411"></p>
</li>
<li><p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 4. 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> head 要传入的链表头</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">//空链表 不能打印</span></span><br><span class="line">     <span class="comment">//创建一个栈,将各个节点压入栈</span></span><br><span class="line">     Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">     <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">     <span class="comment">//将链表所有节点压入栈</span></span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">         stack.push(cur);</span><br><span class="line">         cur = cur.next;<span class="comment">//cur后移,这样就可以压入下一个节点</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//将栈中节点取出打印.利用其先进后出特点,实现逆序da&#x27;yin</span></span><br><span class="line">     <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(stack.pop());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> -----------------main()调用  ---------------------------</span><br><span class="line"><span class="comment">//8.测试逆序打印单链表, 没有改变链表的结构~~</span></span><br><span class="line">System.out.println(<span class="string">&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;</span>);</span><br><span class="line">reversePrint(singleLinkedList.getHead());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>递归方式</code></p>
</li>
<li><p>图例(该动图取自<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuxian1277">RonzL</a>的博客):<img src="数据结构与算法进阶学习笔记中的图片/递归方式实现单向链表逆序打印示例图.gif" alt="递归方式实现单向链表逆序打印示例图" style="zoom: 33%;" /></p>
</li>
<li><p>代码实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归打印结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> [node] 链表的第一个结点，即 head.next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printReverse_3</span><span class="params">(HeroNode node)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里一定要先递归调用再打印</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        printReverse_3(node.next);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node);</span><br><span class="line">&#125;</span><br><span class="line">               </span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="Ⅴ-合并两个有序的单链表，合并之后的链表依然有序"><a href="#Ⅴ-合并两个有序的单链表，合并之后的链表依然有序" class="headerlink" title="Ⅴ-合并两个有序的单链表，合并之后的链表依然有序"></a>Ⅴ-合并两个有序的单链表，合并之后的链表依然有序</h4><blockquote>
<p>练习题目:合并两个有序的单链表，合并之后的链表依然有序</p>
<ol>
<li><p>思路解析:</p>
<ol>
<li>如果传入的节点1为空了(即已经递归到链表尾或者是空链表),返回节点2,反之亦然(同时return会结束该递归函数(但是递归函数结束后接着return,所以整个递归函数将会停止)并返回)。</li>
<li>判断no是否重复,如果重复就重新递归传入链表下一级<code>head2.next</code>,不重复就传入<code>head2</code></li>
<li>递归其实都是在进行对于<code>head.next</code>的赋值,直到传入节点为空(符合前面两个判断条件),开始向外<code>return</code>,此时逐层给<code>head.next</code>赋值,最后会返回到最外层函数返回值处,就是合并后的链表</li>
</ol>
</li>
<li><p>代码实现:</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个单链表静态函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 传入第一个链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 传入第二个链表头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回合并后的链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">mergeLinkedList</span><span class="params">(HeroNode head1, HeroNode head2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">null</span>) <span class="keyword">return</span> head2; <span class="comment">//此处是递归,不能按head.next==null进行判断,否则会造成数据丢失</span></span><br><span class="line">        <span class="keyword">if</span> (head2 == <span class="literal">null</span>)  <span class="keyword">return</span> head1;     </span><br><span class="line">        <span class="keyword">if</span> (head1.no &lt;= head2.no) &#123;</span><br><span class="line">            <span class="comment">//如果不加这个判断,如果两者的no相同,将会导致出现重复的数据(如两个),判断后进入递归</span></span><br><span class="line">            <span class="comment">//打印代码 System.out.println(&quot;head:&quot;+head+&quot;,head.next:&quot;+head.next);</span></span><br><span class="line">            <span class="comment">//打印结果 headHeroNode:[no=0,name=,nickname=],head.nextHeroNode:[no=0,name=,nickname=]</span></span><br><span class="line">            head1.next = (head2.no != head1.no) ? mergeLinkedList(head1.next, head2)</span><br><span class="line">              			  : mergeLinkedList(head1.next, head2.next);</span><br><span class="line"><span class="comment">//            head1.next= mergeLinkedList(head1.next, head2);  犯下的错误,导致数据重复</span></span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head2.next = mergeLinkedList(head1, head2.next);</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历打印静态链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 传入打印的链表头节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticList</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        System.out.println(<span class="string">&quot;head&quot;</span> + head + <span class="string">&quot;,head.next&quot;</span> + head.next);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">-------------------  main()调用 --------------------------------</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;帅哥&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;努力学习的汪&quot;</span>, <span class="string">&quot;好学生&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">7</span>, <span class="string">&quot;离婚且带娃&quot;</span>, <span class="string">&quot;不是我&quot;</span>);</span><br><span class="line">  <span class="type">HeroNode</span> <span class="variable">hero8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;你听我狡辩&quot;</span>, <span class="string">&quot;口头禅&quot;</span>);</span><br><span class="line">      <span class="comment">//创建链表对象</span></span><br><span class="line">  <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">  <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">  <span class="comment">//2. 添加方法</span></span><br><span class="line">  singleLinkedList.addByOrder(hero1);</span><br><span class="line">  singleLinkedList.addByOrder(hero3);</span><br><span class="line">  singleLinkedList.addByOrder(hero4);</span><br><span class="line">  singleLinkedList.addByOrder(hero7);</span><br><span class="line">  singleLinkedList.list();</span><br><span class="line">  System.out.println(<span class="string">&quot;两个链表分界线&quot;</span>);</span><br><span class="line">  <span class="comment">//-----------课后作业:第二个链表-----------------------</span></span><br><span class="line">  singleLinkedList1.addByOrder(hero2);</span><br><span class="line">  singleLinkedList1.addByOrder(hero5);</span><br><span class="line">  singleLinkedList1.addByOrder(hero6);</span><br><span class="line">  singleLinkedList1.addByOrder(hero8);</span><br><span class="line">  singleLinkedList1.list();</span><br><span class="line">  System.out.println(<span class="string">&quot;合并两个链表&quot;</span>);</span><br><span class="line">  staticList(mergeLinkedList(singleLinkedList.getHead(), singleLinkedList1.getHead()));</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4、双向链表与其实例"><a href="#4、双向链表与其实例" class="headerlink" title="4、双向链表与其实例"></a>4、双向链表与其实例</h3><blockquote>
<ol>
<li><p>双向链表实现实际上对比单向链表多了一个<code>pre</code>属性,大部分功能相似</p>
</li>
<li><p>使用双向链表实现水浒传英雄增删改查思路图:</p>
</li>
</ol>
<p>  <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9E%E4%BE%8B%E6%80%9D%E8%B7%AF%E5%9B%BE.png" alt="image-20210419144659899"></p>
<ol start="3">
<li>删除部分代码实现:</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 5. 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">   * 说明:</span></span><br><span class="line"><span class="comment">   * 1.对于双向链表,我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">   * 2.找到后,自我删除即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;链表为空,无法删除&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//辅助遍历(指针)</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识是否找到待删除节点</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//已经到了链表最后</span></span><br><span class="line">          <span class="keyword">if</span> (temp.no == no) &#123; <span class="comment">//找到待删除的节点</span></span><br><span class="line">              flag = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          temp.pre.next = temp.next;<span class="comment">//将下一个节点地址赋值给上一个节点的`next`</span></span><br><span class="line">          <span class="comment">//如果不加判断,可能当前节点是最后一个,导致`temp.next.pre`会出现空指针异常</span></span><br><span class="line">          <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) temp.next.pre = temp.pre;<span class="comment">//将下一个节点的上一个(pre)赋值为当前节点的上一个(pre)</span></span><br><span class="line">      &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>全部代码(<code>包括课堂练习题</code>):</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.doublelinked;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">hero5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">5</span>, <span class="string">&quot;666&quot;</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line">        <span class="comment">//创建链表对象</span></span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        <span class="comment">//1.直接添加到链表尾部</span></span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">//修改测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试修改林冲&quot;</span>);</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">4</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;零充&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">//删除测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试删除吴用&quot;</span>);</span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">        <span class="comment">//测试插入添加</span></span><br><span class="line">        <span class="comment">//1.直接添加到链表尾部</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试插入添加 &quot;</span>);</span><br><span class="line">        doubleLinkedList.addByOrder(hero5);</span><br><span class="line">        doubleLinkedList.addByOrder(hero3);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//1. 先初始化一个头节点,头节点不要动,不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">DoubleHeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleHeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 返回头节点,get方法</span></span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 添加一个节点节点到双向链表的最后</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(DoubleHeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">//因为head节点是不能动的,动了的话链表就找不到入口或者找错路口,所以我们需要一个辅助遍历</span></span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表,找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后:当next值为空,就是最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果没有找到最后,就将temp向后移动,不然就原地踏步死循环了</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环的时候,temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.1 按照no进行对双向链表的插入,课堂练习题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(DoubleHeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//需要找到要添加位置的前一个节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//说明已经遍历到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) <span class="keyword">break</span>;<span class="comment">//说明已经找到,就在temp后面插入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明已经存在重复no</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) System.out.printf(<span class="string">&quot;准备插入的英雄的编号%d已经存在了,不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next; <span class="comment">//将temp的下next赋值到要插入的节点的next</span></span><br><span class="line">            heroNode.pre = temp;  <span class="comment">//将temp作为heroNode的pre(上一位)</span></span><br><span class="line">            temp.next = heroNode; <span class="comment">//在找到的位置后面插入heroNode ,并且这里不用判断非空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 修改节点信息,</span></span><br><span class="line">    <span class="comment">//可以看到双向链表的节点内容修改与单向链表一样,只是节点类型改变</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(DoubleHeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//找到需要修改的节点,根据no编号</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">//表示当前到链表尾端</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;<span class="comment">//表示找到该节点了</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;<span class="comment">//根据flag可以判断是否找到要修改的节点</span></span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;没有找到编号%d的阶段,不能进行修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 从双向链表中删除一个节点</span></span><br><span class="line"><span class="comment">     * 说明:</span></span><br><span class="line"><span class="comment">     * 1.对于双向链表,我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">     * 2.找到后,自我删除即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空,无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;<span class="comment">//辅助遍历(指针)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标识是否找到待删除节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//已经到了链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123; <span class="comment">//找到待删除的节点</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.pre.next = temp.next;<span class="comment">//将下一个节点地址赋值给上一个节点的`next`</span></span><br><span class="line">            <span class="comment">//如果不加判断,可能当前节点是最后一个,导致`temp.next.pre`会出现空指针异常</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) temp.next.pre = temp.pre;<span class="comment">//将下一个节点的上一个(pre)赋值为当前节点的上一个(pre)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.printf(<span class="string">&quot;要删除的%d节点不存在\n&quot;</span>, no);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动且头节点是没有数据的,所以直接`head.next;`</span></span><br><span class="line">        <span class="type">DoubleHeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移,一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、定义一个HeroNode,每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleHeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode next;<span class="comment">//指向下一个节点,默认为null</span></span><br><span class="line">    <span class="keyword">public</span> DoubleHeroNode pre;<span class="comment">//指向前一个节点,默认为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoubleHeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5、单向与双向链表对比"><a href="#5、单向与双向链表对比" class="headerlink" title="5、单向与双向链表对比"></a>5、单向与双向链表对比</h3><blockquote>
<ol>
<li>管理单向链表相较于双向链表的缺点分析</li>
</ol>
<blockquote>
<ul>
<li><p>① 单链表只有一个指向下一结点的指针，也就是只能next; ② 双链表除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</p>
</li>
<li><p>单向链表不能自我删除，需要靠辅助节点 ，而双向链表则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点,双向链表则是可以直接将temp指向要删除的节点</p>
</li>
</ul>
</blockquote>
<ol start="2">
<li>双链表具有以下优点:</li>
</ol>
<blockquote>
<ul>
<li>删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样</li>
<li>查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍</li>
</ul>
</blockquote>
<ol start="3">
<li><code>面试官</code>：从你的描述来看，双链表的在查找、删除的时候可以利用二分法的思想去实现,但是为什么目前市场应用上<code>单链表的应用要比双链表的应用要广泛</code>的多呢?</li>
</ol>
<blockquote>
<p>从存储结构来看，每个双链表的节点要比单链表的节点多一个指针，而长度为n就需要 n*length（这个指针的length在32位系统中是4字节，在64位系统中是8个字节） 的空间，这在一些追求时间效率不高应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。</p>
</blockquote>
<ol start="4">
<li>结构对比图</li>
</ol>
<blockquote>
<p> <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94%E5%9B%BE.png" alt="image-20210419144142974"> </p>
</blockquote>
</blockquote>
<h3 id="6、单链表之约瑟夫问题"><a href="#6、单链表之约瑟夫问题" class="headerlink" title="6、单链表之约瑟夫问题"></a>6、单链表之<code>约瑟夫问题</code></h3><h4 id="Ⅰ-问题描述"><a href="#Ⅰ-问题描述" class="headerlink" title="Ⅰ-问题描述:"></a>Ⅰ-问题描述:</h4><blockquote>
<ol>
<li><code>约瑟夫</code>（ <em>Josephu</em> ） 问题是一个非常著名的有趣的题目。问题具体描述如下：</li>
</ol>
<blockquote>
<p>设编号分别为1、2、3… n 的 n 个人围坐一圈，约定编号为 k（1≤k≤n）的人从 1 开始报数，数到 m 的那个人出列。出列的人的下一位又从 1 开始报数，数到 m 的那个人继续出列。以此类推，直到所有人都出列为止，由此产生一个出队编号的序列，这个序列也就是约瑟夫问题的解。</p>
</blockquote>
<ol start="2">
<li>下面将用一个动图来描述一下这个问题</li>
</ol>
<blockquote>
<p>假设有 4 个人围坐一圈，约定编号为 1 的人开始报数，数到 3 的那个出列。最后产生的出队编号的序列将会是：3、2、4、1。</p>
 <img src="数据结构与算法进阶学习笔记中的图片/约瑟夫问题动态图解.gif" style="zoom: 25%;" /> 
</blockquote>
</blockquote>
<h4 id="Ⅱ-老师给的思路实现"><a href="#Ⅱ-老师给的思路实现" class="headerlink" title="Ⅱ-老师给的思路实现"></a>Ⅱ-老师给的思路实现</h4><blockquote>
<ol>
<li><p>用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结点起从 1 开 始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直到最后一个结点从链表中删除算法结束。</p>
</li>
<li><p>约瑟夫问题-创建环形链表的思路图解</p>
</li>
</ol>
<p>  <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210420142532651.png" alt="image-20210420142532651"></p>
<ol start="3">
<li>约瑟夫问题-小孩出圈的思路分析图</li>
</ol>
<p>  <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210420142614947.png" alt="image-20210420142614947"></p>
<ol start="4">
<li>代码实现:</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.josepfu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josepfu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> NUM=<span class="number">5</span>;<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">        <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">        <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">        circleSingleLinkedList.addBoy(NUM);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line">        <span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, NUM); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二、创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个first节点,当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 添加小孩节点,构建成一个环形的链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">        <span class="comment">//nums做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//辅助指针,帮助构建环形链表</span></span><br><span class="line">        <span class="comment">//使用for来创建我们的环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++) &#123;<span class="comment">//i从1开始,才能得到编号与数字顺序一样的no;</span></span><br><span class="line">            <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">            <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; <span class="comment">//如果fori从0开始遍历,这里也要改为i==0,否则下面 `curBoy.setNext(boy);`将空指针异常</span></span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first); <span class="comment">//构成环,即只有一个时自己指向自己</span></span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                boy.setNext(first); <span class="comment">//将当前次循环的next指向第一个节点形成环</span></span><br><span class="line">                curBoy.setNext(boy);<span class="comment">//此处curBoy标记的是上一次循环的boy 如`i==2`--&gt;curBoy==first、`i==3`--&gt;curBoy==boy(第二个)</span></span><br><span class="line">                curBoy = boy;  <span class="comment">//这一步是移动当前curBoy位置到boy,保存当前boy 用作在下轮循环中指定当前boy的next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 遍历当前环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有任何小孩~~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩编号%d\n&quot;</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) <span class="keyword">break</span>;</span><br><span class="line">            curBoy = curBoy.getNext();<span class="comment">//curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //4. 根据用户输入,计算小孩出圈的顺序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo  开始的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 每次循环的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     单纯用来校验循环次数是否多于总长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo, <span class="type">int</span> countNum, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误,请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//①创建一个辅助指针,帮助完成小孩出圈</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">//②将辅助指针事先指向环形列表的最后这个节点(即next指向first)</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) <span class="keyword">break</span>;<span class="comment">//说明helper指向最后的小孩节点</span></span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//③小孩报数前,先让first和helper移动K-1次(如果我是从3开始,我需要事先指向3的位置)</span></span><br><span class="line">        <span class="comment">//为什么是K-1次--&gt;因为循环i是从0开始的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//④出圈删除:当小孩报数时,让first和helper指针同时移动m-1次,然后出圈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) <span class="keyword">break</span>; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">            <span class="comment">//让first和helper指针同时移动countNum-1次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出了for循环后,此时first指向的节点就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">            <span class="comment">//此时将first指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">           <span class="comment">//注意:此处用的时setNext--&gt;这步就是删除操作,原来的first指向的节点没有任何引用的时候,就会被回收</span></span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d\n&quot;</span>, first.getNo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一、创建一个Boy类,表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next; <span class="comment">//指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<h4 id="Ⅲ-思路改进与代码实现"><a href="#Ⅲ-思路改进与代码实现" class="headerlink" title="Ⅲ-思路改进与代码实现"></a>Ⅲ-思路改进与代码实现</h4><blockquote>
<p>将该问题解决思想带入 实现水浒传英雄 (该思路与解决于查阅<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhuxian1277">RonzL</a>的博客后学习记录)</p>
<ol>
<li><p>思路解析:</p>
<blockquote>
<ol>
<li><p>首先要确定解决问题的核心思想：<code>使用一个不带头结点的循环(环形)链表来处理该问题</code>。</p>
</li>
<li><p>假设每个结点代表一个人，那么一个由 n 个结点组成的循环链表就相当于是 n 个人围成的一个圈。那么约瑟夫问题以环形链表的形式来描述就是如下情景：</p>
</li>
</ol>
<blockquote>
<p>首先使用 n 个结点构成一个单向循环链表，然后由第 k 个结点起从 1 开始计数，当计到 m 时，从链表中删除对应结点；接着从被删除结点的下一个结点开始从 1 计数，当计到 m 时，继续从链表中删除。依次循环往复，直到链表中的所有结点都被删除为止。</p>
</blockquote>
<ol start="3">
<li>那么对于这个单向循环链表形式下的约瑟夫问题，我们如何解决呢？</li>
</ol>
<ul>
<li><p>我们可以引入一个辅助指针 helperNode，这个指针总是指向待删除结点的前一个结点。为什么这个辅助指针要指向待删除结点的前一个结点，而不是指向自身呢？</p>
</li>
<li><p>因为我们的目的是要删除当前计数为 m 的结点，但是受限于单向链表的特性（如果要删除单链表的某个结点，必须要知道该结点的前一个结点），我们无法让结点自己删除自己。鉴于这个特性，我们必须要引入一个辅助指针来记录当前正在计数的结点的前一个结点，这样才能符合删除条件的结点从链表中删除。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>引入这个辅助指针之后，具体的操作思路如下:</p>
<blockquote>
<ol>
<li>每一轮计数开始时，总让辅助指针 helperNode 初始指向本轮第一个计数的结点；</li>
<li>从第一个计数的结点开始计数至 m，实际上是向后移动了 m-1 个结点。由于辅助指针总是指向待删除结点的前一个结点，因此让需要让辅助指从第一个计数结点后移 m-2 个结点；</li>
<li>辅助指针移动到待删除结点的前一个结点之后，只需要让辅助指针指向待删除的结点的下一个结点即可完成删除操作；</li>
<li>依次循环往复，直至只剩最后一个结点；</li>
<li>对于环形链表判断是否只有最后一个结点，只需要判断辅助指针指向的结点是否是辅助指针指向的结点的下一个结点即可。</li>
</ol>
</blockquote>
</li>
<li><p>上面的思路可以用下面一个动图来描述:</p>
</li>
</ol>
<img src="数据结构与算法进阶学习笔记中的图片/约瑟夫问题思路分析图2.gif" style="zoom:25%;" />

<ol start="4">
<li>代码实现:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.linkedlist.doublelinked;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课程外思路实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造测试数据</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;洪吉林&quot;</span>, <span class="string">&quot;码农&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node_6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;努力学习的汪&quot;</span>, <span class="string">&quot;学习狗&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============向环形链表中插入结点==================&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">first</span> <span class="operator">=</span> insertCircleList(<span class="literal">null</span>, node_1);</span><br><span class="line">        first = insertCircleList(first, node_2);</span><br><span class="line">        first = insertCircleList(first, node_3);</span><br><span class="line">        first = insertCircleList(first, node_4);</span><br><span class="line">        first = insertCircleList(first, node_5);</span><br><span class="line">        first = insertCircleList(first, node_6);</span><br><span class="line">        showList(first);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============约瑟夫游戏开始===============&quot;</span>);</span><br><span class="line">        <span class="comment">// 从第 1 个结点开始计数，每次计 3 个数。</span></span><br><span class="line">        josepfuGame(first, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 1. 约瑟夫游戏开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> [first, k, m]   头节点,从第 k 个人开始数，每次数 m 个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">josepfuGame</span><span class="params">(HeroNode first, <span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">helperNode</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">// 首先要移动到第 k 个结点，此时辅助指针初始指向第一个计数的结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            helperNode = helperNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (helperNode.next.getNo() != helperNode.getNo()) &#123;</span><br><span class="line">            <span class="comment">// 报数， m 个数也就是相当于向后移动 m-1 次，也就是要把第 m-1 个结点去掉</span></span><br><span class="line">            <span class="comment">// 由于单链表的特点，要去掉第 m-1 个结点，肯定是要让指针前一个结点，即第(m-2)个结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m - <span class="number">2</span>; j++) &#123;  <span class="comment">// 让指针后移 m-2 个结点</span></span><br><span class="line">                helperNode = helperNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(helperNode.next + <span class="string">&quot;退出链表了!&quot;</span>);</span><br><span class="line">            <span class="comment">// 删除结点</span></span><br><span class="line">            helperNode.next = helperNode.next.next;</span><br><span class="line">            <span class="comment">// 因为下一轮要从刚刚去掉的结点的后面一个结点开始计数了，所以需要让辅助指针初始指向下一轮第一个计数的结点</span></span><br><span class="line">            helperNode = helperNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(helperNode + <span class="string">&quot;退出链表了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 2. 插入结点到环形链表中，用于构造环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">insertCircleList</span><span class="params">(HeroNode first, HeroNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是不是为空，如果为空，就直接插入</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = node;</span><br><span class="line">            <span class="comment">// 因为要环形链表，而且只有一个结点，所以要我指向我自己</span></span><br><span class="line">            first.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果环形链表不为空</span></span><br><span class="line">            <span class="type">HeroNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> first;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果到了环形链表的最后一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (tempNode.next.getNo() == first.getNo()) &#123;</span><br><span class="line">                    tempNode.next = node;</span><br><span class="line">                    <span class="comment">// 因为是环形链表，所以最后一个结点还要指向第一个结点</span></span><br><span class="line">                    node.next = first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tempNode = tempNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 3. 打印单向环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showList</span><span class="params">(HeroNode first)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempNode.next.getNo() == first.getNo()) &#123;</span><br><span class="line">                System.out.println(tempNode);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(tempNode);</span><br><span class="line">            tempNode = tempNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;             <span class="comment">// 本节点数据</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;       <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了显示方法,我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode[no=&quot;</span> + no + <span class="string">&quot;,name=&quot;</span> + name + <span class="string">&quot;,nickname=&quot;</span> + nickName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、栈"><a href="#四、栈" class="headerlink" title="四、栈"></a>四、栈</h2><h3 id="1、栈的概念"><a href="#1、栈的概念" class="headerlink" title="1、栈的概念"></a>1、栈的概念</h3><h4 id="Ⅰ-什么是栈"><a href="#Ⅰ-什么是栈" class="headerlink" title="Ⅰ-什么是栈"></a>Ⅰ-什么是栈</h4><blockquote>
<ol>
<li><p>栈的英文为(stack) </p>
</li>
<li><p>栈是一个<code>先入后出</code>(FILO-First In Last Out)的有序列表。 </p>
</li>
<li><p>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的 一端，为<code>变化的一端，称为栈顶</code>(Top)，另一端为<code>固定的一端，称为栈底</code>(Bottom)。 </p>
</li>
<li><p>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 </p>
</li>
<li><p>图解方式说明<code>出栈(pop)和入栈(push)</code>的概念</p>
</li>
</ol>
<p>​	<img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210426093842922.png" alt="image-20210426093842922"></p>
</blockquote>
<h4 id="Ⅱ-栈的应用场景"><a href="#Ⅱ-栈的应用场景" class="headerlink" title="Ⅱ-栈的应用场景"></a>Ⅱ-栈的应用场景</h4><blockquote>
<p>栈作为一种重要的基本数据结构，它的应用是比较广泛的。栈的应用包括如下几个方面：</p>
<ol>
<li>子程序的调用：在跳往子程序前， 会先将下个指令的地址存到堆栈中， 直到子程序执行完后再将地址取出， 以<br> 回到原来的程序中；</li>
<li>处理递归调用：和子程序的调用类似， 只是除了储存下一个指令的地址外， 也将参数、 区域变量等数据存入堆<br> 栈中；</li>
<li>表达式的转换（中缀表达式转后缀表达式）与求值；</li>
<li>二叉树的遍历；</li>
<li>图形的深度优先（depth 一 first）搜索法。</li>
</ol>
</blockquote>
<h3 id="2、数组模拟栈"><a href="#2、数组模拟栈" class="headerlink" title="2、数组模拟栈"></a>2、数组模拟栈</h3><blockquote>
<p>由于栈是一种有序列表， 当然可以使用数组的结构来储存栈的数据内容。下面我们就用数组模拟栈的出栈， 入栈等操作。</p>
</blockquote>
<h4 id="Ⅰ-思路分析"><a href="#Ⅰ-思路分析" class="headerlink" title="Ⅰ-思路分析"></a>Ⅰ-思路分析</h4><blockquote>
<p>使用数组来模拟栈的思路是比较简单的，按照下面的步骤即可</p>
<ol>
<li>定义一个类，该类的成员变量包括一个数组 stack（用于模拟栈）、两个整型变量 maxSize、top（分别代表栈的大小、栈顶指针）；</li>
<li>栈顶指针 top 初始化为 -1；</li>
<li>每当有元素要入栈时，top 加 1，然后元素记录在数组中，即 stack[top] &#x3D; element；</li>
<li>每当有元素要出栈时，先读取数组的元素，即 element &#x3D; stack[top]，然后 top 减 1。</li>
</ol>
</blockquote>
<h4 id="Ⅱ-代码实现"><a href="#Ⅱ-代码实现" class="headerlink" title="Ⅱ-代码实现"></a>Ⅱ-代码实现</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.stack;</span><br><span class="line">&gt;<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//测试一下ArrayStack 是否正确</span></span><br><span class="line">       <span class="comment">//先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">       <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//控制是否退出菜单</span></span><br><span class="line">       <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;show: 表示显示栈&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;exit: 退出程序&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;push: 表示添加数据到栈(入栈)&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;pop: 表示从栈取出数据(出栈)&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;请输入你的选择&quot;</span>);</span><br><span class="line">           key = scanner.next();</span><br><span class="line">           <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                   stack.list();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                   System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                   <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                   stack.push(value);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                       System.out.printf(<span class="string">&quot;出栈的数据是 %d\n&quot;</span>, res);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                       <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                       System.out.println(e.getMessage());</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                   scanner.close();</span><br><span class="line">                   loop = <span class="literal">false</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;程序退出~~~&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//1. 定义一个ArrayStack栈</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">//数组,数组模拟栈</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//top表示栈顶,初始化为-1</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">       stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//栈满</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//栈空</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//入栈--push</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       top++;</span><br><span class="line">       stack[top] = value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//出栈-pop,将栈顶的数据返回</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空,没有数据&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">       top--;</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历栈,遍历时需要从栈顶开始显示数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;栈空,没有数据&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3、栈实现简单计算器（中缀）"><a href="#3、栈实现简单计算器（中缀）" class="headerlink" title="3、栈实现简单计算器（中缀）"></a>3、栈实现简单计算器（中缀）</h3><h4 id="Ⅰ-思路分析-1"><a href="#Ⅰ-思路分析-1" class="headerlink" title="Ⅰ-思路分析"></a>Ⅰ-思路分析</h4><blockquote>
<ol>
<li><p>表达式分为中缀表达式、前缀表达式、后缀表达式。中缀表达式就是表达式本身，如 “3+2*6-1” 就是一个中缀表达式。关于表达式的详细介绍将会在后面的笔记中展示</p>
</li>
<li><p>本案例实现的简单计算器就是直接对中缀表达式（也就是原计算表达式）进行分析处理。</p>
</li>
<li><p>如果要实现一个计算器，可以按照以下思路：</p>
</li>
</ol>
<blockquote>
<ul>
<li><p>初始化两个栈，一个作为符号栈、一个作为数字栈；</p>
</li>
<li><p>通过一个索引 index，来从左至右遍历中缀表达式；</p>
</li>
<li><p>如果遍历到的是一个数字，就直接入数字栈；</p>
</li>
<li><p>如果遍历到的是一个符号：</p>
</li>
</ul>
<p> ​	① 如果当前符号栈为空，就直接入符号栈；</p>
<p> ​	② 如果符号栈有操作符，就进行比较：</p>
<blockquote>
<ol>
<li>若当前的操作符优先级小于或等于栈顶的操作符，就从数字栈中 pop 出两个数，再从符号栈中 pop 出一个符号进行运算。运算得到的结果 push 入数字栈中，然后将当前的操作符入符号栈；</li>
<li>若当前的操作符优先级大于栈顶的操作符，就直接入符号栈；</li>
</ol>
</blockquote>
<ul>
<li><p>中缀表达式遍历完毕之后，就依次从数字栈和符号栈中 pop 出相应的数和符号，对他们进行运算；</p>
</li>
<li><p>最后在数字栈中将只剩下一个数字，这个数字就是表达式的结果。</p>
</li>
</ul>
</blockquote>
<ol start="4">
<li>思路分析图:</li>
</ol>
<p> <img src="/k705/kk.github.io.git/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/image-20210426144425068.png" alt="image-20210426144425068"></p>
</blockquote>
<h4 id="Ⅱ-代码实现-1"><a href="#Ⅱ-代码实现-1" class="headerlink" title="Ⅱ-代码实现:"></a>Ⅱ-代码实现:</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">package</span> com.stack;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;70*2+2*3+2000&quot;</span>;</span><br><span class="line">       <span class="comment">//先创建两个栈,一个数栈一个符号栈</span></span><br><span class="line">       <span class="type">ArrayStack2</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">       <span class="type">ArrayStack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">       <span class="comment">//定义相关变量</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>, num1 = <span class="number">0</span>, num2 = <span class="number">0</span>, oper = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">       <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//每次将扫描到的char保存于ch中</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">       <span class="comment">//开始循环扫描expression</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//依次得到expression的每一个字符</span></span><br><span class="line">           ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//判断ch是什么</span></span><br><span class="line">           <span class="keyword">if</span> (operStack.isOper(ch)) &#123;<span class="comment">//如果是运算符</span></span><br><span class="line">               <span class="keyword">if</span> (!operStack.isEmpty()) &#123;<span class="comment">//判断当前字符站是否为空</span></span><br><span class="line">                   <span class="comment">//如果符号栈中有操作符,就进行比较如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数</span></span><br><span class="line">                   <span class="comment">//再从符号栈中pop出一个符号进行运算,再将得到的结果入数栈,然后将当前的操作符入符号栈</span></span><br><span class="line">                   <span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                       num1 = numStack.pop();</span><br><span class="line">                       num2 = numStack.pop();</span><br><span class="line">                       oper = operStack.pop();</span><br><span class="line">                       res = numStack.cal(num1, num2, oper);</span><br><span class="line">                       <span class="comment">//把运算的结果入数栈</span></span><br><span class="line">                       numStack.push(res);</span><br><span class="line">                       <span class="comment">//然后将当前的操作符入符号栈</span></span><br><span class="line">                       operStack.push(ch);</span><br><span class="line">                   &#125; <span class="keyword">else</span> operStack.push(ch);<span class="comment">//如果当前操作符的优先级大于栈中的操作符,就直接入符号栈</span></span><br><span class="line">               &#125; <span class="keyword">else</span> operStack.push(ch);   <span class="comment">//如果为空直接入符号栈</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//如果是数,则直接入数栈</span></span><br><span class="line">               <span class="comment">//numStack.push(ch - 48); //? &quot;1+3&quot; &#x27;1&#x27; =&gt; 1</span></span><br><span class="line">               <span class="comment">//分析思路</span></span><br><span class="line">               <span class="comment">//1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">               <span class="comment">//2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">               <span class="comment">//3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line">               <span class="comment">//处理多位数</span></span><br><span class="line">               keepNum += ch;</span><br><span class="line">               <span class="comment">//如果ch已经是expression的最后一位,就直接入栈</span></span><br><span class="line">               <span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//判断下一个字符是不是数字,如果是数字,就继续扫描,如果是运算符,则入栈</span></span><br><span class="line">                   <span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;<span class="comment">//此处是判断是符号入栈,并清空,不是不好就记录下来 下轮使用</span></span><br><span class="line">                       numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                       keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           index++;</span><br><span class="line">           <span class="keyword">if</span> (index &gt;= expression.length()) <span class="keyword">break</span>; <span class="comment">//结束循环，跳出循环体，执行后面的程序。</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号,并进行运算</span></span><br><span class="line">       <span class="comment">//经过上面的操作，符号栈剩下的都是优先级相等的符号了，直接出栈做运算就可以啦</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="comment">//如果符号栈为空,则计算到最后的结果,数栈中只有一个数字--结果</span></span><br><span class="line">           <span class="keyword">if</span> (operStack.isEmpty()) <span class="keyword">break</span>;</span><br><span class="line">           num1 = numStack.pop();</span><br><span class="line">           num2 = numStack.pop();</span><br><span class="line">           oper = operStack.pop();</span><br><span class="line">           res = numStack.cal(num1, num2, oper);</span><br><span class="line">           numStack.push(res);<span class="comment">//结果入栈</span></span><br><span class="line">&gt;<span class="comment">//            System.out.println(&quot;-------- 出循环后数栈 ---------&quot;);</span></span><br><span class="line">&gt;<span class="comment">//            numStack.list();</span></span><br><span class="line">&gt;<span class="comment">//            System.out.println(&quot;-----------------&quot;);</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> numStack.pop();</span><br><span class="line">       System.out.printf(<span class="string">&quot;表达式%s=%d&quot;</span>, expression, res2);</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">//1. 定义一个ArrayStack栈</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">ArrayStack2</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">//数组,数组模拟栈</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//top表示栈顶,初始化为-1</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayStack2</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">       stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//可以返回当前栈顶的值,但不是pop,而是用做对比</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> stack[top];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//栈满</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//栈空</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//入栈--push</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       top++;</span><br><span class="line">       stack[top] = value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//出栈-pop,将栈顶的数据返回</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空,没有数据&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">       top--;</span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历栈,遍历时需要从栈顶开始显示数据</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;栈空,没有数据&quot;</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回运算符的优先级,优先级是程序员来确定,优先级使用数字表示</span></span><br><span class="line">   <span class="comment">//数字越大,则优先级越高</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断是否为一个运算符</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计算方法</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">               res = num1 + num2;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">               res = num2 - num1;<span class="comment">// 注意顺序</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">               res = num1 * num2;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">               res = num2 / num1;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4、前缀、中缀、后缀表达式"><a href="#4、前缀、中缀、后缀表达式" class="headerlink" title="4、前缀、中缀、后缀表达式"></a>4、前缀、中缀、后缀表达式</h3><blockquote>
<p>刚刚说到那个中缀计算器的 时候可能就有同学要问了,什么是中缀?那么带着疑惑来学习,我就将其知识点在此处记录</p>
</blockquote>
<h4 id="Ⅰ-定义与举栗"><a href="#Ⅰ-定义与举栗" class="headerlink" title="Ⅰ - 定义与举栗"></a>Ⅰ - 定义与举栗</h4><blockquote>
<p>它们都是对表达式的记法，因此也被称为前缀记法、中缀记法和后缀记法。它们之间的区别在于运算符相对与操作数的位置不同：前缀表达式的运算符位于与其相关的操作数之前；中缀和后缀同理。</p>
<p>(3 + 4) × 5 - 6 就是中缀表达式<br>- × + 3 4 5 6 前缀表达式<br>3 4 + 5 × 6 - 后缀表达式</p>
</blockquote>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://github.com/k705/kk.github.io.git/2024/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java数据结构与java算法" target="_blank" rel="external">https://github.com/k705/kk.github.io.git/2024/04/08/数据结构与算法进阶学习笔记/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/blog/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">KK</span><small class="ml-1x">前端工程师</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/blog/2024/04/08/%E8%A1%A8%E5%8D%95%E6%AD%A3%E5%88%99%E6%A0%A1%E9%AA%8C%E6%94%B6%E5%BD%95/" title="表单正则校验收录"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/blog/2024/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%B5%85%E5%AD%A6Http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="浏览器的工作原理、HTTP协议底层原理、TCP网络协议、浏览器的渲染流程"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/blog/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/blog/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/blog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/blog/js/plugin.min.js"></script>


<script src="/blog/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/blog/',
        CONTENT_URL: '/blog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/blog/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>